/**
 * @license
 * PlayCanvas Engine v2.4.0-dev revision 23f443b (RELEASE)
 * Copyright 2011-2025 PlayCanvas Ltd. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

pc.version = "Whdinasor-Custom-v0.1";

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pc = {}));
})(this, (function (exports) { 'use strict';

	var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
	function defineProtoFunc(cls, name, func) {
		if (!cls.prototype[name]) {
			Object.defineProperty(cls.prototype, name, {
				value: func,
				configurable: true,
				enumerable: false,
				writable: true
			});
		}
	}

	defineProtoFunc(Array, 'fill', function (value) {
		if (this == null) {
			throw new TypeError('this is null or not defined');
		}
		var O = Object(this);
		var len = O.length >>> 0;
		var start = arguments[1];
		var relativeStart = start >> 0;
		var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
		var end = arguments[2];
		var relativeEnd = end === undefined ? len : end >> 0;
		var finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
		while (k < finalValue) {
			O[k] = value;
			k++;
		}
		return O;
	});

	defineProtoFunc(Array, 'find', function (predicate) {
		if (this == null) {
			throw TypeError('"this" is null or not defined');
		}
		var o = Object(this);
		var len = o.length >>> 0;
		if (typeof predicate !== 'function') {
			throw TypeError('predicate must be a function');
		}
		var thisArg = arguments[1];
		var k = 0;
		while (k < len) {
			var kValue = o[k];
			if (predicate.call(thisArg, kValue, k, o)) {
				return kValue;
			}
			k++;
		}
		return undefined;
	});

	defineProtoFunc(Array, 'findIndex', function (predicate) {
		if (this == null) {
			throw new TypeError('"this" is null or not defined');
		}
		var o = Object(this);
		var len = o.length >>> 0;
		if (typeof predicate !== 'function') {
			throw new TypeError('predicate must be a function');
		}
		var thisArg = arguments[1];
		var k = 0;
		while (k < len) {
			var kValue = o[k];
			if (predicate.call(thisArg, kValue, k, o)) {
				return k;
			}
			k++;
		}
		return -1;
	});

	Math.log2 = Math.log2 || function (x) {
		return Math.log(x) * Math.LOG2E;
	};

	if (!Math.sign) {
		Math.sign = function (x) {
			return (x > 0) - (x < 0) || +x;
		};
	}

	if (Number.isFinite === undefined) Number.isFinite = function (value) {
		return typeof value === 'number' && isFinite(value);
	};

	if (typeof Object.assign != 'function') {
		Object.defineProperty(Object, "assign", {
			value: function assign(target, varArgs) {
				'use strict';

				if (target == null) {
					throw new TypeError('Cannot convert undefined or null to object');
				}
				var to = Object(target);
				for (var index = 1; index < arguments.length; index++) {
					var nextSource = arguments[index];
					if (nextSource != null) {
						for (var nextKey in nextSource) {
							if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}
				return to;
			},
			writable: true,
			configurable: true
		});
	}

	Object.fromEntries = Object.fromEntries || function fromEntries(entries) {
		if (!entries || !entries[Symbol.iterator]) {
			throw new Error('Object.fromEntries() requires a single iterable argument');
		}
		var res = {};
		for (var i = 0; i < entries.length; i++) {
			res[entries[i][0]] = entries[i][1];
		}
		return res;
	};
	Object.entries = Object.entries || function (obj) {
		var ownProps = Object.keys(obj),
			i = ownProps.length,
			resArray = new Array(i);
		while (i--) resArray[i] = [ownProps[i], obj[ownProps[i]]];
		return resArray;
	};

	Object.values = Object.values || function (object) {
		return Object.keys(object).map(function (key) {
			return object[key];
		});
	};

	(function () {
		if (typeof navigator === 'undefined' || typeof document === 'undefined') {
			return;
		}
		navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
		var pointerlockchange = function pointerlockchange() {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockchange', true, false, null);
			document.dispatchEvent(e);
		};
		var pointerlockerror = function pointerlockerror() {
			var e = document.createEvent('CustomEvent');
			e.initCustomEvent('pointerlockerror', true, false, null);
			document.dispatchEvent(e);
		};
		document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
		document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
		document.addEventListener('mozpointerlockchange', pointerlockchange, false);
		document.addEventListener('mozpointerlocklost', pointerlockchange, false);
		document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
		document.addEventListener('mozpointerlockerror', pointerlockerror, false);
		if (Element.prototype.mozRequestPointerLock) {
			Element.prototype.requestPointerLock = function () {
				this.mozRequestPointerLock();
			};
		} else {
			Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
		}
		if (!Element.prototype.requestPointerLock && navigator.pointer) {
			Element.prototype.requestPointerLock = function () {
				var el = this;
				document.pointerLockElement = el;
				navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
			};
		}
		document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
		if (!document.exitPointerLock) {
			document.exitPointerLock = function () {
				if (navigator.pointer) {
					document.pointerLockElement = null;
					navigator.pointer.unlock();
				}
			};
		}
	})();

	defineProtoFunc(String, 'endsWith', function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}
		return this.substring(this_len - search.length, this_len) === search;
	});
	defineProtoFunc(String, 'includes', function (search, start) {
		'use strict';

		if (typeof start !== 'number') {
			start = 0;
		}
		if (start + search.length > this.length) {
			return false;
		} else {
			return this.indexOf(search, start) !== -1;
		}
	});
	defineProtoFunc(String, 'startsWith', function (search, rawPos) {
		var pos = rawPos > 0 ? rawPos | 0 : 0;
		return this.substring(pos, pos + search.length) === search;
	});
	defineProtoFunc(String, 'trimEnd', function () {
		return this.replace(new RegExp(/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/.source + '$', 'g'), '');
	});

	var typedArrays = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
	for (var _i = 0, _typedArrays = typedArrays; _i < _typedArrays.length; _i++) {
		var typedArray = _typedArrays[_i];
		defineProtoFunc(typedArray, "fill", Array.prototype.fill);
		defineProtoFunc(typedArray, "join", Array.prototype.join);
	}

	var TRACEID_RENDER_FRAME = 'RenderFrame';
	var TRACEID_RENDER_FRAME_TIME = 'RenderFrameTime';
	var TRACEID_RENDER_PASS = 'RenderPass';
	var TRACEID_RENDER_PASS_DETAIL = 'RenderPassDetail';
	var TRACEID_RENDER_ACTION = 'RenderAction';
	var TRACEID_RENDER_TARGET_ALLOC = 'RenderTargetAlloc';
	var TRACEID_TEXTURE_ALLOC = 'TextureAlloc';
	var TRACEID_SHADER_ALLOC = 'ShaderAlloc';
	var TRACEID_SHADER_COMPILE = 'ShaderCompile';
	var TRACEID_VRAM_TEXTURE = 'VRAM.Texture';
	var TRACEID_VRAM_VB = 'VRAM.Vb';
	var TRACEID_VRAM_IB = 'VRAM.Ib';
	var TRACEID_VRAM_SB = 'VRAM.Sb';
	var TRACEID_BINDGROUP_ALLOC = 'BindGroupAlloc';
	var TRACEID_BINDGROUPFORMAT_ALLOC = 'BindGroupFormatAlloc';
	var TRACEID_RENDERPIPELINE_ALLOC = 'RenderPipelineAlloc';
	var TRACEID_COMPUTEPIPELINE_ALLOC = 'ComputePipelineAlloc';
	var TRACEID_PIPELINELAYOUT_ALLOC = 'PipelineLayoutAlloc';
	var TRACE_ID_ELEMENT = 'Element';
	var TRACEID_TEXTURES = 'Textures';
	var TRACEID_RENDER_QUEUE = 'RenderQueue';
	var TRACEID_GPU_TIMINGS = 'GpuTimings';

	var version = '2.4.0-dev_Welcome to Whdinasor Engine!';
	var revision = '23f443b_Welcome to Whdinasor Engine!';
	function extend(target, ex) {
		for (var prop in ex) {
			var copy = ex[prop];
			if (Array.isArray(copy)) {
				target[prop] = extend([], copy);
			} else if (copy && typeof copy === 'object') {
				target[prop] = extend({}, copy);
			} else {
				target[prop] = copy;
			}
		}
		return target;
	}

	var guid = {
		create: function create() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = Math.random() * 16 | 0;
				var v = c === 'x' ? r : r & 0x3 | 0x8;
				return v.toString(16);
			});
		}
	};

	var path = {
		delimiter: '/',
		join: function join() {
			var result = arguments.length <= 0 ? undefined : arguments[0];
			for (var i = 0; i < arguments.length - 1; i++) {
				var one = i < 0 || arguments.length <= i ? undefined : arguments[i];
				var two = i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
				if (two[0] === path.delimiter) {
					result = two;
					continue;
				}
				if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
					result += path.delimiter + two;
				} else {
					result += two;
				}
			}
			return result;
		},
		normalize: function normalize(pathname) {
			var lead = pathname.startsWith(path.delimiter);
			var trail = pathname.endsWith(path.delimiter);
			var parts = pathname.split('/');
			var result = '';
			var cleaned = [];
			for (var i = 0; i < parts.length; i++) {
				if (parts[i] === '') continue;
				if (parts[i] === '.') continue;
				if (parts[i] === '..' && cleaned.length > 0) {
					cleaned = cleaned.slice(0, cleaned.length - 2);
					continue;
				}
				if (i > 0) cleaned.push(path.delimiter);
				cleaned.push(parts[i]);
			}
			result = cleaned.join('');
			if (!lead && result[0] === path.delimiter) {
				result = result.slice(1);
			}
			if (trail && result[result.length - 1] !== path.delimiter) {
				result += path.delimiter;
			}
			return result;
		},
		split: function split(pathname) {
			var lastDelimiterIndex = pathname.lastIndexOf(path.delimiter);
			if (lastDelimiterIndex !== -1) {
				return [pathname.substring(0, lastDelimiterIndex), pathname.substring(lastDelimiterIndex + 1)];
			}
			return ['', pathname];
		},
		getBasename: function getBasename(pathname) {
			return path.split(pathname)[1];
		},
		getDirectory: function getDirectory(pathname) {
			return path.split(pathname)[0];
		},
		getExtension: function getExtension(pathname) {
			var ext = pathname.split('?')[0].split('.').pop();
			if (ext !== pathname) {
				return "." + ext;
			}
			return '';
		},
		isRelativePath: function isRelativePath(pathname) {
			return pathname.charAt(0) !== '/' && pathname.match(/:\/\//) === null;
		},
		extractPath: function extractPath(pathname) {
			var result = '';
			var parts = pathname.split('/');
			var i = 0;
			if (parts.length > 1) {
				if (path.isRelativePath(pathname)) {
					if (parts[0] === '.') {
						for (i = 0; i < parts.length - 1; ++i) {
							result += i === 0 ? parts[i] : "/" + parts[i];
						}
					} else if (parts[0] === '..') {
						for (i = 0; i < parts.length - 1; ++i) {
							result += i === 0 ? parts[i] : "/" + parts[i];
						}
					} else {
						result = '.';
						for (i = 0; i < parts.length - 1; ++i) {
							result += "/" + parts[i];
						}
					}
				} else {
					for (i = 0; i < parts.length - 1; ++i) {
						result += i === 0 ? parts[i] : "/" + parts[i];
					}
				}
			}
			return result;
		}
	};

	var _ref, _ref2, _ref3;
	var detectPassiveEvents = function detectPassiveEvents() {
		var result = false;
		try {
			var opts = Object.defineProperty({}, 'passive', {
				get: function get() {
					result = true;
					return false;
				}
			});
			window.addEventListener('testpassive', null, opts);
			window.removeEventListener('testpassive', null, opts);
		} catch (e) {}
		return result;
	};
	var ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';
	var environment = typeof window !== 'undefined' ? 'browser' : typeof global !== 'undefined' ? 'node' : 'worker';
	var platformName = /android/i.test(ua) ? 'android' : /ip(?:[ao]d|hone)/i.test(ua) ? 'ios' : /windows/i.test(ua) ? 'windows' : /mac os/i.test(ua) ? 'osx' : /linux/i.test(ua) ? 'linux' : /cros/i.test(ua) ? 'cros' : null;
	var browserName = environment !== 'browser' ? null : /Chrome\/|Chromium\/|Edg.*\//.test(ua) ? 'chrome' : /Safari\//.test(ua) ? 'safari' : /Firefox\//.test(ua) ? 'firefox' : 'other';
	var xbox = /xbox/i.test(ua);
	var touch = environment === 'browser' && ('ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0);
	var gamepads = environment === 'browser' && (!!navigator.getGamepads || !!navigator.webkitGetGamepads);
	var workers = typeof Worker !== 'undefined';
	var passiveEvents = detectPassiveEvents();
	var platform = {
		name: platformName,
		environment: environment,
		global: (_ref = (_ref2 = (_ref3 = typeof globalThis !== 'undefined' && globalThis) != null ? _ref3 : environment === 'browser' && window) != null ? _ref2 : environment === 'node' && global) != null ? _ref : environment === 'worker' && self,
		browser: environment === 'browser',
		worker: environment === 'worker',
		desktop: ['windows', 'osx', 'linux', 'cros'].includes(platformName),
		mobile: ['android', 'ios'].includes(platformName),
		ios: platformName === 'ios',
		android: platformName === 'android',
		xbox: xbox,
		gamepads: gamepads,
		touch: touch,
		workers: workers,
		passiveEvents: passiveEvents,
		browserName: browserName
	};

	var ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';
	var ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
	var HIGH_SURROGATE_BEGIN = 0xD800;
	var HIGH_SURROGATE_END = 0xDBFF;
	var LOW_SURROGATE_BEGIN = 0xDC00;
	var LOW_SURROGATE_END = 0xDFFF;
	var ZERO_WIDTH_JOINER = 0x200D;
	var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
	var REGIONAL_INDICATOR_END = 0x1F1FF;
	var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
	var FITZPATRICK_MODIFIER_END = 0x1F3FF;
	var DIACRITICAL_MARKS_BEGIN = 0x20D0;
	var DIACRITICAL_MARKS_END = 0x20FF;
	var VARIATION_MODIFIER_BEGIN = 0xFE00;
	var VARIATION_MODIFIER_END = 0xFE0F;
	function getCodePointData(string, i) {
		if (i === void 0) {
			i = 0;
		}
		var size = string.length;
		if (i < 0 || i >= size) {
			return null;
		}
		var first = string.charCodeAt(i);
		if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
			var second = string.charCodeAt(i + 1);
			if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
				return {
					code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
					long: true
				};
			}
		}
		return {
			code: first,
			long: false
		};
	}
	function isCodeBetween(string, begin, end) {
		if (!string) {
			return false;
		}
		var codeData = getCodePointData(string);
		if (codeData) {
			var code = codeData.code;
			return code >= begin && code <= end;
		}
		return false;
	}
	function numCharsToTakeForNextSymbol(string, index) {
		if (index === string.length - 1) {
			return 1;
		}
		if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
			var first = string.substring(index, index + 2);
			var second = string.substring(index + 2, index + 4);
			if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
				return 4;
			}
			if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
				return 3;
			}
			return 2;
		}
		if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
			return 2;
		}
		return 1;
	}
	var string = {
		ASCII_LOWERCASE: ASCII_LOWERCASE,
		ASCII_UPPERCASE: ASCII_UPPERCASE,
		ASCII_LETTERS: ASCII_LETTERS,
		format: function format(s) {
			for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
				s = s.replace("{" + i + "}", i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);
			}
			return s;
		},
		getCodePoint: function getCodePoint(string, i) {
			var codePointData = getCodePointData(string, i);
			return codePointData && codePointData.code;
		},
		getCodePoints: function getCodePoints(string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}
			var i = 0;
			var arr = [];
			var codePoint;
			while (!!(codePoint = getCodePointData(string, i))) {
				arr.push(codePoint.code);
				i += codePoint.long ? 2 : 1;
			}
			return arr;
		},
		getSymbols: function getSymbols(string) {
			if (typeof string !== 'string') {
				throw new TypeError('Not a string');
			}
			var index = 0;
			var length = string.length;
			var output = [];
			var take = 0;
			var ch;
			while (index < length) {
				take += numCharsToTakeForNextSymbol(string, index + take);
				ch = string[index + take];
				if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
					ch = string[index + take++];
				}
				if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
					ch = string[index + take++];
				}
				if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
					ch = string[index + take++];
					continue;
				}
				var _char = string.substring(index, index + take);
				output.push(_char);
				index += take;
				take = 0;
			}
			return output;
		},
		fromCodePoint: function fromCodePoint() {
			var chars = [];
			var current;
			var codePoint;
			var units;
			for (var i = 0; i < arguments.length; ++i) {
				current = Number(arguments[i]);
				codePoint = current - 0x10000;
				units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];
				chars.push(String.fromCharCode.apply(null, units));
			}
			return chars.join('');
		}
	};

	function _arrayLikeToArray(r, a) {
	  (null == a || a > r.length) && (a = r.length);
	  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
	  return n;
	}
	function asyncGeneratorStep(n, t, e, r, o, a, c) {
	  try {
	    var i = n[a](c),
	      u = i.value;
	  } catch (n) {
	    return void e(n);
	  }
	  i.done ? t(u) : Promise.resolve(u).then(r, o);
	}
	function _asyncToGenerator(n) {
	  return function () {
	    var t = this,
	      e = arguments;
	    return new Promise(function (r, o) {
	      var a = n.apply(t, e);
	      function _next(n) {
	        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
	      }
	      function _throw(n) {
	        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
	      }
	      _next(void 0);
	    });
	  };
	}
	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
	    writable: !1
	  }), e;
	}
	function _createForOfIteratorHelperLoose(r, e) {
	  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	  if (t) return (t = t.call(r)).next.bind(t);
	  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
	    t && (r = t);
	    var o = 0;
	    return function () {
	      return o >= r.length ? {
	        done: !0
	      } : {
	        done: !1,
	        value: r[o++]
	      };
	    };
	  }
	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _extends() {
	  return _extends = Object.assign ? Object.assign.bind() : function (n) {
	    for (var e = 1; e < arguments.length; e++) {
	      var t = arguments[e];
	      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
	    }
	    return n;
	  }, _extends.apply(null, arguments);
	}
	function _inheritsLoose(t, o) {
	  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
	}
	function _regeneratorRuntime() {
	  _regeneratorRuntime = function () {
	    return e;
	  };
	  var t,
	    e = {},
	    r = Object.prototype,
	    n = r.hasOwnProperty,
	    o = Object.defineProperty || function (t, e, r) {
	      t[e] = r.value;
	    },
	    i = "function" == typeof Symbol ? Symbol : {},
	    a = i.iterator || "@@iterator",
	    c = i.asyncIterator || "@@asyncIterator",
	    u = i.toStringTag || "@@toStringTag";
	  function define(t, e, r) {
	    return Object.defineProperty(t, e, {
	      value: r,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }), t[e];
	  }
	  try {
	    define({}, "");
	  } catch (t) {
	    define = function (t, e, r) {
	      return t[e] = r;
	    };
	  }
	  function wrap(t, e, r, n) {
	    var i = e && e.prototype instanceof Generator ? e : Generator,
	      a = Object.create(i.prototype),
	      c = new Context(n || []);
	    return o(a, "_invoke", {
	      value: makeInvokeMethod(t, r, c)
	    }), a;
	  }
	  function tryCatch(t, e, r) {
	    try {
	      return {
	        type: "normal",
	        arg: t.call(e, r)
	      };
	    } catch (t) {
	      return {
	        type: "throw",
	        arg: t
	      };
	    }
	  }
	  e.wrap = wrap;
	  var h = "suspendedStart",
	    l = "suspendedYield",
	    f = "executing",
	    s = "completed",
	    y = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var p = {};
	  define(p, a, function () {
	    return this;
	  });
	  var d = Object.getPrototypeOf,
	    v = d && d(d(values([])));
	  v && v !== r && n.call(v, a) && (p = v);
	  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
	  function defineIteratorMethods(t) {
	    ["next", "throw", "return"].forEach(function (e) {
	      define(t, e, function (t) {
	        return this._invoke(e, t);
	      });
	    });
	  }
	  function AsyncIterator(t, e) {
	    function invoke(r, o, i, a) {
	      var c = tryCatch(t[r], t, o);
	      if ("throw" !== c.type) {
	        var u = c.arg,
	          h = u.value;
	        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
	          invoke("next", t, i, a);
	        }, function (t) {
	          invoke("throw", t, i, a);
	        }) : e.resolve(h).then(function (t) {
	          u.value = t, i(u);
	        }, function (t) {
	          return invoke("throw", t, i, a);
	        });
	      }
	      a(c.arg);
	    }
	    var r;
	    o(this, "_invoke", {
	      value: function (t, n) {
	        function callInvokeWithMethodAndArg() {
	          return new e(function (e, r) {
	            invoke(t, n, e, r);
	          });
	        }
	        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }
	    });
	  }
	  function makeInvokeMethod(e, r, n) {
	    var o = h;
	    return function (i, a) {
	      if (o === f) throw Error("Generator is already running");
	      if (o === s) {
	        if ("throw" === i) throw a;
	        return {
	          value: t,
	          done: !0
	        };
	      }
	      for (n.method = i, n.arg = a;;) {
	        var c = n.delegate;
	        if (c) {
	          var u = maybeInvokeDelegate(c, n);
	          if (u) {
	            if (u === y) continue;
	            return u;
	          }
	        }
	        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
	          if (o === h) throw o = s, n.arg;
	          n.dispatchException(n.arg);
	        } else "return" === n.method && n.abrupt("return", n.arg);
	        o = f;
	        var p = tryCatch(e, r, n);
	        if ("normal" === p.type) {
	          if (o = n.done ? s : l, p.arg === y) continue;
	          return {
	            value: p.arg,
	            done: n.done
	          };
	        }
	        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
	      }
	    };
	  }
	  function maybeInvokeDelegate(e, r) {
	    var n = r.method,
	      o = e.iterator[n];
	    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
	    var i = tryCatch(o, e.iterator, r.arg);
	    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
	    var a = i.arg;
	    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
	  }
	  function pushTryEntry(t) {
	    var e = {
	      tryLoc: t[0]
	    };
	    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
	  }
	  function resetTryEntry(t) {
	    var e = t.completion || {};
	    e.type = "normal", delete e.arg, t.completion = e;
	  }
	  function Context(t) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }], t.forEach(pushTryEntry, this), this.reset(!0);
	  }
	  function values(e) {
	    if (e || "" === e) {
	      var r = e[a];
	      if (r) return r.call(e);
	      if ("function" == typeof e.next) return e;
	      if (!isNaN(e.length)) {
	        var o = -1,
	          i = function next() {
	            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
	            return next.value = t, next.done = !0, next;
	          };
	        return i.next = i;
	      }
	    }
	    throw new TypeError(typeof e + " is not iterable");
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: !0
	  }), o(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: !0
	  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
	    var e = "function" == typeof t && t.constructor;
	    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
	  }, e.mark = function (t) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
	  }, e.awrap = function (t) {
	    return {
	      __await: t
	    };
	  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
	    return this;
	  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
	    void 0 === i && (i = Promise);
	    var a = new AsyncIterator(wrap(t, r, n, o), i);
	    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
	      return t.done ? t.value : a.next();
	    });
	  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
	    return this;
	  }), define(g, "toString", function () {
	    return "[object Generator]";
	  }), e.keys = function (t) {
	    var e = Object(t),
	      r = [];
	    for (var n in e) r.push(n);
	    return r.reverse(), function next() {
	      for (; r.length;) {
	        var t = r.pop();
	        if (t in e) return next.value = t, next.done = !1, next;
	      }
	      return next.done = !0, next;
	    };
	  }, e.values = values, Context.prototype = {
	    constructor: Context,
	    reset: function (e) {
	      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
	    },
	    stop: function () {
	      this.done = !0;
	      var t = this.tryEntries[0].completion;
	      if ("throw" === t.type) throw t.arg;
	      return this.rval;
	    },
	    dispatchException: function (e) {
	      if (this.done) throw e;
	      var r = this;
	      function handle(n, o) {
	        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
	      }
	      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
	        var i = this.tryEntries[o],
	          a = i.completion;
	        if ("root" === i.tryLoc) return handle("end");
	        if (i.tryLoc <= this.prev) {
	          var c = n.call(i, "catchLoc"),
	            u = n.call(i, "finallyLoc");
	          if (c && u) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          } else if (c) {
	            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
	          } else {
	            if (!u) throw Error("try statement without catch or finally");
	            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
	          }
	        }
	      }
	    },
	    abrupt: function (t, e) {
	      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
	        var o = this.tryEntries[r];
	        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
	          var i = o;
	          break;
	        }
	      }
	      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
	      var a = i ? i.completion : {};
	      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
	    },
	    complete: function (t, e) {
	      if ("throw" === t.type) throw t.arg;
	      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
	    },
	    finish: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
	      }
	    },
	    catch: function (t) {
	      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
	        var r = this.tryEntries[e];
	        if (r.tryLoc === t) {
	          var n = r.completion;
	          if ("throw" === n.type) {
	            var o = n.arg;
	            resetTryEntry(r);
	          }
	          return o;
	        }
	      }
	      throw Error("illegal catch attempt");
	    },
	    delegateYield: function (e, r, n) {
	      return this.delegate = {
	        iterator: values(e),
	        resultName: r,
	        nextLoc: n
	      }, "next" === this.method && (this.arg = t), y;
	    }
	  }, e;
	}
	function _setPrototypeOf(t, e) {
	  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
	    return t.__proto__ = e, t;
	  }, _setPrototypeOf(t, e);
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r);
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (String )(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}
	function _unsupportedIterableToArray(r, a) {
	  if (r) {
	    if ("string" == typeof r) return _arrayLikeToArray(r, a);
	    var t = {}.toString.call(r).slice(8, -1);
	    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
	  }
	}

	var Tracing = function () {
		function Tracing() {}
		Tracing.set = function set(channel, enabled) {
		};
		Tracing.get = function get(channel) {
			return Tracing._traceChannels.has(channel);
		};
		return Tracing;
	}();
	Tracing._traceChannels = new Set();
	Tracing.stack = false;

	var EventHandle = function () {
		function EventHandle(handler, name, callback, scope, once) {
			if (once === void 0) {
				once = false;
			}
			this.handler = void 0;
			this.name = void 0;
			this.callback = void 0;
			this.scope = void 0;
			this._once = void 0;
			this._removed = false;
			this.handler = handler;
			this.name = name;
			this.callback = callback;
			this.scope = scope;
			this._once = once;
		}
		var _proto = EventHandle.prototype;
		_proto.off = function off() {
			if (this._removed) return;
			this.handler.offByHandle(this);
		};
		_proto.on = function on(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this.handler._addCallback(name, callback, scope, false);
		};
		_proto.once = function once(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this.handler._addCallback(name, callback, scope, true);
		};
		return _createClass(EventHandle, [{
			key: "removed",
			get: function get() {
				return this._removed;
			},
			set: function set(value) {
				if (!value) return;
				this._removed = true;
			}
		}]);
	}();

	var EventHandler = function () {
		function EventHandler() {
			this._callbacks = new Map();
			this._callbackActive = new Map();
		}
		var _proto = EventHandler.prototype;
		_proto.initEventHandler = function initEventHandler() {
			this._callbacks = new Map();
			this._callbackActive = new Map();
		};
		_proto._addCallback = function _addCallback(name, callback, scope, once) {
			if (!this._callbacks.has(name)) {
				this._callbacks.set(name, []);
			}
			if (this._callbackActive.has(name)) {
				var callbackActive = this._callbackActive.get(name);
				if (callbackActive && callbackActive === this._callbacks.get(name)) {
					this._callbackActive.set(name, callbackActive.slice());
				}
			}
			var evt = new EventHandle(this, name, callback, scope, once);
			this._callbacks.get(name).push(evt);
			return evt;
		};
		_proto.on = function on(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this._addCallback(name, callback, scope, false);
		};
		_proto.once = function once(name, callback, scope) {
			if (scope === void 0) {
				scope = this;
			}
			return this._addCallback(name, callback, scope, true);
		};
		_proto.off = function off(name, callback, scope) {
			if (name) {
				if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {
					this._callbackActive.set(name, this._callbackActive.get(name).slice());
				}
			} else {
				for (var _iterator = _createForOfIteratorHelperLoose(this._callbackActive), _step; !(_step = _iterator()).done;) {
					var _step$value = _step.value,
						key = _step$value[0],
						callbacks = _step$value[1];
					if (!this._callbacks.has(key)) {
						continue;
					}
					if (this._callbacks.get(key) !== callbacks) {
						continue;
					}
					this._callbackActive.set(key, callbacks.slice());
				}
			}
			if (!name) {
				for (var _iterator2 = _createForOfIteratorHelperLoose(this._callbacks.values()), _step2; !(_step2 = _iterator2()).done;) {
					var _callbacks = _step2.value;
					for (var i = 0; i < _callbacks.length; i++) {
						_callbacks[i].removed = true;
					}
				}
				this._callbacks.clear();
			} else if (!callback) {
				var _callbacks2 = this._callbacks.get(name);
				if (_callbacks2) {
					for (var _i = 0; _i < _callbacks2.length; _i++) {
						_callbacks2[_i].removed = true;
					}
					this._callbacks.delete(name);
				}
			} else {
				var _callbacks3 = this._callbacks.get(name);
				if (!_callbacks3) {
					return this;
				}
				for (var _i2 = 0; _i2 < _callbacks3.length; _i2++) {
					if (_callbacks3[_i2].callback !== callback) {
						continue;
					}
					if (scope && _callbacks3[_i2].scope !== scope) {
						continue;
					}
					_callbacks3[_i2].removed = true;
					_callbacks3.splice(_i2, 1);
					_i2--;
				}
				if (_callbacks3.length === 0) {
					this._callbacks.delete(name);
				}
			}
			return this;
		};
		_proto.offByHandle = function offByHandle(handle) {
			var name = handle.name;
			handle.removed = true;
			if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {
				this._callbackActive.set(name, this._callbackActive.get(name).slice());
			}
			var callbacks = this._callbacks.get(name);
			if (!callbacks) {
				return this;
			}
			var ind = callbacks.indexOf(handle);
			if (ind !== -1) {
				callbacks.splice(ind, 1);
				if (callbacks.length === 0) {
					this._callbacks.delete(name);
				}
			}
			return this;
		};
		_proto.fire = function fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
			if (!name) {
				return this;
			}
			var callbacksInitial = this._callbacks.get(name);
			if (!callbacksInitial) {
				return this;
			}
			var callbacks;
			if (!this._callbackActive.has(name)) {
				this._callbackActive.set(name, callbacksInitial);
			} else if (this._callbackActive.get(name) !== callbacksInitial) {
				callbacks = callbacksInitial.slice();
			}
			for (var i = 0; (callbacks || this._callbackActive.get(name)) && i < (callbacks || this._callbackActive.get(name)).length; i++) {
				var evt = (callbacks || this._callbackActive.get(name))[i];
				if (!evt.callback) continue;
				evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
				if (evt._once) {
					var existingCallback = this._callbacks.get(name);
					var ind = existingCallback ? existingCallback.indexOf(evt) : -1;
					if (ind !== -1) {
						if (this._callbackActive.get(name) === existingCallback) {
							this._callbackActive.set(name, this._callbackActive.get(name).slice());
						}
						var _callbacks4 = this._callbacks.get(name);
						if (!_callbacks4) continue;
						_callbacks4[ind].removed = true;
						_callbacks4.splice(ind, 1);
						if (_callbacks4.length === 0) {
							this._callbacks.delete(name);
						}
					}
				}
			}
			if (!callbacks) {
				this._callbackActive.delete(name);
			}
			return this;
		};
		_proto.hasEvent = function hasEvent(name) {
			var _this$_callbacks$get;
			return !!((_this$_callbacks$get = this._callbacks.get(name)) != null && _this$_callbacks$get.length);
		};
		return EventHandler;
	}();

	var IndexedList = function () {
		function IndexedList() {
			this._list = [];
			this._index = {};
		}
		var _proto = IndexedList.prototype;
		_proto.push = function push(key, item) {
			if (this._index[key]) {
				throw Error("Key already in index " + key);
			}
			var location = this._list.push(item) - 1;
			this._index[key] = location;
		};
		_proto.has = function has(key) {
			return this._index[key] !== undefined;
		};
		_proto.get = function get(key) {
			var location = this._index[key];
			if (location !== undefined) {
				return this._list[location];
			}
			return null;
		};
		_proto.remove = function remove(key) {
			var location = this._index[key];
			if (location !== undefined) {
				this._list.splice(location, 1);
				delete this._index[key];
				for (key in this._index) {
					var idx = this._index[key];
					if (idx > location) {
						this._index[key] = idx - 1;
					}
				}
				return true;
			}
			return false;
		};
		_proto.list = function list() {
			return this._list;
		};
		_proto.clear = function clear() {
			this._list.length = 0;
			for (var prop in this._index) {
				delete this._index[prop];
			}
		};
		return IndexedList;
	}();

	var cachedResult = function cachedResult(func) {
		var uninitToken = {};
		var result = uninitToken;
		return function () {
			if (result === uninitToken) {
				result = func();
			}
			return result;
		};
	};
	var Impl = function () {
		function Impl() {}
		Impl.loadScript = function loadScript(url, callback) {
			var s = document.createElement('script');
			s.setAttribute('src', url);
			s.onload = function () {
				callback(null);
			};
			s.onerror = function () {
				callback("Failed to load script='" + url + "'");
			};
			document.body.appendChild(s);
		};
		Impl.loadWasm = function loadWasm(moduleName, config, callback) {
			var loadUrl = Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;
			if (loadUrl) {
				Impl.loadScript(loadUrl, function (err) {
					if (err) {
						callback(err, null);
					} else {
						var module = window[moduleName];
						window[moduleName] = undefined;
						module({
							locateFile: function locateFile() {
								return config.wasmUrl;
							},
							onAbort: function onAbort() {
								callback('wasm module aborted.');
							}
						}).then(function (instance) {
							callback(null, instance);
						});
					}
				});
			} else {
				callback('No supported wasm modules found.', null);
			}
		};
		Impl.getModule = function getModule(name) {
			if (!Impl.modules.hasOwnProperty(name)) {
				Impl.modules[name] = {
					config: null,
					initializing: false,
					instance: null,
					callbacks: []
				};
			}
			return Impl.modules[name];
		};
		Impl.initialize = function initialize(moduleName, module) {
			if (module.initializing) {
				return;
			}
			var config = module.config;
			if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
				module.initializing = true;
				Impl.loadWasm(moduleName, config, function (err, instance) {
					if (err) {
						if (config.errorHandler) {
							config.errorHandler(err);
						} else {
							console.error("failed to initialize module=" + moduleName + " error=" + err);
						}
					} else {
						module.instance = instance;
						module.callbacks.forEach(function (callback) {
							callback(instance);
						});
					}
				});
			}
		};
		return Impl;
	}();
	Impl.modules = {};
	Impl.wasmSupported = cachedResult(function () {
		try {
			if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
				var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
				if (module instanceof WebAssembly.Module) {
					return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
				}
			}
		} catch (e) {}
		return false;
	});
	var WasmModule = function () {
		function WasmModule() {}
		WasmModule.setConfig = function setConfig(moduleName, config) {
			var module = Impl.getModule(moduleName);
			module.config = config;
			if (module.callbacks.length > 0) {
				Impl.initialize(moduleName, module);
			}
		};
		WasmModule.getConfig = function getConfig(moduleName) {
			var _Impl$modules;
			return (_Impl$modules = Impl.modules) == null || (_Impl$modules = _Impl$modules[moduleName]) == null ? void 0 : _Impl$modules.config;
		};
		WasmModule.getInstance = function getInstance(moduleName, callback) {
			var module = Impl.getModule(moduleName);
			if (module.instance) {
				callback(module.instance);
			} else {
				module.callbacks.push(callback);
				if (module.config) {
					Impl.initialize(moduleName, module);
				}
			}
		};
		return WasmModule;
	}();

	var ReadStream = function () {
		function ReadStream(arraybuffer) {
			this.arraybuffer = void 0;
			this.dataView = void 0;
			this.offset = 0;
			this.arraybuffer = arraybuffer;
			this.dataView = new DataView(arraybuffer);
		}
		var _proto = ReadStream.prototype;
		_proto.reset = function reset(offset) {
			if (offset === void 0) {
				offset = 0;
			}
			this.offset = offset;
		};
		_proto.skip = function skip(bytes) {
			this.offset += bytes;
		};
		_proto.align = function align(bytes) {
			this.offset = this.offset + bytes - 1 & ~(bytes - 1);
		};
		_proto._inc = function _inc(amount) {
			this.offset += amount;
			return this.offset - amount;
		};
		_proto.readChar = function readChar() {
			return String.fromCharCode(this.dataView.getUint8(this.offset++));
		};
		_proto.readChars = function readChars(numChars) {
			var result = '';
			for (var i = 0; i < numChars; ++i) {
				result += this.readChar();
			}
			return result;
		};
		_proto.readU8 = function readU8() {
			return this.dataView.getUint8(this.offset++);
		};
		_proto.readU16 = function readU16() {
			return this.dataView.getUint16(this._inc(2), true);
		};
		_proto.readU32 = function readU32() {
			return this.dataView.getUint32(this._inc(4), true);
		};
		_proto.readU64 = function readU64() {
			return this.readU32() + Math.pow(2, 32) * this.readU32();
		};
		_proto.readU32be = function readU32be() {
			return this.dataView.getUint32(this._inc(4), false);
		};
		_proto.readArray = function readArray(result) {
			for (var i = 0; i < result.length; ++i) {
				result[i] = this.readU8();
			}
		};
		_proto.readLine = function readLine() {
			var view = this.dataView;
			var result = '';
			while (true) {
				if (this.offset >= view.byteLength) {
					break;
				}
				var c = String.fromCharCode(this.readU8());
				if (c === '\n') {
					break;
				}
				result += c;
			}
			return result;
		};
		return _createClass(ReadStream, [{
			key: "remainingBytes",
			get: function get() {
				return this.dataView.byteLength - this.offset;
			}
		}]);
	}();

	var SortedLoopArray = function () {
		function SortedLoopArray(args) {
			this.items = [];
			this.length = 0;
			this.loopIndex = -1;
			this._sortBy = void 0;
			this._sortHandler = void 0;
			this._sortBy = args.sortBy;
			this._sortHandler = this._doSort.bind(this);
		}
		var _proto = SortedLoopArray.prototype;
		_proto._binarySearch = function _binarySearch(item) {
			var left = 0;
			var right = this.items.length - 1;
			var search = item[this._sortBy];
			var middle;
			var current;
			while (left <= right) {
				middle = Math.floor((left + right) / 2);
				current = this.items[middle][this._sortBy];
				if (current <= search) {
					left = middle + 1;
				} else if (current > search) {
					right = middle - 1;
				}
			}
			return left;
		};
		_proto._doSort = function _doSort(a, b) {
			var sortBy = this._sortBy;
			return a[sortBy] - b[sortBy];
		};
		_proto.insert = function insert(item) {
			var index = this._binarySearch(item);
			this.items.splice(index, 0, item);
			this.length++;
			if (this.loopIndex >= index) {
				this.loopIndex++;
			}
		};
		_proto.append = function append(item) {
			this.items.push(item);
			this.length++;
		};
		_proto.remove = function remove(item) {
			var idx = this.items.indexOf(item);
			if (idx < 0) return;
			this.items.splice(idx, 1);
			this.length--;
			if (this.loopIndex >= idx) {
				this.loopIndex--;
			}
		};
		_proto.sort = function sort() {
			var current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
			this.items.sort(this._sortHandler);
			if (current !== null) {
				this.loopIndex = this.items.indexOf(current);
			}
		};
		return SortedLoopArray;
	}();

	var Tags = function (_EventHandler) {
		function Tags(parent) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._index = {};
			_this._list = [];
			_this._parent = parent;
			return _this;
		}
		_inheritsLoose(Tags, _EventHandler);
		var _proto = Tags.prototype;
		_proto.add = function add() {
			var changed = false;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			var tags = this._processArguments(args, true);
			if (!tags.length) {
				return changed;
			}
			for (var i = 0; i < tags.length; i++) {
				if (this._index[tags[i]]) {
					continue;
				}
				changed = true;
				this._index[tags[i]] = true;
				this._list.push(tags[i]);
				this.fire('add', tags[i], this._parent);
			}
			if (changed) {
				this.fire('change', this._parent);
			}
			return changed;
		};
		_proto.remove = function remove() {
			var changed = false;
			if (!this._list.length) {
				return changed;
			}
			for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}
			var tags = this._processArguments(args, true);
			if (!tags.length) {
				return changed;
			}
			for (var i = 0; i < tags.length; i++) {
				if (!this._index[tags[i]]) {
					continue;
				}
				changed = true;
				delete this._index[tags[i]];
				this._list.splice(this._list.indexOf(tags[i]), 1);
				this.fire('remove', tags[i], this._parent);
			}
			if (changed) {
				this.fire('change', this._parent);
			}
			return changed;
		};
		_proto.clear = function clear() {
			if (!this._list.length) {
				return;
			}
			var tags = this._list.slice(0);
			this._list = [];
			this._index = {};
			for (var i = 0; i < tags.length; i++) {
				this.fire('remove', tags[i], this._parent);
			}
			this.fire('change', this._parent);
		};
		_proto.has = function has() {
			if (!this._list.length) {
				return false;
			}
			for (var _len3 = arguments.length, query = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				query[_key3] = arguments[_key3];
			}
			return this._has(this._processArguments(query));
		};
		_proto._has = function _has(tags) {
			if (!this._list.length || !tags.length) {
				return false;
			}
			for (var i = 0; i < tags.length; i++) {
				if (tags[i].length === 1) {
					if (this._index[tags[i][0]]) {
						return true;
					}
				} else {
					var multiple = true;
					for (var t = 0; t < tags[i].length; t++) {
						if (this._index[tags[i][t]]) {
							continue;
						}
						multiple = false;
						break;
					}
					if (multiple) {
						return true;
					}
				}
			}
			return false;
		};
		_proto.list = function list() {
			return this._list.slice(0);
		};
		_proto._processArguments = function _processArguments(args, flat) {
			var tags = [];
			var tmp = [];
			if (!args || !args.length) {
				return tags;
			}
			for (var i = 0; i < args.length; i++) {
				if (args[i] instanceof Array) {
					if (!flat) {
						tmp = [];
					}
					for (var t = 0; t < args[i].length; t++) {
						if (typeof args[i][t] !== 'string') {
							continue;
						}
						if (flat) {
							tags.push(args[i][t]);
						} else {
							tmp.push(args[i][t]);
						}
					}
					if (!flat && tmp.length) {
						tags.push(tmp);
					}
				} else if (typeof args[i] === 'string') {
					if (flat) {
						tags.push(args[i]);
					} else {
						tags.push([args[i]]);
					}
				}
			}
			return tags;
		};
		return _createClass(Tags, [{
			key: "size",
			get: function get() {
				return this._list.length;
			}
		}]);
	}(EventHandler);
	Tags.EVENT_ADD = 'add';
	Tags.EVENT_REMOVE = 'remove';
	Tags.EVENT_CHANGE = 'change';

	var now = typeof window !== 'undefined' && window.performance && window.performance.now ? performance.now.bind(performance) : Date.now;

	function createURI(options) {
		var s = '';
		if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
			throw new Error('Can\'t have \'scheme\' or \'authority\' and \'host\' or \'hostpath\' option');
		}
		if (options.host && options.hostpath) {
			throw new Error('Can\'t have \'host\' and \'hostpath\' option');
		}
		if (options.path && options.hostpath) {
			throw new Error('Can\'t have \'path\' and \'hostpath\' option');
		}
		if (options.scheme) {
			s += options.scheme + ":";
		}
		if (options.authority) {
			s += "//" + options.authority;
		}
		if (options.host) {
			s += options.host;
		}
		if (options.path) {
			s += options.path;
		}
		if (options.hostpath) {
			s += options.hostpath;
		}
		if (options.query) {
			s += "?" + options.query;
		}
		if (options.fragment) {
			s += "#" + options.fragment;
		}
		return s;
	}
	var re = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
	var URI = function () {
		function URI(uri) {
			this.scheme = void 0;
			this.authority = void 0;
			this.path = void 0;
			this.query = void 0;
			this.fragment = void 0;
			var result = uri.match(re);
			this.scheme = result[2];
			this.authority = result[4];
			this.path = result[5];
			this.query = result[7];
			this.fragment = result[9];
		}
		var _proto = URI.prototype;
		_proto.toString = function toString() {
			var s = '';
			if (this.scheme) {
				s += this.scheme + ":";
			}
			if (this.authority) {
				s += "//" + this.authority;
			}
			s += this.path;
			if (this.query) {
				s += "?" + this.query;
			}
			if (this.fragment) {
				s += "#" + this.fragment;
			}
			return s;
		};
		_proto.getQuery = function getQuery() {
			var result = {};
			if (this.query) {
				var queryParams = decodeURIComponent(this.query).split('&');
				for (var _iterator = _createForOfIteratorHelperLoose(queryParams), _step; !(_step = _iterator()).done;) {
					var queryParam = _step.value;
					var pair = queryParam.split('=');
					result[pair[0]] = pair[1];
				}
			}
			return result;
		};
		_proto.setQuery = function setQuery(params) {
			var q = '';
			for (var key in params) {
				if (params.hasOwnProperty(key)) {
					if (q !== '') {
						q += '&';
					}
					q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
				}
			}
			this.query = q;
		};
		return URI;
	}();

	var CURVE_LINEAR = 0;
	var CURVE_SMOOTHSTEP = 1;
	var CURVE_SPLINE = 4;
	var CURVE_STEP = 5;

	var math = {
		DEG_TO_RAD: Math.PI / 180,
		RAD_TO_DEG: 180 / Math.PI,
		clamp: function clamp(value, min, max) {
			if (value >= max) return max;
			if (value <= min) return min;
			return value;
		},
		intToBytes24: function intToBytes24(i) {
			var r = i >> 16 & 0xff;
			var g = i >> 8 & 0xff;
			var b = i & 0xff;
			return [r, g, b];
		},
		intToBytes32: function intToBytes32(i) {
			var r = i >> 24 & 0xff;
			var g = i >> 16 & 0xff;
			var b = i >> 8 & 0xff;
			var a = i & 0xff;
			return [r, g, b, a];
		},
		bytesToInt24: function bytesToInt24(r, g, b) {
			if (r.length) {
				b = r[2];
				g = r[1];
				r = r[0];
			}
			return r << 16 | g << 8 | b;
		},
		bytesToInt32: function bytesToInt32(r, g, b, a) {
			if (r.length) {
				a = r[3];
				b = r[2];
				g = r[1];
				r = r[0];
			}
			return (r << 24 | g << 16 | b << 8 | a) >>> 0;
		},
		lerp: function lerp(a, b, alpha) {
			return a + (b - a) * math.clamp(alpha, 0, 1);
		},
		lerpAngle: function lerpAngle(a, b, alpha) {
			if (b - a > 180) {
				b -= 360;
			}
			if (b - a < -180) {
				b += 360;
			}
			return math.lerp(a, b, math.clamp(alpha, 0, 1));
		},
		powerOfTwo: function powerOfTwo(x) {
			return x !== 0 && !(x & x - 1);
		},
		nextPowerOfTwo: function nextPowerOfTwo(val) {
			val--;
			val |= val >> 1;
			val |= val >> 2;
			val |= val >> 4;
			val |= val >> 8;
			val |= val >> 16;
			val++;
			return val;
		},
		nearestPowerOfTwo: function nearestPowerOfTwo(val) {
			return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));
		},
		random: function random(min, max) {
			var diff = max - min;
			return Math.random() * diff + min;
		},
		smoothstep: function smoothstep(min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * (3 - 2 * x);
		},
		smootherstep: function smootherstep(min, max, x) {
			if (x <= min) return 0;
			if (x >= max) return 1;
			x = (x - min) / (max - min);
			return x * x * x * (x * (x * 6 - 15) + 10);
		},
		roundUp: function roundUp(numToRound, multiple) {
			if (multiple === 0) {
				return numToRound;
			}
			return Math.ceil(numToRound / multiple) * multiple;
		},
		between: function between(num, a, b, inclusive) {
			var min = Math.min(a, b);
			var max = Math.max(a, b);
			return inclusive ? num >= min && num <= max : num > min && num < max;
		}
	};

	var _Color;
	var Color = function () {
		function Color(r, g, b, a) {
			if (r === void 0) {
				r = 0;
			}
			if (g === void 0) {
				g = 0;
			}
			if (b === void 0) {
				b = 0;
			}
			if (a === void 0) {
				a = 1;
			}
			this.r = void 0;
			this.g = void 0;
			this.b = void 0;
			this.a = void 0;
			var length = r.length;
			if (length === 3 || length === 4) {
				var _r$;
				this.r = r[0];
				this.g = r[1];
				this.b = r[2];
				this.a = (_r$ = r[3]) != null ? _r$ : 1;
			} else {
				this.r = r;
				this.g = g;
				this.b = b;
				this.a = a;
			}
		}
		var _proto = Color.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.r, this.g, this.b, this.a);
		};
		_proto.copy = function copy(rhs) {
			this.r = rhs.r;
			this.g = rhs.g;
			this.b = rhs.b;
			this.a = rhs.a;
			return this;
		};
		_proto.equals = function equals(rhs) {
			return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
		};
		_proto.set = function set(r, g, b, a) {
			if (a === void 0) {
				a = 1;
			}
			this.r = r;
			this.g = g;
			this.b = b;
			this.a = a;
			return this;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.r = lhs.r + alpha * (rhs.r - lhs.r);
			this.g = lhs.g + alpha * (rhs.g - lhs.g);
			this.b = lhs.b + alpha * (rhs.b - lhs.b);
			this.a = lhs.a + alpha * (rhs.a - lhs.a);
			return this;
		};
		_proto.linear = function linear(src) {
			if (src === void 0) {
				src = this;
			}
			this.r = Math.pow(src.r, 2.2);
			this.g = Math.pow(src.g, 2.2);
			this.b = Math.pow(src.b, 2.2);
			this.a = src.a;
			return this;
		};
		_proto.gamma = function gamma(src) {
			if (src === void 0) {
				src = this;
			}
			this.r = Math.pow(src.r, 1 / 2.2);
			this.g = Math.pow(src.g, 1 / 2.2);
			this.b = Math.pow(src.b, 1 / 2.2);
			this.a = src.a;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar) {
			this.r *= scalar;
			this.g *= scalar;
			this.b *= scalar;
			return this;
		};
		_proto.fromString = function fromString(hex) {
			var i = parseInt(hex.replace('#', '0x'), 16);
			var bytes;
			if (hex.length > 7) {
				bytes = math.intToBytes32(i);
			} else {
				bytes = math.intToBytes24(i);
				bytes[3] = 255;
			}
			this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
			return this;
		};
		_proto.toString = function toString(alpha, asArray) {
			var r = this.r,
				g = this.g,
				b = this.b,
				a = this.a;
			if (asArray || r > 1 || g > 1 || b > 1) {
				return r.toFixed(3) + ", " + g.toFixed(3) + ", " + b.toFixed(3) + ", " + a.toFixed(3);
			}
			var s = "#" + ((1 << 24) + (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
			if (alpha === true) {
				var aa = Math.round(a * 255).toString(16);
				if (this.a < 16 / 255) {
					s += "0" + aa;
				} else {
					s += aa;
				}
			}
			return s;
		};
		return Color;
	}();
	_Color = Color;
	Color.BLACK = Object.freeze(new _Color(0, 0, 0, 1));
	Color.BLUE = Object.freeze(new _Color(0, 0, 1, 1));
	Color.CYAN = Object.freeze(new _Color(0, 1, 1, 1));
	Color.GRAY = Object.freeze(new _Color(0.5, 0.5, 0.5, 1));
	Color.GREEN = Object.freeze(new _Color(0, 1, 0, 1));
	Color.MAGENTA = Object.freeze(new _Color(1, 0, 1, 1));
	Color.RED = Object.freeze(new _Color(1, 0, 0, 1));
	Color.WHITE = Object.freeze(new _Color(1, 1, 1, 1));
	Color.YELLOW = Object.freeze(new _Color(1, 1, 0, 1));

	var CurveEvaluator = function () {
		function CurveEvaluator(curve, time) {
			if (time === void 0) {
				time = 0;
			}
			this._curve = void 0;
			this._left = -Infinity;
			this._right = Infinity;
			this._recip = 0;
			this._p0 = 0;
			this._p1 = 0;
			this._m0 = 0;
			this._m1 = 0;
			this._curve = curve;
			this._reset(time);
		}
		var _proto = CurveEvaluator.prototype;
		_proto.evaluate = function evaluate(time, forceReset) {
			if (forceReset === void 0) {
				forceReset = false;
			}
			if (forceReset || time < this._left || time >= this._right) {
				this._reset(time);
			}
			var result;
			var type = this._curve.type;
			if (type === CURVE_STEP) {
				result = this._p0;
			} else {
				var t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
				if (type === CURVE_LINEAR) {
					result = math.lerp(this._p0, this._p1, t);
				} else if (type === CURVE_SMOOTHSTEP) {
					result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
				} else {
					result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
				}
			}
			return result;
		};
		_proto._reset = function _reset(time) {
			var keys = this._curve.keys;
			var len = keys.length;
			if (!len) {
				this._left = -Infinity;
				this._right = Infinity;
				this._recip = 0;
				this._p0 = this._p1 = this._m0 = this._m1 = 0;
			} else {
				if (time < keys[0][0]) {
					this._left = -Infinity;
					this._right = keys[0][0];
					this._recip = 0;
					this._p0 = this._p1 = keys[0][1];
					this._m0 = this._m1 = 0;
				} else if (time >= keys[len - 1][0]) {
					this._left = keys[len - 1][0];
					this._right = Infinity;
					this._recip = 0;
					this._p0 = this._p1 = keys[len - 1][1];
					this._m0 = this._m1 = 0;
				} else {
					var index = 0;
					while (time >= keys[index + 1][0]) {
						index++;
					}
					this._left = keys[index][0];
					this._right = keys[index + 1][0];
					var diff = 1.0 / (this._right - this._left);
					this._recip = isFinite(diff) ? diff : 0;
					this._p0 = keys[index][1];
					this._p1 = keys[index + 1][1];
					if (this._curve.type === CURVE_SPLINE) {
						this._calcTangents(keys, index);
					}
				}
			}
		};
		_proto._calcTangents = function _calcTangents(keys, index) {
			var a;
			var b = keys[index];
			var c = keys[index + 1];
			var d;
			if (index === 0) {
				a = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];
			} else {
				a = keys[index - 1];
			}
			if (index === keys.length - 2) {
				d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
			} else {
				d = keys[index + 2];
			}
			if (this._curve.type === CURVE_SPLINE) {
				var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
				var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
				this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
				this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
			} else {
				var s1 = (c[0] - b[0]) / (b[0] - a[0]);
				var s2 = (c[0] - b[0]) / (d[0] - c[0]);
				var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
				var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
				var tension = this._curve.tension;
				this._m0 = tension * (c[1] - a_);
				this._m1 = tension * (d_ - b[1]);
			}
		};
		_proto._evaluateHermite = function _evaluateHermite(p0, p1, m0, m1, t) {
			var t2 = t * t;
			var twot = t + t;
			var omt = 1 - t;
			var omt2 = omt * omt;
			return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
		};
		return CurveEvaluator;
	}();

	var Curve = function () {
		function Curve(data) {
			this.keys = [];
			this.type = CURVE_SMOOTHSTEP;
			this.tension = 0.5;
			this._eval = new CurveEvaluator(this);
			if (data) {
				for (var i = 0; i < data.length - 1; i += 2) {
					this.keys.push([data[i], data[i + 1]]);
				}
			}
			this.sort();
		}
		var _proto = Curve.prototype;
		_proto.add = function add(time, value) {
			var keys = this.keys;
			var len = keys.length;
			var i = 0;
			for (; i < len; i++) {
				if (keys[i][0] > time) {
					break;
				}
			}
			var key = [time, value];
			this.keys.splice(i, 0, key);
			return key;
		};
		_proto.get = function get(index) {
			return this.keys[index];
		};
		_proto.sort = function sort() {
			this.keys.sort(function (a, b) {
				return a[0] - b[0];
			});
		};
		_proto.value = function value(time) {
			return this._eval.evaluate(time, true);
		};
		_proto.closest = function closest(time) {
			var keys = this.keys;
			var length = keys.length;
			var min = 2;
			var result = null;
			for (var i = 0; i < length; i++) {
				var diff = Math.abs(time - keys[i][0]);
				if (min >= diff) {
					min = diff;
					result = keys[i];
				} else {
					break;
				}
			}
			return result;
		};
		_proto.clone = function clone() {
			var result = new this.constructor();
			result.keys = this.keys.map(function (key) {
				return [].concat(key);
			});
			result.type = this.type;
			result.tension = this.tension;
			return result;
		};
		_proto.quantize = function quantize(precision) {
			precision = Math.max(precision, 2);
			var values = new Float32Array(precision);
			var step = 1.0 / (precision - 1);
			values[0] = this._eval.evaluate(0, true);
			for (var i = 1; i < precision; i++) {
				values[i] = this._eval.evaluate(step * i);
			}
			return values;
		};
		_proto.quantizeClamped = function quantizeClamped(precision, min, max) {
			var result = this.quantize(precision);
			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}
			return result;
		};
		return _createClass(Curve, [{
			key: "length",
			get: function get() {
				return this.keys.length;
			}
		}]);
	}();

	var CurveSet = function () {
		function CurveSet() {
			this.curves = [];
			this._type = CURVE_SMOOTHSTEP;
			if (arguments.length > 1) {
				for (var i = 0; i < arguments.length; i++) {
					this.curves.push(new Curve(arguments[i]));
				}
			} else {
				if (arguments.length === 0) {
					this.curves.push(new Curve());
				} else {
					var arg = arguments[0];
					if (typeof arg === 'number') {
						for (var _i = 0; _i < arg; _i++) {
							this.curves.push(new Curve());
						}
					} else {
						for (var _i2 = 0; _i2 < arg.length; _i2++) {
							this.curves.push(new Curve(arg[_i2]));
						}
					}
				}
			}
		}
		var _proto = CurveSet.prototype;
		_proto.get = function get(index) {
			return this.curves[index];
		};
		_proto.value = function value(time, result) {
			if (result === void 0) {
				result = [];
			}
			var length = this.curves.length;
			result.length = length;
			for (var i = 0; i < length; i++) {
				result[i] = this.curves[i].value(time);
			}
			return result;
		};
		_proto.clone = function clone() {
			var result = new this.constructor();
			result.curves = [];
			for (var i = 0; i < this.curves.length; i++) {
				result.curves.push(this.curves[i].clone());
			}
			result._type = this._type;
			return result;
		};
		_proto.quantize = function quantize(precision) {
			precision = Math.max(precision, 2);
			var numCurves = this.curves.length;
			var values = new Float32Array(precision * numCurves);
			var step = 1.0 / (precision - 1);
			for (var c = 0; c < numCurves; c++) {
				var ev = new CurveEvaluator(this.curves[c]);
				for (var i = 0; i < precision; i++) {
					values[i * numCurves + c] = ev.evaluate(step * i);
				}
			}
			return values;
		};
		_proto.quantizeClamped = function quantizeClamped(precision, min, max) {
			var result = this.quantize(precision);
			for (var i = 0; i < result.length; ++i) {
				result[i] = Math.min(max, Math.max(min, result[i]));
			}
			return result;
		};
		return _createClass(CurveSet, [{
			key: "length",
			get: function get() {
				return this.curves.length;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				this._type = value;
				for (var i = 0; i < this.curves.length; i++) {
					this.curves[i].type = value;
				}
			}
		}]);
	}();

	var oneDiv255 = 1 / 255;
	var floatView = new Float32Array(1);
	var int32View = new Int32Array(floatView.buffer);
	var FloatPacking = function () {
		function FloatPacking() {}
		FloatPacking.float2Half = function float2Half(value) {
			floatView[0] = value;
			var x = int32View[0];
			var bits = x >> 16 & 0x8000;
			var m = x >> 12 & 0x07ff;
			var e = x >> 23 & 0xff;
			if (e < 103) {
				return bits;
			}
			if (e > 142) {
				bits |= 0x7c00;
				bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			if (e < 113) {
				m |= 0x0800;
				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}
			bits |= e - 112 << 10 | m >> 1;
			bits += m & 1;
			return bits;
		};
		FloatPacking.float2Bytes = function float2Bytes(value, array, offset, numBytes) {
			var enc1 = 255.0 * value % 1;
			array[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);
			if (numBytes > 1) {
				var enc2 = 65025.0 * value % 1;
				array[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);
				if (numBytes > 2) {
					var enc3 = 16581375.0 * value % 1;
					array[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);
					if (numBytes > 3) {
						array[offset + 3] = Math.round(enc3 * 255);
					}
				}
			}
		};
		FloatPacking.float2BytesRange = function float2BytesRange(value, array, offset, min, max, numBytes) {
			value = math.clamp((value - min) / (max - min), 0, 1);
			FloatPacking.float2Bytes(value, array, offset, numBytes);
		};
		FloatPacking.float2RGBA8 = function float2RGBA8(value, data) {
			floatView[0] = value;
			var intBits = int32View[0];
			data.r = (intBits >> 24 & 0xFF) / 255.0;
			data.g = (intBits >> 16 & 0xFF) / 255.0;
			data.b = (intBits >> 8 & 0xFF) / 255.0;
			data.a = (intBits & 0xFF) / 255.0;
		};
		return FloatPacking;
	}();

	var Kernel = function () {
		function Kernel() {}
		Kernel.concentric = function concentric(numRings, numPoints) {
			var kernel = [];
			kernel.push(0, 0);
			var spacing = 2 * Math.PI / numRings / numPoints;
			for (var ring = 1; ring <= numRings; ring++) {
				var radius = ring / numRings;
				var circumference = 2 * Math.PI * radius;
				var pointsPerRing = Math.max(1, Math.floor(circumference / spacing));
				var angleStep = 2 * Math.PI / pointsPerRing;
				for (var point = 0; point < pointsPerRing; point++) {
					var angle = point * angleStep;
					var x = radius * Math.cos(angle);
					var y = radius * Math.sin(angle);
					kernel.push(x, y);
				}
			}
			return kernel;
		};
		return Kernel;
	}();

	var _Vec$2;
	var Vec3 = function () {
		function Vec3(x, y, z) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			if (z === void 0) {
				z = 0;
			}
			this.x = void 0;
			this.y = void 0;
			this.z = void 0;
			if (x.length === 3) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}
		var _proto = Vec3.prototype;
		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			return this;
		};
		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			return this;
		};
		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			this.z += scalar;
			return this;
		};
		_proto.addScaled = function addScaled(rhs, scalar) {
			this.x += rhs.x * scalar;
			this.y += rhs.y * scalar;
			this.z += rhs.z * scalar;
			return this;
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y, this.z);
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			return this;
		};
		_proto.cross = function cross(lhs, rhs) {
			var lx = lhs.x;
			var ly = lhs.y;
			var lz = lhs.z;
			var rx = rhs.x;
			var ry = rhs.y;
			var rz = rhs.z;
			this.x = ly * rz - ry * lz;
			this.y = lz * rx - rz * lx;
			this.z = lx * ry - rx * ly;
			return this;
		};
		_proto.distance = function distance(rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			var z = this.z - rhs.z;
			return Math.sqrt(x * x + y * y + z * z);
		};
		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
			return this;
		};
		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			this.z = lhs.z / rhs.z;
			return this;
		};
		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			this.z /= scalar;
			return this;
		};
		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon;
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			return this;
		};
		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x = src.x * invLength;
				this.y = src.y * invLength;
				this.z = src.z * invLength;
			}
			return this;
		};
		_proto.floor = function floor(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.floor(src.x);
			this.y = Math.floor(src.y);
			this.z = Math.floor(src.z);
			return this;
		};
		_proto.ceil = function ceil(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.ceil(src.x);
			this.y = Math.ceil(src.y);
			this.z = Math.ceil(src.z);
			return this;
		};
		_proto.round = function round(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.round(src.x);
			this.y = Math.round(src.y);
			this.z = Math.round(src.z);
			return this;
		};
		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			if (rhs.z < this.z) this.z = rhs.z;
			return this;
		};
		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			if (rhs.z > this.z) this.z = rhs.z;
			return this;
		};
		_proto.project = function project(rhs) {
			var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
			var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
			var s = a_dot_b / b_dot_b;
			this.x = rhs.x * s;
			this.y = rhs.y * s;
			this.z = rhs.z * s;
			return this;
		};
		_proto.set = function set(x, y, z) {
			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		};
		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			return this;
		};
		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			return this;
		};
		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			this.z -= scalar;
			return this;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + "]";
		};
		return Vec3;
	}();
	_Vec$2 = Vec3;
	Vec3.ZERO = Object.freeze(new _Vec$2(0, 0, 0));
	Vec3.HALF = Object.freeze(new _Vec$2(0.5, 0.5, 0.5));
	Vec3.ONE = Object.freeze(new _Vec$2(1, 1, 1));
	Vec3.UP = Object.freeze(new _Vec$2(0, 1, 0));
	Vec3.DOWN = Object.freeze(new _Vec$2(0, -1, 0));
	Vec3.RIGHT = Object.freeze(new _Vec$2(1, 0, 0));
	Vec3.LEFT = Object.freeze(new _Vec$2(-1, 0, 0));
	Vec3.FORWARD = Object.freeze(new _Vec$2(0, 0, -1));
	Vec3.BACK = Object.freeze(new _Vec$2(0, 0, 1));

	var _Mat$1;
	var Mat3 = function () {
		function Mat3() {
			this.data = new Float32Array(9);
			this.data[0] = this.data[4] = this.data[8] = 1;
		}
		var _proto = Mat3.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr().copy(this);
		};
		_proto.copy = function copy(rhs) {
			var src = rhs.data;
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		};
		_proto.set = function set(src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			return this;
		};
		_proto.getX = function getX(x) {
			if (x === void 0) {
				x = new Vec3();
			}
			return x.set(this.data[0], this.data[1], this.data[2]);
		};
		_proto.getY = function getY(y) {
			if (y === void 0) {
				y = new Vec3();
			}
			return y.set(this.data[3], this.data[4], this.data[5]);
		};
		_proto.getZ = function getZ(z) {
			if (z === void 0) {
				z = new Vec3();
			}
			return z.set(this.data[6], this.data[7], this.data[8]);
		};
		_proto.equals = function equals(rhs) {
			var l = this.data;
			var r = rhs.data;
			return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
		};
		_proto.isIdentity = function isIdentity() {
			var m = this.data;
			return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
		};
		_proto.setIdentity = function setIdentity() {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 1;
			m[5] = 0;
			m[6] = 0;
			m[7] = 0;
			m[8] = 1;
			return this;
		};
		_proto.toString = function toString() {
			return "[" + this.data.join(', ') + "]";
		};
		_proto.transpose = function transpose(src) {
			if (src === void 0) {
				src = this;
			}
			var s = src.data;
			var t = this.data;
			if (s === t) {
				var tmp;
				tmp = s[1];
				t[1] = s[3];
				t[3] = tmp;
				tmp = s[2];
				t[2] = s[6];
				t[6] = tmp;
				tmp = s[5];
				t[5] = s[7];
				t[7] = tmp;
			} else {
				t[0] = s[0];
				t[1] = s[3];
				t[2] = s[6];
				t[3] = s[1];
				t[4] = s[4];
				t[5] = s[7];
				t[6] = s[2];
				t[7] = s[5];
				t[8] = s[8];
			}
			return this;
		};
		_proto.setFromMat4 = function setFromMat4(m) {
			var src = m.data;
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[4];
			dst[4] = src[5];
			dst[5] = src[6];
			dst[6] = src[8];
			dst[7] = src[9];
			dst[8] = src[10];
			return this;
		};
		_proto.setFromQuat = function setFromQuat(r) {
			var qx = r.x;
			var qy = r.y;
			var qz = r.z;
			var qw = r.w;
			var x2 = qx + qx;
			var y2 = qy + qy;
			var z2 = qz + qz;
			var xx = qx * x2;
			var xy = qx * y2;
			var xz = qx * z2;
			var yy = qy * y2;
			var yz = qy * z2;
			var zz = qz * z2;
			var wx = qw * x2;
			var wy = qw * y2;
			var wz = qw * z2;
			var m = this.data;
			m[0] = 1 - (yy + zz);
			m[1] = xy + wz;
			m[2] = xz - wy;
			m[3] = xy - wz;
			m[4] = 1 - (xx + zz);
			m[5] = yz + wx;
			m[6] = xz + wy;
			m[7] = yz - wx;
			m[8] = 1 - (xx + yy);
			return this;
		};
		_proto.invertMat4 = function invertMat4(src) {
			var s = src.data;
			var a0 = s[0];
			var a1 = s[1];
			var a2 = s[2];
			var a4 = s[4];
			var a5 = s[5];
			var a6 = s[6];
			var a8 = s[8];
			var a9 = s[9];
			var a10 = s[10];
			var b11 = a10 * a5 - a6 * a9;
			var b21 = -a10 * a1 + a2 * a9;
			var b31 = a6 * a1 - a2 * a5;
			var b12 = -a10 * a4 + a6 * a8;
			var b22 = a10 * a0 - a2 * a8;
			var b32 = -a6 * a0 + a2 * a4;
			var b13 = a9 * a4 - a5 * a8;
			var b23 = -a9 * a0 + a1 * a8;
			var b33 = a5 * a0 - a1 * a4;
			var det = a0 * b11 + a1 * b12 + a2 * b13;
			if (det === 0) {
				this.setIdentity();
			} else {
				var invDet = 1 / det;
				var t = this.data;
				t[0] = b11 * invDet;
				t[1] = b21 * invDet;
				t[2] = b31 * invDet;
				t[3] = b12 * invDet;
				t[4] = b22 * invDet;
				t[5] = b32 * invDet;
				t[6] = b13 * invDet;
				t[7] = b23 * invDet;
				t[8] = b33 * invDet;
			}
			return this;
		};
		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var m = this.data;
			var x = vec.x,
				y = vec.y,
				z = vec.z;
			res.x = x * m[0] + y * m[3] + z * m[6];
			res.y = x * m[1] + y * m[4] + z * m[7];
			res.z = x * m[2] + y * m[5] + z * m[8];
			return res;
		};
		return Mat3;
	}();
	_Mat$1 = Mat3;
	Mat3.IDENTITY = Object.freeze(new _Mat$1());
	Mat3.ZERO = Object.freeze(new _Mat$1().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var _Vec$1;
	var Vec2 = function () {
		function Vec2(x, y) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			this.x = void 0;
			this.y = void 0;
			if (x.length === 2) {
				this.x = x[0];
				this.y = x[1];
			} else {
				this.x = x;
				this.y = y;
			}
		}
		var _proto = Vec2.prototype;
		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			return this;
		};
		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			return this;
		};
		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			return this;
		};
		_proto.addScaled = function addScaled(rhs, scalar) {
			this.x += rhs.x * scalar;
			this.y += rhs.y * scalar;
			return this;
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y);
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			return this;
		};
		_proto.cross = function cross(rhs) {
			return this.x * rhs.y - this.y * rhs.x;
		};
		_proto.distance = function distance(rhs) {
			var x = this.x - rhs.x;
			var y = this.y - rhs.y;
			return Math.sqrt(x * x + y * y);
		};
		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			return this;
		};
		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			return this;
		};
		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			return this;
		};
		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon;
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			return this;
		};
		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var lengthSq = src.x * src.x + src.y * src.y;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x = src.x * invLength;
				this.y = src.y * invLength;
			}
			return this;
		};
		_proto.rotate = function rotate(degrees) {
			var angle = Math.atan2(this.x, this.y) + degrees * math.DEG_TO_RAD;
			var len = Math.sqrt(this.x * this.x + this.y * this.y);
			this.x = Math.sin(angle) * len;
			this.y = Math.cos(angle) * len;
			return this;
		};
		_proto.angle = function angle() {
			return Math.atan2(this.x, this.y) * math.RAD_TO_DEG;
		};
		_proto.angleTo = function angleTo(rhs) {
			return Math.atan2(this.x * rhs.y + this.y * rhs.x, this.x * rhs.x + this.y * rhs.y) * math.RAD_TO_DEG;
		};
		_proto.floor = function floor(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.floor(src.x);
			this.y = Math.floor(src.y);
			return this;
		};
		_proto.ceil = function ceil(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.ceil(src.x);
			this.y = Math.ceil(src.y);
			return this;
		};
		_proto.round = function round(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.round(src.x);
			this.y = Math.round(src.y);
			return this;
		};
		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			return this;
		};
		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			return this;
		};
		_proto.set = function set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		};
		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			return this;
		};
		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			return this;
		};
		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			return this;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + "]";
		};
		Vec2.angleRad = function angleRad(lhs, rhs) {
			return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
		};
		return Vec2;
	}();
	_Vec$1 = Vec2;
	Vec2.ZERO = Object.freeze(new _Vec$1(0, 0));
	Vec2.HALF = Object.freeze(new _Vec$1(0.5, 0.5));
	Vec2.ONE = Object.freeze(new _Vec$1(1, 1));
	Vec2.UP = Object.freeze(new _Vec$1(0, 1));
	Vec2.DOWN = Object.freeze(new _Vec$1(0, -1));
	Vec2.RIGHT = Object.freeze(new _Vec$1(1, 0));
	Vec2.LEFT = Object.freeze(new _Vec$1(-1, 0));

	var _Vec;
	var Vec4 = function () {
		function Vec4(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			if (z === void 0) {
				z = 0;
			}
			if (w === void 0) {
				w = 0;
			}
			this.x = void 0;
			this.y = void 0;
			this.z = void 0;
			this.w = void 0;
			if (x.length === 4) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
				this.w = x[3];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}
		}
		var _proto = Vec4.prototype;
		_proto.add = function add(rhs) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
			this.w += rhs.w;
			return this;
		};
		_proto.add2 = function add2(lhs, rhs) {
			this.x = lhs.x + rhs.x;
			this.y = lhs.y + rhs.y;
			this.z = lhs.z + rhs.z;
			this.w = lhs.w + rhs.w;
			return this;
		};
		_proto.addScalar = function addScalar(scalar) {
			this.x += scalar;
			this.y += scalar;
			this.z += scalar;
			this.w += scalar;
			return this;
		};
		_proto.addScaled = function addScaled(rhs, scalar) {
			this.x += rhs.x * scalar;
			this.y += rhs.y * scalar;
			this.z += rhs.z * scalar;
			this.w += rhs.w * scalar;
			return this;
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y, this.z, this.w);
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		};
		_proto.div = function div(rhs) {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
			this.w /= rhs.w;
			return this;
		};
		_proto.div2 = function div2(lhs, rhs) {
			this.x = lhs.x / rhs.x;
			this.y = lhs.y / rhs.y;
			this.z = lhs.z / rhs.z;
			this.w = lhs.w / rhs.w;
			return this;
		};
		_proto.divScalar = function divScalar(scalar) {
			this.x /= scalar;
			this.y /= scalar;
			this.z /= scalar;
			this.w /= scalar;
			return this;
		};
		_proto.dot = function dot(rhs) {
			return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};
		_proto.lerp = function lerp(lhs, rhs, alpha) {
			this.x = lhs.x + alpha * (rhs.x - lhs.x);
			this.y = lhs.y + alpha * (rhs.y - lhs.y);
			this.z = lhs.z + alpha * (rhs.z - lhs.z);
			this.w = lhs.w + alpha * (rhs.w - lhs.w);
			return this;
		};
		_proto.mul = function mul(rhs) {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
			this.w *= rhs.w;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			this.x = lhs.x * rhs.x;
			this.y = lhs.y * rhs.y;
			this.z = lhs.z * rhs.z;
			this.w = lhs.w * rhs.w;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w;
			if (lengthSq > 0) {
				var invLength = 1 / Math.sqrt(lengthSq);
				this.x = src.x * invLength;
				this.y = src.y * invLength;
				this.z = src.z * invLength;
				this.w = src.w * invLength;
			}
			return this;
		};
		_proto.floor = function floor(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.floor(src.x);
			this.y = Math.floor(src.y);
			this.z = Math.floor(src.z);
			this.w = Math.floor(src.w);
			return this;
		};
		_proto.ceil = function ceil(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.ceil(src.x);
			this.y = Math.ceil(src.y);
			this.z = Math.ceil(src.z);
			this.w = Math.ceil(src.w);
			return this;
		};
		_proto.round = function round(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = Math.round(src.x);
			this.y = Math.round(src.y);
			this.z = Math.round(src.z);
			this.w = Math.round(src.w);
			return this;
		};
		_proto.min = function min(rhs) {
			if (rhs.x < this.x) this.x = rhs.x;
			if (rhs.y < this.y) this.y = rhs.y;
			if (rhs.z < this.z) this.z = rhs.z;
			if (rhs.w < this.w) this.w = rhs.w;
			return this;
		};
		_proto.max = function max(rhs) {
			if (rhs.x > this.x) this.x = rhs.x;
			if (rhs.y > this.y) this.y = rhs.y;
			if (rhs.z > this.z) this.z = rhs.z;
			if (rhs.w > this.w) this.w = rhs.w;
			return this;
		};
		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};
		_proto.sub = function sub(rhs) {
			this.x -= rhs.x;
			this.y -= rhs.y;
			this.z -= rhs.z;
			this.w -= rhs.w;
			return this;
		};
		_proto.sub2 = function sub2(lhs, rhs) {
			this.x = lhs.x - rhs.x;
			this.y = lhs.y - rhs.y;
			this.z = lhs.z - rhs.z;
			this.w = lhs.w - rhs.w;
			return this;
		};
		_proto.subScalar = function subScalar(scalar) {
			this.x -= scalar;
			this.y -= scalar;
			this.z -= scalar;
			this.w -= scalar;
			return this;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		};
		return Vec4;
	}();
	_Vec = Vec4;
	Vec4.ZERO = Object.freeze(new _Vec(0, 0, 0, 0));
	Vec4.HALF = Object.freeze(new _Vec(0.5, 0.5, 0.5, 0.5));
	Vec4.ONE = Object.freeze(new _Vec(1, 1, 1, 1));

	var _Mat;
	var _halfSize$1 = new Vec2();
	var x$1 = new Vec3();
	var y = new Vec3();
	var z = new Vec3();
	var scale = new Vec3();
	var Mat4 = function () {
		function Mat4() {
			this.data = new Float32Array(16);
			this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;
		}
		Mat4._getPerspectiveHalfSize = function _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
			if (fovIsHorizontal) {
				halfSize.x = znear * Math.tan(fov * Math.PI / 360);
				halfSize.y = halfSize.x / aspect;
			} else {
				halfSize.y = znear * Math.tan(fov * Math.PI / 360);
				halfSize.x = halfSize.y * aspect;
			}
		};
		var _proto = Mat4.prototype;
		_proto.add2 = function add2(lhs, rhs) {
			var a = lhs.data,
				b = rhs.data,
				r = this.data;
			r[0] = a[0] + b[0];
			r[1] = a[1] + b[1];
			r[2] = a[2] + b[2];
			r[3] = a[3] + b[3];
			r[4] = a[4] + b[4];
			r[5] = a[5] + b[5];
			r[6] = a[6] + b[6];
			r[7] = a[7] + b[7];
			r[8] = a[8] + b[8];
			r[9] = a[9] + b[9];
			r[10] = a[10] + b[10];
			r[11] = a[11] + b[11];
			r[12] = a[12] + b[12];
			r[13] = a[13] + b[13];
			r[14] = a[14] + b[14];
			r[15] = a[15] + b[15];
			return this;
		};
		_proto.add = function add(rhs) {
			return this.add2(this, rhs);
		};
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr().copy(this);
		};
		_proto.copy = function copy(rhs) {
			var src = rhs.data,
				dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		};
		_proto.equals = function equals(rhs) {
			var l = this.data,
				r = rhs.data;
			return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
		};
		_proto.isIdentity = function isIdentity() {
			var m = this.data;
			return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			var a = lhs.data;
			var b = rhs.data;
			var r = this.data;
			var a00 = a[0];
			var a01 = a[1];
			var a02 = a[2];
			var a03 = a[3];
			var a10 = a[4];
			var a11 = a[5];
			var a12 = a[6];
			var a13 = a[7];
			var a20 = a[8];
			var a21 = a[9];
			var a22 = a[10];
			var a23 = a[11];
			var a30 = a[12];
			var a31 = a[13];
			var a32 = a[14];
			var a33 = a[15];
			var b0, b1, b2, b3;
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			b3 = b[3];
			r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			b3 = b[7];
			r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			b3 = b[11];
			r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			b3 = b[15];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
			r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
			return this;
		};
		_proto.mulAffine2 = function mulAffine2(lhs, rhs) {
			var a = lhs.data;
			var b = rhs.data;
			var r = this.data;
			var a00 = a[0];
			var a01 = a[1];
			var a02 = a[2];
			var a10 = a[4];
			var a11 = a[5];
			var a12 = a[6];
			var a20 = a[8];
			var a21 = a[9];
			var a22 = a[10];
			var a30 = a[12];
			var a31 = a[13];
			var a32 = a[14];
			var b0, b1, b2;
			b0 = b[0];
			b1 = b[1];
			b2 = b[2];
			r[0] = a00 * b0 + a10 * b1 + a20 * b2;
			r[1] = a01 * b0 + a11 * b1 + a21 * b2;
			r[2] = a02 * b0 + a12 * b1 + a22 * b2;
			r[3] = 0;
			b0 = b[4];
			b1 = b[5];
			b2 = b[6];
			r[4] = a00 * b0 + a10 * b1 + a20 * b2;
			r[5] = a01 * b0 + a11 * b1 + a21 * b2;
			r[6] = a02 * b0 + a12 * b1 + a22 * b2;
			r[7] = 0;
			b0 = b[8];
			b1 = b[9];
			b2 = b[10];
			r[8] = a00 * b0 + a10 * b1 + a20 * b2;
			r[9] = a01 * b0 + a11 * b1 + a21 * b2;
			r[10] = a02 * b0 + a12 * b1 + a22 * b2;
			r[11] = 0;
			b0 = b[12];
			b1 = b[13];
			b2 = b[14];
			r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
			r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
			r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
			r[15] = 1;
			return this;
		};
		_proto.mul = function mul(rhs) {
			return this.mul2(this, rhs);
		};
		_proto.transformPoint = function transformPoint(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var m = this.data;
			var x = vec.x,
				y = vec.y,
				z = vec.z;
			res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
			return res;
		};
		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var m = this.data;
			var x = vec.x,
				y = vec.y,
				z = vec.z;
			res.x = x * m[0] + y * m[4] + z * m[8];
			res.y = x * m[1] + y * m[5] + z * m[9];
			res.z = x * m[2] + y * m[6] + z * m[10];
			return res;
		};
		_proto.transformVec4 = function transformVec4(vec, res) {
			if (res === void 0) {
				res = new Vec4();
			}
			var m = this.data;
			var x = vec.x,
				y = vec.y,
				z = vec.z,
				w = vec.w;
			res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
			res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
			res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
			res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
			return res;
		};
		_proto.setLookAt = function setLookAt(position, target, up) {
			z.sub2(position, target).normalize();
			y.copy(up).normalize();
			x$1.cross(y, z).normalize();
			y.cross(z, x$1);
			var r = this.data;
			r[0] = x$1.x;
			r[1] = x$1.y;
			r[2] = x$1.z;
			r[3] = 0;
			r[4] = y.x;
			r[5] = y.y;
			r[6] = y.z;
			r[7] = 0;
			r[8] = z.x;
			r[9] = z.y;
			r[10] = z.z;
			r[11] = 0;
			r[12] = position.x;
			r[13] = position.y;
			r[14] = position.z;
			r[15] = 1;
			return this;
		};
		_proto.setFrustum = function setFrustum(left, right, bottom, top, znear, zfar) {
			var temp1 = 2 * znear;
			var temp2 = right - left;
			var temp3 = top - bottom;
			var temp4 = zfar - znear;
			var r = this.data;
			r[0] = temp1 / temp2;
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = temp1 / temp3;
			r[6] = 0;
			r[7] = 0;
			r[8] = (right + left) / temp2;
			r[9] = (top + bottom) / temp3;
			r[10] = (-zfar - znear) / temp4;
			r[11] = -1;
			r[12] = 0;
			r[13] = 0;
			r[14] = -temp1 * zfar / temp4;
			r[15] = 0;
			return this;
		};
		_proto.setPerspective = function setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
			Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);
			return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
		};
		_proto.setOrtho = function setOrtho(left, right, bottom, top, near, far) {
			var r = this.data;
			r[0] = 2 / (right - left);
			r[1] = 0;
			r[2] = 0;
			r[3] = 0;
			r[4] = 0;
			r[5] = 2 / (top - bottom);
			r[6] = 0;
			r[7] = 0;
			r[8] = 0;
			r[9] = 0;
			r[10] = -2 / (far - near);
			r[11] = 0;
			r[12] = -(right + left) / (right - left);
			r[13] = -(top + bottom) / (top - bottom);
			r[14] = -(far + near) / (far - near);
			r[15] = 1;
			return this;
		};
		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			angle *= math.DEG_TO_RAD;
			var x = axis.x,
				y = axis.y,
				z = axis.z;
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			var t = 1 - c;
			var tx = t * x;
			var ty = t * y;
			var m = this.data;
			m[0] = tx * x + c;
			m[1] = tx * y + s * z;
			m[2] = tx * z - s * y;
			m[3] = 0;
			m[4] = tx * y - s * z;
			m[5] = ty * y + c;
			m[6] = ty * z + s * x;
			m[7] = 0;
			m[8] = tx * z + s * y;
			m[9] = ty * z - x * s;
			m[10] = t * z * z + c;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.setTranslate = function setTranslate(x, y, z) {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = x;
			m[13] = y;
			m[14] = z;
			m[15] = 1;
			return this;
		};
		_proto.setScale = function setScale(x, y, z) {
			var m = this.data;
			m[0] = x;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = y;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = z;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.setViewport = function setViewport(x, y, width, height) {
			var m = this.data;
			m[0] = width * 0.5;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = height * 0.5;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 0.5;
			m[11] = 0;
			m[12] = x + width * 0.5;
			m[13] = y + height * 0.5;
			m[14] = 0.5;
			m[15] = 1;
			return this;
		};
		_proto.setReflection = function setReflection(normal, distance) {
			var a = normal.x;
			var b = normal.y;
			var c = normal.z;
			var data = this.data;
			data[0] = 1.0 - 2 * a * a;
			data[1] = -2 * a * b;
			data[2] = -2 * a * c;
			data[3] = 0;
			data[4] = -2 * a * b;
			data[5] = 1.0 - 2 * b * b;
			data[6] = -2 * b * c;
			data[7] = 0;
			data[8] = -2 * a * c;
			data[9] = -2 * b * c;
			data[10] = 1.0 - 2 * c * c;
			data[11] = 0;
			data[12] = -2 * a * distance;
			data[13] = -2 * b * distance;
			data[14] = -2 * c * distance;
			data[15] = 1;
			return this;
		};
		_proto.invert = function invert(src) {
			if (src === void 0) {
				src = this;
			}
			var s = src.data;
			var a00 = s[0];
			var a01 = s[1];
			var a02 = s[2];
			var a03 = s[3];
			var a10 = s[4];
			var a11 = s[5];
			var a12 = s[6];
			var a13 = s[7];
			var a20 = s[8];
			var a21 = s[9];
			var a22 = s[10];
			var a23 = s[11];
			var a30 = s[12];
			var a31 = s[13];
			var a32 = s[14];
			var a33 = s[15];
			var b00 = a00 * a11 - a01 * a10;
			var b01 = a00 * a12 - a02 * a10;
			var b02 = a00 * a13 - a03 * a10;
			var b03 = a01 * a12 - a02 * a11;
			var b04 = a01 * a13 - a03 * a11;
			var b05 = a02 * a13 - a03 * a12;
			var b06 = a20 * a31 - a21 * a30;
			var b07 = a20 * a32 - a22 * a30;
			var b08 = a20 * a33 - a23 * a30;
			var b09 = a21 * a32 - a22 * a31;
			var b10 = a21 * a33 - a23 * a31;
			var b11 = a22 * a33 - a23 * a32;
			var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
			if (det === 0) {
				this.setIdentity();
			} else {
				var invDet = 1 / det;
				var t = this.data;
				t[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
				t[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
				t[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
				t[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
				t[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
				t[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
				t[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
				t[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
				t[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
				t[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
				t[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
				t[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
				t[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
				t[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
				t[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
				t[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
			}
			return this;
		};
		_proto.set = function set(src) {
			var dst = this.data;
			dst[0] = src[0];
			dst[1] = src[1];
			dst[2] = src[2];
			dst[3] = src[3];
			dst[4] = src[4];
			dst[5] = src[5];
			dst[6] = src[6];
			dst[7] = src[7];
			dst[8] = src[8];
			dst[9] = src[9];
			dst[10] = src[10];
			dst[11] = src[11];
			dst[12] = src[12];
			dst[13] = src[13];
			dst[14] = src[14];
			dst[15] = src[15];
			return this;
		};
		_proto.setIdentity = function setIdentity() {
			var m = this.data;
			m[0] = 1;
			m[1] = 0;
			m[2] = 0;
			m[3] = 0;
			m[4] = 0;
			m[5] = 1;
			m[6] = 0;
			m[7] = 0;
			m[8] = 0;
			m[9] = 0;
			m[10] = 1;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.setTRS = function setTRS(t, r, s) {
			var qx = r.x;
			var qy = r.y;
			var qz = r.z;
			var qw = r.w;
			var sx = s.x;
			var sy = s.y;
			var sz = s.z;
			var x2 = qx + qx;
			var y2 = qy + qy;
			var z2 = qz + qz;
			var xx = qx * x2;
			var xy = qx * y2;
			var xz = qx * z2;
			var yy = qy * y2;
			var yz = qy * z2;
			var zz = qz * z2;
			var wx = qw * x2;
			var wy = qw * y2;
			var wz = qw * z2;
			var m = this.data;
			m[0] = (1 - (yy + zz)) * sx;
			m[1] = (xy + wz) * sx;
			m[2] = (xz - wy) * sx;
			m[3] = 0;
			m[4] = (xy - wz) * sy;
			m[5] = (1 - (xx + zz)) * sy;
			m[6] = (yz + wx) * sy;
			m[7] = 0;
			m[8] = (xz + wy) * sz;
			m[9] = (yz - wx) * sz;
			m[10] = (1 - (xx + yy)) * sz;
			m[11] = 0;
			m[12] = t.x;
			m[13] = t.y;
			m[14] = t.z;
			m[15] = 1;
			return this;
		};
		_proto.transpose = function transpose(src) {
			if (src === void 0) {
				src = this;
			}
			var s = src.data;
			var t = this.data;
			if (s === t) {
				var tmp;
				tmp = s[1];
				t[1] = s[4];
				t[4] = tmp;
				tmp = s[2];
				t[2] = s[8];
				t[8] = tmp;
				tmp = s[3];
				t[3] = s[12];
				t[12] = tmp;
				tmp = s[6];
				t[6] = s[9];
				t[9] = tmp;
				tmp = s[7];
				t[7] = s[13];
				t[13] = tmp;
				tmp = s[11];
				t[11] = s[14];
				t[14] = tmp;
			} else {
				t[0] = s[0];
				t[1] = s[4];
				t[2] = s[8];
				t[3] = s[12];
				t[4] = s[1];
				t[5] = s[5];
				t[6] = s[9];
				t[7] = s[13];
				t[8] = s[2];
				t[9] = s[6];
				t[10] = s[10];
				t[11] = s[14];
				t[12] = s[3];
				t[13] = s[7];
				t[14] = s[11];
				t[15] = s[15];
			}
			return this;
		};
		_proto.getTranslation = function getTranslation(t) {
			if (t === void 0) {
				t = new Vec3();
			}
			return t.set(this.data[12], this.data[13], this.data[14]);
		};
		_proto.getX = function getX(x) {
			if (x === void 0) {
				x = new Vec3();
			}
			return x.set(this.data[0], this.data[1], this.data[2]);
		};
		_proto.getY = function getY(y) {
			if (y === void 0) {
				y = new Vec3();
			}
			return y.set(this.data[4], this.data[5], this.data[6]);
		};
		_proto.getZ = function getZ(z) {
			if (z === void 0) {
				z = new Vec3();
			}
			return z.set(this.data[8], this.data[9], this.data[10]);
		};
		_proto.getScale = function getScale(scale) {
			if (scale === void 0) {
				scale = new Vec3();
			}
			this.getX(x$1);
			this.getY(y);
			this.getZ(z);
			scale.set(x$1.length(), y.length(), z.length());
			return scale;
		};
		_proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
			ex *= math.DEG_TO_RAD;
			ey *= math.DEG_TO_RAD;
			ez *= math.DEG_TO_RAD;
			var s1 = Math.sin(-ex);
			var c1 = Math.cos(-ex);
			var s2 = Math.sin(-ey);
			var c2 = Math.cos(-ey);
			var s3 = Math.sin(-ez);
			var c3 = Math.cos(-ez);
			var m = this.data;
			m[0] = c2 * c3;
			m[1] = -c2 * s3;
			m[2] = s2;
			m[3] = 0;
			m[4] = c1 * s3 + c3 * s1 * s2;
			m[5] = c1 * c3 - s1 * s2 * s3;
			m[6] = -c2 * s1;
			m[7] = 0;
			m[8] = s1 * s3 - c1 * c3 * s2;
			m[9] = c3 * s1 + c1 * s2 * s3;
			m[10] = c1 * c2;
			m[11] = 0;
			m[12] = 0;
			m[13] = 0;
			m[14] = 0;
			m[15] = 1;
			return this;
		};
		_proto.getEulerAngles = function getEulerAngles(eulers) {
			if (eulers === void 0) {
				eulers = new Vec3();
			}
			this.getScale(scale);
			var sx = scale.x;
			var sy = scale.y;
			var sz = scale.z;
			if (sx === 0 || sy === 0 || sz === 0) {
				return eulers.set(0, 0, 0);
			}
			var m = this.data;
			var y = Math.asin(-m[2] / sx);
			var halfPi = Math.PI * 0.5;
			var x, z;
			if (y < halfPi) {
				if (y > -halfPi) {
					x = Math.atan2(m[6] / sy, m[10] / sz);
					z = Math.atan2(m[1] / sx, m[0] / sx);
				} else {
					z = 0;
					x = -Math.atan2(m[4] / sy, m[5] / sy);
				}
			} else {
				z = 0;
				x = Math.atan2(m[4] / sy, m[5] / sy);
			}
			return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		};
		_proto.toString = function toString() {
			return "[" + this.data.join(', ') + "]";
		};
		return _createClass(Mat4, [{
			key: "scaleSign",
			get: function get() {
				this.getX(x$1);
				this.getY(y);
				this.getZ(z);
				x$1.cross(x$1, y);
				return x$1.dot(z) < 0 ? -1 : 1;
			}
		}]);
	}();
	_Mat = Mat4;
	Mat4.IDENTITY = Object.freeze(new _Mat());
	Mat4.ZERO = Object.freeze(new _Mat().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));

	var _Quat;
	var Quat = function () {
		function Quat(x, y, z, w) {
			if (x === void 0) {
				x = 0;
			}
			if (y === void 0) {
				y = 0;
			}
			if (z === void 0) {
				z = 0;
			}
			if (w === void 0) {
				w = 1;
			}
			this.x = void 0;
			this.y = void 0;
			this.z = void 0;
			this.w = void 0;
			if (x.length === 4) {
				this.x = x[0];
				this.y = x[1];
				this.z = x[2];
				this.w = x[3];
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}
		}
		var _proto = Quat.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr(this.x, this.y, this.z, this.w);
		};
		_proto.conjugate = function conjugate(src) {
			if (src === void 0) {
				src = this;
			}
			this.x = src.x * -1;
			this.y = src.y * -1;
			this.z = src.z * -1;
			this.w = src.w;
			return this;
		};
		_proto.copy = function copy(rhs) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
			return this;
		};
		_proto.equals = function equals(rhs) {
			return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
		};
		_proto.equalsApprox = function equalsApprox(rhs, epsilon) {
			if (epsilon === void 0) {
				epsilon = 1e-6;
			}
			return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
		};
		_proto.getAxisAngle = function getAxisAngle(axis) {
			var rad = Math.acos(this.w) * 2;
			var s = Math.sin(rad / 2);
			if (s !== 0) {
				axis.x = this.x / s;
				axis.y = this.y / s;
				axis.z = this.z / s;
				if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
					axis.x *= -1;
					axis.y *= -1;
					axis.z *= -1;
					rad *= -1;
				}
			} else {
				axis.x = 1;
				axis.y = 0;
				axis.z = 0;
			}
			return rad * math.RAD_TO_DEG;
		};
		_proto.getEulerAngles = function getEulerAngles(eulers) {
			if (eulers === void 0) {
				eulers = new Vec3();
			}
			var x, y, z;
			var qx = this.x;
			var qy = this.y;
			var qz = this.z;
			var qw = this.w;
			var a2 = 2 * (qw * qy - qx * qz);
			if (a2 <= -0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = -Math.PI / 2;
				z = 0;
			} else if (a2 >= 0.99999) {
				x = 2 * Math.atan2(qx, qw);
				y = Math.PI / 2;
				z = 0;
			} else {
				x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
				y = Math.asin(a2);
				z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
			}
			return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
		};
		_proto.invert = function invert(src) {
			if (src === void 0) {
				src = this;
			}
			return this.conjugate(src).normalize();
		};
		_proto.length = function length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};
		_proto.lengthSq = function lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		};
		_proto.mul = function mul(rhs) {
			var q1x = this.x;
			var q1y = this.y;
			var q1z = this.z;
			var q1w = this.w;
			var q2x = rhs.x;
			var q2y = rhs.y;
			var q2z = rhs.z;
			var q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		};
		_proto.mulScalar = function mulScalar(scalar, src) {
			if (src === void 0) {
				src = this;
			}
			this.x = src.x * scalar;
			this.y = src.y * scalar;
			this.z = src.z * scalar;
			this.w = src.w * scalar;
			return this;
		};
		_proto.mul2 = function mul2(lhs, rhs) {
			var q1x = lhs.x;
			var q1y = lhs.y;
			var q1z = lhs.z;
			var q1w = lhs.w;
			var q2x = rhs.x;
			var q2y = rhs.y;
			var q2z = rhs.z;
			var q2w = rhs.w;
			this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
			this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
			this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
			this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
			return this;
		};
		_proto.normalize = function normalize(src) {
			if (src === void 0) {
				src = this;
			}
			var len = src.length();
			if (len === 0) {
				this.x = this.y = this.z = 0;
				this.w = 1;
			} else {
				len = 1 / len;
				this.x = src.x * len;
				this.y = src.y * len;
				this.z = src.z * len;
				this.w = src.w * len;
			}
			return this;
		};
		_proto.set = function set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		};
		_proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
			angle *= 0.5 * math.DEG_TO_RAD;
			var sa = Math.sin(angle);
			var ca = Math.cos(angle);
			this.x = sa * axis.x;
			this.y = sa * axis.y;
			this.z = sa * axis.z;
			this.w = ca;
			return this;
		};
		_proto.setFromEulerAngles = function setFromEulerAngles(ex, ey, ez) {
			if (ex instanceof Vec3) {
				var vec = ex;
				ex = vec.x;
				ey = vec.y;
				ez = vec.z;
			}
			var halfToRad = 0.5 * math.DEG_TO_RAD;
			ex *= halfToRad;
			ey *= halfToRad;
			ez *= halfToRad;
			var sx = Math.sin(ex);
			var cx = Math.cos(ex);
			var sy = Math.sin(ey);
			var cy = Math.cos(ey);
			var sz = Math.sin(ez);
			var cz = Math.cos(ez);
			this.x = sx * cy * cz - cx * sy * sz;
			this.y = cx * sy * cz + sx * cy * sz;
			this.z = cx * cy * sz - sx * sy * cz;
			this.w = cx * cy * cz + sx * sy * sz;
			return this;
		};
		_proto.setFromMat4 = function setFromMat4(m) {
			var d = m.data;
			var m00 = d[0];
			var m01 = d[1];
			var m02 = d[2];
			var m10 = d[4];
			var m11 = d[5];
			var m12 = d[6];
			var m20 = d[8];
			var m21 = d[9];
			var m22 = d[10];
			var l;
			l = m00 * m00 + m01 * m01 + m02 * m02;
			if (l === 0) return this.set(0, 0, 0, 1);
			l = 1 / Math.sqrt(l);
			m00 *= l;
			m01 *= l;
			m02 *= l;
			l = m10 * m10 + m11 * m11 + m12 * m12;
			if (l === 0) return this.set(0, 0, 0, 1);
			l = 1 / Math.sqrt(l);
			m10 *= l;
			m11 *= l;
			m12 *= l;
			l = m20 * m20 + m21 * m21 + m22 * m22;
			if (l === 0) return this.set(0, 0, 0, 1);
			l = 1 / Math.sqrt(l);
			m20 *= l;
			m21 *= l;
			m22 *= l;
			if (m22 < 0) {
				if (m00 > m11) {
					this.set(1 + m00 - m11 - m22, m01 + m10, m20 + m02, m12 - m21);
				} else {
					this.set(m01 + m10, 1 - m00 + m11 - m22, m12 + m21, m20 - m02);
				}
			} else {
				if (m00 < -m11) {
					this.set(m20 + m02, m12 + m21, 1 - m00 - m11 + m22, m01 - m10);
				} else {
					this.set(m12 - m21, m20 - m02, m01 - m10, 1 + m00 + m11 + m22);
				}
			}
			return this.mulScalar(1.0 / this.length());
		};
		_proto.setFromDirections = function setFromDirections(from, to) {
			var dotProduct = 1 + from.dot(to);
			if (dotProduct < Number.EPSILON) {
				if (Math.abs(from.x) > Math.abs(from.y)) {
					this.x = -from.z;
					this.y = 0;
					this.z = from.x;
					this.w = 0;
				} else {
					this.x = 0;
					this.y = -from.z;
					this.z = from.y;
					this.w = 0;
				}
			} else {
				this.x = from.y * to.z - from.z * to.y;
				this.y = from.z * to.x - from.x * to.z;
				this.z = from.x * to.y - from.y * to.x;
				this.w = dotProduct;
			}
			return this.normalize();
		};
		_proto.slerp = function slerp(lhs, rhs, alpha) {
			var lx = lhs.x;
			var ly = lhs.y;
			var lz = lhs.z;
			var lw = lhs.w;
			var rx = rhs.x;
			var ry = rhs.y;
			var rz = rhs.z;
			var rw = rhs.w;
			var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
			if (cosHalfTheta < 0) {
				rw = -rw;
				rx = -rx;
				ry = -ry;
				rz = -rz;
				cosHalfTheta = -cosHalfTheta;
			}
			if (Math.abs(cosHalfTheta) >= 1) {
				this.w = lw;
				this.x = lx;
				this.y = ly;
				this.z = lz;
				return this;
			}
			var halfTheta = Math.acos(cosHalfTheta);
			var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
			if (Math.abs(sinHalfTheta) < 0.001) {
				this.w = lw * 0.5 + rw * 0.5;
				this.x = lx * 0.5 + rx * 0.5;
				this.y = ly * 0.5 + ry * 0.5;
				this.z = lz * 0.5 + rz * 0.5;
				return this;
			}
			var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
			var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
			this.w = lw * ratioA + rw * ratioB;
			this.x = lx * ratioA + rx * ratioB;
			this.y = ly * ratioA + ry * ratioB;
			this.z = lz * ratioA + rz * ratioB;
			return this;
		};
		_proto.transformVector = function transformVector(vec, res) {
			if (res === void 0) {
				res = new Vec3();
			}
			var x = vec.x,
				y = vec.y,
				z = vec.z;
			var qx = this.x,
				qy = this.y,
				qz = this.z,
				qw = this.w;
			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z;
			res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return res;
		};
		_proto.toString = function toString() {
			return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
		};
		return Quat;
	}();
	_Quat = Quat;
	Quat.IDENTITY = Object.freeze(new _Quat(0, 0, 0, 1));
	Quat.ZERO = Object.freeze(new _Quat(0, 0, 0, 0));

	var tmpVecA$1 = new Vec3();
	var tmpVecB$1 = new Vec3();
	var tmpVecC = new Vec3();
	var tmpVecD = new Vec3();
	var tmpVecE = new Vec3();
	var BoundingBox = function () {
		function BoundingBox(center, halfExtents) {
			this.center = new Vec3();
			this.halfExtents = new Vec3(0.5, 0.5, 0.5);
			this._min = new Vec3();
			this._max = new Vec3();
			if (center) {
				this.center.copy(center);
			}
			if (halfExtents) {
				this.halfExtents.copy(halfExtents);
			}
		}
		var _proto = BoundingBox.prototype;
		_proto.add = function add(other) {
			var tc = this.center;
			var tcx = tc.x;
			var tcy = tc.y;
			var tcz = tc.z;
			var th = this.halfExtents;
			var thx = th.x;
			var thy = th.y;
			var thz = th.z;
			var tminx = tcx - thx;
			var tmaxx = tcx + thx;
			var tminy = tcy - thy;
			var tmaxy = tcy + thy;
			var tminz = tcz - thz;
			var tmaxz = tcz + thz;
			var oc = other.center;
			var ocx = oc.x;
			var ocy = oc.y;
			var ocz = oc.z;
			var oh = other.halfExtents;
			var ohx = oh.x;
			var ohy = oh.y;
			var ohz = oh.z;
			var ominx = ocx - ohx;
			var omaxx = ocx + ohx;
			var ominy = ocy - ohy;
			var omaxy = ocy + ohy;
			var ominz = ocz - ohz;
			var omaxz = ocz + ohz;
			if (ominx < tminx) tminx = ominx;
			if (omaxx > tmaxx) tmaxx = omaxx;
			if (ominy < tminy) tminy = ominy;
			if (omaxy > tmaxy) tmaxy = omaxy;
			if (ominz < tminz) tminz = ominz;
			if (omaxz > tmaxz) tmaxz = omaxz;
			tc.x = (tminx + tmaxx) * 0.5;
			tc.y = (tminy + tmaxy) * 0.5;
			tc.z = (tminz + tmaxz) * 0.5;
			th.x = (tmaxx - tminx) * 0.5;
			th.y = (tmaxy - tminy) * 0.5;
			th.z = (tmaxz - tminz) * 0.5;
		};
		_proto.copy = function copy(src) {
			this.center.copy(src.center);
			this.halfExtents.copy(src.halfExtents);
		};
		_proto.clone = function clone() {
			return new BoundingBox(this.center, this.halfExtents);
		};
		_proto.intersects = function intersects(other) {
			var aMax = this.getMax();
			var aMin = this.getMin();
			var bMax = other.getMax();
			var bMin = other.getMin();
			return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
		};
		_proto._intersectsRay = function _intersectsRay(ray, point) {
			var tMin = tmpVecA$1.copy(this.getMin()).sub(ray.origin);
			var tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
			var dir = ray.direction;
			if (dir.x === 0) {
				tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.x /= dir.x;
				tMax.x /= dir.x;
			}
			if (dir.y === 0) {
				tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.y /= dir.y;
				tMax.y /= dir.y;
			}
			if (dir.z === 0) {
				tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
				tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
			} else {
				tMin.z /= dir.z;
				tMax.z /= dir.z;
			}
			var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
			var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
			var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
			var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
			var intersects = minMax >= maxMin && maxMin >= 0;
			if (intersects) {
				point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
			}
			return intersects;
		};
		_proto._fastIntersectsRay = function _fastIntersectsRay(ray) {
			var diff = tmpVecA$1;
			var cross = tmpVecB$1;
			var prod = tmpVecC;
			var absDiff = tmpVecD;
			var absDir = tmpVecE;
			var rayDir = ray.direction;
			diff.sub2(ray.origin, this.center);
			absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
			prod.mul2(diff, rayDir);
			if (absDiff.x > this.halfExtents.x && prod.x >= 0) {
				return false;
			}
			if (absDiff.y > this.halfExtents.y && prod.y >= 0) {
				return false;
			}
			if (absDiff.z > this.halfExtents.z && prod.z >= 0) {
				return false;
			}
			absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
			cross.cross(rayDir, diff);
			cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
			if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) {
				return false;
			}
			if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) {
				return false;
			}
			if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) {
				return false;
			}
			return true;
		};
		_proto.intersectsRay = function intersectsRay(ray, point) {
			if (point) {
				return this._intersectsRay(ray, point);
			}
			return this._fastIntersectsRay(ray);
		};
		_proto.setMinMax = function setMinMax(min, max) {
			this.center.add2(max, min).mulScalar(0.5);
			this.halfExtents.sub2(max, min).mulScalar(0.5);
		};
		_proto.getMin = function getMin() {
			return this._min.copy(this.center).sub(this.halfExtents);
		};
		_proto.getMax = function getMax() {
			return this._max.copy(this.center).add(this.halfExtents);
		};
		_proto.containsPoint = function containsPoint(point) {
			var min = this.getMin();
			var max = this.getMax();
			if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
				return false;
			}
			return true;
		};
		_proto.setFromTransformedAabb = function setFromTransformedAabb(aabb, m, ignoreScale) {
			if (ignoreScale === void 0) {
				ignoreScale = false;
			}
			var ac = aabb.center;
			var ar = aabb.halfExtents;
			var d = m.data;
			var mx0 = d[0];
			var mx1 = d[4];
			var mx2 = d[8];
			var my0 = d[1];
			var my1 = d[5];
			var my2 = d[9];
			var mz0 = d[2];
			var mz1 = d[6];
			var mz2 = d[10];
			if (ignoreScale) {
				var lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;
				if (lengthSq > 0) {
					var invLength = 1 / Math.sqrt(lengthSq);
					mx0 *= invLength;
					mx1 *= invLength;
					mx2 *= invLength;
				}
				lengthSq = my0 * my0 + my1 * my1 + my2 * my2;
				if (lengthSq > 0) {
					var _invLength = 1 / Math.sqrt(lengthSq);
					my0 *= _invLength;
					my1 *= _invLength;
					my2 *= _invLength;
				}
				lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;
				if (lengthSq > 0) {
					var _invLength2 = 1 / Math.sqrt(lengthSq);
					mz0 *= _invLength2;
					mz1 *= _invLength2;
					mz2 *= _invLength2;
				}
			}
			this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
			this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
		};
		BoundingBox.computeMinMax = function computeMinMax(vertices, min, max, numVerts) {
			if (numVerts === void 0) {
				numVerts = vertices.length / 3;
			}
			if (numVerts > 0) {
				var minx = vertices[0];
				var miny = vertices[1];
				var minz = vertices[2];
				var maxx = minx;
				var maxy = miny;
				var maxz = minz;
				var n = numVerts * 3;
				for (var i = 3; i < n; i += 3) {
					var x = vertices[i];
					var y = vertices[i + 1];
					var z = vertices[i + 2];
					if (x < minx) minx = x;
					if (y < miny) miny = y;
					if (z < minz) minz = z;
					if (x > maxx) maxx = x;
					if (y > maxy) maxy = y;
					if (z > maxz) maxz = z;
				}
				min.set(minx, miny, minz);
				max.set(maxx, maxy, maxz);
			}
		};
		_proto.compute = function compute(vertices, numVerts) {
			BoundingBox.computeMinMax(vertices, tmpVecA$1, tmpVecB$1, numVerts);
			this.setMinMax(tmpVecA$1, tmpVecB$1);
		};
		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			var sq = this._distanceToBoundingSphereSq(sphere);
			if (sq <= sphere.radius * sphere.radius) {
				return true;
			}
			return false;
		};
		_proto._distanceToBoundingSphereSq = function _distanceToBoundingSphereSq(sphere) {
			var boxMin = this.getMin();
			var boxMax = this.getMax();
			var sq = 0;
			var axis = ['x', 'y', 'z'];
			for (var i = 0; i < 3; ++i) {
				var out = 0;
				var pn = sphere.center[axis[i]];
				var bMin = boxMin[axis[i]];
				var bMax = boxMax[axis[i]];
				var val = 0;
				if (pn < bMin) {
					val = bMin - pn;
					out += val * val;
				}
				if (pn > bMax) {
					val = pn - bMax;
					out += val * val;
				}
				sq += out;
			}
			return sq;
		};
		_proto._expand = function _expand(expandMin, expandMax) {
			tmpVecA$1.add2(this.getMin(), expandMin);
			tmpVecB$1.add2(this.getMax(), expandMax);
			this.setMinMax(tmpVecA$1, tmpVecB$1);
		};
		return BoundingBox;
	}();

	var tmpVecA = new Vec3();
	var tmpVecB = new Vec3();
	var BoundingSphere = function () {
		function BoundingSphere(center, radius) {
			if (center === void 0) {
				center = new Vec3();
			}
			if (radius === void 0) {
				radius = 0.5;
			}
			this.center = void 0;
			this.radius = void 0;
			this.center = center;
			this.radius = radius;
		}
		var _proto = BoundingSphere.prototype;
		_proto.containsPoint = function containsPoint(point) {
			var lenSq = tmpVecA.sub2(point, this.center).lengthSq();
			var r = this.radius;
			return lenSq < r * r;
		};
		_proto.intersectsRay = function intersectsRay(ray, point) {
			var m = tmpVecA.copy(ray.origin).sub(this.center);
			var b = m.dot(tmpVecB.copy(ray.direction).normalize());
			var c = m.dot(m) - this.radius * this.radius;
			if (c > 0 && b > 0) {
				return false;
			}
			var discr = b * b - c;
			if (discr < 0) {
				return false;
			}
			var t = Math.abs(-b - Math.sqrt(discr));
			if (point) {
				point.copy(ray.direction).mulScalar(t).add(ray.origin);
			}
			return true;
		};
		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			tmpVecA.sub2(sphere.center, this.center);
			var totalRadius = sphere.radius + this.radius;
			if (tmpVecA.lengthSq() <= totalRadius * totalRadius) {
				return true;
			}
			return false;
		};
		return BoundingSphere;
	}();

	var Plane = function () {
		function Plane(normal, distance) {
			if (normal === void 0) {
				normal = Vec3.UP;
			}
			if (distance === void 0) {
				distance = 0;
			}
			this.normal = new Vec3();
			this.distance = void 0;
			this.normal.copy(normal);
			this.distance = distance;
		}
		var _proto = Plane.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr().copy(this);
		};
		_proto.copy = function copy(src) {
			this.normal.copy(src.normal);
			this.distance = src.distance;
			return this;
		};
		_proto.intersectsLine = function intersectsLine(start, end, point) {
			var d = this.distance;
			var d0 = this.normal.dot(start) + d;
			var d1 = this.normal.dot(end) + d;
			var t = d0 / (d0 - d1);
			var intersects = t >= 0 && t <= 1;
			if (intersects && point) {
				point.lerp(start, end, t);
			}
			return intersects;
		};
		_proto.intersectsRay = function intersectsRay(ray, point) {
			var denominator = this.normal.dot(ray.direction);
			if (denominator === 0) {
				return false;
			}
			var t = -(this.normal.dot(ray.origin) + this.distance) / denominator;
			if (t >= 0 && point) {
				point.copy(ray.direction).mulScalar(t).add(ray.origin);
			}
			return t >= 0;
		};
		_proto.normalize = function normalize() {
			var invLength = 1 / this.normal.length();
			this.normal.mulScalar(invLength);
			this.distance *= invLength;
			return this;
		};
		_proto.set = function set(nx, ny, nz, d) {
			this.normal.set(nx, ny, nz);
			this.distance = d;
			return this;
		};
		_proto.setFromPointNormal = function setFromPointNormal(point, normal) {
			this.normal.copy(normal);
			this.distance = -this.normal.dot(point);
			return this;
		};
		return Plane;
	}();

	var Frustum = function () {
		function Frustum() {
			this.planes = [];
			for (var i = 0; i < 6; i++) {
				this.planes[i] = new Plane();
			}
		}
		var _proto = Frustum.prototype;
		_proto.clone = function clone() {
			var cstr = this.constructor;
			return new cstr().copy(this);
		};
		_proto.copy = function copy(src) {
			for (var i = 0; i < 6; i++) {
				this.planes[i].copy(src.planes[i]);
			}
			return this;
		};
		_proto.setFromMat4 = function setFromMat4(matrix) {
			var _matrix$data = matrix.data,
				m00 = _matrix$data[0],
				m01 = _matrix$data[1],
				m02 = _matrix$data[2],
				m03 = _matrix$data[3],
				m10 = _matrix$data[4],
				m11 = _matrix$data[5],
				m12 = _matrix$data[6],
				m13 = _matrix$data[7],
				m20 = _matrix$data[8],
				m21 = _matrix$data[9],
				m22 = _matrix$data[10],
				m23 = _matrix$data[11],
				m30 = _matrix$data[12],
				m31 = _matrix$data[13],
				m32 = _matrix$data[14],
				m33 = _matrix$data[15];
			var planes = this.planes;
			planes[0].set(m03 - m00, m13 - m10, m23 - m20, m33 - m30).normalize();
			planes[1].set(m03 + m00, m13 + m10, m23 + m20, m33 + m30).normalize();
			planes[2].set(m03 + m01, m13 + m11, m23 + m21, m33 + m31).normalize();
			planes[3].set(m03 - m01, m13 - m11, m23 - m21, m33 - m31).normalize();
			planes[4].set(m03 - m02, m13 - m12, m23 - m22, m33 - m32).normalize();
			planes[5].set(m03 + m02, m13 + m12, m23 + m22, m33 + m32).normalize();
		};
		_proto.containsPoint = function containsPoint(point) {
			for (var p = 0; p < 6; p++) {
				var _this$planes$p = this.planes[p],
					normal = _this$planes$p.normal,
					distance = _this$planes$p.distance;
				if (normal.dot(point) + distance <= 0) {
					return false;
				}
			}
			return true;
		};
		_proto.containsSphere = function containsSphere(sphere) {
			var center = sphere.center,
				radius = sphere.radius;
			var c = 0;
			for (var p = 0; p < 6; p++) {
				var _this$planes$p2 = this.planes[p],
					normal = _this$planes$p2.normal,
					distance = _this$planes$p2.distance;
				var d = normal.dot(center) + distance;
				if (d <= -radius) {
					return 0;
				}
				if (d > radius) {
					c++;
				}
			}
			return c === 6 ? 2 : 1;
		};
		return Frustum;
	}();

	var Ray = function () {
		function Ray(origin, direction) {
			this.origin = new Vec3();
			this.direction = Vec3.FORWARD.clone();
			if (origin) {
				this.origin.copy(origin);
			}
			if (direction) {
				this.direction.copy(direction);
			}
		}
		var _proto = Ray.prototype;
		_proto.set = function set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		};
		_proto.copy = function copy(src) {
			return this.set(src.origin, src.direction);
		};
		_proto.clone = function clone() {
			return new this.constructor(this.origin, this.direction);
		};
		return Ray;
	}();

	var tmpRay = new Ray();
	var tmpVec3$2 = new Vec3();
	var tmpSphere = new BoundingSphere();
	var tmpMat4$1 = new Mat4();
	var OrientedBox = function () {
		function OrientedBox(worldTransform, halfExtents) {
			if (worldTransform === void 0) {
				worldTransform = new Mat4();
			}
			this.halfExtents = new Vec3(0.5, 0.5, 0.5);
			this._modelTransform = void 0;
			this._worldTransform = void 0;
			this._aabb = void 0;
			if (halfExtents) {
				this.halfExtents.copy(halfExtents);
			}
			this._modelTransform = worldTransform.clone().invert();
			this._worldTransform = worldTransform.clone();
			this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
		}
		var _proto = OrientedBox.prototype;
		_proto.intersectsRay = function intersectsRay(ray, point) {
			this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
			this._modelTransform.transformVector(ray.direction, tmpRay.direction);
			if (point) {
				var result = this._aabb._intersectsRay(tmpRay, point);
				tmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);
				return result;
			}
			return this._aabb._fastIntersectsRay(tmpRay);
		};
		_proto.containsPoint = function containsPoint(point) {
			this._modelTransform.transformPoint(point, tmpVec3$2);
			return this._aabb.containsPoint(tmpVec3$2);
		};
		_proto.intersectsBoundingSphere = function intersectsBoundingSphere(sphere) {
			this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
			tmpSphere.radius = sphere.radius;
			if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
				return true;
			}
			return false;
		};
		return _createClass(OrientedBox, [{
			key: "worldTransform",
			get: function get() {
				return this._worldTransform;
			},
			set: function set(value) {
				this._worldTransform.copy(value);
				this._modelTransform.copy(value).invert();
			}
		}]);
	}();

	var e1 = new Vec3();
	var e2 = new Vec3();
	var h = new Vec3();
	var s = new Vec3();
	var q$1 = new Vec3();
	var EPSILON = 1e-6;
	var Tri = function () {
		function Tri(v0, v1, v2) {
			if (v0 === void 0) {
				v0 = Vec3.ZERO;
			}
			if (v1 === void 0) {
				v1 = Vec3.ZERO;
			}
			if (v2 === void 0) {
				v2 = Vec3.ZERO;
			}
			this.v0 = new Vec3();
			this.v1 = new Vec3();
			this.v2 = new Vec3();
			this.set(v0, v1, v2);
		}
		var _proto = Tri.prototype;
		_proto.set = function set(v0, v1, v2) {
			this.v0.copy(v0);
			this.v1.copy(v1);
			this.v2.copy(v2);
			return this;
		};
		_proto.intersectsRay = function intersectsRay(ray, point) {
			e1.sub2(this.v1, this.v0);
			e2.sub2(this.v2, this.v0);
			h.cross(ray.direction, e2);
			var a = e1.dot(h);
			if (a > -EPSILON && a < EPSILON) {
				return false;
			}
			var f = 1 / a;
			s.sub2(ray.origin, this.v0);
			var u = f * s.dot(h);
			if (u < 0 || u > 1) {
				return false;
			}
			q$1.cross(s, e1);
			var v = f * ray.direction.dot(q$1);
			if (v < 0 || u + v > 1) {
				return false;
			}
			var t = f * e2.dot(q$1);
			if (t > EPSILON) {
				if (point instanceof Vec3) {
					point.copy(ray.direction).mulScalar(t).add(ray.origin);
				}
				return true;
			}
			return false;
		};
		_proto.toString = function toString() {
			return "[" + this.v0.toString() + ", " + this.v1.toString() + ", " + this.v2.toString() + "]";
		};
		return Tri;
	}();

	var DISTANCE_LINEAR = 'linear';
	var DISTANCE_INVERSE = 'inverse';
	var DISTANCE_EXPONENTIAL = 'exponential';

	var ADDRESS_REPEAT = 0;
	var ADDRESS_CLAMP_TO_EDGE = 1;
	var ADDRESS_MIRRORED_REPEAT = 2;
	var BLENDMODE_ZERO = 0;
	var BLENDMODE_ONE = 1;
	var BLENDMODE_SRC_COLOR = 2;
	var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
	var BLENDMODE_DST_COLOR = 4;
	var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
	var BLENDMODE_SRC_ALPHA = 6;
	var BLENDMODE_SRC_ALPHA_SATURATE = 7;
	var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
	var BLENDMODE_DST_ALPHA = 9;
	var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;
	var BLENDMODE_CONSTANT = 11;
	var BLENDMODE_ONE_MINUS_CONSTANT = 12;
	var BLENDEQUATION_ADD = 0;
	var BLENDEQUATION_SUBTRACT = 1;
	var BLENDEQUATION_REVERSE_SUBTRACT = 2;
	var BLENDEQUATION_MIN = 3;
	var BLENDEQUATION_MAX = 4;
	var BUFFERUSAGE_READ = 0x0001;
	var BUFFERUSAGE_WRITE = 0x0002;
	var BUFFERUSAGE_COPY_SRC = 0x0004;
	var BUFFERUSAGE_COPY_DST = 0x0008;
	var BUFFERUSAGE_INDEX = 0x0010;
	var BUFFERUSAGE_VERTEX = 0x0020;
	var BUFFERUSAGE_UNIFORM = 0x0040;
	var BUFFERUSAGE_STORAGE = 0x0080;
	var BUFFERUSAGE_INDIRECT = 0x0100;
	var BUFFER_STATIC = 0;
	var BUFFER_DYNAMIC = 1;
	var BUFFER_STREAM = 2;
	var BUFFER_GPUDYNAMIC = 3;
	var CLEARFLAG_COLOR = 1;
	var CLEARFLAG_DEPTH = 2;
	var CLEARFLAG_STENCIL = 4;
	var CUBEFACE_POSX = 0;
	var CUBEFACE_NEGX = 1;
	var CUBEFACE_POSY = 2;
	var CUBEFACE_NEGY = 3;
	var CUBEFACE_POSZ = 4;
	var CUBEFACE_NEGZ = 5;
	var CULLFACE_NONE = 0;
	var CULLFACE_BACK = 1;
	var CULLFACE_FRONT = 2;
	var CULLFACE_FRONTANDBACK = 3;
	var FILTER_NEAREST = 0;
	var FILTER_LINEAR = 1;
	var FILTER_NEAREST_MIPMAP_NEAREST = 2;
	var FILTER_NEAREST_MIPMAP_LINEAR = 3;
	var FILTER_LINEAR_MIPMAP_NEAREST = 4;
	var FILTER_LINEAR_MIPMAP_LINEAR = 5;
	var FUNC_NEVER = 0;
	var FUNC_LESS = 1;
	var FUNC_EQUAL = 2;
	var FUNC_LESSEQUAL = 3;
	var FUNC_GREATER = 4;
	var FUNC_NOTEQUAL = 5;
	var FUNC_GREATEREQUAL = 6;
	var FUNC_ALWAYS = 7;
	var INDEXFORMAT_UINT8 = 0;
	var INDEXFORMAT_UINT16 = 1;
	var INDEXFORMAT_UINT32 = 2;
	var PIXELFORMAT_A8 = 0;
	var PIXELFORMAT_L8 = 1;
	var PIXELFORMAT_LA8 = 2;
	var PIXELFORMAT_RGB565 = 3;
	var PIXELFORMAT_RGBA5551 = 4;
	var PIXELFORMAT_RGBA4 = 5;
	var PIXELFORMAT_RGB8 = 6;
	var PIXELFORMAT_RGBA8 = 7;
	var PIXELFORMAT_DXT1 = 8;
	var PIXELFORMAT_DXT3 = 9;
	var PIXELFORMAT_DXT5 = 10;
	var PIXELFORMAT_RGB16F = 11;
	var PIXELFORMAT_RGBA16F = 12;
	var PIXELFORMAT_RGB32F = 13;
	var PIXELFORMAT_RGBA32F = 14;
	var PIXELFORMAT_R32F = 15;
	var PIXELFORMAT_DEPTH = 16;
	var PIXELFORMAT_DEPTHSTENCIL = 17;
	var PIXELFORMAT_111110F = 18;
	var PIXELFORMAT_SRGB8 = 19;
	var PIXELFORMAT_SRGBA8 = 20;
	var PIXELFORMAT_ETC1 = 21;
	var PIXELFORMAT_ETC2_RGB = 22;
	var PIXELFORMAT_ETC2_RGBA = 23;
	var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
	var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
	var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
	var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
	var PIXELFORMAT_ASTC_4x4 = 28;
	var PIXELFORMAT_ATC_RGB = 29;
	var PIXELFORMAT_ATC_RGBA = 30;
	var PIXELFORMAT_BGRA8 = 31;
	var PIXELFORMAT_R8I = 32;
	var PIXELFORMAT_R8U = 33;
	var PIXELFORMAT_R16I = 34;
	var PIXELFORMAT_R16U = 35;
	var PIXELFORMAT_R32I = 36;
	var PIXELFORMAT_R32U = 37;
	var PIXELFORMAT_RG8I = 38;
	var PIXELFORMAT_RG8U = 39;
	var PIXELFORMAT_RG16I = 40;
	var PIXELFORMAT_RG16U = 41;
	var PIXELFORMAT_RG32I = 42;
	var PIXELFORMAT_RG32U = 43;
	var PIXELFORMAT_RGBA8I = 44;
	var PIXELFORMAT_RGBA8U = 45;
	var PIXELFORMAT_RGBA16I = 46;
	var PIXELFORMAT_RGBA16U = 47;
	var PIXELFORMAT_RGBA32I = 48;
	var PIXELFORMAT_RGBA32U = 49;
	var PIXELFORMAT_R16F = 50;
	var PIXELFORMAT_RG16F = 51;
	var PIXELFORMAT_R8 = 52;
	var PIXELFORMAT_RG8 = 53;
	var PIXELFORMAT_DXT1_SRGB = 54;
	var PIXELFORMAT_DXT3_SRGBA = 55;
	var PIXELFORMAT_DXT5_SRGBA = 56;
	var PIXELFORMAT_PVRTC_2BPP_SRGB_1 = 57;
	var PIXELFORMAT_PVRTC_2BPP_SRGBA_1 = 58;
	var PIXELFORMAT_PVRTC_4BPP_SRGB_1 = 59;
	var PIXELFORMAT_PVRTC_4BPP_SRGBA_1 = 60;
	var PIXELFORMAT_ETC2_SRGB = 61;
	var PIXELFORMAT_ETC2_SRGBA = 62;
	var PIXELFORMAT_ASTC_4x4_SRGB = 63;
	var PIXELFORMAT_SBGRA8 = 64;
	var PIXELFORMAT_BC6F = 65;
	var PIXELFORMAT_BC6UF = 66;
	var PIXELFORMAT_BC7 = 67;
	var PIXELFORMAT_BC7_SRGBA = 68;
	var PIXELFORMAT_DEPTH16 = 69;
	var pixelFormatInfo = new Map([[PIXELFORMAT_A8, {
		name: 'A8',
		size: 1,
		ldr: true
	}], [PIXELFORMAT_R8, {
		name: 'R8',
		size: 1,
		ldr: true
	}], [PIXELFORMAT_L8, {
		name: 'L8',
		size: 1,
		ldr: true
	}], [PIXELFORMAT_LA8, {
		name: 'LA8',
		size: 2,
		ldr: true
	}], [PIXELFORMAT_RG8, {
		name: 'RG8',
		size: 2,
		ldr: true
	}], [PIXELFORMAT_RGB565, {
		name: 'RGB565',
		size: 2,
		ldr: true
	}], [PIXELFORMAT_RGBA5551, {
		name: 'RGBA5551',
		size: 2,
		ldr: true
	}], [PIXELFORMAT_RGBA4, {
		name: 'RGBA4',
		size: 2,
		ldr: true
	}], [PIXELFORMAT_RGB8, {
		name: 'RGB8',
		size: 4,
		ldr: true
	}], [PIXELFORMAT_RGBA8, {
		name: 'RGBA8',
		size: 4,
		ldr: true,
		srgbFormat: PIXELFORMAT_SRGBA8
	}], [PIXELFORMAT_R16F, {
		name: 'R16F',
		size: 2
	}], [PIXELFORMAT_RG16F, {
		name: 'RG16F',
		size: 4
	}], [PIXELFORMAT_RGB16F, {
		name: 'RGB16F',
		size: 8
	}], [PIXELFORMAT_RGBA16F, {
		name: 'RGBA16F',
		size: 8
	}], [PIXELFORMAT_RGB32F, {
		name: 'RGB32F',
		size: 16
	}], [PIXELFORMAT_RGBA32F, {
		name: 'RGBA32F',
		size: 16
	}], [PIXELFORMAT_R32F, {
		name: 'R32F',
		size: 4
	}], [PIXELFORMAT_DEPTH, {
		name: 'DEPTH',
		size: 4
	}], [PIXELFORMAT_DEPTH16, {
		name: 'DEPTH16',
		size: 2
	}], [PIXELFORMAT_DEPTHSTENCIL, {
		name: 'DEPTHSTENCIL',
		size: 4
	}], [PIXELFORMAT_111110F, {
		name: '111110F',
		size: 4
	}], [PIXELFORMAT_SRGB8, {
		name: 'SRGB8',
		size: 4,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_SRGBA8, {
		name: 'SRGBA8',
		size: 4,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_BGRA8, {
		name: 'BGRA8',
		size: 4,
		ldr: true
	}], [PIXELFORMAT_SBGRA8, {
		name: 'SBGRA8',
		size: 4,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_DXT1, {
		name: 'DXT1',
		blockSize: 8,
		ldr: true,
		srgbFormat: PIXELFORMAT_DXT1_SRGB
	}], [PIXELFORMAT_DXT3, {
		name: 'DXT3',
		blockSize: 16,
		ldr: true,
		srgbFormat: PIXELFORMAT_DXT3_SRGBA
	}], [PIXELFORMAT_DXT5, {
		name: 'DXT5',
		blockSize: 16,
		ldr: true,
		srgbFormat: PIXELFORMAT_DXT5_SRGBA
	}], [PIXELFORMAT_ETC1, {
		name: 'ETC1',
		blockSize: 8,
		ldr: true
	}], [PIXELFORMAT_ETC2_RGB, {
		name: 'ETC2_RGB',
		blockSize: 8,
		ldr: true,
		srgbFormat: PIXELFORMAT_ETC2_SRGB
	}], [PIXELFORMAT_ETC2_RGBA, {
		name: 'ETC2_RGBA',
		blockSize: 16,
		ldr: true,
		srgbFormat: PIXELFORMAT_ETC2_SRGBA
	}], [PIXELFORMAT_PVRTC_2BPP_RGB_1, {
		name: 'PVRTC_2BPP_RGB_1',
		ldr: true,
		blockSize: 8,
		srgbFormat: PIXELFORMAT_PVRTC_2BPP_SRGB_1
	}], [PIXELFORMAT_PVRTC_2BPP_RGBA_1, {
		name: 'PVRTC_2BPP_RGBA_1',
		ldr: true,
		blockSize: 8,
		srgbFormat: PIXELFORMAT_PVRTC_2BPP_SRGBA_1
	}], [PIXELFORMAT_PVRTC_4BPP_RGB_1, {
		name: 'PVRTC_4BPP_RGB_1',
		ldr: true,
		blockSize: 8,
		srgbFormat: PIXELFORMAT_PVRTC_4BPP_SRGB_1
	}], [PIXELFORMAT_PVRTC_4BPP_RGBA_1, {
		name: 'PVRTC_4BPP_RGBA_1',
		ldr: true,
		blockSize: 8,
		srgbFormat: PIXELFORMAT_PVRTC_4BPP_SRGBA_1
	}], [PIXELFORMAT_ASTC_4x4, {
		name: 'ASTC_4x4',
		blockSize: 16,
		ldr: true,
		srgbFormat: PIXELFORMAT_ASTC_4x4_SRGB
	}], [PIXELFORMAT_ATC_RGB, {
		name: 'ATC_RGB',
		blockSize: 8,
		ldr: true
	}], [PIXELFORMAT_ATC_RGBA, {
		name: 'ATC_RGBA',
		blockSize: 16,
		ldr: true
	}], [PIXELFORMAT_BC6F, {
		name: 'BC6H_RGBF',
		blockSize: 16
	}], [PIXELFORMAT_BC6UF, {
		name: 'BC6H_RGBUF',
		blockSize: 16
	}], [PIXELFORMAT_BC7, {
		name: 'BC7_RGBA',
		blockSize: 16,
		ldr: true,
		srgbFormat: PIXELFORMAT_BC7_SRGBA
	}], [PIXELFORMAT_DXT1_SRGB, {
		name: 'DXT1_SRGB',
		blockSize: 8,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_DXT3_SRGBA, {
		name: 'DXT3_SRGBA',
		blockSize: 16,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_DXT5_SRGBA, {
		name: 'DXT5_SRGBA',
		blockSize: 16,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_PVRTC_2BPP_SRGB_1, {
		name: 'PVRTC_2BPP_SRGB_1',
		blockSize: 8,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_PVRTC_2BPP_SRGBA_1, {
		name: 'PVRTC_2BPP_SRGBA_1',
		blockSize: 8,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_PVRTC_4BPP_SRGB_1, {
		name: 'PVRTC_4BPP_SRGB_1',
		blockSize: 8,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_PVRTC_4BPP_SRGBA_1, {
		name: 'PVRTC_4BPP_SRGBA_1',
		blockSize: 8,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_ETC2_SRGB, {
		name: 'ETC2_SRGB',
		blockSize: 8,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_ETC2_SRGBA, {
		name: 'ETC2_SRGBA',
		blockSize: 16,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_ASTC_4x4_SRGB, {
		name: 'ASTC_4x4_SRGB',
		blockSize: 16,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_BC7_SRGBA, {
		name: 'BC7_SRGBA',
		blockSize: 16,
		ldr: true,
		srgb: true
	}], [PIXELFORMAT_R8I, {
		name: 'R8I',
		size: 1,
		isInt: true
	}], [PIXELFORMAT_R8U, {
		name: 'R8U',
		size: 1,
		isInt: true
	}], [PIXELFORMAT_R16I, {
		name: 'R16I',
		size: 2,
		isInt: true
	}], [PIXELFORMAT_R16U, {
		name: 'R16U',
		size: 2,
		isInt: true
	}], [PIXELFORMAT_R32I, {
		name: 'R32I',
		size: 4,
		isInt: true
	}], [PIXELFORMAT_R32U, {
		name: 'R32U',
		size: 4,
		isInt: true
	}], [PIXELFORMAT_RG8I, {
		name: 'RG8I',
		size: 2,
		isInt: true
	}], [PIXELFORMAT_RG8U, {
		name: 'RG8U',
		size: 2,
		isInt: true
	}], [PIXELFORMAT_RG16I, {
		name: 'RG16I',
		size: 4,
		isInt: true
	}], [PIXELFORMAT_RG16U, {
		name: 'RG16U',
		size: 4,
		isInt: true
	}], [PIXELFORMAT_RG32I, {
		name: 'RG32I',
		size: 8,
		isInt: true
	}], [PIXELFORMAT_RG32U, {
		name: 'RG32U',
		size: 8,
		isInt: true
	}], [PIXELFORMAT_RGBA8I, {
		name: 'RGBA8I',
		size: 4,
		isInt: true
	}], [PIXELFORMAT_RGBA8U, {
		name: 'RGBA8U',
		size: 4,
		isInt: true
	}], [PIXELFORMAT_RGBA16I, {
		name: 'RGBA16I',
		size: 8,
		isInt: true
	}], [PIXELFORMAT_RGBA16U, {
		name: 'RGBA16U',
		size: 8,
		isInt: true
	}], [PIXELFORMAT_RGBA32I, {
		name: 'RGBA32I',
		size: 16,
		isInt: true
	}], [PIXELFORMAT_RGBA32U, {
		name: 'RGBA32U',
		size: 16,
		isInt: true
	}]]);
	var isCompressedPixelFormat = function isCompressedPixelFormat(format) {
		var _pixelFormatInfo$get;
		return ((_pixelFormatInfo$get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get.blockSize) !== undefined;
	};
	var isSrgbPixelFormat = function isSrgbPixelFormat(format) {
		var _pixelFormatInfo$get2;
		return ((_pixelFormatInfo$get2 = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get2.srgb) === true;
	};
	var isIntegerPixelFormat = function isIntegerPixelFormat(format) {
		var _pixelFormatInfo$get3;
		return ((_pixelFormatInfo$get3 = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get3.isInt) === true;
	};
	var pixelFormatLinearToGamma = function pixelFormatLinearToGamma(format) {
		var _pixelFormatInfo$get4;
		return ((_pixelFormatInfo$get4 = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get4.srgbFormat) || format;
	};
	var requiresManualGamma = function requiresManualGamma(format) {
		var info = pixelFormatInfo.get(format);
		return !!(info != null && info.ldr && !(info != null && info.srgb));
	};
	var getPixelFormatArrayType = function getPixelFormatArrayType(format) {
		switch (format) {
			case PIXELFORMAT_R32F:
			case PIXELFORMAT_RGB32F:
			case PIXELFORMAT_RGBA32F:
				return Float32Array;
			case PIXELFORMAT_R32I:
			case PIXELFORMAT_RG32I:
			case PIXELFORMAT_RGBA32I:
				return Int32Array;
			case PIXELFORMAT_R32U:
			case PIXELFORMAT_RG32U:
			case PIXELFORMAT_RGBA32U:
				return Uint32Array;
			case PIXELFORMAT_R16I:
			case PIXELFORMAT_RG16I:
			case PIXELFORMAT_RGBA16I:
				return Int16Array;
			case PIXELFORMAT_RG8:
			case PIXELFORMAT_R16U:
			case PIXELFORMAT_RG16U:
			case PIXELFORMAT_RGBA16U:
			case PIXELFORMAT_RGB565:
			case PIXELFORMAT_RGBA5551:
			case PIXELFORMAT_RGBA4:
			case PIXELFORMAT_R16F:
			case PIXELFORMAT_RG16F:
			case PIXELFORMAT_RGB16F:
			case PIXELFORMAT_RGBA16F:
				return Uint16Array;
			case PIXELFORMAT_R8I:
			case PIXELFORMAT_RG8I:
			case PIXELFORMAT_RGBA8I:
				return Int8Array;
			default:
				return Uint8Array;
		}
	};
	var PRIMITIVE_POINTS = 0;
	var PRIMITIVE_LINES = 1;
	var PRIMITIVE_LINELOOP = 2;
	var PRIMITIVE_LINESTRIP = 3;
	var PRIMITIVE_TRIANGLES = 4;
	var PRIMITIVE_TRISTRIP = 5;
	var PRIMITIVE_TRIFAN = 6;
	var SEMANTIC_POSITION = 'POSITION';
	var SEMANTIC_NORMAL = 'NORMAL';
	var SEMANTIC_TANGENT = 'TANGENT';
	var SEMANTIC_BLENDWEIGHT = 'BLENDWEIGHT';
	var SEMANTIC_BLENDINDICES = 'BLENDINDICES';
	var SEMANTIC_COLOR = 'COLOR';
	var SEMANTIC_TEXCOORD = 'TEXCOORD';
	var SEMANTIC_TEXCOORD0 = 'TEXCOORD0';
	var SEMANTIC_TEXCOORD1 = 'TEXCOORD1';
	var SEMANTIC_TEXCOORD2 = 'TEXCOORD2';
	var SEMANTIC_TEXCOORD3 = 'TEXCOORD3';
	var SEMANTIC_TEXCOORD4 = 'TEXCOORD4';
	var SEMANTIC_TEXCOORD5 = 'TEXCOORD5';
	var SEMANTIC_TEXCOORD6 = 'TEXCOORD6';
	var SEMANTIC_TEXCOORD7 = 'TEXCOORD7';
	var SEMANTIC_ATTR0 = 'ATTR0';
	var SEMANTIC_ATTR1 = 'ATTR1';
	var SEMANTIC_ATTR2 = 'ATTR2';
	var SEMANTIC_ATTR3 = 'ATTR3';
	var SEMANTIC_ATTR4 = 'ATTR4';
	var SEMANTIC_ATTR5 = 'ATTR5';
	var SEMANTIC_ATTR6 = 'ATTR6';
	var SEMANTIC_ATTR7 = 'ATTR7';
	var SEMANTIC_ATTR8 = 'ATTR8';
	var SEMANTIC_ATTR9 = 'ATTR9';
	var SEMANTIC_ATTR10 = 'ATTR10';
	var SEMANTIC_ATTR11 = 'ATTR11';
	var SEMANTIC_ATTR12 = 'ATTR12';
	var SEMANTIC_ATTR13 = 'ATTR13';
	var SEMANTIC_ATTR14 = 'ATTR14';
	var SEMANTIC_ATTR15 = 'ATTR15';
	var SHADERTAG_MATERIAL = 1;
	var STENCILOP_KEEP = 0;
	var STENCILOP_ZERO = 1;
	var STENCILOP_REPLACE = 2;
	var STENCILOP_INCREMENT = 3;
	var STENCILOP_INCREMENTWRAP = 4;
	var STENCILOP_DECREMENT = 5;
	var STENCILOP_DECREMENTWRAP = 6;
	var STENCILOP_INVERT = 7;
	var TEXTURELOCK_NONE = 0;
	var TEXTURELOCK_READ = 1;
	var TEXTURELOCK_WRITE = 2;
	var TEXTURETYPE_DEFAULT = 'default';
	var TEXTURETYPE_RGBM = 'rgbm';
	var TEXTURETYPE_RGBE = 'rgbe';
	var TEXTURETYPE_RGBP = 'rgbp';
	var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
	var TEXHINT_NONE = 0;
	var TEXHINT_SHADOWMAP = 1;
	var TEXHINT_ASSET = 2;
	var TEXHINT_LIGHTMAP = 3;
	var TEXTUREDIMENSION_1D = '1d';
	var TEXTUREDIMENSION_2D = '2d';
	var TEXTUREDIMENSION_2D_ARRAY = '2d-array';
	var TEXTUREDIMENSION_CUBE = 'cube';
	var TEXTUREDIMENSION_CUBE_ARRAY = 'cube-array';
	var TEXTUREDIMENSION_3D = '3d';
	var SAMPLETYPE_FLOAT = 0;
	var SAMPLETYPE_UNFILTERABLE_FLOAT = 1;
	var SAMPLETYPE_DEPTH = 2;
	var SAMPLETYPE_INT = 3;
	var SAMPLETYPE_UINT = 4;
	var TEXTUREPROJECTION_NONE = 'none';
	var TEXTUREPROJECTION_CUBE = 'cube';
	var TEXTUREPROJECTION_EQUIRECT = 'equirect';
	var TEXTUREPROJECTION_OCTAHEDRAL = 'octahedral';
	var SHADERLANGUAGE_GLSL = 'glsl';
	var SHADERLANGUAGE_WGSL = 'wgsl';
	var TYPE_INT8 = 0;
	var TYPE_UINT8 = 1;
	var TYPE_INT16 = 2;
	var TYPE_UINT16 = 3;
	var TYPE_INT32 = 4;
	var TYPE_UINT32 = 5;
	var TYPE_FLOAT32 = 6;
	var TYPE_FLOAT16 = 7;
	var UNIFORMTYPE_BOOL = 0;
	var UNIFORMTYPE_INT = 1;
	var UNIFORMTYPE_FLOAT = 2;
	var UNIFORMTYPE_VEC2 = 3;
	var UNIFORMTYPE_VEC3 = 4;
	var UNIFORMTYPE_VEC4 = 5;
	var UNIFORMTYPE_IVEC2 = 6;
	var UNIFORMTYPE_IVEC3 = 7;
	var UNIFORMTYPE_IVEC4 = 8;
	var UNIFORMTYPE_BVEC2 = 9;
	var UNIFORMTYPE_BVEC3 = 10;
	var UNIFORMTYPE_BVEC4 = 11;
	var UNIFORMTYPE_MAT2 = 12;
	var UNIFORMTYPE_MAT3 = 13;
	var UNIFORMTYPE_MAT4 = 14;
	var UNIFORMTYPE_TEXTURE2D = 15;
	var UNIFORMTYPE_TEXTURECUBE = 16;
	var UNIFORMTYPE_FLOATARRAY = 17;
	var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
	var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
	var UNIFORMTYPE_TEXTURE3D = 20;
	var UNIFORMTYPE_VEC2ARRAY = 21;
	var UNIFORMTYPE_VEC3ARRAY = 22;
	var UNIFORMTYPE_VEC4ARRAY = 23;
	var UNIFORMTYPE_MAT4ARRAY = 24;
	var UNIFORMTYPE_TEXTURE2D_ARRAY = 25;
	var UNIFORMTYPE_UINT = 26;
	var UNIFORMTYPE_UVEC2 = 27;
	var UNIFORMTYPE_UVEC3 = 28;
	var UNIFORMTYPE_UVEC4 = 29;
	var UNIFORMTYPE_INTARRAY = 30;
	var UNIFORMTYPE_UINTARRAY = 31;
	var UNIFORMTYPE_BOOLARRAY = 32;
	var UNIFORMTYPE_IVEC2ARRAY = 33;
	var UNIFORMTYPE_UVEC2ARRAY = 34;
	var UNIFORMTYPE_BVEC2ARRAY = 35;
	var UNIFORMTYPE_IVEC3ARRAY = 36;
	var UNIFORMTYPE_UVEC3ARRAY = 37;
	var UNIFORMTYPE_BVEC3ARRAY = 38;
	var UNIFORMTYPE_IVEC4ARRAY = 39;
	var UNIFORMTYPE_UVEC4ARRAY = 40;
	var UNIFORMTYPE_BVEC4ARRAY = 41;
	var UNIFORMTYPE_ITEXTURE2D = 42;
	var UNIFORMTYPE_UTEXTURE2D = 43;
	var UNIFORMTYPE_ITEXTURECUBE = 44;
	var UNIFORMTYPE_UTEXTURECUBE = 45;
	var UNIFORMTYPE_ITEXTURE3D = 46;
	var UNIFORMTYPE_UTEXTURE3D = 47;
	var UNIFORMTYPE_ITEXTURE2D_ARRAY = 48;
	var UNIFORMTYPE_UTEXTURE2D_ARRAY = 49;
	var uniformTypeToName = ['bool', 'int', 'float', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'bvec2', 'bvec3', 'bvec4', 'mat2', 'mat3', 'mat4', 'sampler2D', 'samplerCube', '', 'sampler2DShadow', 'samplerCubeShadow', 'sampler3D', '', '', '', '', 'sampler2DArray', 'uint', 'uvec2', 'uvec3', 'uvec4', '', '', '', '', '', '', '', '', '', '', '', '', 'isampler2D', 'usampler2D', 'isamplerCube', 'usamplerCube', 'isampler3D', 'usampler3D', 'isampler2DArray', 'usampler2DArray'];
	var uniformTypeToStorage = new Uint8Array([TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_UINT32, TYPE_UINT32, TYPE_UINT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32]);
	var DEVICETYPE_WEBGL2 = 'webgl2';
	var DEVICETYPE_WEBGPU = 'webgpu';
	var DEVICETYPE_NULL = 'null';
	var SHADERSTAGE_VERTEX = 1;
	var SHADERSTAGE_FRAGMENT = 2;
	var SHADERSTAGE_COMPUTE = 4;
	var DISPLAYFORMAT_LDR = 'ldr';
	var DISPLAYFORMAT_LDR_SRGB = 'ldr_srgb';
	var DISPLAYFORMAT_HDR = 'hdr';
	var TEXPROPERTY_MIN_FILTER = 1;
	var TEXPROPERTY_MAG_FILTER = 2;
	var TEXPROPERTY_ADDRESS_U = 4;
	var TEXPROPERTY_ADDRESS_V = 8;
	var TEXPROPERTY_ADDRESS_W = 16;
	var TEXPROPERTY_COMPARE_ON_READ = 32;
	var TEXPROPERTY_COMPARE_FUNC = 64;
	var TEXPROPERTY_ANISOTROPY = 128;
	var TEXPROPERTY_ALL = 255;
	var BINDGROUP_VIEW = 0;
	var BINDGROUP_MESH = 1;
	var BINDGROUP_MESH_UB = 2;
	var bindGroupNames = ['view', 'mesh', 'mesh_ub'];
	var UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';
	var typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Uint16Array];
	var typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4, 2];
	var vertexTypesNames = ['INT8', 'UINT8', 'INT16', 'UINT16', 'INT32', 'UINT32', 'FLOAT32', 'FLOAT16'];
	var typedArrayToType = {
		'Int8Array': TYPE_INT8,
		'Uint8Array': TYPE_UINT8,
		'Int16Array': TYPE_INT16,
		'Uint16Array': TYPE_UINT16,
		'Int32Array': TYPE_INT32,
		'Uint32Array': TYPE_UINT32,
		'Float32Array': TYPE_FLOAT32
	};
	var typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
	var typedArrayIndexFormatsByteSize = [1, 2, 4];
	var semanticToLocation = {};
	semanticToLocation[SEMANTIC_POSITION] = 0;
	semanticToLocation[SEMANTIC_NORMAL] = 1;
	semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
	semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
	semanticToLocation[SEMANTIC_COLOR] = 4;
	semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
	semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
	semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
	semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
	semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
	semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
	semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
	semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
	semanticToLocation[SEMANTIC_TANGENT] = 13;
	semanticToLocation[SEMANTIC_ATTR0] = 0;
	semanticToLocation[SEMANTIC_ATTR1] = 1;
	semanticToLocation[SEMANTIC_ATTR2] = 2;
	semanticToLocation[SEMANTIC_ATTR3] = 3;
	semanticToLocation[SEMANTIC_ATTR4] = 4;
	semanticToLocation[SEMANTIC_ATTR5] = 5;
	semanticToLocation[SEMANTIC_ATTR6] = 6;
	semanticToLocation[SEMANTIC_ATTR7] = 7;
	semanticToLocation[SEMANTIC_ATTR8] = 8;
	semanticToLocation[SEMANTIC_ATTR9] = 9;
	semanticToLocation[SEMANTIC_ATTR10] = 10;
	semanticToLocation[SEMANTIC_ATTR11] = 11;
	semanticToLocation[SEMANTIC_ATTR12] = 12;
	semanticToLocation[SEMANTIC_ATTR13] = 13;
	semanticToLocation[SEMANTIC_ATTR14] = 14;
	semanticToLocation[SEMANTIC_ATTR15] = 15;
	var CHUNKAPI_1_51 = '1.51';
	var CHUNKAPI_1_55 = '1.55';
	var CHUNKAPI_1_56 = '1.56';
	var CHUNKAPI_1_57 = '1.57';
	var CHUNKAPI_1_58 = '1.58';
	var CHUNKAPI_1_60 = '1.60';
	var CHUNKAPI_1_62 = '1.62';
	var CHUNKAPI_1_65 = '1.65';
	var CHUNKAPI_1_70 = '1.70';
	var CHUNKAPI_2_1 = '2.1';
	var CHUNKAPI_2_3 = '2.3';

	var _textureDimensionInfo;
	var id$b = 0;
	var textureDimensionInfo = (_textureDimensionInfo = {}, _textureDimensionInfo[TEXTUREDIMENSION_2D] = 'texture2D', _textureDimensionInfo[TEXTUREDIMENSION_CUBE] = 'textureCube', _textureDimensionInfo[TEXTUREDIMENSION_3D] = 'texture3D', _textureDimensionInfo[TEXTUREDIMENSION_2D_ARRAY] = 'texture2DArray', _textureDimensionInfo);
	var BindBaseFormat = function BindBaseFormat(name, visibility) {
		this.slot = -1;
		this.scopeId = null;
		this.name = name;
		this.visibility = visibility;
	};
	var BindUniformBufferFormat = function (_BindBaseFormat2) {
		function BindUniformBufferFormat() {
			return _BindBaseFormat2.apply(this, arguments) || this;
		}
		_inheritsLoose(BindUniformBufferFormat, _BindBaseFormat2);
		return BindUniformBufferFormat;
	}(BindBaseFormat);
	var BindStorageBufferFormat = function (_BindBaseFormat3) {
		function BindStorageBufferFormat(name, visibility, readOnly) {
			var _this;
			if (readOnly === void 0) {
				readOnly = false;
			}
			_this = _BindBaseFormat3.call(this, name, visibility) || this;
			_this.readOnly = readOnly;
			return _this;
		}
		_inheritsLoose(BindStorageBufferFormat, _BindBaseFormat3);
		return BindStorageBufferFormat;
	}(BindBaseFormat);
	var BindTextureFormat = function (_BindBaseFormat4) {
		function BindTextureFormat(name, visibility, textureDimension, sampleType, hasSampler) {
			var _this2;
			if (textureDimension === void 0) {
				textureDimension = TEXTUREDIMENSION_2D;
			}
			if (sampleType === void 0) {
				sampleType = SAMPLETYPE_FLOAT;
			}
			if (hasSampler === void 0) {
				hasSampler = true;
			}
			_this2 = _BindBaseFormat4.call(this, name, visibility) || this;
			_this2.textureDimension = textureDimension;
			_this2.sampleType = sampleType;
			_this2.hasSampler = hasSampler;
			return _this2;
		}
		_inheritsLoose(BindTextureFormat, _BindBaseFormat4);
		return BindTextureFormat;
	}(BindBaseFormat);
	var BindStorageTextureFormat = function (_BindBaseFormat5) {
		function BindStorageTextureFormat(name, format, textureDimension, write, read) {
			var _this3;
			if (format === void 0) {
				format = PIXELFORMAT_RGBA8;
			}
			if (textureDimension === void 0) {
				textureDimension = TEXTUREDIMENSION_2D;
			}
			if (write === void 0) {
				write = true;
			}
			if (read === void 0) {
				read = false;
			}
			_this3 = _BindBaseFormat5.call(this, name, SHADERSTAGE_COMPUTE) || this;
			_this3.format = format;
			_this3.textureDimension = textureDimension;
			_this3.write = write;
			_this3.read = read;
			return _this3;
		}
		_inheritsLoose(BindStorageTextureFormat, _BindBaseFormat5);
		return BindStorageTextureFormat;
	}(BindBaseFormat);
	var BindGroupFormat = function () {
		function BindGroupFormat(graphicsDevice, formats) {
			var _this4 = this;
			this.uniformBufferFormats = [];
			this.textureFormats = [];
			this.storageTextureFormats = [];
			this.storageBufferFormats = [];
			this.id = id$b++;
			var slot = 0;
			formats.forEach(function (format) {
				format.slot = slot++;
				if (format instanceof BindTextureFormat && format.hasSampler) {
					slot++;
				}
				if (format instanceof BindUniformBufferFormat) {
					_this4.uniformBufferFormats.push(format);
				} else if (format instanceof BindTextureFormat) {
					_this4.textureFormats.push(format);
				} else if (format instanceof BindStorageTextureFormat) {
					_this4.storageTextureFormats.push(format);
				} else if (format instanceof BindStorageBufferFormat) {
					_this4.storageBufferFormats.push(format);
				} else ;
			});
			this.device = graphicsDevice;
			var scope = graphicsDevice.scope;
			this.bufferFormatsMap = new Map();
			this.uniformBufferFormats.forEach(function (bf, i) {
				return _this4.bufferFormatsMap.set(bf.name, i);
			});
			this.textureFormatsMap = new Map();
			this.textureFormats.forEach(function (tf, i) {
				_this4.textureFormatsMap.set(tf.name, i);
				tf.scopeId = scope.resolve(tf.name);
			});
			this.storageTextureFormatsMap = new Map();
			this.storageTextureFormats.forEach(function (tf, i) {
				_this4.storageTextureFormatsMap.set(tf.name, i);
				tf.scopeId = scope.resolve(tf.name);
			});
			this.storageBufferFormatsMap = new Map();
			this.storageBufferFormats.forEach(function (bf, i) {
				_this4.storageBufferFormatsMap.set(bf.name, i);
				bf.scopeId = scope.resolve(bf.name);
			});
			this.impl = graphicsDevice.createBindGroupFormatImpl(this);
		}
		var _proto = BindGroupFormat.prototype;
		_proto.destroy = function destroy() {
			this.impl.destroy();
		};
		_proto.getTexture = function getTexture(name) {
			var index = this.textureFormatsMap.get(name);
			if (index !== undefined) {
				return this.textureFormats[index];
			}
			return null;
		};
		_proto.getStorageTexture = function getStorageTexture(name) {
			var index = this.storageTextureFormatsMap.get(name);
			if (index !== undefined) {
				return this.storageTextureFormats[index];
			}
			return null;
		};
		_proto.getShaderDeclarationTextures = function getShaderDeclarationTextures(bindGroup) {
			var code = '';
			this.textureFormats.forEach(function (format) {
				var textureType = textureDimensionInfo[format.textureDimension];
				var isArray = textureType === 'texture2DArray';
				var sampleTypePrefix = format.sampleType === SAMPLETYPE_UINT ? 'u' : format.sampleType === SAMPLETYPE_INT ? 'i' : '';
				textureType = "" + sampleTypePrefix + textureType;
				var namePostfix = '';
				var extraCode = '';
				if (isArray) {
					namePostfix = '_texture';
					extraCode = "#define " + format.name + " " + sampleTypePrefix + "sampler2DArray(" + format.name + namePostfix + ", " + format.name + "_sampler)\n";
				}
				code += "layout(set = " + bindGroup + ", binding = " + format.slot + ") uniform " + textureType + " " + format.name + namePostfix + ";\n";
				if (format.hasSampler) {
					code += "layout(set = " + bindGroup + ", binding = " + (format.slot + 1) + ") uniform sampler " + format.name + "_sampler;\n";
				}
				code += extraCode;
			});
			return code;
		};
		_proto.loseContext = function loseContext() {};
		return BindGroupFormat;
	}();

	var DeviceCache = function () {
		function DeviceCache() {
			this._cache = new Map();
		}
		var _proto = DeviceCache.prototype;
		_proto.get = function get(device, onCreate) {
			var _this = this;
			if (!this._cache.has(device)) {
				this._cache.set(device, onCreate());
				device.on('destroy', function () {
					_this.remove(device);
				});
				device.on('devicelost', function () {
					var _this$_cache$get;
					(_this$_cache$get = _this._cache.get(device)) == null || _this$_cache$get.loseContext == null || _this$_cache$get.loseContext(device);
				});
			}
			return this._cache.get(device);
		};
		_proto.remove = function remove(device) {
			var _this$_cache$get2;
			(_this$_cache$get2 = this._cache.get(device)) == null || _this$_cache$get2.destroy == null || _this$_cache$get2.destroy(device);
			this._cache.delete(device);
		};
		return DeviceCache;
	}();

	var TextureUtils = function () {
		function TextureUtils() {}
		TextureUtils.calcLevelDimension = function calcLevelDimension(dimension, mipLevel) {
			return Math.max(dimension >> mipLevel, 1);
		};
		TextureUtils.calcMipLevelsCount = function calcMipLevelsCount(width, height, depth) {
			if (depth === void 0) {
				depth = 1;
			}
			return 1 + Math.floor(Math.log2(Math.max(width, height, depth)));
		};
		TextureUtils.calcLevelGpuSize = function calcLevelGpuSize(width, height, depth, format) {
			var _pixelFormatInfo$get$, _pixelFormatInfo$get, _formatInfo$blockSize;
			var formatInfo = pixelFormatInfo.get(format);
			var pixelSize = (_pixelFormatInfo$get$ = (_pixelFormatInfo$get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get.size) != null ? _pixelFormatInfo$get$ : 0;
			if (pixelSize > 0) {
				return width * height * depth * pixelSize;
			}
			var blockSize = (_formatInfo$blockSize = formatInfo.blockSize) != null ? _formatInfo$blockSize : 0;
			var blockWidth = Math.floor((width + 3) / 4);
			var blockHeight = Math.floor((height + 3) / 4);
			var blockDepth = Math.floor((depth + 3) / 4);
			if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
				blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
			}
			return blockWidth * blockHeight * blockDepth * blockSize;
		};
		TextureUtils.calcGpuSize = function calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
			var result = 0;
			while (1) {
				result += TextureUtils.calcLevelGpuSize(width, height, depth, format);
				if (!mipmaps || width === 1 && height === 1 && depth === 1) {
					break;
				}
				width = Math.max(width >> 1, 1);
				height = Math.max(height >> 1, 1);
				depth = Math.max(depth >> 1, 1);
			}
			return result * (cubemap ? 6 : 1);
		};
		return TextureUtils;
	}();

	var id$a = 0;
	var Texture = function () {
		function Texture(graphicsDevice, options) {
			var _options$name, _options$width, _options$height, _options$format, _options$volume, _options$depth, _options$arrayLength, _options$storage, _options$cubemap, _options$flipY, _options$premultiplyA, _options$mipmaps, _options$minFilter, _options$magFilter, _options$anisotropy, _options$addressU, _options$addressV, _options$addressW, _options$compareOnRea, _options$compareFunc;
			if (options === void 0) {
				options = {};
			}
			this.name = void 0;
			this._gpuSize = 0;
			this.id = id$a++;
			this._invalid = false;
			this._lockedLevel = -1;
			this._lockedMode = TEXTURELOCK_NONE;
			this.renderVersionDirty = 0;
			this._storage = false;
			this._numLevels = 0;
			this._numLevelsRequested = void 0;
			this.device = graphicsDevice;
			this.name = (_options$name = options.name) != null ? _options$name : '';
			this._width = Math.floor((_options$width = options.width) != null ? _options$width : 4);
			this._height = Math.floor((_options$height = options.height) != null ? _options$height : 4);
			this._format = (_options$format = options.format) != null ? _options$format : PIXELFORMAT_RGBA8;
			this._compressed = isCompressedPixelFormat(this._format);
			this._integerFormat = isIntegerPixelFormat(this._format);
			if (this._integerFormat) {
				options.minFilter = FILTER_NEAREST;
				options.magFilter = FILTER_NEAREST;
			}
			this._volume = (_options$volume = options.volume) != null ? _options$volume : false;
			this._depth = Math.floor((_options$depth = options.depth) != null ? _options$depth : 1);
			this._arrayLength = Math.floor((_options$arrayLength = options.arrayLength) != null ? _options$arrayLength : 0);
			this._storage = (_options$storage = options.storage) != null ? _options$storage : false;
			this._cubemap = (_options$cubemap = options.cubemap) != null ? _options$cubemap : false;
			this._flipY = (_options$flipY = options.flipY) != null ? _options$flipY : false;
			this._premultiplyAlpha = (_options$premultiplyA = options.premultiplyAlpha) != null ? _options$premultiplyA : false;
			this._mipmaps = (_options$mipmaps = options.mipmaps) != null ? _options$mipmaps : true;
			this._numLevelsRequested = options.numLevels;
			if (options.numLevels !== undefined) {
				this._numLevels = options.numLevels;
			}
			this._updateNumLevel();
			this._minFilter = (_options$minFilter = options.minFilter) != null ? _options$minFilter : FILTER_LINEAR_MIPMAP_LINEAR;
			this._magFilter = (_options$magFilter = options.magFilter) != null ? _options$magFilter : FILTER_LINEAR;
			this._anisotropy = (_options$anisotropy = options.anisotropy) != null ? _options$anisotropy : 1;
			this._addressU = (_options$addressU = options.addressU) != null ? _options$addressU : ADDRESS_REPEAT;
			this._addressV = (_options$addressV = options.addressV) != null ? _options$addressV : ADDRESS_REPEAT;
			this._addressW = (_options$addressW = options.addressW) != null ? _options$addressW : ADDRESS_REPEAT;
			this._compareOnRead = (_options$compareOnRea = options.compareOnRead) != null ? _options$compareOnRea : false;
			this._compareFunc = (_options$compareFunc = options.compareFunc) != null ? _options$compareFunc : FUNC_LESS;
			this.type = options.hasOwnProperty('type') ? options.type : TEXTURETYPE_DEFAULT;
			this.projection = TEXTUREPROJECTION_NONE;
			if (this._cubemap) {
				this.projection = TEXTUREPROJECTION_CUBE;
			} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
				this.projection = options.projection;
			}
			this.impl = graphicsDevice.createTextureImpl(this);
			this.dirtyAll();
			this._levels = options.levels;
			if (this._levels) {
				this.upload();
			} else {
				this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
			}
			graphicsDevice.textures.push(this);
		}
		var _proto = Texture.prototype;
		_proto.destroy = function destroy() {
			var device = this.device;
			if (device) {
				var idx = device.textures.indexOf(this);
				if (idx !== -1) {
					device.textures.splice(idx, 1);
				}
				device.scope.removeValue(this);
				this.impl.destroy(device);
				this.adjustVramSizeTracking(device._vram, -this._gpuSize);
				this._levels = null;
				this.device = null;
			}
		};
		_proto.resize = function resize(width, height, depth) {
			if (depth === void 0) {
				depth = 1;
			}
			var device = this.device;
			this.adjustVramSizeTracking(device._vram, -this._gpuSize);
			this.impl.destroy(device);
			this._width = Math.floor(width);
			this._height = Math.floor(height);
			this._depth = Math.floor(depth);
			this._updateNumLevel();
			this.impl = device.createTextureImpl(this);
			this.dirtyAll();
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
			this.dirtyAll();
		};
		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.tex += size;
		};
		_proto.propertyChanged = function propertyChanged(flag) {
			this.impl.propertyChanged(flag);
			this.renderVersionDirty = this.device.renderVersion;
		};
		_proto._updateNumLevel = function _updateNumLevel() {
			var maxLevels = this.mipmaps ? TextureUtils.calcMipLevelsCount(this.width, this.height) : 1;
			var requestedLevels = this._numLevelsRequested;
			this._numLevels = Math.min(requestedLevels != null ? requestedLevels : maxLevels, maxLevels);
			this._mipmaps = this._numLevels > 1;
		};
		_proto.dirtyAll = function dirtyAll() {
			this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
			this._mipmapsUploaded = false;
			this.propertyChanged(TEXPROPERTY_ALL);
		};
		_proto.lock = function lock(options) {
			var _options, _options$level, _options2, _options2$face, _options3, _options3$mode;
			if (options === void 0) {
				options = {};
			}
			(_options$level = (_options = options).level) != null ? _options$level : _options.level = 0;
			(_options2$face = (_options2 = options).face) != null ? _options2$face : _options2.face = 0;
			(_options3$mode = (_options3 = options).mode) != null ? _options3$mode : _options3.mode = TEXTURELOCK_WRITE;
			this._lockedMode = options.mode;
			this._lockedLevel = options.level;
			var levels = this.cubemap ? this._levels[options.face] : this._levels;
			if (levels[options.level] === null) {
				var width = Math.max(1, this._width >> options.level);
				var height = Math.max(1, this._height >> options.level);
				var depth = Math.max(1, this._depth >> options.level);
				var data = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, depth, this._format));
				levels[options.level] = new (getPixelFormatArrayType(this._format))(data);
			}
			return levels[options.level];
		};
		_proto.setSource = function setSource(source, mipLevel) {
			if (mipLevel === void 0) {
				mipLevel = 0;
			}
			var invalid = false;
			var width, height;
			if (this._cubemap) {
				if (source[0]) {
					width = source[0].width || 0;
					height = source[0].height || 0;
					for (var i = 0; i < 6; i++) {
						var face = source[i];
						if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
							invalid = true;
							break;
						}
					}
				} else {
					invalid = true;
				}
				if (!invalid) {
					for (var _i = 0; _i < 6; _i++) {
						if (this._levels[mipLevel][_i] !== source[_i]) {
							this._levelsUpdated[mipLevel][_i] = true;
						}
					}
				}
			} else {
				if (!this.device._isBrowserInterface(source)) {
					invalid = true;
				}
				if (!invalid) {
					if (source !== this._levels[mipLevel]) {
						this._levelsUpdated[mipLevel] = true;
					}
					if (source instanceof HTMLVideoElement) {
						width = source.videoWidth;
						height = source.videoHeight;
					} else {
						width = source.width;
						height = source.height;
					}
				}
			}
			if (invalid) {
				this._width = 4;
				this._height = 4;
				if (this._cubemap) {
					for (var _i2 = 0; _i2 < 6; _i2++) {
						this._levels[mipLevel][_i2] = null;
						this._levelsUpdated[mipLevel][_i2] = true;
					}
				} else {
					this._levels[mipLevel] = null;
					this._levelsUpdated[mipLevel] = true;
				}
			} else {
				if (mipLevel === 0) {
					this._width = width;
					this._height = height;
				}
				this._levels[mipLevel] = source;
			}
			if (this._invalid !== invalid || !invalid) {
				this._invalid = invalid;
				this.upload();
			}
		};
		_proto.getSource = function getSource(mipLevel) {
			if (mipLevel === void 0) {
				mipLevel = 0;
			}
			return this._levels[mipLevel];
		};
		_proto.unlock = function unlock() {
			if (this._lockedMode === TEXTURELOCK_NONE) ;
			if (this._lockedMode === TEXTURELOCK_WRITE) {
				this.upload();
			}
			this._lockedLevel = -1;
			this._lockedMode = TEXTURELOCK_NONE;
		};
		_proto.upload = function upload() {
			var _this$impl$uploadImme, _this$impl;
			this._needsUpload = true;
			this._needsMipmapsUpload = this._mipmaps;
			(_this$impl$uploadImme = (_this$impl = this.impl).uploadImmediate) == null || _this$impl$uploadImme.call(_this$impl, this.device, this);
		};
		_proto.read = function read(x, y, width, height, options) {
			var _this$impl$read, _this$impl2;
			if (options === void 0) {
				options = {};
			}
			return (_this$impl$read = (_this$impl2 = this.impl).read) == null ? void 0 : _this$impl$read.call(_this$impl2, x, y, width, height, options);
		};
		return _createClass(Texture, [{
			key: "lockedMode",
			get: function get() {
				return this._lockedMode;
			}
		}, {
			key: "minFilter",
			get: function get() {
				return this._minFilter;
			},
			set: function set(v) {
				if (this._minFilter !== v) {
					if (isIntegerPixelFormat(this._format)) ; else {
						this._minFilter = v;
						this.propertyChanged(TEXPROPERTY_MIN_FILTER);
					}
				}
			}
		}, {
			key: "magFilter",
			get: function get() {
				return this._magFilter;
			},
			set: function set(v) {
				if (this._magFilter !== v) {
					if (isIntegerPixelFormat(this._format)) ; else {
						this._magFilter = v;
						this.propertyChanged(TEXPROPERTY_MAG_FILTER);
					}
				}
			}
		}, {
			key: "addressU",
			get: function get() {
				return this._addressU;
			},
			set: function set(v) {
				if (this._addressU !== v) {
					this._addressU = v;
					this.propertyChanged(TEXPROPERTY_ADDRESS_U);
				}
			}
		}, {
			key: "addressV",
			get: function get() {
				return this._addressV;
			},
			set: function set(v) {
				if (this._addressV !== v) {
					this._addressV = v;
					this.propertyChanged(TEXPROPERTY_ADDRESS_V);
				}
			}
		}, {
			key: "addressW",
			get: function get() {
				return this._addressW;
			},
			set: function set(addressW) {
				if (!this._volume) {
					return;
				}
				if (addressW !== this._addressW) {
					this._addressW = addressW;
					this.propertyChanged(TEXPROPERTY_ADDRESS_W);
				}
			}
		}, {
			key: "compareOnRead",
			get: function get() {
				return this._compareOnRead;
			},
			set: function set(v) {
				if (this._compareOnRead !== v) {
					this._compareOnRead = v;
					this.propertyChanged(TEXPROPERTY_COMPARE_ON_READ);
				}
			}
		}, {
			key: "compareFunc",
			get: function get() {
				return this._compareFunc;
			},
			set: function set(v) {
				if (this._compareFunc !== v) {
					this._compareFunc = v;
					this.propertyChanged(TEXPROPERTY_COMPARE_FUNC);
				}
			}
		}, {
			key: "anisotropy",
			get: function get() {
				return this._anisotropy;
			},
			set: function set(v) {
				if (this._anisotropy !== v) {
					this._anisotropy = v;
					this.propertyChanged(TEXPROPERTY_ANISOTROPY);
				}
			}
		}, {
			key: "mipmaps",
			get: function get() {
				return this._mipmaps;
			},
			set: function set(v) {
				if (this._mipmaps !== v) {
					if (this.device.isWebGPU) ; else if (isIntegerPixelFormat(this._format)) ; else {
						this._mipmaps = v;
					}
					if (v) this._needsMipmapsUpload = true;
				}
			}
		}, {
			key: "numLevels",
			get: function get() {
				return this._numLevels;
			}
		}, {
			key: "storage",
			get: function get() {
				return this._storage;
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			}
		}, {
			key: "depth",
			get: function get() {
				return this._depth;
			}
		}, {
			key: "format",
			get: function get() {
				return this._format;
			}
		}, {
			key: "cubemap",
			get: function get() {
				return this._cubemap;
			}
		}, {
			key: "gpuSize",
			get: function get() {
				var mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
				return TextureUtils.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
			}
		}, {
			key: "array",
			get: function get() {
				return this._arrayLength > 0;
			}
		}, {
			key: "arrayLength",
			get: function get() {
				return this._arrayLength;
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			}
		}, {
			key: "flipY",
			get: function get() {
				return this._flipY;
			},
			set: function set(flipY) {
				if (this._flipY !== flipY) {
					this._flipY = flipY;
					this._needsUpload = true;
				}
			}
		}, {
			key: "premultiplyAlpha",
			get: function get() {
				return this._premultiplyAlpha;
			},
			set: function set(premultiplyAlpha) {
				if (this._premultiplyAlpha !== premultiplyAlpha) {
					this._premultiplyAlpha = premultiplyAlpha;
					this._needsUpload = true;
				}
			}
		}, {
			key: "pot",
			get: function get() {
				return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
			}
		}, {
			key: "encoding",
			get: function get() {
				switch (this.type) {
					case TEXTURETYPE_RGBM:
						return 'rgbm';
					case TEXTURETYPE_RGBE:
						return 'rgbe';
					case TEXTURETYPE_RGBP:
						return 'rgbp';
				}
				return requiresManualGamma(this.format) ? 'srgb' : 'linear';
			}
		}]);
	}();

	var textureData = {
		white: [255, 255, 255, 255],
		gray: [128, 128, 128, 255],
		black: [0, 0, 0, 255],
		normal: [128, 128, 255, 255],
		pink: [255, 128, 255, 255]
	};
	var BuiltInTextures = function () {
		function BuiltInTextures() {
			this.map = new Map();
		}
		var _proto = BuiltInTextures.prototype;
		_proto.destroy = function destroy() {
			this.map.forEach(function (texture) {
				texture.destroy();
			});
		};
		return BuiltInTextures;
	}();
	var deviceCache$3 = new DeviceCache();
	var getBuiltInTexture = function getBuiltInTexture(device, name) {
		var cache = deviceCache$3.get(device, function () {
			return new BuiltInTextures();
		});
		if (!cache.map.has(name)) {
			var texture = new Texture(device, {
				name: "built-in-texture-" + name,
				width: 1,
				height: 1,
				format: PIXELFORMAT_RGBA8
			});
			var pixels = texture.lock();
			var data = textureData[name];
			pixels.set(data);
			texture.unlock();
			cache.map.set(name, texture);
		}
		return cache.map.get(name);
	};

	var id$9 = 0;
	var DynamicBindGroup = function DynamicBindGroup() {
		this.bindGroup = void 0;
		this.offsets = [];
	};
	var BindGroup = function () {
		function BindGroup(graphicsDevice, format, defaultUniformBuffer) {
			this.renderVersionUpdated = -1;
			this.uniformBuffers = void 0;
			this.uniformBufferOffsets = [];
			this.id = id$9++;
			this.device = graphicsDevice;
			this.format = format;
			this.dirty = true;
			this.impl = graphicsDevice.createBindGroupImpl(this);
			this.textures = [];
			this.storageTextures = [];
			this.storageBuffers = [];
			this.uniformBuffers = [];
			this.defaultUniformBuffer = defaultUniformBuffer;
			if (defaultUniformBuffer) {
				this.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);
			}
		}
		var _proto = BindGroup.prototype;
		_proto.destroy = function destroy() {
			this.impl.destroy();
			this.impl = null;
			this.format = null;
			this.defaultUniformBuffer = null;
		};
		_proto.setUniformBuffer = function setUniformBuffer(name, uniformBuffer) {
			var index = this.format.bufferFormatsMap.get(name);
			if (this.uniformBuffers[index] !== uniformBuffer) {
				this.uniformBuffers[index] = uniformBuffer;
				this.dirty = true;
			}
		};
		_proto.setStorageBuffer = function setStorageBuffer(name, storageBuffer) {
			var index = this.format.storageBufferFormatsMap.get(name);
			if (this.storageBuffers[index] !== storageBuffer) {
				this.storageBuffers[index] = storageBuffer;
				this.dirty = true;
			}
		};
		_proto.setTexture = function setTexture(name, texture) {
			var index = this.format.textureFormatsMap.get(name);
			if (this.textures[index] !== texture) {
				this.textures[index] = texture;
				this.dirty = true;
			} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
				this.dirty = true;
			}
		};
		_proto.setStorageTexture = function setStorageTexture(name, texture) {
			var index = this.format.storageTextureFormatsMap.get(name);
			if (this.storageTextures[index] !== texture) {
				this.storageTextures[index] = texture;
				this.dirty = true;
			} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
				this.dirty = true;
			}
		};
		_proto.updateUniformBuffers = function updateUniformBuffers() {
			for (var i = 0; i < this.uniformBuffers.length; i++) {
				this.uniformBuffers[i].update();
			}
		};
		_proto.update = function update() {
			var _this$format = this.format,
				textureFormats = _this$format.textureFormats,
				storageTextureFormats = _this$format.storageTextureFormats,
				storageBufferFormats = _this$format.storageBufferFormats;
			for (var i = 0; i < textureFormats.length; i++) {
				var textureFormat = textureFormats[i];
				var value = textureFormat.scopeId.value;
				if (!value) {
					if (textureFormat.name === 'uSceneDepthMap') {
						value = getBuiltInTexture(this.device, 'white');
					}
					if (textureFormat.name === 'uSceneColorMap') {
						value = getBuiltInTexture(this.device, 'pink');
					}
					if (!value) {
						value = getBuiltInTexture(this.device, 'pink');
					}
				}
				this.setTexture(textureFormat.name, value);
			}
			for (var _i = 0; _i < storageTextureFormats.length; _i++) {
				var storageTextureFormat = storageTextureFormats[_i];
				var _value = storageTextureFormat.scopeId.value;
				this.setStorageTexture(storageTextureFormat.name, _value);
			}
			for (var _i2 = 0; _i2 < storageBufferFormats.length; _i2++) {
				var storageBufferFormat = storageBufferFormats[_i2];
				var _value2 = storageBufferFormat.scopeId.value;
				this.setStorageBuffer(storageBufferFormat.name, _value2);
			}
			this.uniformBufferOffsets.length = this.uniformBuffers.length;
			for (var _i3 = 0; _i3 < this.uniformBuffers.length; _i3++) {
				var uniformBuffer = this.uniformBuffers[_i3];
				this.uniformBufferOffsets[_i3] = uniformBuffer.offset;
				if (this.renderVersionUpdated < uniformBuffer.renderVersionDirty) {
					this.dirty = true;
				}
			}
			if (this.dirty) {
				this.dirty = false;
				this.renderVersionUpdated = this.device.renderVersion;
				this.impl.update(this);
			}
		};
		return BindGroup;
	}();

	var BitPacking = {
		set: function set(storage, value, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			var data = storage & ~(mask << shift);
			return data | value << shift;
		},
		get: function get(storage, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			return storage >> shift & mask;
		},
		all: function all(storage, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			var shifted = mask << shift;
			return (storage & shifted) === shifted;
		},
		any: function any(storage, shift, mask) {
			if (mask === void 0) {
				mask = 1;
			}
			return (storage & mask << shift) !== 0;
		}
	};

	var _BlendState;
	var opMask = 7;
	var factorMask = 15;
	var colorOpShift = 0;
	var colorSrcFactorShift = 3;
	var colorDstFactorShift = 7;
	var alphaOpShift = 11;
	var alphaSrcFactorShift = 14;
	var alphaDstFactorShift = 18;
	var redWriteShift = 22;
	var greenWriteShift = 23;
	var blueWriteShift = 24;
	var alphaWriteShift = 25;
	var blendShift = 26;
	var allWriteMasks = 15;
	var allWriteShift = redWriteShift;
	var BlendState = function () {
		function BlendState(blend, colorOp, colorSrcFactor, colorDstFactor, alphaOp, alphaSrcFactor, alphaDstFactor, redWrite, greenWrite, blueWrite, alphaWrite) {
			if (blend === void 0) {
				blend = false;
			}
			if (colorOp === void 0) {
				colorOp = BLENDEQUATION_ADD;
			}
			if (colorSrcFactor === void 0) {
				colorSrcFactor = BLENDMODE_ONE;
			}
			if (colorDstFactor === void 0) {
				colorDstFactor = BLENDMODE_ZERO;
			}
			if (redWrite === void 0) {
				redWrite = true;
			}
			if (greenWrite === void 0) {
				greenWrite = true;
			}
			if (blueWrite === void 0) {
				blueWrite = true;
			}
			if (alphaWrite === void 0) {
				alphaWrite = true;
			}
			this.target0 = 0;
			this.setColorBlend(colorOp, colorSrcFactor, colorDstFactor);
			this.setAlphaBlend(alphaOp != null ? alphaOp : colorOp, alphaSrcFactor != null ? alphaSrcFactor : colorSrcFactor, alphaDstFactor != null ? alphaDstFactor : colorDstFactor);
			this.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
			this.blend = blend;
		}
		var _proto = BlendState.prototype;
		_proto.setColorBlend = function setColorBlend(op, srcFactor, dstFactor) {
			this.target0 = BitPacking.set(this.target0, op, colorOpShift, opMask);
			this.target0 = BitPacking.set(this.target0, srcFactor, colorSrcFactorShift, factorMask);
			this.target0 = BitPacking.set(this.target0, dstFactor, colorDstFactorShift, factorMask);
		};
		_proto.setAlphaBlend = function setAlphaBlend(op, srcFactor, dstFactor) {
			this.target0 = BitPacking.set(this.target0, op, alphaOpShift, opMask);
			this.target0 = BitPacking.set(this.target0, srcFactor, alphaSrcFactorShift, factorMask);
			this.target0 = BitPacking.set(this.target0, dstFactor, alphaDstFactorShift, factorMask);
		};
		_proto.setColorWrite = function setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite) {
			this.redWrite = redWrite;
			this.greenWrite = greenWrite;
			this.blueWrite = blueWrite;
			this.alphaWrite = alphaWrite;
		};
		_proto.copy = function copy(rhs) {
			this.target0 = rhs.target0;
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		_proto.equals = function equals(rhs) {
			return this.target0 === rhs.target0;
		};
		return _createClass(BlendState, [{
			key: "blend",
			get: function get() {
				return BitPacking.all(this.target0, blendShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blendShift);
			}
		}, {
			key: "colorOp",
			get: function get() {
				return BitPacking.get(this.target0, colorOpShift, opMask);
			}
		}, {
			key: "colorSrcFactor",
			get: function get() {
				return BitPacking.get(this.target0, colorSrcFactorShift, factorMask);
			}
		}, {
			key: "colorDstFactor",
			get: function get() {
				return BitPacking.get(this.target0, colorDstFactorShift, factorMask);
			}
		}, {
			key: "alphaOp",
			get: function get() {
				return BitPacking.get(this.target0, alphaOpShift, opMask);
			}
		}, {
			key: "alphaSrcFactor",
			get: function get() {
				return BitPacking.get(this.target0, alphaSrcFactorShift, factorMask);
			}
		}, {
			key: "alphaDstFactor",
			get: function get() {
				return BitPacking.get(this.target0, alphaDstFactorShift, factorMask);
			}
		}, {
			key: "redWrite",
			get: function get() {
				return BitPacking.all(this.target0, redWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, redWriteShift);
			}
		}, {
			key: "greenWrite",
			get: function get() {
				return BitPacking.all(this.target0, greenWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, greenWriteShift);
			}
		}, {
			key: "blueWrite",
			get: function get() {
				return BitPacking.all(this.target0, blueWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blueWriteShift);
			}
		}, {
			key: "alphaWrite",
			get: function get() {
				return BitPacking.all(this.target0, alphaWriteShift);
			},
			set: function set(value) {
				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, alphaWriteShift);
			}
		}, {
			key: "allWrite",
			get: function get() {
				return BitPacking.get(this.target0, allWriteShift, allWriteMasks);
			}
		}, {
			key: "key",
			get: function get() {
				return this.target0;
			}
		}]);
	}();
	_BlendState = BlendState;
	BlendState.NOBLEND = Object.freeze(new _BlendState());
	BlendState.NOWRITE = Object.freeze(new _BlendState(undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, false, false, false));
	BlendState.ALPHABLEND = Object.freeze(new _BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA));
	BlendState.ADDBLEND = Object.freeze(new _BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE));

	var StringIds = function () {
		function StringIds() {
			this.map = new Map();
			this.id = 0;
		}
		var _proto = StringIds.prototype;
		_proto.get = function get(name) {
			var value = this.map.get(name);
			if (value === undefined) {
				value = this.id++;
				this.map.set(name, value);
			}
			return value;
		};
		return StringIds;
	}();

	var _DepthState;
	var stringIds$4 = new StringIds();
	var funcMask = 7;
	var funcShift = 0;
	var writeShift = 3;
	var DepthState = function () {
		function DepthState(func, write) {
			if (func === void 0) {
				func = FUNC_LESSEQUAL;
			}
			if (write === void 0) {
				write = true;
			}
			this.data = 0;
			this._depthBias = 0;
			this._depthBiasSlope = 0;
			this.key = 0;
			this.func = func;
			this.write = write;
		}
		var _proto = DepthState.prototype;
		_proto.copy = function copy(rhs) {
			this.data = rhs.data;
			this._depthBias = rhs._depthBias;
			this._depthBiasSlope = rhs._depthBiasSlope;
			this.key = rhs.key;
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		_proto.updateKey = function updateKey() {
			var data = this.data,
				_depthBias = this._depthBias,
				_depthBiasSlope = this._depthBiasSlope;
			var key = data + "-" + _depthBias + "-" + _depthBiasSlope;
			this.key = stringIds$4.get(key);
		};
		_proto.equals = function equals(rhs) {
			return this.key === rhs.key;
		};
		return _createClass(DepthState, [{
			key: "test",
			get: function get() {
				return this.func !== FUNC_ALWAYS;
			},
			set: function set(value) {
				this.func = value ? FUNC_LESSEQUAL : FUNC_ALWAYS;
				this.updateKey();
			}
		}, {
			key: "write",
			get: function get() {
				return BitPacking.all(this.data, writeShift);
			},
			set: function set(value) {
				this.data = BitPacking.set(this.data, value ? 1 : 0, writeShift);
				this.updateKey();
			}
		}, {
			key: "func",
			get: function get() {
				return BitPacking.get(this.data, funcShift, funcMask);
			},
			set: function set(value) {
				this.data = BitPacking.set(this.data, value, funcShift, funcMask);
				this.updateKey();
			}
		}, {
			key: "depthBias",
			get: function get() {
				return this._depthBias;
			},
			set: function set(value) {
				this._depthBias = value;
				this.updateKey();
			}
		}, {
			key: "depthBiasSlope",
			get: function get() {
				return this._depthBiasSlope;
			},
			set: function set(value) {
				this._depthBiasSlope = value;
				this.updateKey();
			}
		}]);
	}();
	_DepthState = DepthState;
	DepthState.DEFAULT = Object.freeze(new _DepthState());
	DepthState.NODEPTH = Object.freeze(new _DepthState(FUNC_ALWAYS, false));
	DepthState.WRITEDEPTH = Object.freeze(new _DepthState(FUNC_ALWAYS, true));

	var Version = function () {
		function Version() {
			this.globalId = 0;
			this.revision = 0;
		}
		var _proto = Version.prototype;
		_proto.equals = function equals(other) {
			return this.globalId === other.globalId && this.revision === other.revision;
		};
		_proto.copy = function copy(other) {
			this.globalId = other.globalId;
			this.revision = other.revision;
		};
		_proto.reset = function reset() {
			this.globalId = 0;
			this.revision = 0;
		};
		return Version;
	}();

	var idCounter = 0;
	var VersionedObject = function () {
		function VersionedObject() {
			idCounter++;
			this.version = new Version();
			this.version.globalId = idCounter;
		}
		var _proto = VersionedObject.prototype;
		_proto.increment = function increment() {
			this.version.revision++;
		};
		return VersionedObject;
	}();

	var ScopeId = function () {
		function ScopeId(name) {
			this.name = name;
			this.value = null;
			this.versionObject = new VersionedObject();
		}
		var _proto = ScopeId.prototype;
		_proto.toJSON = function toJSON(key) {
			return undefined;
		};
		_proto.setValue = function setValue(value) {
			this.value = value;
			this.versionObject.increment();
		};
		_proto.getValue = function getValue() {
			return this.value;
		};
		return ScopeId;
	}();

	var ScopeSpace = function () {
		function ScopeSpace(name) {
			this.name = name;
			this.variables = new Map();
		}
		var _proto = ScopeSpace.prototype;
		_proto.resolve = function resolve(name) {
			if (!this.variables.has(name)) {
				this.variables.set(name, new ScopeId(name));
			}
			return this.variables.get(name);
		};
		_proto.removeValue = function removeValue(value) {
			for (var uniformName in this.variables) {
				var uniform = this.variables[uniformName];
				if (uniform.value === value) {
					uniform.value = null;
				}
			}
		};
		return ScopeSpace;
	}();

	var id$8 = 0;
	var VertexBuffer = function () {
		function VertexBuffer(graphicsDevice, format, numVertices, options) {
			var _options$usage;
			this.usage = BUFFER_STATIC;
			this.usage = (_options$usage = options == null ? void 0 : options.usage) != null ? _options$usage : BUFFER_STATIC;
			this.device = graphicsDevice;
			this.format = format;
			this.numVertices = numVertices;
			this.id = id$8++;
			this.impl = graphicsDevice.createVertexBufferImpl(this, format, options);
			this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
			this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
			var initialData = options == null ? void 0 : options.data;
			if (initialData) {
				this.setData(initialData);
			} else {
				this.storage = new ArrayBuffer(this.numBytes);
			}
			this.device.buffers.push(this);
		}
		var _proto = VertexBuffer.prototype;
		_proto.destroy = function destroy() {
			var device = this.device;
			var idx = device.buffers.indexOf(this);
			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}
			if (this.impl.initialized) {
				this.impl.destroy(device);
				this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
			}
		};
		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.vb += size;
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};
		_proto.getFormat = function getFormat() {
			return this.format;
		};
		_proto.getUsage = function getUsage() {
			return this.usage;
		};
		_proto.getNumVertices = function getNumVertices() {
			return this.numVertices;
		};
		_proto.lock = function lock() {
			return this.storage;
		};
		_proto.unlock = function unlock() {
			this.impl.unlock(this);
		};
		_proto.setData = function setData(data) {
			if (data.byteLength !== this.numBytes) {
				return false;
			}
			this.storage = data;
			this.unlock();
			return true;
		};
		return VertexBuffer;
	}();

	function hashCode(str) {
		if (str === null || str === undefined) {
			return 0;
		}
		var hash = 0;
		for (var i = 0, len = str.length; i < len; i++) {
			hash = (hash << 5) - hash + str.charCodeAt(i);
			hash |= 0;
		}
		return hash;
	}
	function hash32Fnv1a(array) {
		var prime = 16777619;
		var hash = 2166136261;
		for (var i = 0; i < array.length; i++) {
			hash ^= array[i];
			hash *= prime;
		}
		return hash >>> 0;
	}

	var stringIds$3 = new StringIds();
	var webgpuValidElementSizes = [2, 4, 8, 12, 16];
	var deviceCache$2 = new DeviceCache();
	var VertexFormat = function () {
		function VertexFormat(graphicsDevice, description, vertexCount) {
			this.device = graphicsDevice;
			this._elements = [];
			this.hasUv0 = false;
			this.hasUv1 = false;
			this.hasColor = false;
			this.hasTangents = false;
			this.verticesByteSize = 0;
			this.vertexCount = vertexCount;
			this.interleaved = vertexCount === undefined;
			this.instancing = false;
			this.size = description.reduce(function (total, desc) {
				return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
			}, 0);
			var offset = 0,
				elementSize;
			for (var i = 0, len = description.length; i < len; i++) {
				var _elementDesc$asInt, _elementDesc$normaliz;
				var elementDesc = description[i];
				elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
				if (vertexCount) {
					offset = math.roundUp(offset, elementSize);
				}
				var asInt = (_elementDesc$asInt = elementDesc.asInt) != null ? _elementDesc$asInt : false;
				var normalize = asInt ? false : (_elementDesc$normaliz = elementDesc.normalize) != null ? _elementDesc$normaliz : false;
				var element = {
					name: elementDesc.semantic,
					offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
					stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
					dataType: elementDesc.type,
					numComponents: elementDesc.components,
					normalize: normalize,
					size: elementSize,
					asInt: asInt
				};
				this._elements.push(element);
				if (vertexCount) {
					offset += elementSize * vertexCount;
				} else {
					offset += Math.ceil(elementSize / 4) * 4;
				}
				if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
					this.hasUv0 = true;
				} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
					this.hasUv1 = true;
				} else if (elementDesc.semantic === SEMANTIC_COLOR) {
					this.hasColor = true;
				} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
					this.hasTangents = true;
				}
			}
			if (vertexCount) {
				this.verticesByteSize = offset;
			}
			this._evaluateHash();
		}
		VertexFormat.getDefaultInstancingFormat = function getDefaultInstancingFormat(graphicsDevice) {
			return deviceCache$2.get(graphicsDevice, function () {
				return new VertexFormat(graphicsDevice, [{
					semantic: SEMANTIC_ATTR12,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR13,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR14,
					components: 4,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_ATTR15,
					components: 4,
					type: TYPE_FLOAT32
				}]);
			});
		};
		VertexFormat.isElementValid = function isElementValid(graphicsDevice, elementDesc) {
			var elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
			if (graphicsDevice.isWebGPU && !webgpuValidElementSizes.includes(elementSize)) {
				return false;
			}
			return true;
		};
		var _proto = VertexFormat.prototype;
		_proto.update = function update() {
			this._evaluateHash();
		};
		_proto._evaluateHash = function _evaluateHash() {
			var stringElementsBatch = [];
			var stringElementsRender = [];
			var len = this._elements.length;
			for (var i = 0; i < len; i++) {
				var _this$_elements$i = this._elements[i],
					name = _this$_elements$i.name,
					dataType = _this$_elements$i.dataType,
					numComponents = _this$_elements$i.numComponents,
					normalize = _this$_elements$i.normalize,
					offset = _this$_elements$i.offset,
					stride = _this$_elements$i.stride,
					size = _this$_elements$i.size,
					asInt = _this$_elements$i.asInt;
				var stringElementBatch = name + dataType + numComponents + normalize + asInt;
				stringElementsBatch.push(stringElementBatch);
				var stringElementRender = stringElementBatch + offset + stride + size;
				stringElementsRender.push(stringElementRender);
			}
			stringElementsBatch.sort();
			var batchingString = stringElementsBatch.join();
			this.batchingHash = hashCode(batchingString);
			this.shaderProcessingHashString = batchingString;
			this.renderingHashString = stringElementsRender.join('_');
			this.renderingHash = stringIds$3.get(this.renderingHashString);
		};
		return _createClass(VertexFormat, [{
			key: "elements",
			get: function get() {
				return this._elements;
			}
		}]);
	}();

	var _StencilParameters;
	var stringIds$2 = new StringIds();
	var StencilParameters = function () {
		function StencilParameters(options) {
			var _options$func, _options$ref, _options$readMask, _options$writeMask, _options$fail, _options$zfail, _options$zpass;
			if (options === void 0) {
				options = {};
			}
			this._func = void 0;
			this._ref = void 0;
			this._fail = void 0;
			this._zfail = void 0;
			this._zpass = void 0;
			this._readMask = void 0;
			this._writeMask = void 0;
			this._dirty = true;
			this._key = void 0;
			this._func = (_options$func = options.func) != null ? _options$func : FUNC_ALWAYS;
			this._ref = (_options$ref = options.ref) != null ? _options$ref : 0;
			this._readMask = (_options$readMask = options.readMask) != null ? _options$readMask : 0xFF;
			this._writeMask = (_options$writeMask = options.writeMask) != null ? _options$writeMask : 0xFF;
			this._fail = (_options$fail = options.fail) != null ? _options$fail : STENCILOP_KEEP;
			this._zfail = (_options$zfail = options.zfail) != null ? _options$zfail : STENCILOP_KEEP;
			this._zpass = (_options$zpass = options.zpass) != null ? _options$zpass : STENCILOP_KEEP;
			this._evalKey();
		}
		var _proto = StencilParameters.prototype;
		_proto._evalKey = function _evalKey() {
			var _func = this._func,
				_ref = this._ref,
				_fail = this._fail,
				_zfail = this._zfail,
				_zpass = this._zpass,
				_readMask = this._readMask,
				_writeMask = this._writeMask;
			var key = _func + "," + _ref + "," + _fail + "," + _zfail + "," + _zpass + "," + _readMask + "," + _writeMask;
			this._key = stringIds$2.get(key);
			this._dirty = false;
		};
		_proto.copy = function copy(rhs) {
			this._func = rhs._func;
			this._ref = rhs._ref;
			this._readMask = rhs._readMask;
			this._writeMask = rhs._writeMask;
			this._fail = rhs._fail;
			this._zfail = rhs._zfail;
			this._zpass = rhs._zpass;
			this._dirty = rhs._dirty;
			this._key = rhs._key;
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		return _createClass(StencilParameters, [{
			key: "func",
			get: function get() {
				return this._func;
			},
			set: function set(value) {
				this._func = value;
				this._dirty = true;
			}
		}, {
			key: "ref",
			get: function get() {
				return this._ref;
			},
			set: function set(value) {
				this._ref = value;
				this._dirty = true;
			}
		}, {
			key: "fail",
			get: function get() {
				return this._fail;
			},
			set: function set(value) {
				this._fail = value;
				this._dirty = true;
			}
		}, {
			key: "zfail",
			get: function get() {
				return this._zfail;
			},
			set: function set(value) {
				this._zfail = value;
				this._dirty = true;
			}
		}, {
			key: "zpass",
			get: function get() {
				return this._zpass;
			},
			set: function set(value) {
				this._zpass = value;
				this._dirty = true;
			}
		}, {
			key: "readMask",
			get: function get() {
				return this._readMask;
			},
			set: function set(value) {
				this._readMask = value;
				this._dirty = true;
			}
		}, {
			key: "writeMask",
			get: function get() {
				return this._writeMask;
			},
			set: function set(value) {
				this._writeMask = value;
				this._dirty = true;
			}
		}, {
			key: "key",
			get: function get() {
				if (this._dirty) {
					this._evalKey();
				}
				return this._key;
			}
		}]);
	}();
	_StencilParameters = StencilParameters;
	StencilParameters.DEFAULT = Object.freeze(new _StencilParameters());

	var GraphicsDevice = function (_EventHandler) {
		function GraphicsDevice(canvas, options) {
			var _this$initOptions, _this$initOptions$alp, _this$initOptions2, _this$initOptions2$de, _this$initOptions3, _this$initOptions3$st, _this$initOptions4, _this$initOptions4$an, _this$initOptions5, _this$initOptions5$po, _this$initOptions6, _this$initOptions6$di;
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.canvas = void 0;
			_this.backBuffer = null;
			_this.backBufferSize = new Vec2();
			_this.backBufferFormat = void 0;
			_this.backBufferAntialias = false;
			_this.isWebGPU = false;
			_this.isWebGL2 = false;
			_this.isHdr = false;
			_this.scope = void 0;
			_this.maxAnisotropy = void 0;
			_this.maxCubeMapSize = void 0;
			_this.maxTextureSize = void 0;
			_this.maxVolumeSize = void 0;
			_this.maxColorAttachments = 1;
			_this.precision = void 0;
			_this.samples = void 0;
			_this.maxSamples = 1;
			_this.supportsStencil = void 0;
			_this.supportsCompute = false;
			_this.supportsStorageTextureRead = false;
			_this.renderTarget = null;
			_this.shaders = [];
			_this.textures = [];
			_this.targets = new Set();
			_this.renderVersion = 0;
			_this.renderPassIndex = void 0;
			_this.insideRenderPass = false;
			_this.supportsUniformBuffers = false;
			_this.supportsClipDistances = false;
			_this.textureFloatRenderable = void 0;
			_this.textureHalfFloatRenderable = void 0;
			_this.textureRG11B10Renderable = false;
			_this.textureFloatFilterable = false;
			_this.quadVertexBuffer = void 0;
			_this.blendState = new BlendState();
			_this.depthState = new DepthState();
			_this.stencilEnabled = false;
			_this.stencilFront = new StencilParameters();
			_this.stencilBack = new StencilParameters();
			_this.dynamicBuffers = void 0;
			_this.gpuProfiler = void 0;
			_this.defaultClearOptions = {
				color: [0, 0, 0, 1],
				depth: 1,
				stencil: 0,
				flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
			};
			_this.clientRect = {
				width: 0,
				height: 0
			};
			_this.canvas = canvas;
			_this.initOptions = _extends({}, options);
			(_this$initOptions$alp = (_this$initOptions = _this.initOptions).alpha) != null ? _this$initOptions$alp : _this$initOptions.alpha = true;
			(_this$initOptions2$de = (_this$initOptions2 = _this.initOptions).depth) != null ? _this$initOptions2$de : _this$initOptions2.depth = true;
			(_this$initOptions3$st = (_this$initOptions3 = _this.initOptions).stencil) != null ? _this$initOptions3$st : _this$initOptions3.stencil = true;
			(_this$initOptions4$an = (_this$initOptions4 = _this.initOptions).antialias) != null ? _this$initOptions4$an : _this$initOptions4.antialias = true;
			(_this$initOptions5$po = (_this$initOptions5 = _this.initOptions).powerPreference) != null ? _this$initOptions5$po : _this$initOptions5.powerPreference = 'high-performance';
			(_this$initOptions6$di = (_this$initOptions6 = _this.initOptions).displayFormat) != null ? _this$initOptions6$di : _this$initOptions6.displayFormat = DISPLAYFORMAT_LDR;
			_this._maxPixelRatio = platform.browser ? Math.min(1, window.devicePixelRatio) : 1;
			_this.buffers = [];
			_this._vram = {
				tex: 0,
				vb: 0,
				ib: 0,
				ub: 0,
				sb: 0
			};
			_this._shaderStats = {
				vsCompiled: 0,
				fsCompiled: 0,
				linked: 0,
				materialShaders: 0,
				compileTime: 0
			};
			_this.initializeContextCaches();
			_this._drawCallsPerFrame = 0;
			_this._shaderSwitchesPerFrame = 0;
			_this._primsPerFrame = [];
			for (var i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
				_this._primsPerFrame[i] = 0;
			}
			_this._renderTargetCreationTime = 0;
			_this.scope = new ScopeSpace('Device');
			_this.textureBias = _this.scope.resolve('textureBias');
			_this.textureBias.setValue(0.0);
			return _this;
		}
		_inheritsLoose(GraphicsDevice, _EventHandler);
		var _proto = GraphicsDevice.prototype;
		_proto.postInit = function postInit() {
			var vertexFormat = new VertexFormat(this, [{
				semantic: SEMANTIC_POSITION,
				components: 2,
				type: TYPE_FLOAT32
			}]);
			var positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
			this.quadVertexBuffer = new VertexBuffer(this, vertexFormat, 4, {
				data: positions
			});
		};
		_proto.destroy = function destroy() {
			var _this$quadVertexBuffe, _this$dynamicBuffers, _this$gpuProfiler;
			this.fire('destroy');
			(_this$quadVertexBuffe = this.quadVertexBuffer) == null || _this$quadVertexBuffe.destroy();
			this.quadVertexBuffer = null;
			(_this$dynamicBuffers = this.dynamicBuffers) == null || _this$dynamicBuffers.destroy();
			this.dynamicBuffers = null;
			(_this$gpuProfiler = this.gpuProfiler) == null || _this$gpuProfiler.destroy();
			this.gpuProfiler = null;
		};
		_proto.onDestroyShader = function onDestroyShader(shader) {
			this.fire('destroy:shader', shader);
			var idx = this.shaders.indexOf(shader);
			if (idx !== -1) {
				this.shaders.splice(idx, 1);
			}
		};
		_proto.postDestroy = function postDestroy() {
			this.scope = null;
			this.canvas = null;
		};
		_proto.loseContext = function loseContext() {
			var _this$gpuProfiler2;
			this.contextLost = true;
			this.backBufferSize.set(-1, -1);
			for (var _iterator = _createForOfIteratorHelperLoose(this.textures), _step; !(_step = _iterator()).done;) {
				var texture = _step.value;
				texture.loseContext();
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(this.buffers), _step2; !(_step2 = _iterator2()).done;) {
				var buffer = _step2.value;
				buffer.loseContext();
			}
			for (var _iterator3 = _createForOfIteratorHelperLoose(this.targets), _step3; !(_step3 = _iterator3()).done;) {
				var target = _step3.value;
				target.loseContext();
			}
			(_this$gpuProfiler2 = this.gpuProfiler) == null || _this$gpuProfiler2.loseContext();
		};
		_proto.restoreContext = function restoreContext() {
			var _this$gpuProfiler3;
			this.contextLost = false;
			this.initializeRenderState();
			this.initializeContextCaches();
			for (var _iterator4 = _createForOfIteratorHelperLoose(this.buffers), _step4; !(_step4 = _iterator4()).done;) {
				var buffer = _step4.value;
				buffer.unlock();
			}
			(_this$gpuProfiler3 = this.gpuProfiler) == null || _this$gpuProfiler3.restoreContext == null || _this$gpuProfiler3.restoreContext();
		};
		_proto.toJSON = function toJSON(key) {
			return undefined;
		};
		_proto.initializeContextCaches = function initializeContextCaches() {
			this.indexBuffer = null;
			this.vertexBuffers = [];
			this.shader = null;
			this.shaderValid = undefined;
			this.shaderAsyncCompile = false;
			this.renderTarget = null;
		};
		_proto.initializeRenderState = function initializeRenderState() {
			this.blendState = new BlendState();
			this.depthState = new DepthState();
			this.cullMode = CULLFACE_BACK;
			this.vx = this.vy = this.vw = this.vh = 0;
			this.sx = this.sy = this.sw = this.sh = 0;
			this.blendColor = new Color(0, 0, 0, 0);
		};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {};
		_proto.setBlendState = function setBlendState(blendState) {};
		_proto.setBlendColor = function setBlendColor(r, g, b, a) {};
		_proto.setDepthState = function setDepthState(depthState) {};
		_proto.setCullMode = function setCullMode(cullMode) {};
		_proto.setRenderTarget = function setRenderTarget(renderTarget) {
			this.renderTarget = renderTarget;
		};
		_proto.setIndexBuffer = function setIndexBuffer(indexBuffer) {
			this.indexBuffer = indexBuffer;
		};
		_proto.setVertexBuffer = function setVertexBuffer(vertexBuffer) {
			if (vertexBuffer) {
				this.vertexBuffers.push(vertexBuffer);
			}
		};
		_proto.clearVertexBuffer = function clearVertexBuffer() {
			this.vertexBuffers.length = 0;
		};
		_proto.getRenderTarget = function getRenderTarget() {
			return this.renderTarget;
		};
		_proto.initRenderTarget = function initRenderTarget(target) {
			if (target.initialized) return;
			target.init();
			this.targets.add(target);
		};
		_proto._isBrowserInterface = function _isBrowserInterface(texture) {
			return this._isImageBrowserInterface(texture) || this._isImageCanvasInterface(texture) || this._isImageVideoInterface(texture);
		};
		_proto._isImageBrowserInterface = function _isImageBrowserInterface(texture) {
			return typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement;
		};
		_proto._isImageCanvasInterface = function _isImageCanvasInterface(texture) {
			return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement;
		};
		_proto._isImageVideoInterface = function _isImageVideoInterface(texture) {
			return typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement;
		};
		_proto.resizeCanvas = function resizeCanvas(width, height) {
			var pixelRatio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
			var w = Math.floor(width * pixelRatio);
			var h = Math.floor(height * pixelRatio);
			if (w !== this.canvas.width || h !== this.canvas.height) {
				this.setResolution(w, h);
			}
		};
		_proto.setResolution = function setResolution(width, height) {
			this.canvas.width = width;
			this.canvas.height = height;
			this.fire(GraphicsDevice.EVENT_RESIZE, width, height);
		};
		_proto.updateClientRect = function updateClientRect() {
			if (platform.worker) {
				this.clientRect.width = this.canvas.width;
				this.clientRect.height = this.canvas.height;
			} else {
				var rect = this.canvas.getBoundingClientRect();
				this.clientRect.width = rect.width;
				this.clientRect.height = rect.height;
			}
		};
		_proto.startRenderPass = function startRenderPass(renderPass) {};
		_proto.endRenderPass = function endRenderPass(renderPass) {};
		_proto.startComputePass = function startComputePass(name) {};
		_proto.endComputePass = function endComputePass() {};
		_proto.frameStart = function frameStart() {
			this.renderPassIndex = 0;
			this.renderVersion++;
		};
		_proto.frameEnd = function frameEnd() {};
		_proto.computeDispatch = function computeDispatch(computes, name) {
		};
		_proto.getRenderableHdrFormat = function getRenderableHdrFormat(formats, filterable, samples) {
			if (formats === void 0) {
				formats = [PIXELFORMAT_111110F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F];
			}
			if (filterable === void 0) {
				filterable = true;
			}
			if (samples === void 0) {
				samples = 1;
			}
			for (var i = 0; i < formats.length; i++) {
				var format = formats[i];
				switch (format) {
					case PIXELFORMAT_111110F:
						{
							if (this.textureRG11B10Renderable) {
								return format;
							}
							break;
						}
					case PIXELFORMAT_RGBA16F:
						if (this.textureHalfFloatRenderable) {
							return format;
						}
						break;
					case PIXELFORMAT_RGBA32F:
						if (this.isWebGPU && samples > 1) {
							continue;
						}
						if (this.textureFloatRenderable && (!filterable || this.textureFloatFilterable)) {
							return format;
						}
						break;
				}
			}
			return undefined;
		};
		return _createClass(GraphicsDevice, [{
			key: "width",
			get: function get() {
				return this.canvas.width;
			}
		}, {
			key: "height",
			get: function get() {
				return this.canvas.height;
			}
		}, {
			key: "fullscreen",
			get: function get() {
				return false;
			},
			set: function set(fullscreen) {}
		}, {
			key: "maxPixelRatio",
			get: function get() {
				return this._maxPixelRatio;
			},
			set: function set(ratio) {
				this._maxPixelRatio = ratio;
			}
		}, {
			key: "deviceType",
			get: function get() {
				return this._deviceType;
			}
		}]);
	}(EventHandler);
	GraphicsDevice.EVENT_RESIZE = 'resizecanvas';

	var id$7 = 0;
	var RenderTarget = function () {
		function RenderTarget(options) {
			var _ref, _ref2, _options$colorBuffer$, _options$colorBuffer, _options$colorBuffers, _options$depthBuffer, _options$samples, _options$face, _options$autoResolve, _options$flipY, _options$mipLevel;
			if (options === void 0) {
				options = {};
			}
			this.name = void 0;
			this._device = void 0;
			this._colorBuffer = void 0;
			this._colorBuffers = void 0;
			this._depthBuffer = void 0;
			this._depth = void 0;
			this._stencil = void 0;
			this._samples = void 0;
			this.autoResolve = void 0;
			this._face = void 0;
			this._mipLevel = void 0;
			this._mipmaps = void 0;
			this.flipY = void 0;
			this.id = id$7++;
			var device = (_ref = (_ref2 = (_options$colorBuffer$ = (_options$colorBuffer = options.colorBuffer) == null ? void 0 : _options$colorBuffer.device) != null ? _options$colorBuffer$ : (_options$colorBuffers = options.colorBuffers) == null ? void 0 : _options$colorBuffers[0].device) != null ? _ref2 : (_options$depthBuffer = options.depthBuffer) == null ? void 0 : _options$depthBuffer.device) != null ? _ref : options.graphicsDevice;
			this._device = device;
			var maxSamples = this._device.maxSamples;
			this._samples = Math.min((_options$samples = options.samples) != null ? _options$samples : 1, maxSamples);
			if (device.isWebGPU) {
				this._samples = this._samples > 1 ? maxSamples : 1;
			}
			this._colorBuffer = options.colorBuffer;
			if (options.colorBuffer) {
				this._colorBuffers = [options.colorBuffer];
			}
			this._depthBuffer = options.depthBuffer;
			this._face = (_options$face = options.face) != null ? _options$face : 0;
			if (this._depthBuffer) {
				var format = this._depthBuffer._format;
				if (format === PIXELFORMAT_DEPTH || format === PIXELFORMAT_DEPTH16) {
					this._depth = true;
					this._stencil = false;
				} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
					this._depth = true;
					this._stencil = true;
				} else if (format === PIXELFORMAT_R32F && this._depthBuffer.device.isWebGPU && this._samples > 1) {
					this._depth = true;
					this._stencil = false;
				} else {
					this._depth = false;
					this._stencil = false;
				}
			} else {
				var _options$depth, _options$stencil;
				this._depth = (_options$depth = options.depth) != null ? _options$depth : true;
				this._stencil = (_options$stencil = options.stencil) != null ? _options$stencil : false;
			}
			if (options.colorBuffers) {
				if (!this._colorBuffers) {
					this._colorBuffers = [].concat(options.colorBuffers);
					this._colorBuffer = options.colorBuffers[0];
				}
			}
			this.autoResolve = (_options$autoResolve = options.autoResolve) != null ? _options$autoResolve : true;
			this.name = options.name;
			if (!this.name) {
				var _this$_colorBuffer;
				this.name = (_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.name;
			}
			if (!this.name) {
				var _this$_depthBuffer;
				this.name = (_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.name;
			}
			if (!this.name) {
				this.name = 'Untitled';
			}
			this.flipY = (_options$flipY = options.flipY) != null ? _options$flipY : false;
			this._mipLevel = (_options$mipLevel = options.mipLevel) != null ? _options$mipLevel : 0;
			if (this._mipLevel > 0 && this._depth) {
				this._mipLevel = 0;
			}
			this._mipmaps = options.mipLevel === undefined;
			this.validateMrt();
			this.impl = device.createRenderTargetImpl(this);
		}
		var _proto = RenderTarget.prototype;
		_proto.destroy = function destroy() {
			var device = this._device;
			if (device) {
				device.targets.delete(this);
				if (device.renderTarget === this) {
					device.setRenderTarget(null);
				}
				this.destroyFrameBuffers();
			}
		};
		_proto.destroyFrameBuffers = function destroyFrameBuffers() {
			var device = this._device;
			if (device) {
				this.impl.destroy(device);
			}
		};
		_proto.destroyTextureBuffers = function destroyTextureBuffers() {
			var _this$_depthBuffer2, _this$_colorBuffers;
			(_this$_depthBuffer2 = this._depthBuffer) == null || _this$_depthBuffer2.destroy();
			this._depthBuffer = null;
			(_this$_colorBuffers = this._colorBuffers) == null || _this$_colorBuffers.forEach(function (colorBuffer) {
				colorBuffer.destroy();
			});
			this._colorBuffers = null;
			this._colorBuffer = null;
		};
		_proto.resize = function resize(width, height) {
			if (this.width !== width || this.height !== height) {
				var _this$_depthBuffer3, _this$_colorBuffers2;
				if (this.mipLevel > 0) {
					return;
				}
				var device = this._device;
				this.destroyFrameBuffers();
				if (device.renderTarget === this) {
					device.setRenderTarget(null);
				}
				(_this$_depthBuffer3 = this._depthBuffer) == null || _this$_depthBuffer3.resize(width, height);
				(_this$_colorBuffers2 = this._colorBuffers) == null || _this$_colorBuffers2.forEach(function (colorBuffer) {
					colorBuffer.resize(width, height);
				});
				this.validateMrt();
				this.impl = device.createRenderTargetImpl(this);
			}
		};
		_proto.validateMrt = function validateMrt() {};
		_proto.init = function init() {
			this.impl.init(this._device, this);
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};
		_proto.resolve = function resolve(color, depth) {
			if (color === void 0) {
				color = true;
			}
			if (depth === void 0) {
				depth = !!this._depthBuffer;
			}
			if (this._device && this._samples > 1) {
				this.impl.resolve(this._device, this, color, depth);
			}
		};
		_proto.copy = function copy(source, color, depth) {
			if (!this._device) {
				if (source._device) {
					this._device = source._device;
				} else {
					return false;
				}
			}
			var success = this._device.copyRenderTarget(source, this, color, depth);
			return success;
		};
		_proto.getColorBuffer = function getColorBuffer(index) {
			var _this$_colorBuffers3;
			return (_this$_colorBuffers3 = this._colorBuffers) == null ? void 0 : _this$_colorBuffers3[index];
		};
		_proto.isColorBufferSrgb = function isColorBufferSrgb(index) {
			if (index === void 0) {
				index = 0;
			}
			if (this.device.backBuffer === this) {
				return isSrgbPixelFormat(this.device.backBufferFormat);
			}
			var colorBuffer = this.getColorBuffer(index);
			return colorBuffer ? isSrgbPixelFormat(colorBuffer.format) : false;
		};
		return _createClass(RenderTarget, [{
			key: "initialized",
			get: function get() {
				return this.impl.initialized;
			}
		}, {
			key: "device",
			get: function get() {
				return this._device;
			}
		}, {
			key: "samples",
			get: function get() {
				return this._samples;
			}
		}, {
			key: "depth",
			get: function get() {
				return this._depth;
			}
		}, {
			key: "stencil",
			get: function get() {
				return this._stencil;
			}
		}, {
			key: "colorBuffer",
			get: function get() {
				return this._colorBuffer;
			}
		}, {
			key: "depthBuffer",
			get: function get() {
				return this._depthBuffer;
			}
		}, {
			key: "face",
			get: function get() {
				return this._face;
			}
		}, {
			key: "mipLevel",
			get: function get() {
				return this._mipLevel;
			}
		}, {
			key: "mipmaps",
			get: function get() {
				return this._mipmaps;
			}
		}, {
			key: "width",
			get: function get() {
				var _this$_colorBuffer2, _this$_depthBuffer4;
				var width = ((_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.width) || ((_this$_depthBuffer4 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer4.width) || this._device.width;
				if (this._mipLevel > 0) {
					width = TextureUtils.calcLevelDimension(width, this._mipLevel);
				}
				return width;
			}
		}, {
			key: "height",
			get: function get() {
				var _this$_colorBuffer3, _this$_depthBuffer5;
				var height = ((_this$_colorBuffer3 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer3.height) || ((_this$_depthBuffer5 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer5.height) || this._device.height;
				if (this._mipLevel > 0) {
					height = TextureUtils.calcLevelDimension(height, this._mipLevel);
				}
				return height;
			}
		}]);
	}();

	var WebgpuBindGroup = function () {
		function WebgpuBindGroup() {
			this.bindGroup = void 0;
		}
		var _proto = WebgpuBindGroup.prototype;
		_proto.update = function update(bindGroup) {
			this.destroy();
			var device = bindGroup.device;
			var desc = this.createDescriptor(device, bindGroup);
			this.bindGroup = device.wgpu.createBindGroup(desc);
		};
		_proto.destroy = function destroy() {
			this.bindGroup = null;
		};
		_proto.createDescriptor = function createDescriptor(device, bindGroup) {
			var entries = [];
			var format = bindGroup.format;
			var uniformBufferFormats = bindGroup.format.uniformBufferFormats;
			bindGroup.uniformBuffers.forEach(function (ub, i) {
				var slot = uniformBufferFormats[i].slot;
				var buffer = ub.persistent ? ub.impl.buffer : ub.allocation.gpuBuffer.buffer;
				entries.push({
					binding: slot,
					resource: {
						buffer: buffer,
						offset: 0,
						size: ub.format.byteSize
					}
				});
			});
			var textureFormats = bindGroup.format.textureFormats;
			bindGroup.textures.forEach(function (tex, textureIndex) {
				var wgpuTexture = tex.impl;
				var textureFormat = format.textureFormats[textureIndex];
				var slot = textureFormats[textureIndex].slot;
				var view = wgpuTexture.getView(device);
				entries.push({
					binding: slot,
					resource: view
				});
				if (textureFormat.hasSampler) {
					var sampler = wgpuTexture.getSampler(device, textureFormat.sampleType);
					entries.push({
						binding: slot + 1,
						resource: sampler
					});
				}
			});
			var storageTextureFormats = bindGroup.format.storageTextureFormats;
			bindGroup.storageTextures.forEach(function (tex, textureIndex) {
				var wgpuTexture = tex.impl;
				var slot = storageTextureFormats[textureIndex].slot;
				var view = wgpuTexture.getView(device);
				entries.push({
					binding: slot,
					resource: view
				});
			});
			var storageBufferFormats = bindGroup.format.storageBufferFormats;
			bindGroup.storageBuffers.forEach(function (buffer, bufferIndex) {
				var wgpuBuffer = buffer.impl.buffer;
				var slot = storageBufferFormats[bufferIndex].slot;
				entries.push({
					binding: slot,
					resource: {
						buffer: wgpuBuffer
					}
				});
			});
			var desc = {
				layout: bindGroup.format.impl.bindGroupLayout,
				entries: entries
			};
			return desc;
		};
		return WebgpuBindGroup;
	}();

	var WebgpuUtils = function () {
		function WebgpuUtils() {}
		WebgpuUtils.shaderStage = function shaderStage(stage) {
			var ret = 0;
			if (stage & SHADERSTAGE_VERTEX) ret |= GPUShaderStage.VERTEX;
			if (stage & SHADERSTAGE_FRAGMENT) ret |= GPUShaderStage.FRAGMENT;
			if (stage & SHADERSTAGE_COMPUTE) ret |= GPUShaderStage.COMPUTE;
			return ret;
		};
		return WebgpuUtils;
	}();

	var gpuTextureFormats = [];
	gpuTextureFormats[PIXELFORMAT_A8] = '';
	gpuTextureFormats[PIXELFORMAT_L8] = '';
	gpuTextureFormats[PIXELFORMAT_LA8] = '';
	gpuTextureFormats[PIXELFORMAT_R8] = 'r8unorm';
	gpuTextureFormats[PIXELFORMAT_RG8] = 'rg8unorm';
	gpuTextureFormats[PIXELFORMAT_RGB565] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA5551] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA4] = '';
	gpuTextureFormats[PIXELFORMAT_RGB8] = 'rgba8unorm';
	gpuTextureFormats[PIXELFORMAT_RGBA8] = 'rgba8unorm';
	gpuTextureFormats[PIXELFORMAT_DXT1] = 'bc1-rgba-unorm';
	gpuTextureFormats[PIXELFORMAT_DXT3] = 'bc2-rgba-unorm';
	gpuTextureFormats[PIXELFORMAT_DXT5] = 'bc3-rgba-unorm';
	gpuTextureFormats[PIXELFORMAT_RGB16F] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA16F] = 'rgba16float';
	gpuTextureFormats[PIXELFORMAT_R16F] = 'r16float';
	gpuTextureFormats[PIXELFORMAT_RG16F] = 'rg16float';
	gpuTextureFormats[PIXELFORMAT_RGB32F] = '';
	gpuTextureFormats[PIXELFORMAT_RGBA32F] = 'rgba32float';
	gpuTextureFormats[PIXELFORMAT_R32F] = 'r32float';
	gpuTextureFormats[PIXELFORMAT_DEPTH] = 'depth32float';
	gpuTextureFormats[PIXELFORMAT_DEPTH16] = 'depth16unorm';
	gpuTextureFormats[PIXELFORMAT_DEPTHSTENCIL] = 'depth24plus-stencil8';
	gpuTextureFormats[PIXELFORMAT_111110F] = 'rg11b10ufloat';
	gpuTextureFormats[PIXELFORMAT_SRGB8] = '';
	gpuTextureFormats[PIXELFORMAT_SRGBA8] = 'rgba8unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_ETC1] = '';
	gpuTextureFormats[PIXELFORMAT_ETC2_RGB] = 'etc2-rgb8unorm';
	gpuTextureFormats[PIXELFORMAT_ETC2_RGBA] = 'etc2-rgba8unorm';
	gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGB_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGB_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = '';
	gpuTextureFormats[PIXELFORMAT_ASTC_4x4] = 'astc-4x4-unorm';
	gpuTextureFormats[PIXELFORMAT_ATC_RGB] = '';
	gpuTextureFormats[PIXELFORMAT_ATC_RGBA] = '';
	gpuTextureFormats[PIXELFORMAT_BGRA8] = 'bgra8unorm';
	gpuTextureFormats[PIXELFORMAT_SBGRA8] = 'bgra8unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_R8I] = 'r8sint';
	gpuTextureFormats[PIXELFORMAT_R8U] = 'r8uint';
	gpuTextureFormats[PIXELFORMAT_R16I] = 'r16sint';
	gpuTextureFormats[PIXELFORMAT_R16U] = 'r16uint';
	gpuTextureFormats[PIXELFORMAT_R32I] = 'r32sint';
	gpuTextureFormats[PIXELFORMAT_R32U] = 'r32uint';
	gpuTextureFormats[PIXELFORMAT_RG8I] = 'rg8sint';
	gpuTextureFormats[PIXELFORMAT_RG8U] = 'rg8uint';
	gpuTextureFormats[PIXELFORMAT_RG16I] = 'rg16sint';
	gpuTextureFormats[PIXELFORMAT_RG16U] = 'rg16uint';
	gpuTextureFormats[PIXELFORMAT_RG32I] = 'rg32sint';
	gpuTextureFormats[PIXELFORMAT_RG32U] = 'rg32uint';
	gpuTextureFormats[PIXELFORMAT_RGBA8I] = 'rgba8sint';
	gpuTextureFormats[PIXELFORMAT_RGBA8U] = 'rgba8uint';
	gpuTextureFormats[PIXELFORMAT_RGBA16I] = 'rgba16sint';
	gpuTextureFormats[PIXELFORMAT_RGBA16U] = 'rgba16uint';
	gpuTextureFormats[PIXELFORMAT_RGBA32I] = 'rgba32sint';
	gpuTextureFormats[PIXELFORMAT_RGBA32U] = 'rgba32uint';
	gpuTextureFormats[PIXELFORMAT_BC6F] = 'bc6h-rgb-float';
	gpuTextureFormats[PIXELFORMAT_BC6UF] = 'bc6h-rgb-ufloat';
	gpuTextureFormats[PIXELFORMAT_BC7] = 'bc7-rgba-unorm';
	gpuTextureFormats[PIXELFORMAT_DXT1_SRGB] = 'bc1-rgba-unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_DXT3_SRGBA] = 'bc2-rgba-unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_DXT5_SRGBA] = 'bc3-rgba-unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_SRGB_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_SRGBA_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_SRGB_1] = '';
	gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_SRGBA_1] = '';
	gpuTextureFormats[PIXELFORMAT_ETC2_SRGB] = 'etc2-rgb8unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_ETC2_SRGBA] = 'etc2-rgba8unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_BC7_SRGBA] = 'bc7-rgba-unorm-srgb';
	gpuTextureFormats[PIXELFORMAT_ASTC_4x4_SRGB] = 'astc-4x4-unorm-srgb';

	var samplerTypes = [];
	samplerTypes[SAMPLETYPE_FLOAT] = 'filtering';
	samplerTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'non-filtering';
	samplerTypes[SAMPLETYPE_DEPTH] = 'comparison';
	samplerTypes[SAMPLETYPE_INT] = 'comparison';
	samplerTypes[SAMPLETYPE_UINT] = 'comparison';
	var sampleTypes = [];
	sampleTypes[SAMPLETYPE_FLOAT] = 'float';
	sampleTypes[SAMPLETYPE_UNFILTERABLE_FLOAT] = 'unfilterable-float';
	sampleTypes[SAMPLETYPE_DEPTH] = 'depth';
	sampleTypes[SAMPLETYPE_INT] = 'sint';
	sampleTypes[SAMPLETYPE_UINT] = 'uint';
	var stringIds$1 = new StringIds();
	var WebgpuBindGroupFormat = function () {
		function WebgpuBindGroupFormat(bindGroupFormat) {
			var device = bindGroupFormat.device;
			var _this$createDescripto = this.createDescriptor(bindGroupFormat),
				key = _this$createDescripto.key,
				desc = _this$createDescripto.desc;
			this.key = stringIds$1.get(key);
			this.bindGroupLayout = device.wgpu.createBindGroupLayout(desc);
		}
		var _proto = WebgpuBindGroupFormat.prototype;
		_proto.destroy = function destroy() {
			this.bindGroupLayout = null;
		};
		_proto.loseContext = function loseContext() {};
		_proto.createDescriptor = function createDescriptor(bindGroupFormat) {
			var entries = [];
			var key = '';
			bindGroupFormat.uniformBufferFormats.forEach(function (bufferFormat) {
				var visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
				key += "#" + bufferFormat.slot + "U:" + visibility;
				entries.push({
					binding: bufferFormat.slot,
					visibility: visibility,
					buffer: {
						type: 'uniform',
						hasDynamicOffset: true
					}
				});
			});
			bindGroupFormat.textureFormats.forEach(function (textureFormat) {
				var visibility = WebgpuUtils.shaderStage(textureFormat.visibility);
				var sampleType = textureFormat.sampleType;
				var viewDimension = textureFormat.textureDimension;
				var multisampled = false;
				var gpuSampleType = sampleTypes[sampleType];
				key += "#" + textureFormat.slot + "T:" + visibility + "-" + gpuSampleType + "-" + viewDimension + "-" + multisampled;
				entries.push({
					binding: textureFormat.slot,
					visibility: visibility,
					texture: {
						sampleType: gpuSampleType,
						viewDimension: viewDimension,
						multisampled: multisampled
					}
				});
				if (textureFormat.hasSampler) {
					var gpuSamplerType = samplerTypes[sampleType];
					key += "#" + (textureFormat.slot + 1) + "S:" + visibility + "-" + gpuSamplerType;
					entries.push({
						binding: textureFormat.slot + 1,
						visibility: visibility,
						sampler: {
							type: gpuSamplerType
						}
					});
				}
			});
			bindGroupFormat.storageTextureFormats.forEach(function (textureFormat) {
				var format = textureFormat.format,
					textureDimension = textureFormat.textureDimension;
				var read = textureFormat.read,
					write = textureFormat.write;
				key += "#" + textureFormat.slot + "ST:" + format + "-" + textureDimension + "-" + (read ? 'r1' : 'r0') + "-" + (write ? 'w1' : 'w0');
				entries.push({
					binding: textureFormat.slot,
					visibility: GPUShaderStage.COMPUTE,
					storageTexture: {
						access: read ? write ? 'read-write' : 'read-only' : 'write-only',
						format: gpuTextureFormats[format],
						viewDimension: textureDimension
					}
				});
			});
			bindGroupFormat.storageBufferFormats.forEach(function (bufferFormat) {
				var readOnly = bufferFormat.readOnly;
				var visibility = WebgpuUtils.shaderStage(bufferFormat.visibility);
				key += "#" + bufferFormat.slot + "SB:" + visibility + "-" + (readOnly ? 'ro' : 'rw');
				entries.push({
					binding: bufferFormat.slot,
					visibility: visibility,
					buffer: {
						type: readOnly ? 'read-only-storage' : 'storage'
					}
				});
			});
			var desc = {
				entries: entries
			};
			return {
				key: key,
				desc: desc
			};
		};
		return WebgpuBindGroupFormat;
	}();

	var WebgpuBuffer = function () {
		function WebgpuBuffer(usageFlags) {
			if (usageFlags === void 0) {
				usageFlags = 0;
			}
			this.buffer = null;
			this.usageFlags = 0;
			this.usageFlags = usageFlags;
		}
		var _proto = WebgpuBuffer.prototype;
		_proto.destroy = function destroy(device) {
			if (this.buffer) {
				this.buffer.destroy();
				this.buffer = null;
			}
		};
		_proto.loseContext = function loseContext() {};
		_proto.allocate = function allocate(device, size) {
			this.buffer = device.wgpu.createBuffer({
				size: size,
				usage: this.usageFlags
			});
		};
		_proto.unlock = function unlock(device, storage) {
			var _storage$byteOffset, _storage$buffer;
			var wgpu = device.wgpu;
			if (!this.buffer) {
				var size = storage.byteLength + 3 & ~3;
				this.usageFlags |= GPUBufferUsage.COPY_DST;
				this.allocate(device, size);
			}
			var srcOffset = (_storage$byteOffset = storage.byteOffset) != null ? _storage$byteOffset : 0;
			var srcData = new Uint8Array((_storage$buffer = storage.buffer) != null ? _storage$buffer : storage, srcOffset, storage.byteLength);
			var data = new Uint8Array(this.buffer.size);
			data.set(srcData);
			wgpu.queue.writeBuffer(this.buffer, 0, data, 0, data.length);
		};
		_proto.read = function read(device, offset, size, data) {
			return device.readStorageBuffer(this, offset, size, data);
		};
		_proto.write = function write(device, bufferOffset, data, dataOffset, size) {
			device.writeStorageBuffer(this, bufferOffset, data, dataOffset, size);
		};
		_proto.clear = function clear(device, offset, size) {
			device.clearStorageBuffer(this, offset, size);
		};
		return _createClass(WebgpuBuffer, [{
			key: "initialized",
			get: function get() {
				return !!this.buffer;
			}
		}]);
	}();

	var WebgpuIndexBuffer = function (_WebgpuBuffer) {
		function WebgpuIndexBuffer(indexBuffer, options) {
			var _this;
			_this = _WebgpuBuffer.call(this, BUFFERUSAGE_INDEX | (options != null && options.storage ? BUFFERUSAGE_STORAGE : 0)) || this;
			_this.format = null;
			_this.format = indexBuffer.format === INDEXFORMAT_UINT16 ? 'uint16' : 'uint32';
			return _this;
		}
		_inheritsLoose(WebgpuIndexBuffer, _WebgpuBuffer);
		var _proto = WebgpuIndexBuffer.prototype;
		_proto.unlock = function unlock(indexBuffer) {
			var device = indexBuffer.device;
			_WebgpuBuffer.prototype.unlock.call(this, device, indexBuffer.storage);
		};
		return WebgpuIndexBuffer;
	}(WebgpuBuffer);

	var array = {
		equals: function equals(arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}
	};

	var gpuVertexFormats = [];
	gpuVertexFormats[TYPE_INT8] = 'sint8';
	gpuVertexFormats[TYPE_UINT8] = 'uint8';
	gpuVertexFormats[TYPE_INT16] = 'sint16';
	gpuVertexFormats[TYPE_UINT16] = 'uint16';
	gpuVertexFormats[TYPE_INT32] = 'sint32';
	gpuVertexFormats[TYPE_UINT32] = 'uint32';
	gpuVertexFormats[TYPE_FLOAT32] = 'float32';
	gpuVertexFormats[TYPE_FLOAT16] = 'float16';
	var gpuVertexFormatsNormalized = [];
	gpuVertexFormatsNormalized[TYPE_INT8] = 'snorm8';
	gpuVertexFormatsNormalized[TYPE_UINT8] = 'unorm8';
	gpuVertexFormatsNormalized[TYPE_INT16] = 'snorm16';
	gpuVertexFormatsNormalized[TYPE_UINT16] = 'unorm16';
	gpuVertexFormatsNormalized[TYPE_INT32] = 'sint32';
	gpuVertexFormatsNormalized[TYPE_UINT32] = 'uint32';
	gpuVertexFormatsNormalized[TYPE_FLOAT32] = 'float32';
	gpuVertexFormatsNormalized[TYPE_FLOAT16] = 'float16';
	var WebgpuVertexBufferLayout = function () {
		function WebgpuVertexBufferLayout() {
			this.cache = new Map();
		}
		var _proto = WebgpuVertexBufferLayout.prototype;
		_proto.get = function get(vertexFormat0, vertexFormat1) {
			if (vertexFormat1 === void 0) {
				vertexFormat1 = null;
			}
			var key = this.getKey(vertexFormat0, vertexFormat1);
			var layout = this.cache.get(key);
			if (!layout) {
				layout = this.create(vertexFormat0, vertexFormat1);
				this.cache.set(key, layout);
			}
			return layout;
		};
		_proto.getKey = function getKey(vertexFormat0, vertexFormat1) {
			var _vertexFormat;
			if (vertexFormat1 === void 0) {
				vertexFormat1 = null;
			}
			return (vertexFormat0 == null ? void 0 : vertexFormat0.renderingHashString) + "-" + ((_vertexFormat = vertexFormat1) == null ? void 0 : _vertexFormat.renderingHashString);
		};
		_proto.create = function create(vertexFormat0, vertexFormat1) {
			var layout = [];
			var addFormat = function addFormat(format) {
				var interleaved = format.interleaved;
				var stepMode = format.instancing ? 'instance' : 'vertex';
				var attributes = [];
				var elementCount = format.elements.length;
				for (var i = 0; i < elementCount; i++) {
					var element = format.elements[i];
					var location = semanticToLocation[element.name];
					var formatTable = element.normalize ? gpuVertexFormatsNormalized : gpuVertexFormats;
					attributes.push({
						shaderLocation: location,
						offset: interleaved ? element.offset : 0,
						format: "" + formatTable[element.dataType] + (element.numComponents > 1 ? "x" + element.numComponents : '')
					});
					if (!interleaved || i === elementCount - 1) {
						layout.push({
							attributes: attributes,
							arrayStride: element.stride,
							stepMode: stepMode
						});
						attributes = [];
					}
				}
			};
			if (vertexFormat0) {
				addFormat(vertexFormat0);
			}
			if (vertexFormat1) {
				addFormat(vertexFormat1);
			}
			return layout;
		};
		return WebgpuVertexBufferLayout;
	}();

	var WebgpuPipeline = function () {
		function WebgpuPipeline(device) {
			this.device = device;
		}
		var _proto = WebgpuPipeline.prototype;
		_proto.getPipelineLayout = function getPipelineLayout(bindGroupFormats) {
			var bindGroupLayouts = [];
			bindGroupFormats.forEach(function (format) {
				bindGroupLayouts.push(format.bindGroupLayout);
			});
			var desc = {
				bindGroupLayouts: bindGroupLayouts
			};
			var pipelineLayout = this.device.wgpu.createPipelineLayout(desc);
			return pipelineLayout;
		};
		return WebgpuPipeline;
	}();

	var _primitiveTopology = ['point-list', 'line-list', undefined, 'line-strip', 'triangle-list', 'triangle-strip', undefined];
	var _blendOperation = ['add', 'subtract', 'reverse-subtract', 'min', 'max'];
	var _blendFactor = ['zero', 'one', 'src', 'one-minus-src', 'dst', 'one-minus-dst', 'src-alpha', 'src-alpha-saturated', 'one-minus-src-alpha', 'dst-alpha', 'one-minus-dst-alpha', 'constant', 'one-minus-constant'];
	var _compareFunction = ['never', 'less', 'equal', 'less-equal', 'greater', 'not-equal', 'greater-equal', 'always'];
	var _cullModes = ['none', 'back', 'front'];
	var _stencilOps = ['keep', 'zero', 'replace', 'increment-clamp', 'increment-wrap', 'decrement-clamp', 'decrement-wrap', 'invert'];
	var CacheEntry = function CacheEntry() {
		this.pipeline = void 0;
		this.hashes = void 0;
	};
	var WebgpuRenderPipeline = function (_WebgpuPipeline) {
		function WebgpuRenderPipeline(device) {
			var _this;
			_this = _WebgpuPipeline.call(this, device) || this;
			_this.lookupHashes = new Uint32Array(13);
			_this.vertexBufferLayout = new WebgpuVertexBufferLayout();
			_this.cache = new Map();
			return _this;
		}
		_inheritsLoose(WebgpuRenderPipeline, _WebgpuPipeline);
		var _proto = WebgpuRenderPipeline.prototype;
		_proto.get = function get(primitive, vertexFormat0, vertexFormat1, shader, renderTarget, bindGroupFormats, blendState, depthState, cullMode, stencilEnabled, stencilFront, stencilBack) {
			var _vertexFormat0$render, _vertexFormat1$render, _bindGroupFormats$0$k, _bindGroupFormats$, _bindGroupFormats$1$k, _bindGroupFormats$2, _bindGroupFormats$2$k, _bindGroupFormats$3;
			var lookupHashes = this.lookupHashes;
			lookupHashes[0] = primitive.type;
			lookupHashes[1] = shader.id;
			lookupHashes[2] = cullMode;
			lookupHashes[3] = depthState.key;
			lookupHashes[4] = blendState.key;
			lookupHashes[5] = (_vertexFormat0$render = vertexFormat0 == null ? void 0 : vertexFormat0.renderingHash) != null ? _vertexFormat0$render : 0;
			lookupHashes[6] = (_vertexFormat1$render = vertexFormat1 == null ? void 0 : vertexFormat1.renderingHash) != null ? _vertexFormat1$render : 0;
			lookupHashes[7] = renderTarget.impl.key;
			lookupHashes[8] = (_bindGroupFormats$0$k = (_bindGroupFormats$ = bindGroupFormats[0]) == null ? void 0 : _bindGroupFormats$.key) != null ? _bindGroupFormats$0$k : 0;
			lookupHashes[9] = (_bindGroupFormats$1$k = (_bindGroupFormats$2 = bindGroupFormats[1]) == null ? void 0 : _bindGroupFormats$2.key) != null ? _bindGroupFormats$1$k : 0;
			lookupHashes[10] = (_bindGroupFormats$2$k = (_bindGroupFormats$3 = bindGroupFormats[2]) == null ? void 0 : _bindGroupFormats$3.key) != null ? _bindGroupFormats$2$k : 0;
			lookupHashes[11] = stencilEnabled ? stencilFront.key : 0;
			lookupHashes[12] = stencilEnabled ? stencilBack.key : 0;
			var hash = hash32Fnv1a(lookupHashes);
			var cacheEntries = this.cache.get(hash);
			if (cacheEntries) {
				for (var i = 0; i < cacheEntries.length; i++) {
					var entry = cacheEntries[i];
					if (array.equals(entry.hashes, lookupHashes)) {
						return entry.pipeline;
					}
				}
			}
			var primitiveTopology = _primitiveTopology[primitive.type];
			var pipelineLayout = this.getPipelineLayout(bindGroupFormats);
			var vertexBufferLayout = this.vertexBufferLayout.get(vertexFormat0, vertexFormat1);
			var cacheEntry = new CacheEntry();
			cacheEntry.hashes = new Uint32Array(lookupHashes);
			cacheEntry.pipeline = this.create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack);
			if (cacheEntries) {
				cacheEntries.push(cacheEntry);
			} else {
				cacheEntries = [cacheEntry];
			}
			this.cache.set(hash, cacheEntries);
			return cacheEntry.pipeline;
		};
		_proto.getBlend = function getBlend(blendState) {
			var blend;
			if (blendState.blend) {
				blend = {
					color: {
						operation: _blendOperation[blendState.colorOp],
						srcFactor: _blendFactor[blendState.colorSrcFactor],
						dstFactor: _blendFactor[blendState.colorDstFactor]
					},
					alpha: {
						operation: _blendOperation[blendState.alphaOp],
						srcFactor: _blendFactor[blendState.alphaSrcFactor],
						dstFactor: _blendFactor[blendState.alphaDstFactor]
					}
				};
			}
			return blend;
		};
		_proto.getDepthStencil = function getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack) {
			var depthStencil;
			var depth = renderTarget.depth,
				stencil = renderTarget.stencil;
			if (depth || stencil) {
				depthStencil = {
					format: renderTarget.impl.depthAttachment.format
				};
				if (depth) {
					depthStencil.depthWriteEnabled = depthState.write;
					depthStencil.depthCompare = _compareFunction[depthState.func];
					depthStencil.depthBias = depthState.depthBias;
					depthStencil.depthBiasSlopeScale = depthState.depthBiasSlope;
				} else {
					depthStencil.depthWriteEnabled = false;
					depthStencil.depthCompare = 'always';
				}
				if (stencil && stencilEnabled) {
					depthStencil.stencilReadMas = stencilFront.readMask;
					depthStencil.stencilWriteMask = stencilFront.writeMask;
					depthStencil.stencilFront = {
						compare: _compareFunction[stencilFront.func],
						failOp: _stencilOps[stencilFront.fail],
						passOp: _stencilOps[stencilFront.zpass],
						depthFailOp: _stencilOps[stencilFront.zfail]
					};
					depthStencil.stencilBack = {
						compare: _compareFunction[stencilBack.func],
						failOp: _stencilOps[stencilBack.fail],
						passOp: _stencilOps[stencilBack.zpass],
						depthFailOp: _stencilOps[stencilBack.zfail]
					};
				}
			}
			return depthStencil;
		};
		_proto.create = function create(primitiveTopology, shader, renderTarget, pipelineLayout, blendState, depthState, vertexBufferLayout, cullMode, stencilEnabled, stencilFront, stencilBack) {
			var wgpu = this.device.wgpu;
			var webgpuShader = shader.impl;
			var desc = {
				vertex: {
					module: webgpuShader.getVertexShaderModule(),
					entryPoint: webgpuShader.vertexEntryPoint,
					buffers: vertexBufferLayout
				},
				primitive: {
					topology: primitiveTopology,
					frontFace: 'ccw',
					cullMode: _cullModes[cullMode]
				},
				depthStencil: this.getDepthStencil(depthState, renderTarget, stencilEnabled, stencilFront, stencilBack),
				multisample: {
					count: renderTarget.samples
				},
				layout: pipelineLayout
			};
			desc.fragment = {
				module: webgpuShader.getFragmentShaderModule(),
				entryPoint: webgpuShader.fragmentEntryPoint,
				targets: []
			};
			var colorAttachments = renderTarget.impl.colorAttachments;
			if (colorAttachments.length > 0) {
				var writeMask = 0;
				if (blendState.redWrite) writeMask |= GPUColorWrite.RED;
				if (blendState.greenWrite) writeMask |= GPUColorWrite.GREEN;
				if (blendState.blueWrite) writeMask |= GPUColorWrite.BLUE;
				if (blendState.alphaWrite) writeMask |= GPUColorWrite.ALPHA;
				var blend = this.getBlend(blendState);
				colorAttachments.forEach(function (attachment) {
					desc.fragment.targets.push({
						format: attachment.format,
						writeMask: writeMask,
						blend: blend
					});
				});
			}
			var pipeline = wgpu.createRenderPipeline(desc);
			return pipeline;
		};
		return WebgpuRenderPipeline;
	}(WebgpuPipeline);

	var WebgpuComputePipeline = function (_WebgpuPipeline) {
		function WebgpuComputePipeline() {
			return _WebgpuPipeline.apply(this, arguments) || this;
		}
		_inheritsLoose(WebgpuComputePipeline, _WebgpuPipeline);
		var _proto = WebgpuComputePipeline.prototype;
		_proto.get = function get(shader, bindGroupFormat) {
			var pipelineLayout = this.getPipelineLayout([bindGroupFormat.impl]);
			var pipeline = this.create(shader, pipelineLayout);
			return pipeline;
		};
		_proto.create = function create(shader, pipelineLayout) {
			var wgpu = this.device.wgpu;
			var webgpuShader = shader.impl;
			var desc = {
				compute: {
					module: webgpuShader.getComputeShaderModule(),
					entryPoint: webgpuShader.computeEntryPoint
				},
				layout: pipelineLayout
			};
			var pipeline = wgpu.createComputePipeline(desc);
			return pipeline;
		};
		return WebgpuComputePipeline;
	}(WebgpuPipeline);

	var RefCountedObject = function () {
		function RefCountedObject() {
			this._refCount = 0;
		}
		var _proto = RefCountedObject.prototype;
		_proto.incRefCount = function incRefCount() {
			this._refCount++;
		};
		_proto.decRefCount = function decRefCount() {
			this._refCount--;
		};
		return _createClass(RefCountedObject, [{
			key: "refCount",
			get: function get() {
				return this._refCount;
			}
		}]);
	}();

	var Entry = function (_RefCountedObject) {
		function Entry(obj) {
			var _this;
			_this = _RefCountedObject.call(this) || this;
			_this.object = void 0;
			_this.object = obj;
			_this.incRefCount();
			return _this;
		}
		_inheritsLoose(Entry, _RefCountedObject);
		return Entry;
	}(RefCountedObject);
	var RefCountedKeyCache = function () {
		function RefCountedKeyCache() {
			this.cache = new Map();
		}
		var _proto = RefCountedKeyCache.prototype;
		_proto.destroy = function destroy() {
			this.cache.forEach(function (entry) {
				var _entry$object;
				(_entry$object = entry.object) == null || _entry$object.destroy();
			});
			this.cache.clear();
		};
		_proto.clear = function clear() {
			this.cache.clear();
		};
		_proto.get = function get(key) {
			var entry = this.cache.get(key);
			if (entry) {
				entry.incRefCount();
				return entry.object;
			}
			return null;
		};
		_proto.set = function set(key, object) {
			this.cache.set(key, new Entry(object));
		};
		_proto.release = function release(key) {
			var entry = this.cache.get(key);
			if (entry) {
				entry.decRefCount();
				if (entry.refCount === 0) {
					var _entry$object2;
					this.cache.delete(key);
					(_entry$object2 = entry.object) == null || _entry$object2.destroy();
				}
			}
		};
		return RefCountedKeyCache;
	}();

	var MultisampledTextureCache = function (_RefCountedKeyCache) {
		function MultisampledTextureCache() {
			return _RefCountedKeyCache.apply(this, arguments) || this;
		}
		_inheritsLoose(MultisampledTextureCache, _RefCountedKeyCache);
		var _proto = MultisampledTextureCache.prototype;
		_proto.loseContext = function loseContext(device) {
			this.clear();
		};
		return MultisampledTextureCache;
	}(RefCountedKeyCache);
	var multisampledTextureCache = new DeviceCache();
	var getMultisampledTextureCache = function getMultisampledTextureCache(device) {
		return multisampledTextureCache.get(device, function () {
			return new MultisampledTextureCache();
		});
	};

	var stringIds = new StringIds();
	var ColorAttachment = function () {
		function ColorAttachment() {
			this.format = void 0;
			this.multisampledBuffer = void 0;
		}
		var _proto = ColorAttachment.prototype;
		_proto.destroy = function destroy() {
			var _this$multisampledBuf;
			(_this$multisampledBuf = this.multisampledBuffer) == null || _this$multisampledBuf.destroy();
			this.multisampledBuffer = null;
		};
		return ColorAttachment;
	}();
	var DepthAttachment = function () {
		function DepthAttachment(gpuFormat) {
			this.format = void 0;
			this.hasStencil = void 0;
			this.depthTexture = null;
			this.depthTextureInternal = false;
			this.multisampledDepthBuffer = null;
			this.multisampledDepthBufferKey = void 0;
			this.format = gpuFormat;
			this.hasStencil = gpuFormat === 'depth24plus-stencil8';
		}
		var _proto2 = DepthAttachment.prototype;
		_proto2.destroy = function destroy(device) {
			if (this.depthTextureInternal) {
				var _this$depthTexture;
				(_this$depthTexture = this.depthTexture) == null || _this$depthTexture.destroy();
				this.depthTexture = null;
			}
			if (this.multisampledDepthBuffer) {
				this.multisampledDepthBuffer = null;
				getMultisampledTextureCache(device).release(this.multisampledDepthBufferKey);
			}
		};
		return DepthAttachment;
	}();
	var WebgpuRenderTarget = function () {
		function WebgpuRenderTarget(renderTarget) {
			this.initialized = false;
			this.key = void 0;
			this.colorAttachments = [];
			this.depthAttachment = null;
			this.assignedColorTexture = null;
			this.renderPassDescriptor = {};
			this.isBackbuffer = false;
			this.renderTarget = renderTarget;
		}
		var _proto3 = WebgpuRenderTarget.prototype;
		_proto3.destroy = function destroy(device) {
			var _this$depthAttachment;
			this.initialized = false;
			this.assignedColorTexture = null;
			this.colorAttachments.forEach(function (colorAttachment) {
				colorAttachment.destroy();
			});
			this.colorAttachments.length = 0;
			(_this$depthAttachment = this.depthAttachment) == null || _this$depthAttachment.destroy(device);
			this.depthAttachment = null;
		};
		_proto3.updateKey = function updateKey() {
			var rt = this.renderTarget;
			var key = rt.samples + ":" + (this.depthAttachment ? this.depthAttachment.format : 'nodepth');
			this.colorAttachments.forEach(function (colorAttachment) {
				key += ":" + colorAttachment.format;
			});
			this.key = stringIds.get(key);
		};
		_proto3.assignColorTexture = function assignColorTexture(device, gpuTexture) {
			this.assignedColorTexture = gpuTexture;
			var view = gpuTexture.createView({
				format: device.backBufferViewFormat
			});
			var colorAttachment = this.renderPassDescriptor.colorAttachments[0];
			var samples = this.renderTarget.samples;
			if (samples > 1) {
				colorAttachment.resolveTarget = view;
			} else {
				colorAttachment.view = view;
			}
			this.setColorAttachment(0, undefined, device.backBufferViewFormat);
			this.updateKey();
		};
		_proto3.setColorAttachment = function setColorAttachment(index, multisampledBuffer, format) {
			if (!this.colorAttachments[index]) {
				this.colorAttachments[index] = new ColorAttachment();
			}
			if (multisampledBuffer) {
				this.colorAttachments[index].multisampledBuffer = multisampledBuffer;
			}
			if (format) {
				this.colorAttachments[index].format = format;
			}
		};
		_proto3.init = function init(device, renderTarget) {
			var _this = this,
				_renderTarget$_colorB,
				_renderTarget$_colorB2;
			var wgpu = device.wgpu;
			this.initDepthStencil(device, wgpu, renderTarget);
			if (renderTarget._colorBuffers) {
				renderTarget._colorBuffers.forEach(function (colorBuffer, index) {
					_this.setColorAttachment(index, undefined, colorBuffer.impl.format);
				});
			}
			this.renderPassDescriptor.colorAttachments = [];
			var count = this.isBackbuffer ? 1 : (_renderTarget$_colorB = (_renderTarget$_colorB2 = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB2.length) != null ? _renderTarget$_colorB : 0;
			for (var i = 0; i < count; ++i) {
				var _this$colorAttachment;
				var colorAttachment = this.initColor(device, wgpu, renderTarget, i);
				var isDefaultFramebuffer = i === 0 && ((_this$colorAttachment = this.colorAttachments[0]) == null ? void 0 : _this$colorAttachment.format);
				if (colorAttachment.view || isDefaultFramebuffer) {
					this.renderPassDescriptor.colorAttachments.push(colorAttachment);
				}
			}
			this.updateKey();
			this.initialized = true;
		};
		_proto3.initDepthStencil = function initDepthStencil(device, wgpu, renderTarget) {
			var samples = renderTarget.samples,
				width = renderTarget.width,
				height = renderTarget.height,
				depth = renderTarget.depth,
				depthBuffer = renderTarget.depthBuffer;
			if (depth || depthBuffer) {
				var renderingView;
				if (!depthBuffer) {
					this.depthAttachment = new DepthAttachment('depth24plus-stencil8');
					var depthTextureDesc = {
						size: [width, height, 1],
						dimension: '2d',
						sampleCount: samples,
						format: this.depthAttachment.format,
						usage: GPUTextureUsage.RENDER_ATTACHMENT
					};
					if (samples > 1) {
						depthTextureDesc.usage |= GPUTextureUsage.TEXTURE_BINDING;
					} else {
						depthTextureDesc.usage |= GPUTextureUsage.COPY_SRC;
					}
					var depthTexture = wgpu.createTexture(depthTextureDesc);
					this.depthAttachment.depthTexture = depthTexture;
					this.depthAttachment.depthTextureInternal = true;
					renderingView = depthTexture.createView();
				} else {
					this.depthAttachment = new DepthAttachment(depthBuffer.impl.format);
					if (samples > 1) {
						var depthFormat = 'depth24plus-stencil8';
						this.depthAttachment.format = depthFormat;
						this.depthAttachment.hasStencil = depthFormat === 'depth24plus-stencil8';
						var key = depthBuffer.id + ":" + width + ":" + height + ":" + samples + ":" + depthFormat;
						var msTextures = getMultisampledTextureCache(device);
						var msDepthTexture = msTextures.get(key);
						if (!msDepthTexture) {
							var multisampledDepthDesc = {
								size: [width, height, 1],
								dimension: '2d',
								sampleCount: samples,
								format: depthFormat,
								usage: GPUTextureUsage.RENDER_ATTACHMENT | (depthFormat !== depthBuffer.impl.format ? GPUTextureUsage.TEXTURE_BINDING : 0)
							};
							msDepthTexture = wgpu.createTexture(multisampledDepthDesc);
							msTextures.set(key, msDepthTexture);
						}
						this.depthAttachment.multisampledDepthBuffer = msDepthTexture;
						this.depthAttachment.multisampledDepthBufferKey = key;
						renderingView = msDepthTexture.createView();
					} else {
						var _depthTexture = depthBuffer.impl.gpuTexture;
						this.depthAttachment.depthTexture = _depthTexture;
						renderingView = _depthTexture.createView();
					}
				}
				this.renderPassDescriptor.depthStencilAttachment = {
					view: renderingView
				};
			}
		};
		_proto3.initColor = function initColor(device, wgpu, renderTarget, index) {
			var colorAttachment = {};
			var samples = renderTarget.samples,
				width = renderTarget.width,
				height = renderTarget.height,
				mipLevel = renderTarget.mipLevel;
			var colorBuffer = renderTarget.getColorBuffer(index);
			var colorView = null;
			if (colorBuffer) {
				var mipLevelCount = 1;
				if (colorBuffer.cubemap) {
					colorView = colorBuffer.impl.createView({
						dimension: '2d',
						baseArrayLayer: renderTarget.face,
						arrayLayerCount: 1,
						mipLevelCount: mipLevelCount,
						baseMipLevel: mipLevel
					});
				} else {
					colorView = colorBuffer.impl.createView({
						mipLevelCount: mipLevelCount,
						baseMipLevel: mipLevel
					});
				}
			}
			if (samples > 1) {
				var format = this.isBackbuffer ? device.backBufferViewFormat : colorBuffer.impl.format;
				var multisampledTextureDesc = {
					size: [width, height, 1],
					dimension: '2d',
					sampleCount: samples,
					format: format,
					usage: GPUTextureUsage.RENDER_ATTACHMENT
				};
				var multisampledColorBuffer = wgpu.createTexture(multisampledTextureDesc);
				this.setColorAttachment(index, multisampledColorBuffer, multisampledTextureDesc.format);
				colorAttachment.view = multisampledColorBuffer.createView();
				colorAttachment.resolveTarget = colorView;
			} else {
				colorAttachment.view = colorView;
			}
			return colorAttachment;
		};
		_proto3.setupForRenderPass = function setupForRenderPass(renderPass, renderTarget) {
			var _this$renderPassDescr, _this$renderPassDescr2;
			var count = (_this$renderPassDescr = (_this$renderPassDescr2 = this.renderPassDescriptor.colorAttachments) == null ? void 0 : _this$renderPassDescr2.length) != null ? _this$renderPassDescr : 0;
			for (var i = 0; i < count; ++i) {
				var colorAttachment = this.renderPassDescriptor.colorAttachments[i];
				var colorOps = renderPass.colorArrayOps[i];
				var srgb = renderTarget.isColorBufferSrgb(i);
				colorAttachment.clearValue = srgb ? colorOps.clearValueLinear : colorOps.clearValue;
				colorAttachment.loadOp = colorOps.clear ? 'clear' : 'load';
				colorAttachment.storeOp = colorOps.store ? 'store' : 'discard';
			}
			var depthAttachment = this.renderPassDescriptor.depthStencilAttachment;
			if (depthAttachment) {
				depthAttachment.depthClearValue = renderPass.depthStencilOps.clearDepthValue;
				depthAttachment.depthLoadOp = renderPass.depthStencilOps.clearDepth ? 'clear' : 'load';
				depthAttachment.depthStoreOp = renderPass.depthStencilOps.storeDepth ? 'store' : 'discard';
				depthAttachment.depthReadOnly = false;
				if (this.depthAttachment.hasStencil) {
					depthAttachment.stencilClearValue = renderPass.depthStencilOps.clearStencilValue;
					depthAttachment.stencilLoadOp = renderPass.depthStencilOps.clearStencil ? 'clear' : 'load';
					depthAttachment.stencilStoreOp = renderPass.depthStencilOps.storeStencil ? 'store' : 'discard';
					depthAttachment.stencilReadOnly = false;
				}
			}
		};
		_proto3.loseContext = function loseContext() {
			this.initialized = false;
		};
		_proto3.resolve = function resolve(device, target, color, depth) {};
		return WebgpuRenderTarget;
	}();

	var uniformTypeToNumComponents = [];
	uniformTypeToNumComponents[UNIFORMTYPE_FLOAT] = 1;
	uniformTypeToNumComponents[UNIFORMTYPE_VEC2] = 2;
	uniformTypeToNumComponents[UNIFORMTYPE_VEC3] = 3;
	uniformTypeToNumComponents[UNIFORMTYPE_VEC4] = 4;
	uniformTypeToNumComponents[UNIFORMTYPE_INT] = 1;
	uniformTypeToNumComponents[UNIFORMTYPE_IVEC2] = 2;
	uniformTypeToNumComponents[UNIFORMTYPE_IVEC3] = 3;
	uniformTypeToNumComponents[UNIFORMTYPE_IVEC4] = 4;
	uniformTypeToNumComponents[UNIFORMTYPE_BOOL] = 1;
	uniformTypeToNumComponents[UNIFORMTYPE_BVEC2] = 2;
	uniformTypeToNumComponents[UNIFORMTYPE_BVEC3] = 3;
	uniformTypeToNumComponents[UNIFORMTYPE_BVEC4] = 4;
	uniformTypeToNumComponents[UNIFORMTYPE_MAT2] = 8;
	uniformTypeToNumComponents[UNIFORMTYPE_MAT3] = 12;
	uniformTypeToNumComponents[UNIFORMTYPE_MAT4] = 16;
	uniformTypeToNumComponents[UNIFORMTYPE_UINT] = 1;
	uniformTypeToNumComponents[UNIFORMTYPE_UVEC2] = 2;
	uniformTypeToNumComponents[UNIFORMTYPE_UVEC3] = 3;
	uniformTypeToNumComponents[UNIFORMTYPE_UVEC4] = 4;
	var UniformFormat = function () {
		function UniformFormat(name, type, count) {
			if (count === void 0) {
				count = 0;
			}
			this.name = void 0;
			this.type = void 0;
			this.byteSize = void 0;
			this.offset = void 0;
			this.scopeId = void 0;
			this.count = void 0;
			this.numComponents = void 0;
			this.shortName = name;
			this.name = count ? name + "[0]" : name;
			this.type = type;
			this.numComponents = uniformTypeToNumComponents[type];
			this.updateType = type;
			if (count > 0) {
				switch (type) {
					case UNIFORMTYPE_FLOAT:
						this.updateType = UNIFORMTYPE_FLOATARRAY;
						break;
					case UNIFORMTYPE_INT:
						this.updateType = UNIFORMTYPE_INTARRAY;
						break;
					case UNIFORMTYPE_UINT:
						this.updateType = UNIFORMTYPE_UINTARRAY;
						break;
					case UNIFORMTYPE_BOOL:
						this.updateType = UNIFORMTYPE_BOOLARRAY;
						break;
					case UNIFORMTYPE_VEC2:
						this.updateType = UNIFORMTYPE_VEC2ARRAY;
						break;
					case UNIFORMTYPE_IVEC2:
						this.updateType = UNIFORMTYPE_IVEC2ARRAY;
						break;
					case UNIFORMTYPE_UVEC2:
						this.updateType = UNIFORMTYPE_UVEC2ARRAY;
						break;
					case UNIFORMTYPE_BVEC2:
						this.updateType = UNIFORMTYPE_BVEC2ARRAY;
						break;
					case UNIFORMTYPE_VEC3:
						this.updateType = UNIFORMTYPE_VEC3ARRAY;
						break;
					case UNIFORMTYPE_IVEC3:
						this.updateType = UNIFORMTYPE_IVEC3ARRAY;
						break;
					case UNIFORMTYPE_UVEC3:
						this.updateType = UNIFORMTYPE_UVEC3ARRAY;
						break;
					case UNIFORMTYPE_BVEC3:
						this.updateType = UNIFORMTYPE_BVEC3ARRAY;
						break;
					case UNIFORMTYPE_VEC4:
						this.updateType = UNIFORMTYPE_VEC4ARRAY;
						break;
					case UNIFORMTYPE_IVEC4:
						this.updateType = UNIFORMTYPE_IVEC4ARRAY;
						break;
					case UNIFORMTYPE_UVEC4:
						this.updateType = UNIFORMTYPE_UVEC4ARRAY;
						break;
					case UNIFORMTYPE_BVEC4:
						this.updateType = UNIFORMTYPE_BVEC4ARRAY;
						break;
					case UNIFORMTYPE_MAT4:
						this.updateType = UNIFORMTYPE_MAT4ARRAY;
						break;
				}
			}
			this.count = count;
			var componentSize = this.numComponents;
			if (count) {
				componentSize = math.roundUp(componentSize, 4);
			}
			this.byteSize = componentSize * 4;
			if (count) {
				this.byteSize *= count;
			}
		}
		var _proto = UniformFormat.prototype;
		_proto.calculateOffset = function calculateOffset(offset) {
			var alignment = this.byteSize <= 8 ? this.byteSize : 16;
			if (this.count) {
				alignment = 16;
			}
			offset = math.roundUp(offset, alignment);
			this.offset = offset / 4;
		};
		return _createClass(UniformFormat, [{
			key: "isArrayType",
			get: function get() {
				return this.count > 0;
			}
		}]);
	}();
	var UniformBufferFormat = function () {
		function UniformBufferFormat(graphicsDevice, uniforms) {
			this.byteSize = 0;
			this.map = new Map();
			this.scope = graphicsDevice.scope;
			this.uniforms = uniforms;
			var offset = 0;
			for (var i = 0; i < uniforms.length; i++) {
				var uniform = uniforms[i];
				uniform.calculateOffset(offset);
				offset = uniform.offset * 4 + uniform.byteSize;
				uniform.scopeId = this.scope.resolve(uniform.name);
				this.map.set(uniform.name, uniform);
			}
			this.byteSize = math.roundUp(offset, 16);
		}
		var _proto2 = UniformBufferFormat.prototype;
		_proto2.get = function get(name) {
			return this.map.get(name);
		};
		_proto2.getShaderDeclaration = function getShaderDeclaration(bindGroup, bindIndex) {
			var name = bindGroupNames[bindGroup];
			var code = "layout(set = " + bindGroup + ", binding = " + bindIndex + ", std140) uniform ub_" + name + " {\n";
			this.uniforms.forEach(function (uniform) {
				var typeString = uniformTypeToName[uniform.type];
				code += "    " + typeString + " " + uniform.shortName + (uniform.count ? "[" + uniform.count + "]" : '') + ";\n";
			});
			return code + "};\n";
		};
		return UniformBufferFormat;
	}();

	var KEYWORD$1 = /[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g;
	var KEYWORD_LINE = /(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)(;+)/g;
	var MARKER = '@@@';
	var ARRAY_IDENTIFIER = /([\w-]+)\[(.*?)\]/;
	var precisionQualifiers = new Set(['highp', 'mediump', 'lowp']);
	var shadowSamplers = new Set(['sampler2DShadow', 'samplerCubeShadow', 'sampler2DArrayShadow']);
	var textureDimensions = {
		sampler2D: TEXTUREDIMENSION_2D,
		sampler3D: TEXTUREDIMENSION_3D,
		samplerCube: TEXTUREDIMENSION_CUBE,
		samplerCubeShadow: TEXTUREDIMENSION_CUBE,
		sampler2DShadow: TEXTUREDIMENSION_2D,
		sampler2DArray: TEXTUREDIMENSION_2D_ARRAY,
		sampler2DArrayShadow: TEXTUREDIMENSION_2D_ARRAY,
		isampler2D: TEXTUREDIMENSION_2D,
		usampler2D: TEXTUREDIMENSION_2D,
		isampler3D: TEXTUREDIMENSION_3D,
		usampler3D: TEXTUREDIMENSION_3D,
		isamplerCube: TEXTUREDIMENSION_CUBE,
		usamplerCube: TEXTUREDIMENSION_CUBE,
		isampler2DArray: TEXTUREDIMENSION_2D_ARRAY,
		usampler2DArray: TEXTUREDIMENSION_2D_ARRAY
	};
	var UniformLine = function UniformLine(line, shader) {
		this.line = line;
		var words = line.trim().split(/\s+/);
		if (precisionQualifiers.has(words[0])) {
			this.precision = words.shift();
		}
		this.type = words.shift();
		if (line.includes(',')) ;
		if (line.includes('[')) {
			var rest = words.join(' ');
			var match = ARRAY_IDENTIFIER.exec(rest);
			this.name = match[1];
			this.arraySize = Number(match[2]);
			if (isNaN(this.arraySize)) {
				shader.failed = true;
			}
		} else {
			this.name = words.shift();
			this.arraySize = 0;
		}
		this.isSampler = this.type.indexOf('sampler') !== -1;
		this.isSignedInt = this.type.indexOf('isampler') !== -1;
		this.isUnsignedInt = this.type.indexOf('usampler') !== -1;
	};
	var ShaderProcessor = function () {
		function ShaderProcessor() {}
		ShaderProcessor.run = function run(device, shaderDefinition, shader) {
			var varyingMap = new Map();
			var vertexExtracted = ShaderProcessor.extract(shaderDefinition.vshader);
			var fragmentExtracted = ShaderProcessor.extract(shaderDefinition.fshader);
			var attributesBlock = ShaderProcessor.processAttributes(vertexExtracted.attributes, shaderDefinition.attributes, shaderDefinition.processingOptions);
			var vertexVaryingsBlock = ShaderProcessor.processVaryings(vertexExtracted.varyings, varyingMap, true);
			var fragmentVaryingsBlock = ShaderProcessor.processVaryings(fragmentExtracted.varyings, varyingMap, false);
			var outBlock = ShaderProcessor.processOuts(fragmentExtracted.outs);
			var concatUniforms = vertexExtracted.uniforms.concat(fragmentExtracted.uniforms);
			var uniforms = Array.from(new Set(concatUniforms));
			var parsedUniforms = uniforms.map(function (line) {
				return new UniformLine(line, shader);
			});
			var uniformsData = ShaderProcessor.processUniforms(device, parsedUniforms, shaderDefinition.processingOptions, shader);
			var vBlock = attributesBlock + "\n" + vertexVaryingsBlock + "\n" + uniformsData.code;
			var vshader = vertexExtracted.src.replace(MARKER, vBlock);
			var fBlock = fragmentVaryingsBlock + "\n" + outBlock + "\n" + uniformsData.code;
			var fshader = fragmentExtracted.src.replace(MARKER, fBlock);
			return {
				vshader: vshader,
				fshader: fshader,
				meshUniformBufferFormat: uniformsData.meshUniformBufferFormat,
				meshBindGroupFormat: uniformsData.meshBindGroupFormat
			};
		};
		ShaderProcessor.extract = function extract(src) {
			var attributes = [];
			var varyings = [];
			var outs = [];
			var uniforms = [];
			var replacement = MARKER + "\n";
			var match;
			while ((match = KEYWORD$1.exec(src)) !== null) {
				var keyword = match[1];
				switch (keyword) {
					case 'attribute':
					case 'varying':
					case 'uniform':
					case 'out':
						{
							KEYWORD_LINE.lastIndex = match.index;
							var lineMatch = KEYWORD_LINE.exec(src);
							if (keyword === 'attribute') {
								attributes.push(lineMatch[2]);
							} else if (keyword === 'varying') {
								varyings.push(lineMatch[2]);
							} else if (keyword === 'out') {
								outs.push(lineMatch[2]);
							} else if (keyword === 'uniform') {
								uniforms.push(lineMatch[2]);
							}
							src = ShaderProcessor.cutOut(src, match.index, KEYWORD_LINE.lastIndex, replacement);
							KEYWORD$1.lastIndex = match.index + replacement.length;
							replacement = '';
							break;
						}
				}
			}
			return {
				src: src,
				attributes: attributes,
				varyings: varyings,
				outs: outs,
				uniforms: uniforms
			};
		};
		ShaderProcessor.processUniforms = function processUniforms(device, uniforms, processingOptions, shader) {
			var uniformLinesSamplers = [];
			var uniformLinesNonSamplers = [];
			uniforms.forEach(function (uniform) {
				if (uniform.isSampler) {
					uniformLinesSamplers.push(uniform);
				} else {
					uniformLinesNonSamplers.push(uniform);
				}
			});
			var meshUniforms = [];
			uniformLinesNonSamplers.forEach(function (uniform) {
				if (!processingOptions.hasUniform(uniform.name)) {
					var uniformType = uniformTypeToName.indexOf(uniform.type);
					var uniformFormat = new UniformFormat(uniform.name, uniformType, uniform.arraySize);
					meshUniforms.push(uniformFormat);
				}
			});
			var meshUniformBufferFormat = meshUniforms.length ? new UniformBufferFormat(device, meshUniforms) : null;
			var textureFormats = [];
			uniformLinesSamplers.forEach(function (uniform) {
				if (!processingOptions.hasTexture(uniform.name)) {
					var sampleType = SAMPLETYPE_FLOAT;
					if (uniform.isSignedInt) {
						sampleType = SAMPLETYPE_INT;
					} else if (uniform.isUnsignedInt) {
						sampleType = SAMPLETYPE_UINT;
					} else {
						if (uniform.precision === 'highp') {
							sampleType = SAMPLETYPE_UNFILTERABLE_FLOAT;
						}
						if (shadowSamplers.has(uniform.type)) {
							sampleType = SAMPLETYPE_DEPTH;
						}
					}
					var dimension = textureDimensions[uniform.type];
					textureFormats.push(new BindTextureFormat(uniform.name, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT, dimension, sampleType));
				}
			});
			var meshBindGroupFormat = new BindGroupFormat(device, textureFormats);
			var code = '';
			processingOptions.uniformFormats.forEach(function (format, bindGroupIndex) {
				if (format) {
					code += format.getShaderDeclaration(bindGroupIndex, 0);
				}
			});
			if (meshUniformBufferFormat) {
				code += meshUniformBufferFormat.getShaderDeclaration(BINDGROUP_MESH_UB, 0);
			}
			processingOptions.bindGroupFormats.forEach(function (format, bindGroupIndex) {
				if (format) {
					code += format.getShaderDeclarationTextures(bindGroupIndex);
				}
			});
			code += meshBindGroupFormat.getShaderDeclarationTextures(BINDGROUP_MESH);
			return {
				code: code,
				meshUniformBufferFormat: meshUniformBufferFormat,
				meshBindGroupFormat: meshBindGroupFormat
			};
		};
		ShaderProcessor.processVaryings = function processVaryings(varyingLines, varyingMap, isVertex) {
			var block = '';
			var op = isVertex ? 'out' : 'in';
			varyingLines.forEach(function (line, index) {
				var words = ShaderProcessor.splitToWords(line);
				var type = words.slice(0, -1).join(' ');
				var name = words[words.length - 1];
				if (isVertex) {
					varyingMap.set(name, index);
				} else {
					index = varyingMap.get(name);
				}
				block += "layout(location = " + index + ") " + op + " " + type + " " + name + ";\n";
			});
			return block;
		};
		ShaderProcessor.processOuts = function processOuts(outsLines) {
			var block = '';
			outsLines.forEach(function (line, index) {
				block += "layout(location = " + index + ") out " + line + ";\n";
			});
			return block;
		};
		ShaderProcessor.getTypeCount = function getTypeCount(type) {
			var lastChar = type.substring(type.length - 1);
			var num = parseInt(lastChar, 10);
			return isNaN(num) ? 1 : num;
		};
		ShaderProcessor.processAttributes = function processAttributes(attributeLines, shaderDefinitionAttributes, processingOptions) {
			var block = '';
			attributeLines.forEach(function (line) {
				var words = ShaderProcessor.splitToWords(line);
				var type = words[0];
				var name = words[1];
				if (shaderDefinitionAttributes.hasOwnProperty(name)) {
					var semantic = shaderDefinitionAttributes[name];
					var location = semanticToLocation[semantic];
					var copyCode;
					var element = processingOptions.getVertexElement(semantic);
					if (element) {
						var dataType = element.dataType;
						if (dataType !== TYPE_FLOAT32 && dataType !== TYPE_FLOAT16 && !element.normalize && !element.asInt) {
							var attribNumElements = ShaderProcessor.getTypeCount(type);
							var newName = "_private_" + name;
							copyCode = "vec" + attribNumElements + " " + name + " = vec" + attribNumElements + "(" + newName + ");\n";
							name = newName;
							var isSignedType = dataType === TYPE_INT8 || dataType === TYPE_INT16 || dataType === TYPE_INT32;
							if (attribNumElements === 1) {
								type = isSignedType ? 'int' : 'uint';
							} else {
								type = isSignedType ? "ivec" + attribNumElements : "uvec" + attribNumElements;
							}
						}
					}
					block += "layout(location = " + location + ") in " + type + " " + name + ";\n";
					if (copyCode) {
						block += copyCode;
					}
				}
			});
			return block;
		};
		ShaderProcessor.splitToWords = function splitToWords(line) {
			line = line.replace(/\s+/g, ' ').trim();
			return line.split(' ');
		};
		ShaderProcessor.cutOut = function cutOut(src, start, end, replacement) {
			return src.substring(0, start) + replacement + src.substring(end);
		};
		return ShaderProcessor;
	}();

	var WebgpuShader = function () {
		function WebgpuShader(shader) {
			this._vertexCode = null;
			this._fragmentCode = null;
			this._computeCode = null;
			this.vertexEntryPoint = 'main';
			this.fragmentEntryPoint = 'main';
			this.computeEntryPoint = 'main';
			this.shader = shader;
			var definition = shader.definition;
			if (definition.shaderLanguage === SHADERLANGUAGE_WGSL) {
				var _definition$vshader, _definition$fshader, _definition$cshader;
				this._vertexCode = (_definition$vshader = definition.vshader) != null ? _definition$vshader : null;
				this._fragmentCode = (_definition$fshader = definition.fshader) != null ? _definition$fshader : null;
				this._computeCode = (_definition$cshader = definition.cshader) != null ? _definition$cshader : null;
				shader.meshUniformBufferFormat = definition.meshUniformBufferFormat;
				shader.meshBindGroupFormat = definition.meshBindGroupFormat;
				this.computeUniformBufferFormats = definition.computeUniformBufferFormats;
				this.computeBindGroupFormat = definition.computeBindGroupFormat;
				this.vertexEntryPoint = 'vertexMain';
				this.fragmentEntryPoint = 'fragmentMain';
				shader.ready = true;
			} else {
				if (definition.processingOptions) {
					this.process();
				}
			}
		}
		var _proto = WebgpuShader.prototype;
		_proto.destroy = function destroy(shader) {
			this._vertexCode = null;
			this._fragmentCode = null;
		};
		_proto.createShaderModule = function createShaderModule(code, shaderType) {
			var device = this.shader.device;
			var wgpu = device.wgpu;
			var shaderModule = wgpu.createShaderModule({
				code: code
			});
			return shaderModule;
		};
		_proto.getVertexShaderModule = function getVertexShaderModule() {
			return this.createShaderModule(this._vertexCode, 'Vertex');
		};
		_proto.getFragmentShaderModule = function getFragmentShaderModule() {
			return this.createShaderModule(this._fragmentCode, 'Fragment');
		};
		_proto.getComputeShaderModule = function getComputeShaderModule() {
			return this.createShaderModule(this._computeCode, 'Compute');
		};
		_proto.process = function process() {
			var shader = this.shader;
			var processed = ShaderProcessor.run(shader.device, shader.definition, shader);
			this._vertexCode = this.transpile(processed.vshader, 'vertex', shader.definition.vshader);
			this._fragmentCode = this.transpile(processed.fshader, 'fragment', shader.definition.fshader);
			if (!(this._vertexCode && this._fragmentCode)) {
				shader.failed = true;
			} else {
				shader.ready = true;
			}
			shader.meshUniformBufferFormat = processed.meshUniformBufferFormat;
			shader.meshBindGroupFormat = processed.meshBindGroupFormat;
		};
		_proto.transpile = function transpile(src, shaderType, originalSrc) {
			try {
				var spirv = this.shader.device.glslang.compileGLSL(src, shaderType);
				var wgsl = this.shader.device.twgsl.convertSpirV2WGSL(spirv);
				return wgsl;
			} catch (err) {
				console.error("Failed to transpile webgl " + shaderType + " shader [" + this.shader.label + "] to WebGPU while rendering " + void 0 + ", error:\n [" + err.stack + "]", {
					processed: src,
					original: originalSrc,
					shader: this.shader,
					error: err,
					stack: err.stack
				});
			}
		};
		_proto.loseContext = function loseContext() {};
		_proto.restoreContext = function restoreContext(device, shader) {};
		return _createClass(WebgpuShader, [{
			key: "vertexCode",
			get: function get() {
				return this._vertexCode;
			}
		}, {
			key: "fragmentCode",
			get: function get() {
				return this._fragmentCode;
			}
		}]);
	}();

	var gpuAddressModes = [];
	gpuAddressModes[ADDRESS_REPEAT] = 'repeat';
	gpuAddressModes[ADDRESS_CLAMP_TO_EDGE] = 'clamp-to-edge';
	gpuAddressModes[ADDRESS_MIRRORED_REPEAT] = 'mirror-repeat';
	var gpuFilterModes = [];
	gpuFilterModes[FILTER_NEAREST] = {
		level: 'nearest',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_LINEAR] = {
		level: 'linear',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_NEAREST_MIPMAP_NEAREST] = {
		level: 'nearest',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_NEAREST_MIPMAP_LINEAR] = {
		level: 'nearest',
		mip: 'linear'
	};
	gpuFilterModes[FILTER_LINEAR_MIPMAP_NEAREST] = {
		level: 'linear',
		mip: 'nearest'
	};
	gpuFilterModes[FILTER_LINEAR_MIPMAP_LINEAR] = {
		level: 'linear',
		mip: 'linear'
	};
	var dummyUse = function dummyUse(thingOne) {};
	var WebgpuTexture = function () {
		function WebgpuTexture(texture) {
			this.gpuTexture = void 0;
			this.view = void 0;
			this.samplers = [];
			this.desc = void 0;
			this.format = void 0;
			this.texture = texture;
			this.format = gpuTextureFormats[texture.format];
			this.create(texture.device);
		}
		var _proto = WebgpuTexture.prototype;
		_proto.create = function create(device) {
			var texture = this.texture;
			var wgpu = device.wgpu;
			var numLevels = texture.numLevels;
			this.desc = {
				size: {
					width: texture.width,
					height: texture.height,
					depthOrArrayLayers: texture.cubemap ? 6 : texture.array ? texture.arrayLength : 1
				},
				format: this.format,
				mipLevelCount: numLevels,
				sampleCount: 1,
				dimension: texture.volume ? '3d' : '2d',
				usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | (isCompressedPixelFormat(texture.format) ? 0 : GPUTextureUsage.RENDER_ATTACHMENT) | (texture.storage ? GPUTextureUsage.STORAGE_BINDING : 0)
			};
			this.gpuTexture = wgpu.createTexture(this.desc);
			var viewDescr;
			if (this.texture.format === PIXELFORMAT_DEPTHSTENCIL) {
				viewDescr = {
					format: 'depth24plus',
					aspect: 'depth-only'
				};
			}
			this.view = this.createView(viewDescr);
		};
		_proto.destroy = function destroy(device) {};
		_proto.propertyChanged = function propertyChanged(flag) {
			this.samplers.length = 0;
		};
		_proto.getView = function getView(device) {
			this.uploadImmediate(device, this.texture);
			return this.view;
		};
		_proto.createView = function createView(viewDescr) {
			var _options$format, _options$dimension, _options$aspect, _options$baseMipLevel, _options$mipLevelCoun, _options$baseArrayLay, _options$arrayLayerCo;
			var options = viewDescr != null ? viewDescr : {};
			var textureDescr = this.desc;
			var texture = this.texture;
			var defaultViewDimension = function defaultViewDimension() {
				if (texture.cubemap) return 'cube';
				if (texture.volume) return '3d';
				if (texture.array) return '2d-array';
				return '2d';
			};
			var desc = {
				format: (_options$format = options.format) != null ? _options$format : textureDescr.format,
				dimension: (_options$dimension = options.dimension) != null ? _options$dimension : defaultViewDimension(),
				aspect: (_options$aspect = options.aspect) != null ? _options$aspect : 'all',
				baseMipLevel: (_options$baseMipLevel = options.baseMipLevel) != null ? _options$baseMipLevel : 0,
				mipLevelCount: (_options$mipLevelCoun = options.mipLevelCount) != null ? _options$mipLevelCoun : textureDescr.mipLevelCount,
				baseArrayLayer: (_options$baseArrayLay = options.baseArrayLayer) != null ? _options$baseArrayLay : 0,
				arrayLayerCount: (_options$arrayLayerCo = options.arrayLayerCount) != null ? _options$arrayLayerCo : textureDescr.depthOrArrayLayers
			};
			var view = this.gpuTexture.createView(desc);
			return view;
		};
		_proto.getSampler = function getSampler(device, sampleType) {
			var sampler = this.samplers[sampleType];
			if (!sampler) {
				var texture = this.texture;
				var desc = {
					addressModeU: gpuAddressModes[texture.addressU],
					addressModeV: gpuAddressModes[texture.addressV],
					addressModeW: gpuAddressModes[texture.addressW]
				};
				if (!sampleType && texture.compareOnRead) {
					sampleType = SAMPLETYPE_DEPTH;
				}
				if (sampleType === SAMPLETYPE_DEPTH || sampleType === SAMPLETYPE_INT || sampleType === SAMPLETYPE_UINT) {
					desc.compare = 'less';
					desc.magFilter = 'linear';
					desc.minFilter = 'linear';
				} else if (sampleType === SAMPLETYPE_UNFILTERABLE_FLOAT) {
					desc.magFilter = 'nearest';
					desc.minFilter = 'nearest';
					desc.mipmapFilter = 'nearest';
				} else {
					var forceNearest = !device.textureFloatFilterable && (texture.format === PIXELFORMAT_RGBA32F || texture.format === PIXELFORMAT_RGBA16F);
					if (forceNearest || this.texture.format === PIXELFORMAT_DEPTHSTENCIL || isIntegerPixelFormat(this.texture.format)) {
						desc.magFilter = 'nearest';
						desc.minFilter = 'nearest';
						desc.mipmapFilter = 'nearest';
					} else {
						desc.magFilter = gpuFilterModes[texture.magFilter].level;
						desc.minFilter = gpuFilterModes[texture.minFilter].level;
						desc.mipmapFilter = gpuFilterModes[texture.minFilter].mip;
					}
				}
				var allLinear = desc.minFilter === 'linear' && desc.magFilter === 'linear' && desc.mipmapFilter === 'linear';
				desc.maxAnisotropy = allLinear ? math.clamp(Math.round(texture._anisotropy), 1, device.maxTextureAnisotropy) : 1;
				sampler = device.wgpu.createSampler(desc);
				this.samplers[sampleType] = sampler;
			}
			return sampler;
		};
		_proto.loseContext = function loseContext() {};
		_proto.uploadImmediate = function uploadImmediate(device, texture) {
			if (texture._needsUpload || texture._needsMipmapsUpload) {
				this.uploadData(device);
				texture._needsUpload = false;
				texture._needsMipmapsUpload = false;
			}
		};
		_proto.uploadData = function uploadData(device) {
			var texture = this.texture;
			if (texture._levels) {
				var anyUploads = false;
				var anyLevelMissing = false;
				var requiredMipLevels = texture.numLevels;
				for (var mipLevel = 0; mipLevel < requiredMipLevels; mipLevel++) {
					var mipObject = texture._levels[mipLevel];
					if (mipObject) {
						if (texture.cubemap) {
							for (var face = 0; face < 6; face++) {
								var faceSource = mipObject[face];
								if (faceSource) {
									if (this.isExternalImage(faceSource)) {
										this.uploadExternalImage(device, faceSource, mipLevel, face);
										anyUploads = true;
									} else if (ArrayBuffer.isView(faceSource)) {
										this.uploadTypedArrayData(device, faceSource, mipLevel, face);
										anyUploads = true;
									} else ;
								} else {
									anyLevelMissing = true;
								}
							}
						} else if (texture._volume) ; else if (texture.array) {
							if (texture.arrayLength === mipObject.length) {
								for (var index = 0; index < texture._arrayLength; index++) {
									var arraySource = mipObject[index];
									if (this.isExternalImage(arraySource)) {
										this.uploadExternalImage(device, arraySource, mipLevel, index);
										anyUploads = true;
									} else if (ArrayBuffer.isView(arraySource)) {
										this.uploadTypedArrayData(device, arraySource, mipLevel, index);
										anyUploads = true;
									} else ;
								}
							} else {
								anyLevelMissing = true;
							}
						} else {
							if (this.isExternalImage(mipObject)) {
								this.uploadExternalImage(device, mipObject, mipLevel, 0);
								anyUploads = true;
							} else if (ArrayBuffer.isView(mipObject)) {
								this.uploadTypedArrayData(device, mipObject, mipLevel, 0);
								anyUploads = true;
							} else ;
						}
					} else {
						anyLevelMissing = true;
					}
				}
				if (anyUploads && anyLevelMissing && texture.mipmaps && !isCompressedPixelFormat(texture.format) && !isIntegerPixelFormat(texture.format)) {
					device.mipmapRenderer.generate(this);
				}
				if (texture._gpuSize) {
					texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
				}
				texture._gpuSize = texture.gpuSize;
				texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
			}
		};
		_proto.isExternalImage = function isExternalImage(image) {
			return image instanceof ImageBitmap || image instanceof HTMLVideoElement || image instanceof HTMLCanvasElement || image instanceof OffscreenCanvas;
		};
		_proto.uploadExternalImage = function uploadExternalImage(device, image, mipLevel, index) {
			var src = {
				source: image,
				origin: [0, 0],
				flipY: false
			};
			var dst = {
				texture: this.gpuTexture,
				mipLevel: mipLevel,
				origin: [0, 0, index],
				aspect: 'all'
			};
			var copySize = {
				width: this.desc.size.width,
				height: this.desc.size.height,
				depthOrArrayLayers: 1
			};
			device.submit();
			dummyUse(image instanceof HTMLCanvasElement && image.getContext('2d'));
			device.wgpu.queue.copyExternalImageToTexture(src, dst, copySize);
		};
		_proto.uploadTypedArrayData = function uploadTypedArrayData(device, data, mipLevel, index) {
			var texture = this.texture;
			var wgpu = device.wgpu;
			var dest = {
				texture: this.gpuTexture,
				origin: [0, 0, index],
				mipLevel: mipLevel
			};
			var width = TextureUtils.calcLevelDimension(texture.width, mipLevel);
			var height = TextureUtils.calcLevelDimension(texture.height, mipLevel);
			TextureUtils.calcLevelGpuSize(width, height, 1, texture.format);
			var formatInfo = pixelFormatInfo.get(texture.format);
			var dataLayout;
			var size;
			if (formatInfo.size) {
				dataLayout = {
					offset: 0,
					bytesPerRow: formatInfo.size * width,
					rowsPerImage: height
				};
				size = {
					width: width,
					height: height
				};
			} else if (formatInfo.blockSize) {
				var blockDim = function blockDim(size) {
					return Math.floor((size + 3) / 4);
				};
				dataLayout = {
					offset: 0,
					bytesPerRow: formatInfo.blockSize * blockDim(width),
					rowsPerImage: blockDim(height)
				};
				size = {
					width: Math.max(4, width),
					height: Math.max(4, height)
				};
			} else ;
			device.submit();
			wgpu.queue.writeTexture(dest, data, dataLayout, size);
		};
		_proto.read = function read(x, y, width, height, options) {
			var _options$mipLevel, _options$face, _options$data, _options$immediate;
			var mipLevel = (_options$mipLevel = options.mipLevel) != null ? _options$mipLevel : 0;
			var face = (_options$face = options.face) != null ? _options$face : 0;
			var data = (_options$data = options.data) != null ? _options$data : null;
			var immediate = (_options$immediate = options.immediate) != null ? _options$immediate : false;
			var texture = this.texture;
			var formatInfo = pixelFormatInfo.get(texture.format);
			var bytesPerRow = width * formatInfo.size;
			var paddedBytesPerRow = math.roundUp(bytesPerRow, 256);
			var size = paddedBytesPerRow * height;
			var device = texture.device;
			var stagingBuffer = device.createBufferImpl(BUFFERUSAGE_READ | BUFFERUSAGE_COPY_DST);
			stagingBuffer.allocate(device, size);
			var src = {
				texture: this.gpuTexture,
				mipLevel: mipLevel,
				origin: [x, y, face]
			};
			var dst = {
				buffer: stagingBuffer.buffer,
				offset: 0,
				bytesPerRow: paddedBytesPerRow
			};
			var copySize = {
				width: width,
				height: height,
				depthOrArrayLayers: 1
			};
			var commandEncoder = device.getCommandEncoder();
			commandEncoder.copyTextureToBuffer(src, dst, copySize);
			return device.readBuffer(stagingBuffer, size, null, immediate).then(function (temp) {
				var _data;
				(_data = data) != null ? _data : data = new Uint8Array(height * bytesPerRow);
				for (var i = 0; i < height; i++) {
					var srcOffset = i * paddedBytesPerRow;
					var dstOffset = i * bytesPerRow;
					var sub = temp.subarray(srcOffset, srcOffset + bytesPerRow);
					data.set(sub, dstOffset);
				}
				return data;
			});
		};
		return WebgpuTexture;
	}();

	var WebgpuUniformBuffer = function (_WebgpuBuffer) {
		function WebgpuUniformBuffer(uniformBuffer) {
			return _WebgpuBuffer.call(this, BUFFERUSAGE_UNIFORM) || this;
		}
		_inheritsLoose(WebgpuUniformBuffer, _WebgpuBuffer);
		var _proto = WebgpuUniformBuffer.prototype;
		_proto.unlock = function unlock(uniformBuffer) {
			var device = uniformBuffer.device;
			_WebgpuBuffer.prototype.unlock.call(this, device, uniformBuffer.storageInt32.buffer);
		};
		return WebgpuUniformBuffer;
	}(WebgpuBuffer);

	var WebgpuVertexBuffer = function (_WebgpuBuffer) {
		function WebgpuVertexBuffer(vertexBuffer, format, options) {
			return _WebgpuBuffer.call(this, BUFFERUSAGE_VERTEX | (options != null && options.storage ? BUFFERUSAGE_STORAGE : 0)) || this;
		}
		_inheritsLoose(WebgpuVertexBuffer, _WebgpuBuffer);
		var _proto = WebgpuVertexBuffer.prototype;
		_proto.unlock = function unlock(vertexBuffer) {
			var device = vertexBuffer.device;
			_WebgpuBuffer.prototype.unlock.call(this, device, vertexBuffer.storage);
		};
		return WebgpuVertexBuffer;
	}(WebgpuBuffer);

	var KEYWORD = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension|include)/g;
	var DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;
	var EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;
	var UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;
	var IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;
	var ENDIF = /(endif|else|elif)([ \t][^\r\n]+)?\r?(?:\n|$)/g;
	var IDENTIFIER$1 = /([\w-]+)/;
	var DEFINED = /(!|\s)?defined\(([\w-]+)\)/;
	var COMPARISON = /([a-z_]\w*)\s*(==|!=|<|<=|>|>=)\s*([\w"']+)/i;
	var INVALID = /[|&+-]/g;
	var INCLUDE = /include[ \t]+"([\w-]+)"\r?(?:\n|$)/g;
	var Preprocessor = function () {
		function Preprocessor() {}
		Preprocessor.run = function run(source, includes, options) {
			if (includes === void 0) {
				includes = new Map();
			}
			if (options === void 0) {
				options = {};
			}
			source = this.stripComments(source);
			source = source.split(/\r?\n/).map(function (line) {
				return line.trimEnd();
			}).join('\n');
			var defines = new Map();
			if (options.stripUnusedColorAttachments) {
				var counts = new Map();
				var regex = /(pcFragColor[1-8])\b/g;
				var matches = source.match(regex);
				matches == null || matches.forEach(function (match) {
					var _counts$get;
					var index = parseInt(match.charAt(match.length - 1), 10);
					counts.set(index, ((_counts$get = counts.get(index)) != null ? _counts$get : 0) + 1);
				});
				counts.forEach(function (count, index) {
					if (count === 1) {
						defines.set("REMOVE_COLOR_ATTACHMENT_" + index, '');
					}
				});
			}
			source = this._preprocess(source, defines, includes, options.stripDefines);
			var intDefines = new Map();
			defines.forEach(function (value, key) {
				if (Number.isInteger(parseFloat(value)) && !value.includes('.')) {
					intDefines.set(key, value);
				}
			});
			source = this.stripComments(source);
			source = this.RemoveEmptyLines(source);
			source = this.processArraySize(source, intDefines);
			return source;
		};
		Preprocessor.stripComments = function stripComments(source) {
			return source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
		};
		Preprocessor.processArraySize = function processArraySize(source, intDefines) {
			if (source !== null) {
				intDefines.forEach(function (value, key) {
					source = source.replace(new RegExp("\\[" + key + "\\]", 'g'), "[" + value + "]");
				});
			}
			return source;
		};
		Preprocessor.RemoveEmptyLines = function RemoveEmptyLines(source) {
			if (source !== null) {
				source = source.split(/\r?\n/).map(function (line) {
					return line.trim() === '' ? '' : line;
				}).join('\n');
				source = source.replace(/(\n\n){3,}/g, '\n\n');
			}
			return source;
		};
		Preprocessor._preprocess = function _preprocess(source, defines, includes, stripDefines) {
			if (defines === void 0) {
				defines = new Map();
			}
			var originalSource = source;
			var stack = [];
			var error = false;
			var match;
			while ((match = KEYWORD.exec(source)) !== null) {
				var keyword = match[1];
				switch (keyword) {
					case 'define':
						{
							DEFINE.lastIndex = match.index;
							var define = DEFINE.exec(source);
							error || (error = define === null);
							var expression = define[1];
							IDENTIFIER$1.lastIndex = define.index;
							var identifierValue = IDENTIFIER$1.exec(expression);
							var identifier = identifierValue[1];
							var value = expression.substring(identifier.length).trim();
							if (value === '') value = 'true';
							var keep = Preprocessor._keep(stack);
							if (keep) {
								defines.set(identifier, value);
								if (stripDefines) {
									source = source.substring(0, define.index - 1) + source.substring(DEFINE.lastIndex);
									KEYWORD.lastIndex = define.index;
								}
							}
							if (!stripDefines) {
								KEYWORD.lastIndex = define.index + define[0].length;
							}
							break;
						}
					case 'undef':
						{
							UNDEF.lastIndex = match.index;
							var undef = UNDEF.exec(source);
							var _identifier = undef[1].trim();
							var _keep2 = Preprocessor._keep(stack);
							if (_keep2) {
								defines.delete(_identifier);
								if (stripDefines) {
									source = source.substring(0, undef.index - 1) + source.substring(UNDEF.lastIndex);
									KEYWORD.lastIndex = undef.index;
								}
							}
							if (!stripDefines) {
								KEYWORD.lastIndex = undef.index + undef[0].length;
							}
							break;
						}
					case 'extension':
						{
							EXTENSION.lastIndex = match.index;
							var extension = EXTENSION.exec(source);
							error || (error = extension === null);
							if (extension) {
								var _identifier2 = extension[1];
								var _keep3 = Preprocessor._keep(stack);
								if (_keep3) {
									defines.set(_identifier2, 'true');
								}
							}
							KEYWORD.lastIndex = extension.index + extension[0].length;
							break;
						}
					case 'ifdef':
					case 'ifndef':
					case 'if':
						{
							IF.lastIndex = match.index;
							var iff = IF.exec(source);
							var _expression = iff[2];
							var evaluated = Preprocessor.evaluate(_expression, defines);
							error || (error = evaluated.error);
							var result = evaluated.result;
							if (keyword === 'ifndef') {
								result = !result;
							}
							stack.push({
								anyKeep: result,
								keep: result,
								start: match.index,
								end: IF.lastIndex
							});
							KEYWORD.lastIndex = iff.index + iff[0].length;
							break;
						}
					case 'endif':
					case 'else':
					case 'elif':
						{
							ENDIF.lastIndex = match.index;
							var endif = ENDIF.exec(source);
							var blockInfo = stack.pop();
							var blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : '';
							source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
							KEYWORD.lastIndex = blockInfo.start + blockCode.length;
							var endifCommand = endif[1];
							if (endifCommand === 'else' || endifCommand === 'elif') {
								var _result = false;
								if (!blockInfo.anyKeep) {
									if (endifCommand === 'else') {
										_result = !blockInfo.keep;
									} else {
										var _evaluated = Preprocessor.evaluate(endif[2], defines);
										_result = _evaluated.result;
										error || (error = _evaluated.error);
									}
								}
								stack.push({
									anyKeep: blockInfo.anyKeep || _result,
									keep: _result,
									start: KEYWORD.lastIndex,
									end: KEYWORD.lastIndex
								});
							}
							break;
						}
					case 'include':
						{
							INCLUDE.lastIndex = match.index;
							var include = INCLUDE.exec(source);
							error || (error = include === null);
							var _identifier3 = include[1].trim();
							var _keep4 = Preprocessor._keep(stack);
							if (_keep4) {
								var includeSource = includes == null ? void 0 : includes.get(_identifier3);
								if (includeSource !== undefined) {
									source = source.substring(0, include.index - 1) + includeSource + source.substring(INCLUDE.lastIndex);
									KEYWORD.lastIndex = include.index;
								} else {
									console.error("Include \"" + _identifier3 + "\" not resolved while preprocessing a shader", {
										source: originalSource
									});
									error = true;
								}
							}
							break;
						}
				}
			}
			if (error) {
				console.warn('Failed to preprocess shader: ', {
					source: originalSource
				});
				return originalSource;
			}
			return source;
		};
		Preprocessor._keep = function _keep(stack) {
			for (var i = 0; i < stack.length; i++) {
				if (!stack[i].keep) {
					return false;
				}
			}
			return true;
		};
		Preprocessor.evaluate = function evaluate(expression, defines) {
			var correct = INVALID.exec(expression) === null;
			var invert = false;
			var defined = DEFINED.exec(expression);
			if (defined) {
				invert = defined[1] === '!';
				expression = defined[2];
			}
			var comparison = COMPARISON.exec(expression);
			if (comparison) {
				var _defines$get, _defines$get2;
				var left = (_defines$get = defines.get(comparison[1])) != null ? _defines$get : comparison[1];
				var right = (_defines$get2 = defines.get(comparison[3])) != null ? _defines$get2 : comparison[3];
				var operator = comparison[2];
				var result = false;
				switch (operator) {
					case '==':
						result = left === right;
						break;
					case '!=':
						result = left !== right;
						break;
					case '<':
						result = left < right;
						break;
					case '<=':
						result = left <= right;
						break;
					case '>':
						result = left > right;
						break;
					case '>=':
						result = left >= right;
						break;
				}
				return {
					result: result,
					error: !correct
				};
			}
			expression = expression.trim();
			var exists = defines.has(expression);
			if (invert) {
				exists = !exists;
			}
			return {
				result: exists,
				error: !correct
			};
		};
		return Preprocessor;
	}();

	var gles3PS = "\n#ifndef outType_0\n#define outType_0 vec4\n#endif\nlayout(location = 0) out highp outType_0 pc_fragColor;\n#ifndef REMOVE_COLOR_ATTACHMENT_1\n#if COLOR_ATTACHMENT_1\nlayout(location = 1) out highp outType_1 pc_fragColor1;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_2\n#if COLOR_ATTACHMENT_2\nlayout(location = 2) out highp outType_2 pc_fragColor2;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_3\n#if COLOR_ATTACHMENT_3\nlayout(location = 3) out highp outType_3 pc_fragColor3;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_4\n#if COLOR_ATTACHMENT_4\nlayout(location = 4) out highp outType_4 pc_fragColor4;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_5\n#if COLOR_ATTACHMENT_5\nlayout(location = 5) out highp outType_5 pc_fragColor5;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_6\n#if COLOR_ATTACHMENT_6\nlayout(location = 6) out highp outType_6 pc_fragColor6;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_7\n#if COLOR_ATTACHMENT_7\nlayout(location = 7) out highp outType_7 pc_fragColor7;\n#endif\n#endif\n#define gl_FragColor pc_fragColor\n#define pcFragColor0 pc_fragColor\n#define pcFragColor1 pc_fragColor1\n#define pcFragColor2 pc_fragColor2\n#define pcFragColor3 pc_fragColor3\n#define pcFragColor4 pc_fragColor4\n#define pcFragColor5 pc_fragColor5\n#define pcFragColor6 pc_fragColor6\n#define pcFragColor7 pc_fragColor7\n#define varying in\n#define texture2D texture\n#define texture2DBias texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLod textureLod\n#define texture2DProjLod textureProjLod\n#define textureCubeLod textureLod\n#define texture2DGrad textureGrad\n#define texture2DProjGrad textureProjGrad\n#define textureCubeGrad textureGrad\n#define utexture2D texture\n#define itexture2D texture\n#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead\n#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod\n#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead\n#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead\n#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead\n#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead\n#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2DShadow name\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n#define GL2\n";

	var gles3VS = "\n#define attribute in\n#define varying out\n#define texture2D texture\n#define utexture2D texture\n#define itexture2D texture\n#define GL2\n#define VERTEXSHADER\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n";

	var webgpuPS = "\n#extension GL_EXT_samplerless_texture_functions : require\n#ifndef outType_0\n#define outType_0 vec4\n#endif\n#ifndef outType_1\n#define outType_1 vec4\n#endif\n#ifndef outType_2\n#define outType_2 vec4\n#endif\n#ifndef outType_3\n#define outType_3 vec4\n#endif\n#ifndef outType_4\n#define outType_4 vec4\n#endif\n#ifndef outType_5\n#define outType_5 vec4\n#endif\n#ifndef outType_6\n#define outType_6 vec4\n#endif\n#ifndef outType_7\n#define outType_7 vec4\n#endif\nlayout(location = 0) out highp outType_0 pc_fragColor;\nlayout(location = 1) out highp outType_1 pc_fragColor1;\nlayout(location = 2) out highp outType_2 pc_fragColor2;\nlayout(location = 3) out highp outType_3 pc_fragColor3;\nlayout(location = 4) out highp outType_4 pc_fragColor4;\nlayout(location = 5) out highp outType_5 pc_fragColor5;\nlayout(location = 6) out highp outType_6 pc_fragColor6;\nlayout(location = 7) out highp outType_7 pc_fragColor7;\n#define gl_FragColor pc_fragColor\n#define pcFragColor0 pc_fragColor\n#define pcFragColor1 pc_fragColor1\n#define pcFragColor2 pc_fragColor2\n#define pcFragColor3 pc_fragColor3\n#define pcFragColor4 pc_fragColor4\n#define pcFragColor5 pc_fragColor5\n#define pcFragColor6 pc_fragColor6\n#define pcFragColor7 pc_fragColor7\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)\n#define texture2DLod(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)\n#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)\n#define textureCubeLod(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)\n#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead\n#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod\n#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead\n#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead\n#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead\n#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead\n#define SHADOWMAP_PASS(name) name, name ## _sampler\n#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n";

	var webgpuVS = "\n#extension GL_EXT_samplerless_texture_functions : require\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n#define VERTEXSHADER\n#define gl_VertexID gl_VertexIndex\n#define gl_InstanceID gl_InstanceIndex\n";

	var sharedFS = "\nvec2 getGrabScreenPos(vec4 clipPos) {\n\tvec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;\n\t#ifdef WEBGPU\n\t\tuv.y = 1.0 - uv.y;\n\t#endif\n\treturn uv;\n}\nvec2 getImageEffectUV(vec2 uv) {\n\t#ifdef WEBGPU\n\t\tuv.y = 1.0 - uv.y;\n\t#endif\n\treturn uv;\n}\n";

	var _attrib2Semantic = {
		vertex_position: SEMANTIC_POSITION,
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_texCoord2: SEMANTIC_TEXCOORD2,
		vertex_texCoord3: SEMANTIC_TEXCOORD3,
		vertex_texCoord4: SEMANTIC_TEXCOORD4,
		vertex_texCoord5: SEMANTIC_TEXCOORD5,
		vertex_texCoord6: SEMANTIC_TEXCOORD6,
		vertex_texCoord7: SEMANTIC_TEXCOORD7,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneIndices: SEMANTIC_BLENDINDICES,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT
	};
	var ShaderUtils = function () {
		function ShaderUtils() {}
		ShaderUtils.createDefinition = function createDefinition(device, options) {
			var _options$name;
			var getDefines = function getDefines(gpu, gl2, isVertex, options) {
				var deviceIntro = device.isWebGPU ? gpu : gl2;
				var attachmentsDefine = '';
				if (!isVertex) {
					var _options$fragmentOutp;
					var fragmentOutputTypes = (_options$fragmentOutp = options.fragmentOutputTypes) != null ? _options$fragmentOutp : 'vec4';
					if (!Array.isArray(fragmentOutputTypes)) {
						fragmentOutputTypes = [fragmentOutputTypes];
					}
					for (var i = 0; i < device.maxColorAttachments; i++) {
						var _fragmentOutputTypes$;
						attachmentsDefine += "#define COLOR_ATTACHMENT_" + i + "\n";
						var outType = (_fragmentOutputTypes$ = fragmentOutputTypes[i]) != null ? _fragmentOutputTypes$ : 'vec4';
						attachmentsDefine += "#define outType_" + i + " " + outType + "\n";
					}
				}
				return attachmentsDefine + deviceIntro;
			};
			var name = (_options$name = options.name) != null ? _options$name : 'Untitled';
			var vertCode;
			var fragCode;
			if (options.shaderLanguage === SHADERLANGUAGE_WGSL) {
				vertCode = options.vertexCode;
				fragCode = options.fragmentCode;
			} else {
				vertCode = ShaderUtils.versionCode(device) + getDefines(webgpuVS, gles3VS, true, options) + ShaderUtils.getDefinesCode(options.vertexDefines) + ShaderUtils.precisionCode(device) + "\n" + sharedFS + ShaderUtils.getShaderNameCode(name) + options.vertexCode;
				fragCode = (options.fragmentPreamble || '') + ShaderUtils.versionCode(device) + getDefines(webgpuPS, gles3PS, false, options) + ShaderUtils.getDefinesCode(options.fragmentDefines) + ShaderUtils.precisionCode(device) + "\n" + sharedFS + ShaderUtils.getShaderNameCode(name) + (options.fragmentCode || ShaderUtils.dummyFragmentCode());
			}
			return {
				name: name,
				shaderLanguage: options.shaderLanguage,
				attributes: options.attributes,
				vshader: vertCode,
				vincludes: options.vertexIncludes,
				fincludes: options.fragmentIncludes,
				fshader: fragCode,
				useTransformFeedback: options.useTransformFeedback,
				meshUniformBufferFormat: options.meshUniformBufferFormat,
				meshBindGroupFormat: options.meshBindGroupFormat
			};
		};
		ShaderUtils.getDefinesCode = function getDefinesCode(defines) {
			var code = '';
			defines == null || defines.forEach(function (value, key) {
				code += "#define " + key + " " + value + "\n";
			});
			return code;
		};
		ShaderUtils.getShaderNameCode = function getShaderNameCode(name) {
			return "#define SHADER_NAME " + name + "\n";
		};
		ShaderUtils.dummyFragmentCode = function dummyFragmentCode() {
			return 'void main(void) {gl_FragColor = vec4(0.0);}';
		};
		ShaderUtils.versionCode = function versionCode(device) {
			return device.isWebGPU ? '#version 450\n' : '#version 300 es\n';
		};
		ShaderUtils.precisionCode = function precisionCode(device, forcePrecision) {
			if (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {
				forcePrecision = null;
			}
			if (forcePrecision) {
				if (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {
					forcePrecision = 'mediump';
				}
				if (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {
					forcePrecision = 'lowp';
				}
			}
			var precision = forcePrecision ? forcePrecision : device.precision;
			var code = "\n            precision " + precision + " float;\n            precision " + precision + " int;\n            precision " + precision + " usampler2D;\n            precision " + precision + " isampler2D;\n            precision " + precision + " sampler2DShadow;\n            precision " + precision + " samplerCubeShadow;\n            precision " + precision + " sampler2DArray;\n        ";
			return code;
		};
		ShaderUtils.collectAttributes = function collectAttributes(vsCode) {
			var attribs = {};
			var attrs = 0;
			var found = vsCode.indexOf('attribute');
			while (found >= 0) {
				if (found > 0 && vsCode[found - 1] === '/') break;
				var ignore = false;
				if (found > 0) {
					var startOfLine = vsCode.lastIndexOf('\n', found);
					startOfLine = startOfLine !== -1 ? startOfLine + 1 : 0;
					var lineStartString = vsCode.substring(startOfLine, found);
					if (lineStartString.includes('#')) {
						ignore = true;
					}
				}
				if (!ignore) {
					var endOfLine = vsCode.indexOf(';', found);
					var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
					var attribName = vsCode.substring(startOfAttribName + 1, endOfLine);
					if (attribs[attribName]) ; else {
						var semantic = _attrib2Semantic[attribName];
						if (semantic !== undefined) {
							attribs[attribName] = semantic;
						} else {
							attribs[attribName] = "ATTR" + attrs;
							attrs++;
						}
					}
				}
				found = vsCode.indexOf('attribute', found + 1);
			}
			return attribs;
		};
		return ShaderUtils;
	}();

	var id$6 = 0;
	var Shader = function () {
		function Shader(graphicsDevice, definition) {
			this.meshUniformBufferFormat = void 0;
			this.meshBindGroupFormat = void 0;
			this.id = id$6++;
			this.device = graphicsDevice;
			this.definition = definition;
			this.name = definition.name || 'Untitled';
			this.init();
			if (definition.cshader) ; else {
				var _definition$attribute;
				definition.vshader = Preprocessor.run(definition.vshader, definition.vincludes);
				(_definition$attribute = definition.attributes) != null ? _definition$attribute : definition.attributes = ShaderUtils.collectAttributes(definition.vshader);
				var stripUnusedColorAttachments = graphicsDevice.isWebGL2 && (platform.name === 'osx' || platform.name === 'ios');
				definition.fshader = Preprocessor.run(definition.fshader, definition.fincludes, {
					stripUnusedColorAttachments: stripUnusedColorAttachments
				});
			}
			this.impl = graphicsDevice.createShaderImpl(this);
		}
		var _proto = Shader.prototype;
		_proto.init = function init() {
			this.ready = false;
			this.failed = false;
		};
		_proto.destroy = function destroy() {
			this.device.onDestroyShader(this);
			this.impl.destroy(this);
		};
		_proto.loseContext = function loseContext() {
			this.init();
			this.impl.loseContext();
		};
		_proto.restoreContext = function restoreContext() {
			this.impl.restoreContext(this.device, this);
		};
		return _createClass(Shader, [{
			key: "label",
			get: function get() {
				return "Shader Id " + this.id + " " + this.name;
			}
		}]);
	}();

	var UsedBuffer = function UsedBuffer() {
		this.gpuBuffer = void 0;
		this.stagingBuffer = void 0;
		this.offset = void 0;
		this.size = void 0;
	};
	var DynamicBufferAllocation = function DynamicBufferAllocation() {
		this.storage = void 0;
		this.gpuBuffer = void 0;
		this.offset = void 0;
	};
	var DynamicBuffers = function () {
		function DynamicBuffers(device, bufferSize, bufferAlignment) {
			this.bufferSize = void 0;
			this.gpuBuffers = [];
			this.stagingBuffers = [];
			this.usedBuffers = [];
			this.activeBuffer = null;
			this.device = device;
			this.bufferSize = bufferSize;
			this.bufferAlignment = bufferAlignment;
		}
		var _proto = DynamicBuffers.prototype;
		_proto.destroy = function destroy() {
			var _this = this;
			this.gpuBuffers.forEach(function (gpuBuffer) {
				gpuBuffer.destroy(_this.device);
			});
			this.gpuBuffers = null;
			this.stagingBuffers.forEach(function (stagingBuffer) {
				stagingBuffer.destroy(_this.device);
			});
			this.stagingBuffers = null;
			this.usedBuffers = null;
			this.activeBuffer = null;
		};
		_proto.alloc = function alloc(allocation, size) {
			if (this.activeBuffer) {
				var _alignedStart = math.roundUp(this.activeBuffer.size, this.bufferAlignment);
				var space = this.bufferSize - _alignedStart;
				if (space < size) {
					this.scheduleSubmit();
				}
			}
			if (!this.activeBuffer) {
				var gpuBuffer = this.gpuBuffers.pop();
				if (!gpuBuffer) {
					gpuBuffer = this.createBuffer(this.device, this.bufferSize, false);
				}
				var stagingBuffer = this.stagingBuffers.pop();
				if (!stagingBuffer) {
					stagingBuffer = this.createBuffer(this.device, this.bufferSize, true);
				}
				this.activeBuffer = new UsedBuffer();
				this.activeBuffer.stagingBuffer = stagingBuffer;
				this.activeBuffer.gpuBuffer = gpuBuffer;
				this.activeBuffer.offset = 0;
				this.activeBuffer.size = 0;
			}
			var activeBuffer = this.activeBuffer;
			var alignedStart = math.roundUp(activeBuffer.size, this.bufferAlignment);
			allocation.gpuBuffer = activeBuffer.gpuBuffer;
			allocation.offset = alignedStart;
			allocation.storage = activeBuffer.stagingBuffer.alloc(alignedStart, size);
			activeBuffer.size = alignedStart + size;
		};
		_proto.scheduleSubmit = function scheduleSubmit() {
			if (this.activeBuffer) {
				this.usedBuffers.push(this.activeBuffer);
				this.activeBuffer = null;
			}
		};
		_proto.submit = function submit() {
			this.scheduleSubmit();
		};
		return DynamicBuffers;
	}();

	var _updateFunctions = [];
	_updateFunctions[UNIFORMTYPE_FLOAT] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value;
	};
	_updateFunctions[UNIFORMTYPE_VEC2] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
	};
	_updateFunctions[UNIFORMTYPE_VEC3] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
	};
	_updateFunctions[UNIFORMTYPE_VEC4] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
	};
	_updateFunctions[UNIFORMTYPE_INT] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value;
	};
	_updateFunctions[UNIFORMTYPE_IVEC2] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
	};
	_updateFunctions[UNIFORMTYPE_IVEC3] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
	};
	_updateFunctions[UNIFORMTYPE_IVEC4] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageInt32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
	};
	_updateFunctions[UNIFORMTYPE_MAT2] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 4] = value[2];
		dst[offset + 5] = value[3];
		dst[offset + 8] = value[4];
		dst[offset + 9] = value[5];
	};
	_updateFunctions[UNIFORMTYPE_MAT3] = function (uniformBuffer, value, offset) {
		var dst = uniformBuffer.storageFloat32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 4] = value[3];
		dst[offset + 5] = value[4];
		dst[offset + 6] = value[5];
		dst[offset + 8] = value[6];
		dst[offset + 9] = value[7];
		dst[offset + 10] = value[8];
	};
	_updateFunctions[UNIFORMTYPE_FLOATARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageFloat32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i];
		}
	};
	_updateFunctions[UNIFORMTYPE_VEC2ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageFloat32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 2];
			dst[offset + i * 4 + 1] = value[i * 2 + 1];
		}
	};
	_updateFunctions[UNIFORMTYPE_VEC3ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageFloat32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 3];
			dst[offset + i * 4 + 1] = value[i * 3 + 1];
			dst[offset + i * 4 + 2] = value[i * 3 + 2];
		}
	};
	_updateFunctions[UNIFORMTYPE_UINT] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value;
	};
	_updateFunctions[UNIFORMTYPE_UVEC2] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
	};
	_updateFunctions[UNIFORMTYPE_UVEC3] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
	};
	_updateFunctions[UNIFORMTYPE_UVEC4] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		dst[offset] = value[0];
		dst[offset + 1] = value[1];
		dst[offset + 2] = value[2];
		dst[offset + 3] = value[3];
	};
	_updateFunctions[UNIFORMTYPE_INTARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageInt32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i];
		}
	};
	_updateFunctions[UNIFORMTYPE_BOOLARRAY] = _updateFunctions[UNIFORMTYPE_INTARRAY];
	_updateFunctions[UNIFORMTYPE_UINTARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i];
		}
	};
	_updateFunctions[UNIFORMTYPE_IVEC2ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageInt32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 2];
			dst[offset + i * 4 + 1] = value[i * 2 + 1];
		}
	};
	_updateFunctions[UNIFORMTYPE_BVEC2ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC2ARRAY];
	_updateFunctions[UNIFORMTYPE_UVEC2ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 2];
			dst[offset + i * 4 + 1] = value[i * 2 + 1];
		}
	};
	_updateFunctions[UNIFORMTYPE_IVEC3ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageInt32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 3];
			dst[offset + i * 4 + 1] = value[i * 3 + 1];
			dst[offset + i * 4 + 2] = value[i * 3 + 2];
		}
	};
	_updateFunctions[UNIFORMTYPE_BVEC3ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC3ARRAY];
	_updateFunctions[UNIFORMTYPE_UVEC3ARRAY] = function (uniformBuffer, value, offset, count) {
		var dst = uniformBuffer.storageUint32;
		for (var i = 0; i < count; i++) {
			dst[offset + i * 4] = value[i * 3];
			dst[offset + i * 4 + 1] = value[i * 3 + 1];
			dst[offset + i * 4 + 2] = value[i * 3 + 2];
		}
	};
	var UniformBuffer = function () {
		function UniformBuffer(graphicsDevice, format, persistent) {
			if (persistent === void 0) {
				persistent = true;
			}
			this.device = void 0;
			this.persistent = void 0;
			this.allocation = void 0;
			this.storageFloat32 = void 0;
			this.storageInt32 = void 0;
			this.storageUint32 = void 0;
			this.renderVersionDirty = 0;
			this.device = graphicsDevice;
			this.format = format;
			this.persistent = persistent;
			if (persistent) {
				this.impl = graphicsDevice.createUniformBufferImpl(this);
				var storage = new ArrayBuffer(format.byteSize);
				this.assignStorage(new Int32Array(storage));
				graphicsDevice._vram.ub += this.format.byteSize;
			} else {
				this.allocation = new DynamicBufferAllocation();
			}
		}
		var _proto = UniformBuffer.prototype;
		_proto.destroy = function destroy() {
			if (this.persistent) {
				var device = this.device;
				this.impl.destroy(device);
				device._vram.ub -= this.format.byteSize;
			}
		};
		_proto.assignStorage = function assignStorage(storage) {
			this.storageInt32 = storage;
			this.storageUint32 = new Uint32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
			this.storageFloat32 = new Float32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
		};
		_proto.loseContext = function loseContext() {
			var _this$impl;
			(_this$impl = this.impl) == null || _this$impl.loseContext();
		};
		_proto.setUniform = function setUniform(uniformFormat, value) {
			var offset = uniformFormat.offset;
			if (value !== null && value !== undefined) {
				var updateFunction = _updateFunctions[uniformFormat.updateType];
				if (updateFunction) {
					updateFunction(this, value, offset, uniformFormat.count);
				} else {
					this.storageFloat32.set(value, offset);
				}
			}
		};
		_proto.set = function set(name, value) {
			var uniformFormat = this.format.map.get(name);
			if (uniformFormat) {
				this.setUniform(uniformFormat, value);
			}
		};
		_proto.startUpdate = function startUpdate(dynamicBindGroup) {
			if (!this.persistent) {
				var allocation = this.allocation;
				var oldGpuBuffer = allocation.gpuBuffer;
				this.device.dynamicBuffers.alloc(allocation, this.format.byteSize);
				this.assignStorage(allocation.storage);
				if (dynamicBindGroup) {
					dynamicBindGroup.bindGroup = allocation.gpuBuffer.getBindGroup(this);
					dynamicBindGroup.offsets[0] = allocation.offset;
				}
				if (oldGpuBuffer !== allocation.gpuBuffer) {
					this.renderVersionDirty = this.device.renderVersion;
				}
			}
		};
		_proto.endUpdate = function endUpdate() {
			if (this.persistent) {
				this.impl.unlock(this);
			} else {
				this.storageFloat32 = null;
				this.storageInt32 = null;
			}
		};
		_proto.update = function update(dynamicBindGroup) {
			this.startUpdate(dynamicBindGroup);
			var uniforms = this.format.uniforms;
			for (var i = 0; i < uniforms.length; i++) {
				var value = uniforms[i].scopeId.value;
				this.setUniform(uniforms[i], value);
			}
			this.endUpdate();
		};
		return _createClass(UniformBuffer, [{
			key: "offset",
			get: function get() {
				return this.persistent ? 0 : this.allocation.offset;
			}
		}]);
	}();

	var primitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};
	var WebgpuClearRenderer = function () {
		function WebgpuClearRenderer(device) {
			var code = "\n\n            struct ub_mesh {\n                color : vec4f,\n                depth: f32\n            }\n\n            @group(2) @binding(0) var<uniform> ubMesh : ub_mesh;\n\n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0),\n                vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f\n            }\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                var output : VertexOutput;\n                output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);\n                return output;\n            }\n\n            @fragment\n            fn fragmentMain() -> @location(0) vec4f {\n                return ubMesh.color;\n            }\n        ";
			this.shader = new Shader(device, {
				name: 'WebGPUClearRendererShader',
				shaderLanguage: SHADERLANGUAGE_WGSL,
				vshader: code,
				fshader: code
			});
			this.uniformBuffer = new UniformBuffer(device, new UniformBufferFormat(device, [new UniformFormat('color', UNIFORMTYPE_VEC4), new UniformFormat('depth', UNIFORMTYPE_FLOAT)]), false);
			this.dynamicBindGroup = new DynamicBindGroup();
			this.colorData = new Float32Array(4);
		}
		var _proto = WebgpuClearRenderer.prototype;
		_proto.destroy = function destroy() {
			this.shader.destroy();
			this.shader = null;
			this.uniformBuffer.destroy();
			this.uniformBuffer = null;
		};
		_proto.clear = function clear(device, renderTarget, options, defaultOptions) {
			var _options$flags;
			options = options || defaultOptions;
			var flags = (_options$flags = options.flags) != null ? _options$flags : defaultOptions.flags;
			if (flags !== 0) {
				var uniformBuffer = this.uniformBuffer,
					dynamicBindGroup = this.dynamicBindGroup;
				uniformBuffer.startUpdate(dynamicBindGroup);
				device.setBindGroup(BINDGROUP_MESH_UB, dynamicBindGroup.bindGroup, dynamicBindGroup.offsets);
				device.setBindGroup(BINDGROUP_MESH, device.emptyBindGroup);
				if (flags & CLEARFLAG_COLOR && (renderTarget.colorBuffer || renderTarget.impl.assignedColorTexture)) {
					var _options$color;
					var color = (_options$color = options.color) != null ? _options$color : defaultOptions.color;
					this.colorData.set(color);
					device.setBlendState(BlendState.NOBLEND);
				} else {
					device.setBlendState(BlendState.NOWRITE);
				}
				uniformBuffer.set('color', this.colorData);
				if (flags & CLEARFLAG_DEPTH && renderTarget.depth) {
					var _options$depth;
					var depth = (_options$depth = options.depth) != null ? _options$depth : defaultOptions.depth;
					uniformBuffer.set('depth', depth);
					device.setDepthState(DepthState.WRITEDEPTH);
				} else {
					uniformBuffer.set('depth', 1);
					device.setDepthState(DepthState.NODEPTH);
				}
				if (flags & CLEARFLAG_STENCIL && renderTarget.stencil) ;
				uniformBuffer.endUpdate();
				device.setCullMode(CULLFACE_NONE);
				device.setShader(this.shader);
				device.draw(primitive);
			}
		};
		return WebgpuClearRenderer;
	}();

	var WebgpuMipmapRenderer = function () {
		function WebgpuMipmapRenderer(device) {
			this.device = void 0;
			this.device = device;
			var code = "\n \n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0),\n                vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f,\n                @location(0) texCoord : vec2f\n            };\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n              var output : VertexOutput;\n              output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);\n              output.position = vec4f(pos[vertexIndex], 0, 1);\n              return output;\n            }\n\n            @group(0) @binding(0) var imgSampler : sampler;\n            @group(0) @binding(1) var img : texture_2d<f32>;\n\n            @fragment\n            fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {\n              return textureSample(img, imgSampler, texCoord);\n            }\n        ";
			this.shader = new Shader(device, {
				name: 'WebGPUMipmapRendererShader',
				shaderLanguage: SHADERLANGUAGE_WGSL,
				vshader: code,
				fshader: code
			});
			this.minSampler = device.wgpu.createSampler({
				minFilter: 'linear'
			});
		}
		var _proto = WebgpuMipmapRenderer.prototype;
		_proto.destroy = function destroy() {
			this.shader.destroy();
			this.shader = null;
		};
		_proto.generate = function generate(webgpuTexture) {
			var textureDescr = webgpuTexture.desc;
			if (textureDescr.mipLevelCount <= 1) {
				return;
			}
			if (webgpuTexture.texture.volume) {
				return;
			}
			var device = this.device;
			var wgpu = device.wgpu;
			var webgpuShader = this.shader.impl;
			var pipeline = wgpu.createRenderPipeline({
				layout: 'auto',
				vertex: {
					module: webgpuShader.getVertexShaderModule(),
					entryPoint: webgpuShader.vertexEntryPoint
				},
				fragment: {
					module: webgpuShader.getFragmentShaderModule(),
					entryPoint: webgpuShader.fragmentEntryPoint,
					targets: [{
						format: textureDescr.format
					}]
				},
				primitive: {
					topology: 'triangle-strip'
				}
			});
			var texture = webgpuTexture.texture;
			var numFaces = texture.cubemap ? 6 : texture.array ? texture.arrayLength : 1;
			var srcViews = [];
			for (var face = 0; face < numFaces; face++) {
				srcViews.push(webgpuTexture.createView({
					dimension: '2d',
					baseMipLevel: 0,
					mipLevelCount: 1,
					baseArrayLayer: face
				}));
			}
			var commandEncoder = device.getCommandEncoder();
			for (var i = 1; i < textureDescr.mipLevelCount; i++) {
				for (var _face = 0; _face < numFaces; _face++) {
					var dstView = webgpuTexture.createView({
						dimension: '2d',
						baseMipLevel: i,
						mipLevelCount: 1,
						baseArrayLayer: _face
					});
					var passEncoder = commandEncoder.beginRenderPass({
						colorAttachments: [{
							view: dstView,
							loadOp: 'clear',
							storeOp: 'store'
						}]
					});
					var bindGroup = wgpu.createBindGroup({
						layout: pipeline.getBindGroupLayout(0),
						entries: [{
							binding: 0,
							resource: this.minSampler
						}, {
							binding: 1,
							resource: srcViews[_face]
						}]
					});
					passEncoder.setPipeline(pipeline);
					passEncoder.setBindGroup(0, bindGroup);
					passEncoder.draw(4);
					passEncoder.end();
					srcViews[_face] = dstView;
				}
			}
			device.pipeline = null;
		};
		return WebgpuMipmapRenderer;
	}();

	var DynamicBuffer = function () {
		function DynamicBuffer(device) {
			this.device = void 0;
			this.bindGroupCache = new Map();
			this.device = device;
			this.bindGroupFormat = new BindGroupFormat(this.device, [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)]);
		}
		var _proto = DynamicBuffer.prototype;
		_proto.getBindGroup = function getBindGroup(ub) {
			var ubSize = ub.format.byteSize;
			var bindGroup = this.bindGroupCache.get(ubSize);
			if (!bindGroup) {
				bindGroup = new BindGroup(this.device, this.bindGroupFormat, ub);
				bindGroup.update();
				this.bindGroupCache.set(ubSize, bindGroup);
			}
			return bindGroup;
		};
		return DynamicBuffer;
	}();

	var WebgpuDynamicBuffer = function (_DynamicBuffer) {
		function WebgpuDynamicBuffer(device, size, isStaging) {
			var _this;
			_this = _DynamicBuffer.call(this, device) || this;
			_this.buffer = null;
			_this.mappedRange = null;
			_this.buffer = device.wgpu.createBuffer({
				size: size,
				usage: isStaging ? GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
				mappedAtCreation: isStaging
			});
			if (isStaging) {
				_this.onAvailable();
			}
			device._vram.ub += size;
			return _this;
		}
		_inheritsLoose(WebgpuDynamicBuffer, _DynamicBuffer);
		var _proto = WebgpuDynamicBuffer.prototype;
		_proto.destroy = function destroy(device) {
			device._vram.ub -= this.buffer.size;
			this.buffer.destroy();
			this.buffer = null;
		};
		_proto.onAvailable = function onAvailable() {
			this.mappedRange = this.buffer.getMappedRange();
		};
		_proto.alloc = function alloc(offset, size) {
			return new Int32Array(this.mappedRange, offset, size / 4);
		};
		return WebgpuDynamicBuffer;
	}(DynamicBuffer);

	var WebgpuDynamicBuffers = function (_DynamicBuffers) {
		function WebgpuDynamicBuffers() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _DynamicBuffers.call.apply(_DynamicBuffers, [this].concat(args)) || this;
			_this.pendingStagingBuffers = [];
			return _this;
		}
		_inheritsLoose(WebgpuDynamicBuffers, _DynamicBuffers);
		var _proto = WebgpuDynamicBuffers.prototype;
		_proto.createBuffer = function createBuffer(device, size, isStaging) {
			return new WebgpuDynamicBuffer(device, size, isStaging);
		};
		_proto.submit = function submit() {
			_DynamicBuffers.prototype.submit.call(this);
			var count = this.usedBuffers.length;
			if (count) {
				var device = this.device;
				var gpuBuffers = this.gpuBuffers;
				var commandEncoder = device.wgpu.createCommandEncoder();
				for (var i = count - 1; i >= 0; i--) {
					var usedBuffer = this.usedBuffers[i];
					var stagingBuffer = usedBuffer.stagingBuffer,
						gpuBuffer = usedBuffer.gpuBuffer,
						offset = usedBuffer.offset,
						size = usedBuffer.size;
					var src = stagingBuffer.buffer;
					src.unmap();
					commandEncoder.copyBufferToBuffer(src, offset, gpuBuffer.buffer, offset, size);
					gpuBuffers.push(gpuBuffer);
				}
				var cb = commandEncoder.finish();
				device.addCommandBuffer(cb, true);
				for (var _i = 0; _i < count; _i++) {
					var _stagingBuffer = this.usedBuffers[_i].stagingBuffer;
					this.pendingStagingBuffers.push(_stagingBuffer);
				}
				this.usedBuffers.length = 0;
			}
		};
		_proto.onCommandBuffersSubmitted = function onCommandBuffersSubmitted() {
			var _this2 = this;
			var count = this.pendingStagingBuffers.length;
			if (count) {
				var _loop = function _loop() {
					var stagingBuffer = _this2.pendingStagingBuffers[i];
					stagingBuffer.buffer.mapAsync(GPUMapMode.WRITE).then(function () {
						if (_this2.stagingBuffers) {
							stagingBuffer.onAvailable();
							_this2.stagingBuffers.push(stagingBuffer);
						}
					});
				};
				for (var i = 0; i < count; i++) {
					_loop();
				}
				this.pendingStagingBuffers.length = 0;
			}
		};
		return WebgpuDynamicBuffers;
	}(DynamicBuffers);

	var GpuProfiler = function () {
		function GpuProfiler() {
			this.frameAllocations = [];
			this.pastFrameAllocations = new Map();
			this._enabled = false;
			this._enableRequest = false;
			this._frameTime = 0;
		}
		var _proto = GpuProfiler.prototype;
		_proto.loseContext = function loseContext() {
			this.pastFrameAllocations.clear();
		};
		_proto.processEnableRequest = function processEnableRequest() {
			if (this._enableRequest !== this._enabled) {
				this._enabled = this._enableRequest;
				if (!this._enabled) {
					this._frameTime = 0;
				}
			}
		};
		_proto.request = function request(renderVersion) {
			this.pastFrameAllocations.set(renderVersion, this.frameAllocations);
			this.frameAllocations = [];
		};
		_proto.report = function report(renderVersion, timings) {
			if (timings) {
				var allocations = this.pastFrameAllocations.get(renderVersion);
				if (timings.length > 0) {
					this._frameTime = timings[0];
				}
				if (Tracing.get(TRACEID_GPU_TIMINGS)) {
					var total = 0;
					for (var i = 0; i < allocations.length; ++i) {
						allocations[i];
						total += timings[i];
					}
				}
			}
			this.pastFrameAllocations.delete(renderVersion);
		};
		_proto.getSlot = function getSlot(name) {
			var slot = this.frameAllocations.length;
			this.frameAllocations.push(name);
			return slot;
		};
		return _createClass(GpuProfiler, [{
			key: "enabled",
			get: function get() {
				return this._enableRequest;
			},
			set: function set(value) {
				this._enableRequest = value;
			}
		}, {
			key: "slotCount",
			get: function get() {
				return this.frameAllocations.length;
			}
		}]);
	}();

	var WebgpuQuerySet = function () {
		function WebgpuQuerySet(device, isTimestamp, capacity) {
			this.querySet = void 0;
			this.stagingBuffers = [];
			this.activeStagingBuffer = null;
			this.bytesPerSlot = void 0;
			this.device = device;
			this.capacity = capacity;
			this.bytesPerSlot = isTimestamp ? 8 : 4;
			var wgpu = device.wgpu;
			this.querySet = wgpu.createQuerySet({
				type: isTimestamp ? 'timestamp' : 'occlusion',
				count: capacity
			});
			this.queryBuffer = wgpu.createBuffer({
				size: this.bytesPerSlot * capacity,
				usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
			});
		}
		var _proto = WebgpuQuerySet.prototype;
		_proto.destroy = function destroy() {
			var _this$querySet, _this$queryBuffer;
			(_this$querySet = this.querySet) == null || _this$querySet.destroy();
			this.querySet = null;
			(_this$queryBuffer = this.queryBuffer) == null || _this$queryBuffer.destroy();
			this.queryBuffer = null;
			this.activeStagingBuffer = null;
			this.stagingBuffers.forEach(function (stagingBuffer) {
				stagingBuffer.destroy();
			});
			this.stagingBuffers = null;
		};
		_proto.getStagingBuffer = function getStagingBuffer() {
			var stagingBuffer = this.stagingBuffers.pop();
			if (!stagingBuffer) {
				stagingBuffer = this.device.wgpu.createBuffer({
					size: this.queryBuffer.size,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
				});
			}
			return stagingBuffer;
		};
		_proto.resolve = function resolve(count) {
			var device = this.device;
			var commandEncoder = device.getCommandEncoder();
			commandEncoder.resolveQuerySet(this.querySet, 0, count, this.queryBuffer, 0);
			var activeStagingBuffer = this.getStagingBuffer();
			this.activeStagingBuffer = activeStagingBuffer;
			commandEncoder.copyBufferToBuffer(this.queryBuffer, 0, activeStagingBuffer, 0, this.bytesPerSlot * count);
		};
		_proto.request = function request(count, renderVersion) {
			var _this = this;
			var stagingBuffer = this.activeStagingBuffer;
			this.activeStagingBuffer = null;
			return stagingBuffer.mapAsync(GPUMapMode.READ).then(function () {
				var _this$stagingBuffers;
				var srcTimings = new BigInt64Array(stagingBuffer.getMappedRange());
				var timings = [];
				for (var i = 0; i < count; i++) {
					timings.push(Number(srcTimings[i * 2 + 1] - srcTimings[i * 2]) * 0.000001);
				}
				stagingBuffer.unmap();
				(_this$stagingBuffers = _this.stagingBuffers) == null || _this$stagingBuffers.push(stagingBuffer);
				return {
					renderVersion: renderVersion,
					timings: timings
				};
			});
		};
		return WebgpuQuerySet;
	}();

	var WebgpuGpuProfiler = function (_GpuProfiler) {
		function WebgpuGpuProfiler(device) {
			var _this;
			_this = _GpuProfiler.call(this) || this;
			_this.device = void 0;
			_this.frameGPUMarkerSlot = void 0;
			_this.device = device;
			_this.timestampQueriesSet = device.supportsTimestampQuery ? new WebgpuQuerySet(device, true, 512) : null;
			return _this;
		}
		_inheritsLoose(WebgpuGpuProfiler, _GpuProfiler);
		var _proto = WebgpuGpuProfiler.prototype;
		_proto.destroy = function destroy() {
			var _this$timestampQuerie;
			(_this$timestampQuerie = this.timestampQueriesSet) == null || _this$timestampQuerie.destroy();
			this.timestampQueriesSet = null;
		};
		_proto.frameStart = function frameStart() {
			this.processEnableRequest();
		};
		_proto.frameEnd = function frameEnd() {
			if (this._enabled) {
				var _this$timestampQuerie2;
				(_this$timestampQuerie2 = this.timestampQueriesSet) == null || _this$timestampQuerie2.resolve(this.slotCount * 2);
			}
		};
		_proto.request = function request() {
			var _this2 = this;
			if (this._enabled) {
				var _this$timestampQuerie3;
				var renderVersion = this.device.renderVersion;
				(_this$timestampQuerie3 = this.timestampQueriesSet) == null || _this$timestampQuerie3.request(this.slotCount, renderVersion).then(function (results) {
					_this2.report(results.renderVersion, results.timings);
				});
				_GpuProfiler.prototype.request.call(this, renderVersion);
			}
		};
		return WebgpuGpuProfiler;
	}(GpuProfiler);

	var WebgpuResolver = function () {
		function WebgpuResolver(device) {
			this.device = void 0;
			this.pipelineCache = new Map();
			this.device = device;
			var code = "\n \n            var<private> pos : array<vec2f, 4> = array<vec2f, 4>(\n                vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)\n            );\n\n            struct VertexOutput {\n                @builtin(position) position : vec4f,\n            };\n\n            @vertex\n            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n              var output : VertexOutput;\n              output.position = vec4f(pos[vertexIndex], 0, 1);\n              return output;\n            }\n\n            @group(0) @binding(0) var img : texture_depth_multisampled_2d;\n\n            @fragment\n            fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {\n                // load th depth value from sample index 0\n                var depth = textureLoad(img, vec2i(fragColor.xy), 0u);\n                return vec4<f32>(depth, 0.0, 0.0, 0.0);\n            }\n        ";
			this.shader = new Shader(device, {
				name: 'WebGPUResolverDepthShader',
				shaderLanguage: SHADERLANGUAGE_WGSL,
				vshader: code,
				fshader: code
			});
		}
		var _proto = WebgpuResolver.prototype;
		_proto.destroy = function destroy() {
			this.shader.destroy();
			this.shader = null;
			this.pipelineCache = null;
		};
		_proto.getPipeline = function getPipeline(format) {
			var pipeline = this.pipelineCache.get(format);
			if (!pipeline) {
				pipeline = this.createPipeline(format);
				this.pipelineCache.set(format, pipeline);
			}
			return pipeline;
		};
		_proto.createPipeline = function createPipeline(format) {
			var webgpuShader = this.shader.impl;
			var pipeline = this.device.wgpu.createRenderPipeline({
				layout: 'auto',
				vertex: {
					module: webgpuShader.getVertexShaderModule(),
					entryPoint: webgpuShader.vertexEntryPoint
				},
				fragment: {
					module: webgpuShader.getFragmentShaderModule(),
					entryPoint: webgpuShader.fragmentEntryPoint,
					targets: [{
						format: format
					}]
				},
				primitive: {
					topology: 'triangle-strip'
				}
			});
			return pipeline;
		};
		_proto.resolveDepth = function resolveDepth(commandEncoder, sourceTexture, destinationTexture) {
			var device = this.device;
			var wgpu = device.wgpu;
			var pipeline = this.getPipeline(destinationTexture.format);
			var numFaces = sourceTexture.depthOrArrayLayers;
			for (var face = 0; face < numFaces; face++) {
				var srcView = sourceTexture.createView({
					dimension: '2d',
					aspect: 'depth-only',
					baseMipLevel: 0,
					mipLevelCount: 1,
					baseArrayLayer: face
				});
				var dstView = destinationTexture.createView({
					dimension: '2d',
					baseMipLevel: 0,
					mipLevelCount: 1,
					baseArrayLayer: face
				});
				var passEncoder = commandEncoder.beginRenderPass({
					colorAttachments: [{
						view: dstView,
						loadOp: 'clear',
						storeOp: 'store'
					}]
				});
				var bindGroup = wgpu.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [{
						binding: 0,
						resource: srcView
					}]
				});
				passEncoder.setPipeline(pipeline);
				passEncoder.setBindGroup(0, bindGroup);
				passEncoder.draw(4);
				passEncoder.end();
			}
			device.pipeline = null;
		};
		return WebgpuResolver;
	}();

	var WebgpuCompute = function () {
		function WebgpuCompute(compute) {
			this.uniformBuffers = [];
			this.bindGroup = null;
			this.compute = compute;
			var device = compute.device,
				shader = compute.shader;
			var _shader$impl = shader.impl,
				computeBindGroupFormat = _shader$impl.computeBindGroupFormat,
				computeUniformBufferFormats = _shader$impl.computeUniformBufferFormats;
			this.bindGroup = new BindGroup(device, computeBindGroupFormat);
			if (computeUniformBufferFormats) {
				for (var name in computeUniformBufferFormats) {
					if (computeUniformBufferFormats.hasOwnProperty(name)) {
						var ub = new UniformBuffer(device, computeUniformBufferFormats[name], true);
						this.uniformBuffers.push(ub);
						this.bindGroup.setUniformBuffer(name, ub);
					}
				}
			}
			this.pipeline = device.computePipeline.get(shader, computeBindGroupFormat);
		}
		var _proto = WebgpuCompute.prototype;
		_proto.destroy = function destroy() {
			this.uniformBuffers.forEach(function (ub) {
				return ub.destroy();
			});
			this.uniformBuffers.length = 0;
			this.bindGroup.destroy();
			this.bindGroup = null;
		};
		_proto.updateBindGroup = function updateBindGroup() {
			var bindGroup = this.bindGroup;
			bindGroup.updateUniformBuffers();
			bindGroup.update();
		};
		_proto.dispatch = function dispatch(x, y, z) {
			var device = this.compute.device;
			device.setBindGroup(0, this.bindGroup);
			var passEncoder = device.passEncoder;
			passEncoder.setPipeline(this.pipeline);
			passEncoder.dispatchWorkgroups(x, y, z);
		};
		return WebgpuCompute;
	}();

	var _uniqueLocations = new Map();
	var WebgpuGraphicsDevice = function (_GraphicsDevice) {
		function WebgpuGraphicsDevice(canvas, options) {
			var _options$alpha, _options$antialias;
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _GraphicsDevice.call(this, canvas, options) || this;
			_this.renderPipeline = new WebgpuRenderPipeline(_this);
			_this.computePipeline = new WebgpuComputePipeline(_this);
			_this.clearRenderer = void 0;
			_this.mipmapRenderer = void 0;
			_this.pipeline = void 0;
			_this.bindGroupFormats = [];
			_this.emptyBindGroup = void 0;
			_this.commandEncoder = null;
			_this.commandBuffers = [];
			_this.limits = void 0;
			options = _this.initOptions;
			options.alpha = (_options$alpha = options.alpha) != null ? _options$alpha : true;
			_this.backBufferAntialias = (_options$antialias = options.antialias) != null ? _options$antialias : false;
			_this.isWebGPU = true;
			_this._deviceType = DEVICETYPE_WEBGPU;
			return _this;
		}
		_inheritsLoose(WebgpuGraphicsDevice, _GraphicsDevice);
		var _proto = WebgpuGraphicsDevice.prototype;
		_proto.destroy = function destroy() {
			this.clearRenderer.destroy();
			this.clearRenderer = null;
			this.mipmapRenderer.destroy();
			this.mipmapRenderer = null;
			this.resolver.destroy();
			this.resolver = null;
			_GraphicsDevice.prototype.destroy.call(this);
		};
		_proto.initDeviceCaps = function initDeviceCaps() {
			var _this$wgpu;
			var limits = (_this$wgpu = this.wgpu) == null ? void 0 : _this$wgpu.limits;
			this.limits = limits;
			this.precision = 'highp';
			this.maxPrecision = 'highp';
			this.maxSamples = 4;
			this.maxTextures = 16;
			this.maxTextureSize = limits.maxTextureDimension2D;
			this.maxCubeMapSize = limits.maxTextureDimension2D;
			this.maxVolumeSize = limits.maxTextureDimension3D;
			this.maxColorAttachments = limits.maxColorAttachments;
			this.maxPixelRatio = 1;
			this.maxAnisotropy = 16;
			this.fragmentUniformsCount = limits.maxUniformBufferBindingSize / 16;
			this.vertexUniformsCount = limits.maxUniformBufferBindingSize / 16;
			this.supportsUniformBuffers = true;
			this.supportsAreaLights = true;
			this.supportsGpuParticles = true;
			this.supportsCompute = true;
			this.textureFloatRenderable = true;
			this.textureHalfFloatRenderable = true;
			this.supportsImageBitmap = true;
			this.samples = this.backBufferAntialias ? 4 : 1;
			var wgslFeatures = navigator.gpu.wgslLanguageFeatures;
			this.supportsStorageTextureRead = wgslFeatures == null ? void 0 : wgslFeatures.has('readonly_and_readwrite_storage_textures');
		};
		_proto.initWebGpu = function () {
			var _initWebGpu = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(glslangUrl, twgslUrl) {
				var buildUrl, results;
				return _regeneratorRuntime().wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							if (window.navigator.gpu) {
								_context.next = 2;
								break;
							}
							throw new Error('Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.');
						case 2:
							buildUrl = function buildUrl(srcPath) {
								return new URL(srcPath, window.location.href).toString();
							};
							_context.next = 5;
							return Promise.all([new Function("modulePath", "return import(modulePath)")("" + buildUrl(twgslUrl)).then(function (module) {
								return twgsl(twgslUrl.replace('.js', '.wasm'));
							}), new Function("modulePath", "return import(modulePath)")("" + buildUrl(glslangUrl)).then(function (module) {
								return module.default();
							})]);
						case 5:
							results = _context.sent;
							this.twgsl = results[0];
							this.glslang = results[1];
							return _context.abrupt("return", this.createDevice());
						case 9:
						case "end":
							return _context.stop();
					}
				}, _callee, this);
			}));
			function initWebGpu(_x, _x2) {
				return _initWebGpu.apply(this, arguments);
			}
			return initWebGpu;
		}();
		_proto.createDevice = function () {
			var _createDevice = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
				var _this2 = this,
					_this$gpuAdapter,
					_this$wgpu$lost;
				var adapterOptions, requiredFeatures, requireFeature, adapterLimits, requiredLimits, limitName, deviceDescr, canvasToneMapping, preferredCanvasFormat, displayFormat, hdrMediaQuery;
				return _regeneratorRuntime().wrap(function _callee2$(_context2) {
					while (1) switch (_context2.prev = _context2.next) {
						case 0:
							adapterOptions = {
								powerPreference: this.initOptions.powerPreference !== 'default' ? this.initOptions.powerPreference : undefined
							};
							_context2.next = 3;
							return window.navigator.gpu.requestAdapter(adapterOptions);
						case 3:
							this.gpuAdapter = _context2.sent;
							requiredFeatures = [];
							requireFeature = function requireFeature(feature) {
								var supported = _this2.gpuAdapter.features.has(feature);
								if (supported) {
									requiredFeatures.push(feature);
								}
								return supported;
							};
							this.textureFloatFilterable = requireFeature('float32-filterable');
							this.extCompressedTextureS3TC = requireFeature('texture-compression-bc');
							this.extCompressedTextureETC = requireFeature('texture-compression-etc2');
							this.extCompressedTextureASTC = requireFeature('texture-compression-astc');
							this.supportsTimestampQuery = requireFeature('timestamp-query');
							this.supportsDepthClip = requireFeature('depth-clip-control');
							this.supportsDepth32Stencil = requireFeature('depth32float-stencil8');
							this.supportsIndirectFirstInstance = requireFeature('indirect-first-instance');
							this.supportsShaderF16 = requireFeature('shader-f16');
							this.supportsStorageRGBA8 = requireFeature('bgra8unorm-storage');
							this.textureRG11B10Renderable = requireFeature('rg11b10ufloat-renderable');
							this.supportsClipDistances = requireFeature('clip-distances');
							adapterLimits = (_this$gpuAdapter = this.gpuAdapter) == null ? void 0 : _this$gpuAdapter.limits;
							requiredLimits = {};
							if (!adapterLimits) {
								_context2.next = 29;
								break;
							}
							_context2.t0 = _regeneratorRuntime().keys(adapterLimits);
						case 22:
							if ((_context2.t1 = _context2.t0()).done) {
								_context2.next = 29;
								break;
							}
							limitName = _context2.t1.value;
							if (!(limitName === 'minSubgroupSize' || limitName === 'maxSubgroupSize')) {
								_context2.next = 26;
								break;
							}
							return _context2.abrupt("continue", 22);
						case 26:
							requiredLimits[limitName] = adapterLimits[limitName];
							_context2.next = 22;
							break;
						case 29:
							deviceDescr = {
								requiredFeatures: requiredFeatures,
								requiredLimits: requiredLimits,
								defaultQueue: {
									label: 'Default Queue'
								}
							};
							_context2.next = 32;
							return this.gpuAdapter.requestDevice(deviceDescr);
						case 32:
							this.wgpu = _context2.sent;
							(_this$wgpu$lost = this.wgpu.lost) == null || _this$wgpu$lost.then(this.handleDeviceLost.bind(this));
							this.initDeviceCaps();
							this.gpuContext = this.canvas.getContext('webgpu');
							canvasToneMapping = 'standard';
							preferredCanvasFormat = navigator.gpu.getPreferredCanvasFormat();
							displayFormat = this.initOptions.displayFormat;
							this.backBufferFormat = preferredCanvasFormat === 'rgba8unorm' ? displayFormat === DISPLAYFORMAT_LDR_SRGB ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8 : displayFormat === DISPLAYFORMAT_LDR_SRGB ? PIXELFORMAT_SBGRA8 : PIXELFORMAT_BGRA8;
							this.backBufferViewFormat = displayFormat === DISPLAYFORMAT_LDR_SRGB ? preferredCanvasFormat + "-srgb" : preferredCanvasFormat;
							if (displayFormat === DISPLAYFORMAT_HDR && this.textureFloatFilterable) {
								hdrMediaQuery = window.matchMedia('(dynamic-range: high)');
								if (hdrMediaQuery != null && hdrMediaQuery.matches) {
									this.backBufferFormat = PIXELFORMAT_RGBA16F;
									this.backBufferViewFormat = 'rgba16float';
									preferredCanvasFormat = 'rgba16float';
									this.isHdr = true;
									canvasToneMapping = 'extended';
								}
							}
							this.canvasConfig = {
								device: this.wgpu,
								colorSpace: 'srgb',
								alphaMode: this.initOptions.alpha ? 'premultiplied' : 'opaque',
								format: preferredCanvasFormat,
								toneMapping: {
									mode: canvasToneMapping
								},
								usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,
								viewFormats: displayFormat === DISPLAYFORMAT_LDR_SRGB ? [this.backBufferViewFormat] : []
							};
							this.gpuContext.configure(this.canvasConfig);
							this.createBackbuffer();
							this.clearRenderer = new WebgpuClearRenderer(this);
							this.mipmapRenderer = new WebgpuMipmapRenderer(this);
							this.resolver = new WebgpuResolver(this);
							this.postInit();
							return _context2.abrupt("return", this);
						case 50:
						case "end":
							return _context2.stop();
					}
				}, _callee2, this);
			}));
			function createDevice() {
				return _createDevice.apply(this, arguments);
			}
			return createDevice;
		}();
		_proto.handleDeviceLost = function () {
			var _handleDeviceLost = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(info) {
				return _regeneratorRuntime().wrap(function _callee3$(_context3) {
					while (1) switch (_context3.prev = _context3.next) {
						case 0:
							if (!(info.reason !== 'destroyed')) {
								_context3.next = 5;
								break;
							}
							_GraphicsDevice.prototype.loseContext.call(this);
							_context3.next = 4;
							return this.createDevice();
						case 4:
							_GraphicsDevice.prototype.restoreContext.call(this);
						case 5:
						case "end":
							return _context3.stop();
					}
				}, _callee3, this);
			}));
			function handleDeviceLost(_x3) {
				return _handleDeviceLost.apply(this, arguments);
			}
			return handleDeviceLost;
		}();
		_proto.postInit = function postInit() {
			_GraphicsDevice.prototype.postInit.call(this);
			this.initializeRenderState();
			this.setupPassEncoderDefaults();
			this.gpuProfiler = new WebgpuGpuProfiler(this);
			this.dynamicBuffers = new WebgpuDynamicBuffers(this, 100 * 1024, this.limits.minUniformBufferOffsetAlignment);
			this.emptyBindGroup = new BindGroup(this, new BindGroupFormat(this, []));
			this.emptyBindGroup.update();
		};
		_proto.createBackbuffer = function createBackbuffer() {
			this.supportsStencil = this.initOptions.stencil;
			this.backBuffer = new RenderTarget({
				name: 'WebgpuFramebuffer',
				graphicsDevice: this,
				depth: this.initOptions.depth,
				stencil: this.supportsStencil,
				samples: this.samples
			});
			this.backBuffer.impl.isBackbuffer = true;
		};
		_proto.frameStart = function frameStart() {
			_GraphicsDevice.prototype.frameStart.call(this);
			this.gpuProfiler.frameStart();
			this.submit();
			var outColorBuffer = this.gpuContext.getCurrentTexture();
			if (this.backBufferSize.x !== outColorBuffer.width || this.backBufferSize.y !== outColorBuffer.height) {
				this.backBufferSize.set(outColorBuffer.width, outColorBuffer.height);
				this.backBuffer.destroy();
				this.backBuffer = null;
				this.createBackbuffer();
			}
			var rt = this.backBuffer;
			var wrt = rt.impl;
			wrt.setColorAttachment(0, undefined, this.backBufferViewFormat);
			this.initRenderTarget(rt);
			wrt.assignColorTexture(this, outColorBuffer);
		};
		_proto.frameEnd = function frameEnd() {
			_GraphicsDevice.prototype.frameEnd.call(this);
			this.gpuProfiler.frameEnd();
			this.submit();
			if (!this.contextLost) {
				this.gpuProfiler.request();
			}
		};
		_proto.createBufferImpl = function createBufferImpl(usageFlags) {
			return new WebgpuBuffer(usageFlags);
		};
		_proto.createUniformBufferImpl = function createUniformBufferImpl(uniformBuffer) {
			return new WebgpuUniformBuffer(uniformBuffer);
		};
		_proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format, options) {
			return new WebgpuVertexBuffer(vertexBuffer, format, options);
		};
		_proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer, options) {
			return new WebgpuIndexBuffer(indexBuffer, options);
		};
		_proto.createShaderImpl = function createShaderImpl(shader) {
			return new WebgpuShader(shader);
		};
		_proto.createTextureImpl = function createTextureImpl(texture) {
			return new WebgpuTexture(texture);
		};
		_proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
			return new WebgpuRenderTarget(renderTarget);
		};
		_proto.createBindGroupFormatImpl = function createBindGroupFormatImpl(bindGroupFormat) {
			return new WebgpuBindGroupFormat(bindGroupFormat);
		};
		_proto.createBindGroupImpl = function createBindGroupImpl(bindGroup) {
			return new WebgpuBindGroup();
		};
		_proto.createComputeImpl = function createComputeImpl(compute) {
			return new WebgpuCompute(compute);
		};
		_proto.setBindGroup = function setBindGroup(index, bindGroup, offsets) {
			if (this.passEncoder) {
				this.passEncoder.setBindGroup(index, bindGroup.impl.bindGroup, offsets != null ? offsets : bindGroup.uniformBufferOffsets);
				this.bindGroupFormats[index] = bindGroup.format.impl;
			}
		};
		_proto.submitVertexBuffer = function submitVertexBuffer(vertexBuffer, slot) {
			var format = vertexBuffer.format;
			var interleaved = format.interleaved,
				elements = format.elements;
			var elementCount = elements.length;
			var vbBuffer = vertexBuffer.impl.buffer;
			if (interleaved) {
				this.passEncoder.setVertexBuffer(slot, vbBuffer);
				return 1;
			}
			for (var i = 0; i < elementCount; i++) {
				this.passEncoder.setVertexBuffer(slot + i, vbBuffer, elements[i].offset);
			}
			return elementCount;
		};
		_proto.validateVBLocations = function validateVBLocations(vb0, vb1) {
			var validateVB = function validateVB(vb) {
				var elements = vb.format.elements;
				for (var i = 0; i < elements.length; i++) {
					var name = elements[i].name;
					var location = semanticToLocation[name];
					if (_uniqueLocations.has(location)) ;
					_uniqueLocations.set(location, name);
				}
			};
			validateVB(vb0);
			validateVB(vb1);
			_uniqueLocations.clear();
		};
		_proto.draw = function draw(primitive, numInstances, keepBuffers) {
			if (numInstances === void 0) {
				numInstances = 1;
			}
			if (this.shader.ready && !this.shader.failed) {
				var passEncoder = this.passEncoder;
				var vb0 = this.vertexBuffers[0];
				var vb1 = this.vertexBuffers[1];
				this.vertexBuffers.length = 0;
				if (vb0) {
					var vbSlot = this.submitVertexBuffer(vb0, 0);
					if (vb1) {
						this.submitVertexBuffer(vb1, vbSlot);
					}
				}
				var pipeline = this.renderPipeline.get(primitive, vb0 == null ? void 0 : vb0.format, vb1 == null ? void 0 : vb1.format, this.shader, this.renderTarget, this.bindGroupFormats, this.blendState, this.depthState, this.cullMode, this.stencilEnabled, this.stencilFront, this.stencilBack);
				if (this.pipeline !== pipeline) {
					this.pipeline = pipeline;
					passEncoder.setPipeline(pipeline);
				}
				var ib = this.indexBuffer;
				if (ib) {
					this.indexBuffer = null;
					passEncoder.setIndexBuffer(ib.impl.buffer, ib.impl.format);
					passEncoder.drawIndexed(primitive.count, numInstances, primitive.base, 0, 0);
				} else {
					passEncoder.draw(primitive.count, numInstances, primitive.base, 0);
				}
			}
		};
		_proto.setShader = function setShader(shader, asyncCompile) {
			if (shader !== this.shader) {
				this.shader = shader;
			}
		};
		_proto.setBlendState = function setBlendState(blendState) {
			this.blendState.copy(blendState);
		};
		_proto.setDepthState = function setDepthState(depthState) {
			this.depthState.copy(depthState);
		};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {
			if (stencilFront || stencilBack) {
				this.stencilEnabled = true;
				this.stencilFront.copy(stencilFront != null ? stencilFront : StencilParameters.DEFAULT);
				this.stencilBack.copy(stencilBack != null ? stencilBack : StencilParameters.DEFAULT);
				var ref = this.stencilFront.ref;
				if (this.stencilRef !== ref) {
					this.stencilRef = ref;
					this.passEncoder.setStencilReference(ref);
				}
			} else {
				this.stencilEnabled = false;
			}
		};
		_proto.setBlendColor = function setBlendColor(r, g, b, a) {
			var c = this.blendColor;
			if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
				c.set(r, g, b, a);
				this.passEncoder.setBlendConstant(c);
			}
		};
		_proto.setCullMode = function setCullMode(cullMode) {
			this.cullMode = cullMode;
		};
		_proto.setAlphaToCoverage = function setAlphaToCoverage(state) {};
		_proto.initializeContextCaches = function initializeContextCaches() {
			_GraphicsDevice.prototype.initializeContextCaches.call(this);
		};
		_proto.setupPassEncoderDefaults = function setupPassEncoderDefaults() {
			this.pipeline = null;
			this.stencilRef = 0;
			this.blendColor.set(0, 0, 0, 0);
		};
		_proto._uploadDirtyTextures = function _uploadDirtyTextures() {
			this.textures.forEach(function (texture) {
				if (texture._needsUpload || texture._needsMipmaps) {
					texture.upload();
				}
			});
		};
		_proto.setupTimeStampWrites = function setupTimeStampWrites(passDesc, name) {
			if (this.gpuProfiler._enabled) {
				if (this.gpuProfiler.timestampQueriesSet) {
					var _passDesc;
					var slot = this.gpuProfiler.getSlot(name);
					passDesc = (_passDesc = passDesc) != null ? _passDesc : {};
					passDesc.timestampWrites = {
						querySet: this.gpuProfiler.timestampQueriesSet.querySet,
						beginningOfPassWriteIndex: slot * 2,
						endOfPassWriteIndex: slot * 2 + 1
					};
				}
			}
			return passDesc;
		};
		_proto.startRenderPass = function startRenderPass(renderPass) {
			this._uploadDirtyTextures();
			var rt = renderPass.renderTarget || this.backBuffer;
			this.renderTarget = rt;
			var wrt = rt.impl;
			if (rt !== this.backBuffer) {
				this.initRenderTarget(rt);
			}
			wrt.setupForRenderPass(renderPass, rt);
			var renderPassDesc = wrt.renderPassDescriptor;
			this.setupTimeStampWrites(renderPassDesc, renderPass.name);
			var commandEncoder = this.getCommandEncoder();
			this.passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
			this.passEncoder.label = renderPass.name + "-PassEncoder RT:" + rt.name;
			this.setupPassEncoderDefaults();
			var width = rt.width,
				height = rt.height;
			this.setViewport(0, 0, width, height);
			this.setScissor(0, 0, width, height);
			this.insideRenderPass = true;
		};
		_proto.endRenderPass = function endRenderPass(renderPass) {
			this.passEncoder.end();
			this.passEncoder = null;
			this.insideRenderPass = false;
			this.bindGroupFormats.length = 0;
			var target = this.renderTarget;
			if (target) {
				if (target.depthBuffer && renderPass.depthStencilOps.resolveDepth) {
					if (renderPass.samples > 1 && target.autoResolve) {
						var depthAttachment = target.impl.depthAttachment;
						var destTexture = target.depthBuffer.impl.gpuTexture;
						if (depthAttachment && destTexture) {
							this.resolver.resolveDepth(this.commandEncoder, depthAttachment.multisampledDepthBuffer, destTexture);
						}
					}
				}
			}
			for (var i = 0; i < renderPass.colorArrayOps.length; i++) {
				var colorOps = renderPass.colorArrayOps[i];
				if (colorOps.genMipmaps) {
					this.mipmapRenderer.generate(renderPass.renderTarget._colorBuffers[i].impl);
				}
			}
		};
		_proto.startComputePass = function startComputePass(name) {
			this.pipeline = null;
			var computePassDesc = this.setupTimeStampWrites(undefined, name);
			var commandEncoder = this.getCommandEncoder();
			this.passEncoder = commandEncoder.beginComputePass(computePassDesc);
			this.insideRenderPass = true;
		};
		_proto.endComputePass = function endComputePass() {
			this.passEncoder.end();
			this.passEncoder = null;
			this.insideRenderPass = false;
			this.bindGroupFormats.length = 0;
		};
		_proto.computeDispatch = function computeDispatch(computes, name) {
			if (name === void 0) {
				name = 'Unnamed';
			}
			this.startComputePass(name);
			for (var i = 0; i < computes.length; i++) {
				var compute = computes[i];
				compute.applyParameters();
				compute.impl.updateBindGroup();
			}
			for (var _i = 0; _i < computes.length; _i++) {
				var _compute = computes[_i];
				_compute.impl.dispatch(_compute.countX, _compute.countY, _compute.countZ);
			}
			this.endComputePass();
		};
		_proto.getCommandEncoder = function getCommandEncoder() {
			var commandEncoder = this.commandEncoder;
			if (!commandEncoder) {
				commandEncoder = this.wgpu.createCommandEncoder();
				this.commandEncoder = commandEncoder;
			}
			return commandEncoder;
		};
		_proto.endCommandEncoder = function endCommandEncoder() {
			var commandEncoder = this.commandEncoder;
			if (commandEncoder) {
				var cb = commandEncoder.finish();
				this.addCommandBuffer(cb);
				this.commandEncoder = null;
			}
		};
		_proto.addCommandBuffer = function addCommandBuffer(commandBuffer, front) {
			if (front === void 0) {
				front = false;
			}
			if (front) {
				this.commandBuffers.unshift(commandBuffer);
			} else {
				this.commandBuffers.push(commandBuffer);
			}
		};
		_proto.submit = function submit() {
			this.endCommandEncoder();
			if (this.commandBuffers.length > 0) {
				this.dynamicBuffers.submit();
				this.wgpu.queue.submit(this.commandBuffers);
				this.commandBuffers.length = 0;
				this.dynamicBuffers.onCommandBuffersSubmitted();
			}
		};
		_proto.clear = function clear(options) {
			if (options.flags) {
				this.clearRenderer.clear(this, this.renderTarget, options, this.defaultClearOptions);
			}
		};
		_proto.setViewport = function setViewport(x, y, w, h) {
			if (this.passEncoder) {
				if (!this.renderTarget.flipY) {
					y = this.renderTarget.height - y - h;
				}
				this.vx = x;
				this.vy = y;
				this.vw = w;
				this.vh = h;
				this.passEncoder.setViewport(x, y, w, h, 0, 1);
			}
		};
		_proto.setScissor = function setScissor(x, y, w, h) {
			if (this.passEncoder) {
				if (!this.renderTarget.flipY) {
					y = this.renderTarget.height - y - h;
				}
				this.sx = x;
				this.sy = y;
				this.sw = w;
				this.sh = h;
				this.passEncoder.setScissorRect(x, y, w, h);
			}
		};
		_proto.clearStorageBuffer = function clearStorageBuffer(storageBuffer, offset, size) {
			if (offset === void 0) {
				offset = 0;
			}
			if (size === void 0) {
				size = storageBuffer.byteSize;
			}
			var commandEncoder = this.getCommandEncoder();
			commandEncoder.clearBuffer(storageBuffer.buffer, offset, size);
		};
		_proto.readStorageBuffer = function readStorageBuffer(storageBuffer, offset, size, data, immediate) {
			if (offset === void 0) {
				offset = 0;
			}
			if (size === void 0) {
				size = storageBuffer.byteSize - offset;
			}
			if (data === void 0) {
				data = null;
			}
			if (immediate === void 0) {
				immediate = false;
			}
			var stagingBuffer = this.createBufferImpl(BUFFERUSAGE_READ | BUFFERUSAGE_COPY_DST);
			stagingBuffer.allocate(this, size);
			var destBuffer = stagingBuffer.buffer;
			var commandEncoder = this.getCommandEncoder();
			commandEncoder.copyBufferToBuffer(storageBuffer.buffer, offset, destBuffer, 0, size);
			return this.readBuffer(stagingBuffer, size, data, immediate);
		};
		_proto.readBuffer = function readBuffer(stagingBuffer, size, data, immediate) {
			var _this3 = this;
			if (data === void 0) {
				data = null;
			}
			if (immediate === void 0) {
				immediate = false;
			}
			var destBuffer = stagingBuffer.buffer;
			return new Promise(function (resolve, reject) {
				var read = function read() {
					destBuffer == null || destBuffer.mapAsync(GPUMapMode.READ).then(function () {
						var _data;
						(_data = data) != null ? _data : data = new Uint8Array(size);
						var copySrc = destBuffer.getMappedRange(0, size);
						var srcType = data.constructor;
						data.set(new srcType(copySrc));
						destBuffer.unmap();
						stagingBuffer.destroy(_this3);
						resolve(data);
					});
				};
				if (immediate) {
					_this3.submit();
					read();
				} else {
					setTimeout(function () {
						read();
					});
				}
			});
		};
		_proto.writeStorageBuffer = function writeStorageBuffer(storageBuffer, bufferOffset, data, dataOffset, size) {
			if (bufferOffset === void 0) {
				bufferOffset = 0;
			}
			if (dataOffset === void 0) {
				dataOffset = 0;
			}
			this.wgpu.queue.writeBuffer(storageBuffer.buffer, bufferOffset, data, dataOffset, size);
		};
		_proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
			var copySize = {
				width: source ? source.width : dest.width,
				height: source ? source.height : dest.height,
				depthOrArrayLayers: 1
			};
			var commandEncoder = this.getCommandEncoder();
			if (color) {
				var copySrc = {
					texture: source ? source.colorBuffer.impl.gpuTexture : this.backBuffer.impl.assignedColorTexture,
					mipLevel: 0
				};
				var copyDst = {
					texture: dest ? dest.colorBuffer.impl.gpuTexture : this.backBuffer.impl.assignedColorTexture,
					mipLevel: 0
				};
				commandEncoder.copyTextureToTexture(copySrc, copyDst, copySize);
			}
			if (depth) {
				var sourceRT = source ? source : this.renderTarget;
				var sourceTexture = sourceRT.impl.depthAttachment.depthTexture;
				if (source.samples > 1) {
					var destTexture = dest.colorBuffer.impl.gpuTexture;
					this.resolver.resolveDepth(commandEncoder, sourceTexture, destTexture);
				} else {
					var _destTexture = dest ? dest.depthBuffer.impl.gpuTexture : this.renderTarget.impl.depthAttachment.depthTexture;
					var _copySrc = {
						texture: sourceTexture,
						mipLevel: 0
					};
					var _copyDst = {
						texture: _destTexture,
						mipLevel: 0
					};
					commandEncoder.copyTextureToTexture(_copySrc, _copyDst, copySize);
				}
			}
			return true;
		};
		return WebgpuGraphicsDevice;
	}(GraphicsDevice);

	var WebglBuffer = function () {
		function WebglBuffer() {
			this.bufferId = null;
		}
		var _proto = WebglBuffer.prototype;
		_proto.destroy = function destroy(device) {
			if (this.bufferId) {
				device.gl.deleteBuffer(this.bufferId);
				this.bufferId = null;
			}
		};
		_proto.loseContext = function loseContext() {
			this.bufferId = null;
		};
		_proto.unlock = function unlock(device, usage, target, storage) {
			var gl = device.gl;
			if (!this.bufferId) {
				var glUsage;
				switch (usage) {
					case BUFFER_STATIC:
						glUsage = gl.STATIC_DRAW;
						break;
					case BUFFER_DYNAMIC:
						glUsage = gl.DYNAMIC_DRAW;
						break;
					case BUFFER_STREAM:
						glUsage = gl.STREAM_DRAW;
						break;
					case BUFFER_GPUDYNAMIC:
						glUsage = gl.DYNAMIC_COPY;
						break;
				}
				this.bufferId = gl.createBuffer();
				gl.bindBuffer(target, this.bufferId);
				gl.bufferData(target, storage, glUsage);
			} else {
				gl.bindBuffer(target, this.bufferId);
				gl.bufferSubData(target, 0, storage);
			}
		};
		return _createClass(WebglBuffer, [{
			key: "initialized",
			get: function get() {
				return !!this.bufferId;
			}
		}]);
	}();

	var WebglVertexBuffer = function (_WebglBuffer) {
		function WebglVertexBuffer() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _WebglBuffer.call.apply(_WebglBuffer, [this].concat(args)) || this;
			_this.vao = null;
			return _this;
		}
		_inheritsLoose(WebglVertexBuffer, _WebglBuffer);
		var _proto = WebglVertexBuffer.prototype;
		_proto.destroy = function destroy(device) {
			_WebglBuffer.prototype.destroy.call(this, device);
			device.unbindVertexArray();
		};
		_proto.loseContext = function loseContext() {
			_WebglBuffer.prototype.loseContext.call(this);
			this.vao = null;
		};
		_proto.unlock = function unlock(vertexBuffer) {
			var device = vertexBuffer.device;
			_WebglBuffer.prototype.unlock.call(this, device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
		};
		return WebglVertexBuffer;
	}(WebglBuffer);

	var WebglIndexBuffer = function (_WebglBuffer) {
		function WebglIndexBuffer(indexBuffer) {
			var _this;
			_this = _WebglBuffer.call(this) || this;
			var gl = indexBuffer.device.gl;
			var format = indexBuffer.format;
			if (format === INDEXFORMAT_UINT8) {
				_this.glFormat = gl.UNSIGNED_BYTE;
			} else if (format === INDEXFORMAT_UINT16) {
				_this.glFormat = gl.UNSIGNED_SHORT;
			} else if (format === INDEXFORMAT_UINT32) {
				_this.glFormat = gl.UNSIGNED_INT;
			}
			return _this;
		}
		_inheritsLoose(WebglIndexBuffer, _WebglBuffer);
		var _proto = WebglIndexBuffer.prototype;
		_proto.unlock = function unlock(indexBuffer) {
			var device = indexBuffer.device;
			_WebglBuffer.prototype.unlock.call(this, device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
		};
		return WebglIndexBuffer;
	}(WebglBuffer);

	var WebglShaderInput = function WebglShaderInput(graphicsDevice, name, type, locationId) {
		this.locationId = locationId;
		this.scopeId = graphicsDevice.scope.resolve(name);
		this.version = new Version();
		if (name.substring(name.length - 3) === '[0]') {
			switch (type) {
				case UNIFORMTYPE_FLOAT:
					type = UNIFORMTYPE_FLOATARRAY;
					break;
				case UNIFORMTYPE_INT:
					type = UNIFORMTYPE_INTARRAY;
					break;
				case UNIFORMTYPE_UINT:
					type = UNIFORMTYPE_UINTARRAY;
					break;
				case UNIFORMTYPE_BOOL:
					type = UNIFORMTYPE_BOOLARRAY;
					break;
				case UNIFORMTYPE_VEC2:
					type = UNIFORMTYPE_VEC2ARRAY;
					break;
				case UNIFORMTYPE_IVEC2:
					type = UNIFORMTYPE_IVEC2ARRAY;
					break;
				case UNIFORMTYPE_UVEC2:
					type = UNIFORMTYPE_UVEC2ARRAY;
					break;
				case UNIFORMTYPE_BVEC2:
					type = UNIFORMTYPE_BVEC2ARRAY;
					break;
				case UNIFORMTYPE_VEC3:
					type = UNIFORMTYPE_VEC3ARRAY;
					break;
				case UNIFORMTYPE_IVEC3:
					type = UNIFORMTYPE_IVEC3ARRAY;
					break;
				case UNIFORMTYPE_UVEC3:
					type = UNIFORMTYPE_UVEC3ARRAY;
					break;
				case UNIFORMTYPE_BVEC3:
					type = UNIFORMTYPE_BVEC3ARRAY;
					break;
				case UNIFORMTYPE_VEC4:
					type = UNIFORMTYPE_VEC4ARRAY;
					break;
				case UNIFORMTYPE_IVEC4:
					type = UNIFORMTYPE_IVEC4ARRAY;
					break;
				case UNIFORMTYPE_UVEC4:
					type = UNIFORMTYPE_UVEC4ARRAY;
					break;
				case UNIFORMTYPE_BVEC4:
					type = UNIFORMTYPE_BVEC4ARRAY;
					break;
			}
		}
		this.dataType = type;
		this.value = [null, null, null, null];
		this.array = [];
	};

	var _vertexShaderBuiltins = new Set(['gl_VertexID', 'gl_InstanceID', 'gl_DrawID', 'gl_BaseVertex', 'gl_BaseInstance']);
	var CompiledShaderCache = function () {
		function CompiledShaderCache() {
			this.map = new Map();
		}
		var _proto = CompiledShaderCache.prototype;
		_proto.destroy = function destroy(device) {
			this.map.forEach(function (shader) {
				device.gl.deleteShader(shader);
			});
		};
		_proto.loseContext = function loseContext(device) {
			this.map.clear();
		};
		return CompiledShaderCache;
	}();
	var _vertexShaderCache = new DeviceCache();
	var _fragmentShaderCache = new DeviceCache();
	var WebglShader = function () {
		function WebglShader(shader) {
			this.compileDuration = 0;
			this.init();
			this.compile(shader.device, shader);
			this.link(shader.device, shader);
			shader.device.shaders.push(shader);
		}
		var _proto2 = WebglShader.prototype;
		_proto2.destroy = function destroy(shader) {
			if (this.glProgram) {
				shader.device.gl.deleteProgram(this.glProgram);
				this.glProgram = null;
			}
		};
		_proto2.init = function init() {
			this.uniforms = [];
			this.samplers = [];
			this.attributes = [];
			this.glProgram = null;
			this.glVertexShader = null;
			this.glFragmentShader = null;
		};
		_proto2.loseContext = function loseContext() {
			this.init();
		};
		_proto2.restoreContext = function restoreContext(device, shader) {
			this.compile(device, shader);
			this.link(device, shader);
		};
		_proto2.compile = function compile(device, shader) {
			var definition = shader.definition;
			this.glVertexShader = this._compileShaderSource(device, definition.vshader, true);
			this.glFragmentShader = this._compileShaderSource(device, definition.fshader, false);
		};
		_proto2.link = function link(device, shader) {
			if (this.glProgram) {
				return;
			}
			var gl = device.gl;
			if (gl.isContextLost()) {
				return;
			}
			var glProgram = gl.createProgram();
			this.glProgram = glProgram;
			gl.attachShader(glProgram, this.glVertexShader);
			gl.attachShader(glProgram, this.glFragmentShader);
			var definition = shader.definition;
			var attrs = definition.attributes;
			if (definition.useTransformFeedback) {
				var outNames = [];
				for (var attr in attrs) {
					if (attrs.hasOwnProperty(attr)) {
						outNames.push("out_" + attr);
					}
				}
				gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
			}
			for (var _attr in attrs) {
				if (attrs.hasOwnProperty(_attr)) {
					var semantic = attrs[_attr];
					var loc = semanticToLocation[semantic];
					gl.bindAttribLocation(glProgram, loc, _attr);
				}
			}
			gl.linkProgram(glProgram);
		};
		_proto2._compileShaderSource = function _compileShaderSource(device, src, isVertexShader) {
			var gl = device.gl;
			if (gl.isContextLost()) {
				return null;
			}
			var shaderDeviceCache = isVertexShader ? _vertexShaderCache : _fragmentShaderCache;
			var shaderCache = shaderDeviceCache.get(device, function () {
				return new CompiledShaderCache();
			});
			var glShader = shaderCache.map.get(src);
			if (!glShader) {
				glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
				gl.shaderSource(glShader, src);
				gl.compileShader(glShader);
				shaderCache.map.set(src, glShader);
			}
			return glShader;
		};
		_proto2.finalize = function finalize(device, shader) {
			var gl = device.gl;
			if (gl.isContextLost()) {
				return true;
			}
			var glProgram = this.glProgram;
			var definition = shader.definition;
			var linkStatus = gl.getProgramParameter(glProgram, gl.LINK_STATUS);
			if (!linkStatus) {
				if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, 'vertex')) {
					return false;
				}
				if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, 'fragment')) {
					return false;
				}
				var message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
				console.error(message);
				return false;
			}
			var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
			for (var i = 0; i < numAttributes; i++) {
				var info = gl.getActiveAttrib(glProgram, i);
				var location = gl.getAttribLocation(glProgram, info.name);
				if (_vertexShaderBuiltins.has(info.name)) {
					continue;
				}
				if (definition.attributes[info.name] === undefined) {
					console.error("Vertex shader attribute \"" + info.name + "\" is not mapped to a semantic in shader definition, shader [" + shader.label + "]", shader);
					shader.failed = true;
				} else {
					var shaderInput = new WebglShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);
					this.attributes.push(shaderInput);
				}
			}
			var samplerTypes = device._samplerTypes;
			var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
			for (var _i = 0; _i < numUniforms; _i++) {
				var _info = gl.getActiveUniform(glProgram, _i);
				var _location = gl.getUniformLocation(glProgram, _info.name);
				var _shaderInput = new WebglShaderInput(device, _info.name, device.pcUniformType[_info.type], _location);
				if (samplerTypes.has(_info.type)) {
					this.samplers.push(_shaderInput);
				} else {
					this.uniforms.push(_shaderInput);
				}
			}
			shader.ready = true;
			return true;
		};
		_proto2._isCompiled = function _isCompiled(device, shader, glShader, source, shaderType) {
			var gl = device.gl;
			if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
				var infoLog = gl.getShaderInfoLog(glShader);
				var _this$_processError = this._processError(source, infoLog),
					code = _this$_processError[0];
					_this$_processError[1];
				var message = "Failed to compile " + shaderType + " shader:\n\n" + infoLog + "\n" + code + " while rendering " + void 0;
				console.error(message);
				return false;
			}
			return true;
		};
		_proto2.isLinked = function isLinked(device) {
			var extParallelShaderCompile = device.extParallelShaderCompile;
			if (extParallelShaderCompile) {
				return device.gl.getProgramParameter(this.glProgram, extParallelShaderCompile.COMPLETION_STATUS_KHR);
			}
			return true;
		};
		_proto2._processError = function _processError(src, infoLog) {
			var error = {};
			var code = '';
			if (src) {
				var lines = src.split('\n');
				var from = 0;
				var to = lines.length;
				if (infoLog && infoLog.startsWith('ERROR:')) {
					var match = infoLog.match(/^ERROR:\s(\d+):(\d+):\s*(.+)/);
					if (match) {
						error.message = match[3];
						error.line = parseInt(match[2], 10);
						from = Math.max(0, error.line - 6);
						to = Math.min(lines.length, error.line + 5);
					}
				}
				for (var i = from; i < to; i++) {
					code += i + 1 + ":\t" + lines[i] + "\n";
				}
				error.source = src;
			}
			return [code, error];
		};
		return WebglShader;
	}();

	function downsampleImage(image, size) {
		var srcW = image.width;
		var srcH = image.height;
		if (srcW > size || srcH > size) {
			var scale = size / Math.max(srcW, srcH);
			var dstW = Math.floor(srcW * scale);
			var dstH = Math.floor(srcH * scale);
			var canvas = document.createElement('canvas');
			canvas.width = dstW;
			canvas.height = dstH;
			var context = canvas.getContext('2d');
			context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
			return canvas;
		}
		return image;
	}
	var WebglTexture = function () {
		function WebglTexture(texture) {
			this._glTexture = null;
			this._glTarget = void 0;
			this._glFormat = void 0;
			this._glInternalFormat = void 0;
			this._glPixelType = void 0;
			this._glCreated = void 0;
			this.dirtyParameterFlags = 0;
			this.texture = texture;
		}
		var _proto = WebglTexture.prototype;
		_proto.destroy = function destroy(device) {
			if (this._glTexture) {
				for (var i = 0; i < device.textureUnits.length; i++) {
					var textureUnit = device.textureUnits[i];
					for (var j = 0; j < textureUnit.length; j++) {
						if (textureUnit[j] === this._glTexture) {
							textureUnit[j] = null;
						}
					}
				}
				device.gl.deleteTexture(this._glTexture);
				this._glTexture = null;
			}
		};
		_proto.loseContext = function loseContext() {
			this._glTexture = null;
		};
		_proto.propertyChanged = function propertyChanged(flag) {
			this.dirtyParameterFlags |= flag;
		};
		_proto.initialize = function initialize(device, texture) {
			var gl = device.gl;
			this._glTexture = gl.createTexture();
			this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : texture.array ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
			switch (texture._format) {
				case PIXELFORMAT_A8:
					this._glFormat = gl.ALPHA;
					this._glInternalFormat = gl.ALPHA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_L8:
					this._glFormat = gl.LUMINANCE;
					this._glInternalFormat = gl.LUMINANCE;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_LA8:
					this._glFormat = gl.LUMINANCE_ALPHA;
					this._glInternalFormat = gl.LUMINANCE_ALPHA;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_R8:
					this._glFormat = gl.RED;
					this._glInternalFormat = gl.R8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_RG8:
					this._glFormat = gl.RG;
					this._glInternalFormat = gl.RG8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_RGB565:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.RGB;
					this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
					break;
				case PIXELFORMAT_RGBA5551:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA;
					this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
					break;
				case PIXELFORMAT_RGBA4:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA;
					this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
					break;
				case PIXELFORMAT_RGB8:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.RGB8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_RGBA8:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_BGRA8:
				case PIXELFORMAT_SBGRA8:
					break;
				case PIXELFORMAT_DXT1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
					break;
				case PIXELFORMAT_DXT3:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					break;
				case PIXELFORMAT_DXT5:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
					break;
				case PIXELFORMAT_ETC1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
					break;
				case PIXELFORMAT_PVRTC_2BPP_RGB_1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_4BPP_RGB_1:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					break;
				case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					break;
				case PIXELFORMAT_ETC2_RGB:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
					break;
				case PIXELFORMAT_ETC2_RGBA:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
					break;
				case PIXELFORMAT_ASTC_4x4:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
					break;
				case PIXELFORMAT_ATC_RGB:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
					break;
				case PIXELFORMAT_ATC_RGBA:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
					break;
				case PIXELFORMAT_BC6F:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
					break;
				case PIXELFORMAT_BC6UF:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
					break;
				case PIXELFORMAT_BC7:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGBA_BPTC_UNORM_EXT;
					break;
				case PIXELFORMAT_DXT1_SRGB:
					this._glFormat = gl.SRGB;
					this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					break;
				case PIXELFORMAT_DXT3_SRGBA:
					this._glFormat = gl.SRGB_ALPHA;
					this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					break;
				case PIXELFORMAT_DXT5_SRGBA:
					this._glFormat = gl.SRGB_ALPHA;
					this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
					break;
				case PIXELFORMAT_PVRTC_2BPP_SRGB_1:
					this._glFormat = gl.SRGB;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_PVRTC_2BPPV1_EXT;
					break;
				case PIXELFORMAT_PVRTC_2BPP_SRGBA_1:
					this._glFormat = gl.SRGB_ALPHA;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT;
					break;
				case PIXELFORMAT_PVRTC_4BPP_SRGB_1:
					this._glFormat = gl.SRGB;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_PVRTC_4BPPV1_EXT;
					break;
				case PIXELFORMAT_PVRTC_4BPP_SRGBA_1:
					this._glFormat = gl.SRGB_ALPHA;
					this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT;
					break;
				case PIXELFORMAT_ETC2_SRGB:
					this._glFormat = gl.RGB;
					this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
					break;
				case PIXELFORMAT_ETC2_SRGBA:
					this._glFormat = gl.SRGB_ALPHA;
					this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
					break;
				case PIXELFORMAT_ASTC_4x4_SRGB:
					this._glFormat = gl.SRGB_ALPHA;
					this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
					break;
				case PIXELFORMAT_BC7_SRGBA:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
					break;
				case PIXELFORMAT_R16F:
					this._glFormat = gl.RED;
					this._glInternalFormat = gl.R16F;
					this._glPixelType = gl.HALF_FLOAT;
					break;
				case PIXELFORMAT_RG16F:
					this._glFormat = gl.RG;
					this._glInternalFormat = gl.RG16F;
					this._glPixelType = gl.HALF_FLOAT;
					break;
				case PIXELFORMAT_RGB16F:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.RGB16F;
					this._glPixelType = gl.HALF_FLOAT;
					break;
				case PIXELFORMAT_RGBA16F:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA16F;
					this._glPixelType = gl.HALF_FLOAT;
					break;
				case PIXELFORMAT_RGB32F:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.RGB32F;
					this._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_RGBA32F:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.RGBA32F;
					this._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_R32F:
					this._glFormat = gl.RED;
					this._glInternalFormat = gl.R32F;
					this._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_DEPTH:
					this._glFormat = gl.DEPTH_COMPONENT;
					this._glInternalFormat = gl.DEPTH_COMPONENT32F;
					this._glPixelType = gl.FLOAT;
					break;
				case PIXELFORMAT_DEPTH16:
					this._glFormat = gl.DEPTH_COMPONENT;
					this._glInternalFormat = gl.DEPTH_COMPONENT16;
					this._glPixelType = gl.UNSIGNED_SHORT;
					break;
				case PIXELFORMAT_DEPTHSTENCIL:
					this._glFormat = gl.DEPTH_STENCIL;
					this._glInternalFormat = gl.DEPTH24_STENCIL8;
					this._glPixelType = gl.UNSIGNED_INT_24_8;
					break;
				case PIXELFORMAT_111110F:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.R11F_G11F_B10F;
					this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
					break;
				case PIXELFORMAT_SRGB8:
					this._glFormat = gl.RGB;
					this._glInternalFormat = gl.SRGB8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_SRGBA8:
					this._glFormat = gl.RGBA;
					this._glInternalFormat = gl.SRGB8_ALPHA8;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_R8I:
					this._glFormat = gl.RED_INTEGER;
					this._glInternalFormat = gl.R8I;
					this._glPixelType = gl.BYTE;
					break;
				case PIXELFORMAT_R8U:
					this._glFormat = gl.RED_INTEGER;
					this._glInternalFormat = gl.R8UI;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_R16I:
					this._glFormat = gl.RED_INTEGER;
					this._glInternalFormat = gl.R16I;
					this._glPixelType = gl.SHORT;
					break;
				case PIXELFORMAT_R16U:
					this._glFormat = gl.RED_INTEGER;
					this._glInternalFormat = gl.R16UI;
					this._glPixelType = gl.UNSIGNED_SHORT;
					break;
				case PIXELFORMAT_R32I:
					this._glFormat = gl.RED_INTEGER;
					this._glInternalFormat = gl.R32I;
					this._glPixelType = gl.INT;
					break;
				case PIXELFORMAT_R32U:
					this._glFormat = gl.RED_INTEGER;
					this._glInternalFormat = gl.R32UI;
					this._glPixelType = gl.UNSIGNED_INT;
					break;
				case PIXELFORMAT_RG8I:
					this._glFormat = gl.RG_INTEGER;
					this._glInternalFormat = gl.RG8I;
					this._glPixelType = gl.BYTE;
					break;
				case PIXELFORMAT_RG8U:
					this._glFormat = gl.RG_INTEGER;
					this._glInternalFormat = gl.RG8UI;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_RG16I:
					this._glFormat = gl.RG_INTEGER;
					this._glInternalFormat = gl.RG16I;
					this._glPixelType = gl.SHORT;
					break;
				case PIXELFORMAT_RG16U:
					this._glFormat = gl.RG_INTEGER;
					this._glInternalFormat = gl.RG16UI;
					this._glPixelType = gl.UNSIGNED_SHORT;
					break;
				case PIXELFORMAT_RG32I:
					this._glFormat = gl.RG_INTEGER;
					this._glInternalFormat = gl.RG32I;
					this._glPixelType = gl.INT;
					break;
				case PIXELFORMAT_RG32U:
					this._glFormat = gl.RG_INTEGER;
					this._glInternalFormat = gl.RG32UI;
					this._glPixelType = gl.UNSIGNED_INT;
					break;
				case PIXELFORMAT_RGBA8I:
					this._glFormat = gl.RGBA_INTEGER;
					this._glInternalFormat = gl.RGBA8I;
					this._glPixelType = gl.BYTE;
					break;
				case PIXELFORMAT_RGBA8U:
					this._glFormat = gl.RGBA_INTEGER;
					this._glInternalFormat = gl.RGBA8UI;
					this._glPixelType = gl.UNSIGNED_BYTE;
					break;
				case PIXELFORMAT_RGBA16I:
					this._glFormat = gl.RGBA_INTEGER;
					this._glInternalFormat = gl.RGBA16I;
					this._glPixelType = gl.SHORT;
					break;
				case PIXELFORMAT_RGBA16U:
					this._glFormat = gl.RGBA_INTEGER;
					this._glInternalFormat = gl.RGBA16UI;
					this._glPixelType = gl.UNSIGNED_SHORT;
					break;
				case PIXELFORMAT_RGBA32I:
					this._glFormat = gl.RGBA_INTEGER;
					this._glInternalFormat = gl.RGBA32I;
					this._glPixelType = gl.INT;
					break;
				case PIXELFORMAT_RGBA32U:
					this._glFormat = gl.RGBA_INTEGER;
					this._glInternalFormat = gl.RGBA32UI;
					this._glPixelType = gl.UNSIGNED_INT;
					break;
			}
			this._glCreated = false;
		};
		_proto.upload = function upload(device, texture) {
			var gl = device.gl;
			if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) {
				return;
			}
			var mipLevel = 0;
			var mipObject;
			var resMult;
			var requiredMipLevels = texture.numLevels;
			if (texture.array) {
				gl.texStorage3D(gl.TEXTURE_2D_ARRAY, requiredMipLevels, this._glInternalFormat, texture._width, texture._height, texture._arrayLength);
			}
			while (texture._levels[mipLevel] || mipLevel === 0) {
				if (!texture._needsUpload && mipLevel === 0) {
					mipLevel++;
					continue;
				} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
					break;
				}
				mipObject = texture._levels[mipLevel];
				resMult = 1 / Math.pow(2, mipLevel);
				if (mipLevel === 1 && !texture._compressed && !texture._integerFormat && texture._levels.length < requiredMipLevels) {
					gl.generateMipmap(this._glTarget);
					texture._mipmapsUploaded = true;
				}
				if (texture._cubemap) {
					var face = void 0;
					if (device._isBrowserInterface(mipObject[0])) {
						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face]) {
								continue;
							}
							var src = mipObject[face];
							if (device._isImageBrowserInterface(src)) {
								if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
									src = downsampleImage(src, device.maxCubeMapSize);
									if (mipLevel === 0) {
										texture._width = src.width;
										texture._height = src.height;
									}
								}
							}
							device.setUnpackFlipY(false);
							device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							if (this._glCreated) {
								gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, this._glFormat, this._glPixelType, src);
							} else {
								gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
							}
						}
					} else {
						resMult = 1 / Math.pow(2, mipLevel);
						for (face = 0; face < 6; face++) {
							if (!texture._levelsUpdated[0][face]) {
								continue;
							}
							var texData = mipObject[face];
							if (texture._compressed) {
								if (this._glCreated && texData) {
									gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glInternalFormat, texData);
								} else {
									gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
								}
							} else {
								device.setUnpackFlipY(false);
								device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
								if (this._glCreated && texData) {
									gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, texData);
								} else {
									gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
								}
							}
						}
					}
				} else if (texture._volume) {
					if (texture._compressed) {
						gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
					} else {
						device.setUnpackFlipY(false);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
					}
				} else if (texture.array && typeof mipObject === 'object') {
					if (texture._arrayLength === mipObject.length) {
						if (texture._compressed) {
							for (var index = 0; index < texture._arrayLength; index++) {
								gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, mipObject[index]);
							}
						} else {
							for (var _index = 0; _index < texture._arrayLength; _index++) {
								gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, _index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, this._glPixelType, mipObject[_index]);
							}
						}
					}
				} else {
					if (device._isBrowserInterface(mipObject)) {
						if (device._isImageBrowserInterface(mipObject)) {
							if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
								mipObject = downsampleImage(mipObject, device.maxTextureSize);
								if (mipLevel === 0) {
									texture._width = mipObject.width;
									texture._height = mipObject.height;
								}
							}
						}
						var w = mipObject.width || mipObject.videoWidth;
						var h = mipObject.height || mipObject.videoHeight;
						device.setUnpackFlipY(texture._flipY);
						device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
						if (this._glCreated && texture._width === w && texture._height === h && !device._isImageVideoInterface(mipObject)) {
							gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, this._glFormat, this._glPixelType, mipObject);
						} else {
							gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
							if (mipLevel === 0) {
								texture._width = w;
								texture._height = h;
							}
						}
					} else {
						resMult = 1 / Math.pow(2, mipLevel);
						if (texture._compressed) {
							if (this._glCreated && mipObject) {
								gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), this._glInternalFormat, mipObject);
							} else {
								gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
							}
						} else {
							device.setUnpackFlipY(false);
							device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
							if (this._glCreated && mipObject) {
								gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, mipObject);
							} else {
								gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
							}
						}
					}
					if (mipLevel === 0) {
						texture._mipmapsUploaded = false;
					} else {
						texture._mipmapsUploaded = true;
					}
				}
				mipLevel++;
			}
			if (texture._needsUpload) {
				if (texture._cubemap) {
					for (var i = 0; i < 6; i++) {
						texture._levelsUpdated[0][i] = false;
					}
				} else {
					texture._levelsUpdated[0] = false;
				}
			}
			if (!texture._compressed && !texture._integerFormat && texture._mipmaps && texture._needsMipmapsUpload && texture._levels.length === 1) {
				gl.generateMipmap(this._glTarget);
				texture._mipmapsUploaded = true;
			}
			if (texture._gpuSize) {
				texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
			}
			texture._gpuSize = texture.gpuSize;
			texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
			this._glCreated = true;
		};
		_proto.read = function read(x, y, width, height, options) {
			var texture = this.texture;
			var device = texture.device;
			return device.readTextureAsync(texture, x, y, width, height, options);
		};
		return WebglTexture;
	}();

	var FramebufferPair = function () {
		function FramebufferPair(msaaFB, resolveFB) {
			this.msaaFB = void 0;
			this.resolveFB = void 0;
			this.msaaFB = msaaFB;
			this.resolveFB = resolveFB;
		}
		var _proto = FramebufferPair.prototype;
		_proto.destroy = function destroy(gl) {
			if (this.msaaFB) {
				gl.deleteRenderbuffer(this.msaaFB);
				this.msaaFB = null;
			}
			if (this.resolveFB) {
				gl.deleteRenderbuffer(this.resolveFB);
				this.resolveFB = null;
			}
		};
		return FramebufferPair;
	}();
	var WebglRenderTarget = function () {
		function WebglRenderTarget() {
			this._glFrameBuffer = null;
			this._glDepthBuffer = null;
			this._glResolveFrameBuffer = null;
			this.colorMrtFramebuffers = null;
			this._glMsaaColorBuffers = [];
			this._glMsaaDepthBuffer = null;
			this.msaaDepthBufferKey = void 0;
			this.suppliedColorFramebuffer = void 0;
			this._isInitialized = false;
		}
		var _proto2 = WebglRenderTarget.prototype;
		_proto2.destroy = function destroy(device) {
			var _this$colorMrtFramebu;
			var gl = device.gl;
			this._isInitialized = false;
			if (this._glFrameBuffer) {
				if (this._glFrameBuffer !== this.suppliedColorFramebuffer) {
					gl.deleteFramebuffer(this._glFrameBuffer);
				}
				this._glFrameBuffer = null;
			}
			if (this._glDepthBuffer) {
				gl.deleteRenderbuffer(this._glDepthBuffer);
				this._glDepthBuffer = null;
			}
			if (this._glResolveFrameBuffer) {
				if (this._glResolveFrameBuffer !== this.suppliedColorFramebuffer) {
					gl.deleteFramebuffer(this._glResolveFrameBuffer);
				}
				this._glResolveFrameBuffer = null;
			}
			this._glMsaaColorBuffers.forEach(function (buffer) {
				gl.deleteRenderbuffer(buffer);
			});
			this._glMsaaColorBuffers.length = 0;
			(_this$colorMrtFramebu = this.colorMrtFramebuffers) == null || _this$colorMrtFramebu.forEach(function (framebuffer) {
				framebuffer.destroy(gl);
			});
			this.colorMrtFramebuffers = null;
			if (this._glMsaaDepthBuffer) {
				this._glMsaaDepthBuffer = null;
				if (this.msaaDepthBufferKey) {
					getMultisampledTextureCache(device).release(this.msaaDepthBufferKey);
				}
			}
			this.suppliedColorFramebuffer = undefined;
		};
		_proto2.init = function init(device, target) {
			var gl = device.gl;
			this._isInitialized = true;
			var buffers = [];
			if (this.suppliedColorFramebuffer !== undefined) {
				this._glFrameBuffer = this.suppliedColorFramebuffer;
			} else {
				var _target$_colorBuffers, _target$_colorBuffers2;
				this._glFrameBuffer = gl.createFramebuffer();
				device.setFramebuffer(this._glFrameBuffer);
				var colorBufferCount = (_target$_colorBuffers = (_target$_colorBuffers2 = target._colorBuffers) == null ? void 0 : _target$_colorBuffers2.length) != null ? _target$_colorBuffers : 0;
				var attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
				for (var i = 0; i < colorBufferCount; ++i) {
					var colorBuffer = target.getColorBuffer(i);
					if (colorBuffer) {
						if (!colorBuffer.impl._glTexture) {
							colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);
							colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);
							device.setTexture(colorBuffer, 0);
						}
						gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant + i, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, target.mipLevel);
						buffers.push(attachmentBaseConstant + i);
					}
				}
				gl.drawBuffers(buffers);
				var depthBuffer = target._depthBuffer;
				if (depthBuffer || target._depth) {
					var attachmentPoint = target._stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
					if (depthBuffer) {
						if (!depthBuffer.impl._glTexture) {
							depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);
							depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);
							device.setTexture(depthBuffer, 0);
						}
						gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, target.mipLevel);
					} else {
						var willRenderMsaa = target._samples > 1;
						if (!willRenderMsaa) {
							if (!this._glDepthBuffer) {
								this._glDepthBuffer = gl.createRenderbuffer();
							}
							var internalFormat = target._stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT32F;
							gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);
							gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width, target.height);
							gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._glDepthBuffer);
							gl.bindRenderbuffer(gl.RENDERBUFFER, null);
						}
					}
				}
			}
			if (target._samples > 1) {
				var _target$_colorBuffers3, _target$_colorBuffers4;
				this._glResolveFrameBuffer = this._glFrameBuffer;
				this._glFrameBuffer = gl.createFramebuffer();
				device.setFramebuffer(this._glFrameBuffer);
				var _colorBufferCount = (_target$_colorBuffers3 = (_target$_colorBuffers4 = target._colorBuffers) == null ? void 0 : _target$_colorBuffers4.length) != null ? _target$_colorBuffers3 : 0;
				if (this.suppliedColorFramebuffer !== undefined) {
					var buffer = gl.createRenderbuffer();
					this._glMsaaColorBuffers.push(buffer);
					var _internalFormat = device.backBufferFormat === PIXELFORMAT_RGBA8 ? gl.RGBA8 : gl.RGB8;
					gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, _internalFormat, target.width, target.height);
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
				} else {
					for (var _i = 0; _i < _colorBufferCount; ++_i) {
						var _colorBuffer = target.getColorBuffer(_i);
						if (_colorBuffer) {
							var _buffer = gl.createRenderbuffer();
							this._glMsaaColorBuffers.push(_buffer);
							gl.bindRenderbuffer(gl.RENDERBUFFER, _buffer);
							gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, _colorBuffer.impl._glInternalFormat, target.width, target.height);
							gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i, gl.RENDERBUFFER, _buffer);
						}
					}
				}
				if (target._depth) {
					var _internalFormat2 = target._stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT32F;
					var _attachmentPoint = target._stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
					var key;
					var _depthBuffer = target._depthBuffer;
					if (_depthBuffer) {
						key = _depthBuffer.id + ":" + target.width + ":" + target.height + ":" + target._samples + ":" + _internalFormat2 + ":" + _attachmentPoint;
						this._glMsaaDepthBuffer = getMultisampledTextureCache(device).get(key);
					}
					if (!this._glMsaaDepthBuffer) {
						this._glMsaaDepthBuffer = gl.createRenderbuffer();
						gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);
						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, _internalFormat2, target.width, target.height);
						this._glMsaaDepthBuffer.destroy = function () {
							gl.deleteRenderbuffer(this);
						};
						if (_depthBuffer) {
							getMultisampledTextureCache(device).set(key, this._glMsaaDepthBuffer);
						}
					}
					this.msaaDepthBufferKey = key;
					gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachmentPoint, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
				}
				if (_colorBufferCount > 1) {
					this._createMsaaMrtFramebuffers(device, target, _colorBufferCount);
					device.setFramebuffer(this._glFrameBuffer);
					gl.drawBuffers(buffers);
				}
			}
		};
		_proto2._createMsaaMrtFramebuffers = function _createMsaaMrtFramebuffers(device, target, colorBufferCount) {
			var gl = device.gl;
			this.colorMrtFramebuffers = [];
			for (var i = 0; i < colorBufferCount; ++i) {
				var colorBuffer = target.getColorBuffer(i);
				var srcFramebuffer = gl.createFramebuffer();
				device.setFramebuffer(srcFramebuffer);
				var buffer = this._glMsaaColorBuffers[i];
				gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
				gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
				gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
				var dstFramebuffer = gl.createFramebuffer();
				device.setFramebuffer(dstFramebuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
				this.colorMrtFramebuffers[i] = new FramebufferPair(srcFramebuffer, dstFramebuffer);
			}
		};
		_proto2._checkFbo = function _checkFbo(device, target, type) {
			var gl = device.gl;
			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			switch (status) {
				case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
					break;
				case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
					break;
				case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
					break;
				case gl.FRAMEBUFFER_UNSUPPORTED:
					break;
			}
		};
		_proto2.loseContext = function loseContext() {
			this._glFrameBuffer = null;
			this._glDepthBuffer = null;
			this._glResolveFrameBuffer = null;
			this._glMsaaColorBuffers.length = 0;
			this._glMsaaDepthBuffer = null;
			this.msaaDepthBufferKey = undefined;
			this.colorMrtFramebuffers = null;
			this.suppliedColorFramebuffer = undefined;
			this._isInitialized = false;
		};
		_proto2.internalResolve = function internalResolve(device, src, dst, target, mask) {
			device.setScissor(0, 0, target.width, target.height);
			var gl = device.gl;
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
			gl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, mask, gl.NEAREST);
		};
		_proto2.resolve = function resolve(device, target, color, depth) {
			var gl = device.gl;
			if (this.colorMrtFramebuffers) {
				if (color) {
					for (var i = 0; i < this.colorMrtFramebuffers.length; i++) {
						var fbPair = this.colorMrtFramebuffers[i];
						this.internalResolve(device, fbPair.msaaFB, fbPair.resolveFB, target, gl.COLOR_BUFFER_BIT);
					}
				}
				if (depth) {
					this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, gl.DEPTH_BUFFER_BIT);
				}
			} else {
				this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0));
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
		};
		return _createClass(WebglRenderTarget, [{
			key: "initialized",
			get: function get() {
				return this._isInitialized;
			}
		}]);
	}();

	var FrameQueriesInfo = function () {
		function FrameQueriesInfo() {
			this.renderVersion = void 0;
			this.queries = [];
		}
		var _proto = FrameQueriesInfo.prototype;
		_proto.destroy = function destroy(gl) {
			this.queries.forEach(function (query) {
				return gl.deleteQuery(query);
			});
			this.queries = null;
		};
		return FrameQueriesInfo;
	}();
	var WebglGpuProfiler = function (_GpuProfiler) {
		function WebglGpuProfiler(device) {
			var _this;
			_this = _GpuProfiler.call(this) || this;
			_this.device = void 0;
			_this.freeQueries = [];
			_this.frameQueries = [];
			_this.previousFrameQueries = [];
			_this.timings = [];
			_this.device = device;
			_this.ext = device.extDisjointTimerQuery;
			return _this;
		}
		_inheritsLoose(WebglGpuProfiler, _GpuProfiler);
		var _proto2 = WebglGpuProfiler.prototype;
		_proto2.destroy = function destroy() {
			var _this2 = this;
			this.freeQueries.forEach(function (query) {
				return _this2.device.gl.deleteQuery(query);
			});
			this.frameQueries.forEach(function (query) {
				return _this2.device.gl.deleteQuery(query);
			});
			this.previousFrameQueries.forEach(function (frameQueriesInfo) {
				return frameQueriesInfo.destroy(_this2.device.gl);
			});
			this.freeQueries = null;
			this.frameQueries = null;
			this.previousFrameQueries = null;
		};
		_proto2.loseContext = function loseContext() {
			_GpuProfiler.prototype.loseContext.call(this);
			this.freeQueries = [];
			this.frameQueries = [];
			this.previousFrameQueries = [];
		};
		_proto2.restoreContext = function restoreContext() {
			this.ext = this.device.extDisjointTimerQuery;
		};
		_proto2.getQuery = function getQuery() {
			var _this$freeQueries$pop;
			return (_this$freeQueries$pop = this.freeQueries.pop()) != null ? _this$freeQueries$pop : this.device.gl.createQuery();
		};
		_proto2.start = function start(name) {
			if (this.ext) {
				var slot = this.getSlot(name);
				var query = this.getQuery();
				this.frameQueries[slot] = query;
				this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
				return slot;
			}
			return undefined;
		};
		_proto2.end = function end(slot) {
			if (slot !== undefined) {
				this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
			}
		};
		_proto2.frameStart = function frameStart() {
			this.processEnableRequest();
			if (this._enabled) {
				this.frameGPUMarkerSlot = this.start('GpuFrame');
			}
		};
		_proto2.frameEnd = function frameEnd() {
			if (this._enabled) {
				this.end(this.frameGPUMarkerSlot);
			}
		};
		_proto2.request = function request() {
			var _this3 = this;
			if (this._enabled) {
				var ext = this.ext;
				var gl = this.device.gl;
				var renderVersion = this.device.renderVersion;
				var frameQueries = this.frameQueries;
				if (frameQueries.length > 0) {
					this.frameQueries = [];
					var frameQueriesInfo = new FrameQueriesInfo();
					frameQueriesInfo.queries = frameQueries;
					frameQueriesInfo.renderVersion = renderVersion;
					this.previousFrameQueries.push(frameQueriesInfo);
				}
				if (this.previousFrameQueries.length > 0) {
					var previousQueriesInfo = this.previousFrameQueries[0];
					var previousQueries = previousQueriesInfo.queries;
					var lastQuery = previousQueries[previousQueries.length - 1];
					var available = gl.getQueryParameter(lastQuery, gl.QUERY_RESULT_AVAILABLE);
					var disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
					if (available && !disjoint) {
						this.previousFrameQueries.shift();
						var timings = this.timings;
						timings.length = 0;
						for (var i = 0; i < previousQueries.length; i++) {
							var query = previousQueries[i];
							var duration = gl.getQueryParameter(query, gl.QUERY_RESULT);
							timings[i] = duration * 0.000001;
							this.freeQueries.push(query);
						}
						this.report(previousQueriesInfo.renderVersion, timings);
					}
					if (disjoint) {
						this.previousFrameQueries.forEach(function (frameQueriesInfo) {
							_this3.report(frameQueriesInfo.renderVersion, null);
							frameQueriesInfo.destroy(gl);
						});
						this.previousFrameQueries.length = 0;
					}
				}
				_GpuProfiler.prototype.request.call(this, renderVersion);
			}
		};
		return WebglGpuProfiler;
	}(GpuProfiler);

	var invalidateAttachments = [];
	var WebglGraphicsDevice = function (_GraphicsDevice) {
		function WebglGraphicsDevice(canvas, options) {
			var _options$antialias, _options$gl;
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _GraphicsDevice.call(this, canvas, options) || this;
			_this.gl = void 0;
			_this._defaultFramebuffer = null;
			_this._defaultFramebufferChanged = false;
			options = _this.initOptions;
			_this.updateClientRect();
			_this.initTextureUnits();
			_this.contextLost = false;
			_this._contextLostHandler = function (event) {
				event.preventDefault();
				_this.loseContext();
				_this.fire('devicelost');
			};
			_this._contextRestoredHandler = function () {
				_this.restoreContext();
				_this.fire('devicerestored');
			};
			var ua = typeof navigator !== 'undefined' && navigator.userAgent;
			_this.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));
			if (_this.forceDisableMultisampling) {
				options.antialias = false;
			}
			if (platform.browserName === 'firefox') {
				var _ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';
				var match = _ua.match(/Firefox\/(\d+(\.\d+)*)/);
				var firefoxVersion = match ? match[1] : null;
				if (firefoxVersion) {
					var version = parseFloat(firefoxVersion);
					var disableAntialias = platform.name === 'windows' && (version >= 120 || version === 115) || platform.name === 'android' && version >= 132;
					if (disableAntialias) {
						options.antialias = false;
					}
				}
			}
			_this.backBufferAntialias = (_options$antialias = options.antialias) != null ? _options$antialias : false;
			options.antialias = false;
			var gl = (_options$gl = options.gl) != null ? _options$gl : canvas.getContext('webgl2', options);
			if (!gl) {
				throw new Error('WebGL not supported');
			}
			_this.gl = gl;
			_this.isWebGL2 = true;
			_this._deviceType = DEVICETYPE_WEBGL2;
			_this.updateBackbufferFormat(null);
			var isChrome = platform.browserName === 'chrome';
			var isSafari = platform.browserName === 'safari';
			var isMac = platform.browser && navigator.appVersion.indexOf('Mac') !== -1;
			_this._tempEnableSafariTextureUnitWorkaround = isSafari;
			_this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;
			canvas.addEventListener('webglcontextlost', _this._contextLostHandler, false);
			canvas.addEventListener('webglcontextrestored', _this._contextRestoredHandler, false);
			_this.initializeExtensions();
			_this.initializeCapabilities();
			_this.initializeRenderState();
			_this.initializeContextCaches();
			_this.createBackbuffer(null);
			_this.supportsImageBitmap = !isSafari && typeof ImageBitmap !== 'undefined';
			_this._samplerTypes = new Set([gl.SAMPLER_2D, gl.SAMPLER_CUBE, gl.UNSIGNED_INT_SAMPLER_2D, gl.INT_SAMPLER_2D, gl.SAMPLER_2D_SHADOW, gl.SAMPLER_CUBE_SHADOW, gl.SAMPLER_3D, gl.INT_SAMPLER_3D, gl.UNSIGNED_INT_SAMPLER_3D, gl.SAMPLER_2D_ARRAY, gl.INT_SAMPLER_2D_ARRAY, gl.UNSIGNED_INT_SAMPLER_2D_ARRAY]);
			_this.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];
			_this.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, gl.MIN, gl.MAX];
			_this.glBlendFunctionColor = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_COLOR, gl.ONE_MINUS_CONSTANT_COLOR];
			_this.glBlendFunctionAlpha = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA];
			_this.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];
			_this.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];
			_this.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];
			_this.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];
			_this.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];
			_this.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
			_this.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT, gl.HALF_FLOAT];
			_this.pcUniformType = {};
			_this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
			_this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
			_this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
			_this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
			_this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
			_this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
			_this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
			_this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
			_this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
			_this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
			_this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
			_this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
			_this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
			_this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
			_this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
			_this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
			_this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;
			_this.pcUniformType[gl.UNSIGNED_INT] = UNIFORMTYPE_UINT;
			_this.pcUniformType[gl.UNSIGNED_INT_VEC2] = UNIFORMTYPE_UVEC2;
			_this.pcUniformType[gl.UNSIGNED_INT_VEC3] = UNIFORMTYPE_UVEC3;
			_this.pcUniformType[gl.UNSIGNED_INT_VEC4] = UNIFORMTYPE_UVEC4;
			_this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
			_this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
			_this.pcUniformType[gl.SAMPLER_2D_ARRAY] = UNIFORMTYPE_TEXTURE2D_ARRAY;
			_this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
			_this.pcUniformType[gl.INT_SAMPLER_2D] = UNIFORMTYPE_ITEXTURE2D;
			_this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURE2D;
			_this.pcUniformType[gl.INT_SAMPLER_CUBE] = UNIFORMTYPE_ITEXTURECUBE;
			_this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURECUBE;
			_this.pcUniformType[gl.INT_SAMPLER_3D] = UNIFORMTYPE_ITEXTURE3D;
			_this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_3D] = UNIFORMTYPE_UTEXTURE3D;
			_this.pcUniformType[gl.INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_ITEXTURE2D_ARRAY;
			_this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_UTEXTURE2D_ARRAY;
			_this.targetToSlot = {};
			_this.targetToSlot[gl.TEXTURE_2D] = 0;
			_this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
			_this.targetToSlot[gl.TEXTURE_3D] = 2;
			var scopeX, scopeY, scopeZ, scopeW;
			var uniformValue;
			_this.commitFunction = [];
			_this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
				if (uniform.value !== value) {
					gl.uniform1i(uniform.locationId, value);
					uniform.value = value;
				}
			};
			_this.commitFunction[UNIFORMTYPE_INT] = _this.commitFunction[UNIFORMTYPE_BOOL];
			_this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
				if (uniform.value !== value) {
					gl.uniform1f(uniform.locationId, value);
					uniform.value = value;
				}
			};
			_this.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
					gl.uniform2fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
				}
			};
			_this.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
					gl.uniform3fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
				}
			};
			_this.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				scopeW = value[3];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
					gl.uniform4fv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
					uniformValue[3] = scopeW;
				}
			};
			_this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
					gl.uniform2iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
				}
			};
			_this.commitFunction[UNIFORMTYPE_BVEC2] = _this.commitFunction[UNIFORMTYPE_IVEC2];
			_this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
					gl.uniform3iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
				}
			};
			_this.commitFunction[UNIFORMTYPE_BVEC3] = _this.commitFunction[UNIFORMTYPE_IVEC3];
			_this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				scopeW = value[3];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
					gl.uniform4iv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
					uniformValue[3] = scopeW;
				}
			};
			_this.commitFunction[UNIFORMTYPE_BVEC4] = _this.commitFunction[UNIFORMTYPE_IVEC4];
			_this.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {
				gl.uniformMatrix2fv(uniform.locationId, false, value);
			};
			_this.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {
				gl.uniformMatrix3fv(uniform.locationId, false, value);
			};
			_this.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {
				gl.uniformMatrix4fv(uniform.locationId, false, value);
			};
			_this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
				gl.uniform1fv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {
				gl.uniform2fv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {
				gl.uniform3fv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {
				gl.uniform4fv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_UINT] = function (uniform, value) {
				if (uniform.value !== value) {
					gl.uniform1ui(uniform.locationId, value);
					uniform.value = value;
				}
			};
			_this.commitFunction[UNIFORMTYPE_UVEC2] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
					gl.uniform2uiv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
				}
			};
			_this.commitFunction[UNIFORMTYPE_UVEC3] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
					gl.uniform3uiv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
				}
			};
			_this.commitFunction[UNIFORMTYPE_UVEC4] = function (uniform, value) {
				uniformValue = uniform.value;
				scopeX = value[0];
				scopeY = value[1];
				scopeZ = value[2];
				scopeW = value[3];
				if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
					gl.uniform4uiv(uniform.locationId, value);
					uniformValue[0] = scopeX;
					uniformValue[1] = scopeY;
					uniformValue[2] = scopeZ;
					uniformValue[3] = scopeW;
				}
			};
			_this.commitFunction[UNIFORMTYPE_INTARRAY] = function (uniform, value) {
				gl.uniform1iv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_UINTARRAY] = function (uniform, value) {
				gl.uniform1uiv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_BOOLARRAY] = _this.commitFunction[UNIFORMTYPE_INTARRAY];
			_this.commitFunction[UNIFORMTYPE_IVEC2ARRAY] = function (uniform, value) {
				gl.uniform2iv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_UVEC2ARRAY] = function (uniform, value) {
				gl.uniform2uiv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_BVEC2ARRAY] = _this.commitFunction[UNIFORMTYPE_IVEC2ARRAY];
			_this.commitFunction[UNIFORMTYPE_IVEC3ARRAY] = function (uniform, value) {
				gl.uniform3iv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_UVEC3ARRAY] = function (uniform, value) {
				gl.uniform3uiv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_BVEC3ARRAY] = _this.commitFunction[UNIFORMTYPE_IVEC3ARRAY];
			_this.commitFunction[UNIFORMTYPE_IVEC4ARRAY] = function (uniform, value) {
				gl.uniform4iv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_UVEC4ARRAY] = function (uniform, value) {
				gl.uniform4uiv(uniform.locationId, value);
			};
			_this.commitFunction[UNIFORMTYPE_BVEC4ARRAY] = _this.commitFunction[UNIFORMTYPE_IVEC4ARRAY];
			_this.commitFunction[UNIFORMTYPE_MAT4ARRAY] = function (uniform, value) {
				gl.uniformMatrix4fv(uniform.locationId, false, value);
			};
			_this.constantTexSource = _this.scope.resolve('source');
			_this.textureFloatRenderable = !!_this.extColorBufferFloat;
			_this.textureHalfFloatRenderable = !!_this.extColorBufferHalfFloat || !!_this.extColorBufferFloat;
			_this.postInit();
			return _this;
		}
		_inheritsLoose(WebglGraphicsDevice, _GraphicsDevice);
		var _proto = WebglGraphicsDevice.prototype;
		_proto.postInit = function postInit() {
			_GraphicsDevice.prototype.postInit.call(this);
			this.gpuProfiler = new WebglGpuProfiler(this);
		};
		_proto.destroy = function destroy() {
			_GraphicsDevice.prototype.destroy.call(this);
			var gl = this.gl;
			if (this.feedback) {
				gl.deleteTransformFeedback(this.feedback);
			}
			this.clearVertexArrayObjectCache();
			this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
			this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
			this._contextLostHandler = null;
			this._contextRestoredHandler = null;
			this.gl = null;
			_GraphicsDevice.prototype.postDestroy.call(this);
		};
		_proto.createBackbuffer = function createBackbuffer(frameBuffer) {
			this.supportsStencil = this.initOptions.stencil;
			this.backBuffer = new RenderTarget({
				name: 'WebglFramebuffer',
				graphicsDevice: this,
				depth: this.initOptions.depth,
				stencil: this.supportsStencil,
				samples: this.samples
			});
			this.backBuffer.impl.suppliedColorFramebuffer = frameBuffer;
		};
		_proto.updateBackbufferFormat = function updateBackbufferFormat(framebuffer) {
			var gl = this.gl;
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
			var alphaBits = this.gl.getParameter(this.gl.ALPHA_BITS);
			this.backBufferFormat = alphaBits ? PIXELFORMAT_RGBA8 : PIXELFORMAT_RGB8;
		};
		_proto.updateBackbuffer = function updateBackbuffer() {
			var resolutionChanged = this.canvas.width !== this.backBufferSize.x || this.canvas.height !== this.backBufferSize.y;
			if (this._defaultFramebufferChanged || resolutionChanged) {
				if (this._defaultFramebufferChanged) {
					this.updateBackbufferFormat(this._defaultFramebuffer);
				}
				this._defaultFramebufferChanged = false;
				this.backBufferSize.set(this.canvas.width, this.canvas.height);
				this.backBuffer.destroy();
				this.createBackbuffer(this._defaultFramebuffer);
			}
		};
		_proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format) {
			return new WebglVertexBuffer();
		};
		_proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer) {
			return new WebglIndexBuffer(indexBuffer);
		};
		_proto.createShaderImpl = function createShaderImpl(shader) {
			return new WebglShader(shader);
		};
		_proto.createTextureImpl = function createTextureImpl(texture) {
			return new WebglTexture(texture);
		};
		_proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
			return new WebglRenderTarget();
		};
		_proto.getPrecision = function getPrecision() {
			var gl = this.gl;
			var precision = 'highp';
			if (gl.getShaderPrecisionFormat) {
				var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
				var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
				var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
				var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
				if (vertexShaderPrecisionHighpFloat && vertexShaderPrecisionMediumpFloat && fragmentShaderPrecisionHighpFloat && fragmentShaderPrecisionMediumpFloat) {
					var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
					var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
					if (!highpAvailable) {
						if (mediumpAvailable) {
							precision = 'mediump';
						} else {
							precision = 'lowp';
						}
					}
				}
			}
			return precision;
		};
		_proto.getExtension = function getExtension() {
			for (var i = 0; i < arguments.length; i++) {
				if (this.supportedExtensions.indexOf(arguments[i]) !== -1) {
					return this.gl.getExtension(arguments[i]);
				}
			}
			return null;
		};
		_proto.initializeExtensions = function initializeExtensions() {
			var _gl$getSupportedExten;
			var gl = this.gl;
			this.supportedExtensions = (_gl$getSupportedExten = gl.getSupportedExtensions()) != null ? _gl$getSupportedExten : [];
			this._extDisjointTimerQuery = null;
			this.textureRG11B10Renderable = true;
			this.extColorBufferFloat = this.getExtension('EXT_color_buffer_float');
			this.extDebugRendererInfo = this.getExtension('WEBGL_debug_renderer_info');
			this.extTextureFloatLinear = this.getExtension('OES_texture_float_linear');
			this.textureFloatFilterable = !!this.extTextureFloatLinear;
			this.extFloatBlend = this.getExtension('EXT_float_blend');
			this.extTextureFilterAnisotropic = this.getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
			this.extParallelShaderCompile = this.getExtension('KHR_parallel_shader_compile');
			this.extCompressedTextureETC1 = this.getExtension('WEBGL_compressed_texture_etc1');
			this.extCompressedTextureETC = this.getExtension('WEBGL_compressed_texture_etc');
			this.extCompressedTexturePVRTC = this.getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
			this.extCompressedTextureS3TC = this.getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
			this.extCompressedTextureS3TC_SRGB = this.getExtension('WEBGL_compressed_texture_s3tc_srgb');
			this.extCompressedTextureATC = this.getExtension('WEBGL_compressed_texture_atc');
			this.extCompressedTextureASTC = this.getExtension('WEBGL_compressed_texture_astc');
			this.extTextureCompressionBPTC = this.getExtension('EXT_texture_compression_bptc');
			this.extColorBufferHalfFloat = this.getExtension('EXT_color_buffer_half_float');
		};
		_proto.initializeCapabilities = function initializeCapabilities() {
			var _contextAttribs$antia, _contextAttribs$stenc;
			var gl = this.gl;
			var ext;
			var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';
			this.maxPrecision = this.precision = this.getPrecision();
			var contextAttribs = gl.getContextAttributes();
			this.supportsMsaa = (_contextAttribs$antia = contextAttribs == null ? void 0 : contextAttribs.antialias) != null ? _contextAttribs$antia : false;
			this.supportsStencil = (_contextAttribs$stenc = contextAttribs == null ? void 0 : contextAttribs.stencil) != null ? _contextAttribs$stenc : false;
			this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
			this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
			this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
			this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
			this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
			this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
			this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
			this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
			this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
			this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
			ext = this.extDebugRendererInfo;
			this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
			this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
			var maliRendererRegex = /\bMali-G52+/;
			var samsungModelRegex = /SM-[a-zA-Z0-9]+/;
			this.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex)) && !this.unmaskedRenderer.match(maliRendererRegex);
			ext = this.extTextureFilterAnisotropic;
			this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
			var antialiasSupported = !this.forceDisableMultisampling;
			this.maxSamples = antialiasSupported ? gl.getParameter(gl.MAX_SAMPLES) : 1;
			this.maxSamples = Math.min(this.maxSamples, 4);
			this.samples = antialiasSupported && this.backBufferAntialias ? this.maxSamples : 1;
			this.supportsAreaLights = !platform.android;
			if (this.maxTextures <= 8) {
				this.supportsAreaLights = false;
			}
		};
		_proto.initializeRenderState = function initializeRenderState() {
			_GraphicsDevice.prototype.initializeRenderState.call(this);
			var gl = this.gl;
			gl.disable(gl.BLEND);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendEquation(gl.FUNC_ADD);
			gl.colorMask(true, true, true, true);
			gl.blendColor(0, 0, 0, 0);
			gl.enable(gl.CULL_FACE);
			this.cullFace = gl.BACK;
			gl.cullFace(gl.BACK);
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
			gl.depthMask(true);
			this.stencil = false;
			gl.disable(gl.STENCIL_TEST);
			this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
			this.stencilRefFront = this.stencilRefBack = 0;
			this.stencilMaskFront = this.stencilMaskBack = 0xFF;
			gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
			this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
			this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
			this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
			this.stencilWriteMaskFront = 0xFF;
			this.stencilWriteMaskBack = 0xFF;
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.stencilMask(0xFF);
			this.alphaToCoverage = false;
			this.raster = true;
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.disable(gl.RASTERIZER_DISCARD);
			this.depthBiasEnabled = false;
			gl.disable(gl.POLYGON_OFFSET_FILL);
			this.clearDepth = 1;
			gl.clearDepth(1);
			this.clearColor = new Color(0, 0, 0, 0);
			gl.clearColor(0, 0, 0, 0);
			this.clearStencil = 0;
			gl.clearStencil(0);
			gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
			gl.enable(gl.SCISSOR_TEST);
			gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
			this.unpackFlipY = false;
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
			this.unpackPremultiplyAlpha = false;
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		};
		_proto.initTextureUnits = function initTextureUnits(count) {
			if (count === void 0) {
				count = 16;
			}
			this.textureUnits = [];
			for (var i = 0; i < count; i++) {
				this.textureUnits.push([null, null, null]);
			}
		};
		_proto.initializeContextCaches = function initializeContextCaches() {
			_GraphicsDevice.prototype.initializeContextCaches.call(this);
			this._vaoMap = new Map();
			this.boundVao = null;
			this.activeFramebuffer = null;
			this.feedback = null;
			this.transformFeedbackBuffer = null;
			this.textureUnit = 0;
			this.initTextureUnits(this.maxCombinedTextures);
		};
		_proto.loseContext = function loseContext() {
			_GraphicsDevice.prototype.loseContext.call(this);
			for (var _iterator = _createForOfIteratorHelperLoose(this.shaders), _step; !(_step = _iterator()).done;) {
				var shader = _step.value;
				shader.loseContext();
			}
		};
		_proto.restoreContext = function restoreContext() {
			this.initializeExtensions();
			this.initializeCapabilities();
			_GraphicsDevice.prototype.restoreContext.call(this);
			for (var _iterator2 = _createForOfIteratorHelperLoose(this.shaders), _step2; !(_step2 = _iterator2()).done;) {
				var shader = _step2.value;
				shader.restoreContext();
			}
		};
		_proto.setViewport = function setViewport(x, y, w, h) {
			if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
				this.gl.viewport(x, y, w, h);
				this.vx = x;
				this.vy = y;
				this.vw = w;
				this.vh = h;
			}
		};
		_proto.setScissor = function setScissor(x, y, w, h) {
			if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
				this.gl.scissor(x, y, w, h);
				this.sx = x;
				this.sy = y;
				this.sw = w;
				this.sh = h;
			}
		};
		_proto.setFramebuffer = function setFramebuffer(fb) {
			if (this.activeFramebuffer !== fb) {
				var gl = this.gl;
				gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
				this.activeFramebuffer = fb;
			}
		};
		_proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
			var _this$backBuffer, _this$backBuffer2;
			var gl = this.gl;
			if (source === this.backBuffer) {
				source = null;
			}
			if (color) {
				if (!dest) {
					if (!source._colorBuffer) {
						return false;
					}
				} else if (source) {
					if (!source._colorBuffer || !dest._colorBuffer) {
						return false;
					}
					if (source._colorBuffer._format !== dest._colorBuffer._format) {
						return false;
					}
				}
			}
			if (depth && source) {
				if (!source._depth) {
					if (!source._depthBuffer || !dest._depthBuffer) {
						return false;
					}
					if (source._depthBuffer._format !== dest._depthBuffer._format) {
						return false;
					}
				}
			}
			var prevRt = this.renderTarget;
			this.renderTarget = dest;
			this.updateBegin();
			var src = source ? source.impl._glFrameBuffer : (_this$backBuffer = this.backBuffer) == null ? void 0 : _this$backBuffer.impl._glFrameBuffer;
			var dst = dest ? dest.impl._glFrameBuffer : (_this$backBuffer2 = this.backBuffer) == null ? void 0 : _this$backBuffer2.impl._glFrameBuffer;
			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
			var w = source ? source.width : dest ? dest.width : this.width;
			var h = source ? source.height : dest ? dest.height : this.height;
			gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
			this.renderTarget = prevRt;
			gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);
			return true;
		};
		_proto.frameStart = function frameStart() {
			_GraphicsDevice.prototype.frameStart.call(this);
			this.updateBackbuffer();
			this.gpuProfiler.frameStart();
		};
		_proto.frameEnd = function frameEnd() {
			_GraphicsDevice.prototype.frameEnd.call(this);
			this.gpuProfiler.frameEnd();
			this.gpuProfiler.request();
		};
		_proto.startRenderPass = function startRenderPass(renderPass) {
			var _renderPass$renderTar;
			var rt = (_renderPass$renderTar = renderPass.renderTarget) != null ? _renderPass$renderTar : this.backBuffer;
			this.renderTarget = rt;
			this.updateBegin();
			var width = rt.width,
				height = rt.height;
			this.setViewport(0, 0, width, height);
			this.setScissor(0, 0, width, height);
			var colorOps = renderPass.colorOps;
			var depthStencilOps = renderPass.depthStencilOps;
			if (colorOps != null && colorOps.clear || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {
				var clearFlags = 0;
				var clearOptions = {};
				if (colorOps != null && colorOps.clear) {
					clearFlags |= CLEARFLAG_COLOR;
					clearOptions.color = [colorOps.clearValue.r, colorOps.clearValue.g, colorOps.clearValue.b, colorOps.clearValue.a];
				}
				if (depthStencilOps.clearDepth) {
					clearFlags |= CLEARFLAG_DEPTH;
					clearOptions.depth = depthStencilOps.clearDepthValue;
				}
				if (depthStencilOps.clearStencil) {
					clearFlags |= CLEARFLAG_STENCIL;
					clearOptions.stencil = depthStencilOps.clearStencilValue;
				}
				clearOptions.flags = clearFlags;
				this.clear(clearOptions);
			}
			this.insideRenderPass = true;
		};
		_proto.endRenderPass = function endRenderPass(renderPass) {
			this.unbindVertexArray();
			var target = this.renderTarget;
			var colorBufferCount = renderPass.colorArrayOps.length;
			if (target) {
				var _renderPass$colorOps;
				invalidateAttachments.length = 0;
				var gl = this.gl;
				for (var i = 0; i < colorBufferCount; i++) {
					var colorOps = renderPass.colorArrayOps[i];
					if (!(colorOps.store || colorOps.resolve)) {
						invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + i);
					}
				}
				if (target !== this.backBuffer) {
					if (!renderPass.depthStencilOps.storeDepth) {
						invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
					}
					if (!renderPass.depthStencilOps.storeStencil) {
						invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
					}
				}
				if (invalidateAttachments.length > 0) {
					if (renderPass.fullSizeClearRect) {
						gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);
					}
				}
				if (colorBufferCount && (_renderPass$colorOps = renderPass.colorOps) != null && _renderPass$colorOps.resolve) {
					if (renderPass.samples > 1 && target.autoResolve) {
						target.resolve(true, false);
					}
				}
				if (target.depthBuffer && renderPass.depthStencilOps.resolveDepth) {
					if (renderPass.samples > 1 && target.autoResolve) {
						target.resolve(false, true);
					}
				}
				for (var _i = 0; _i < colorBufferCount; _i++) {
					var _colorOps = renderPass.colorArrayOps[_i];
					if (_colorOps.genMipmaps) {
						var colorBuffer = target._colorBuffers[_i];
						if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
							this.activeTexture(this.maxCombinedTextures - 1);
							this.bindTexture(colorBuffer);
							this.gl.generateMipmap(colorBuffer.impl._glTarget);
						}
					}
				}
			}
			this.insideRenderPass = false;
		};
		_proto.updateBegin = function updateBegin() {
			var _this$renderTarget;
			this.boundVao = null;
			if (this._tempEnableSafariTextureUnitWorkaround) {
				for (var unit = 0; unit < this.textureUnits.length; ++unit) {
					for (var slot = 0; slot < 3; ++slot) {
						this.textureUnits[unit][slot] = null;
					}
				}
			}
			var target = (_this$renderTarget = this.renderTarget) != null ? _this$renderTarget : this.backBuffer;
			var targetImpl = target.impl;
			if (!targetImpl.initialized) {
				this.initRenderTarget(target);
			}
			this.setFramebuffer(targetImpl._glFrameBuffer);
		};
		_proto.updateEnd = function updateEnd() {
			this.unbindVertexArray();
			var target = this.renderTarget;
			if (target && target !== this.backBuffer) {
				if (target._samples > 1 && target.autoResolve) {
					target.resolve();
				}
				var colorBuffer = target._colorBuffer;
				if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
					this.activeTexture(this.maxCombinedTextures - 1);
					this.bindTexture(colorBuffer);
					this.gl.generateMipmap(colorBuffer.impl._glTarget);
				}
			}
		};
		_proto.setUnpackFlipY = function setUnpackFlipY(flipY) {
			if (this.unpackFlipY !== flipY) {
				this.unpackFlipY = flipY;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
			}
		};
		_proto.setUnpackPremultiplyAlpha = function setUnpackPremultiplyAlpha(premultiplyAlpha) {
			if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
				this.unpackPremultiplyAlpha = premultiplyAlpha;
				var gl = this.gl;
				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
			}
		};
		_proto.activeTexture = function activeTexture(textureUnit) {
			if (this.textureUnit !== textureUnit) {
				this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
				this.textureUnit = textureUnit;
			}
		};
		_proto.bindTexture = function bindTexture(texture) {
			var impl = texture.impl;
			var textureTarget = impl._glTarget;
			var textureObject = impl._glTexture;
			var textureUnit = this.textureUnit;
			var slot = this.targetToSlot[textureTarget];
			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		};
		_proto.bindTextureOnUnit = function bindTextureOnUnit(texture, textureUnit) {
			var impl = texture.impl;
			var textureTarget = impl._glTarget;
			var textureObject = impl._glTexture;
			var slot = this.targetToSlot[textureTarget];
			if (this.textureUnits[textureUnit][slot] !== textureObject) {
				this.activeTexture(textureUnit);
				this.gl.bindTexture(textureTarget, textureObject);
				this.textureUnits[textureUnit][slot] = textureObject;
			}
		};
		_proto.setTextureParameters = function setTextureParameters(texture) {
			var gl = this.gl;
			var flags = texture.impl.dirtyParameterFlags;
			var target = texture.impl._glTarget;
			if (flags & TEXPROPERTY_MIN_FILTER) {
				var filter = texture._minFilter;
				if (!texture._mipmaps || texture._compressed && texture._levels.length === 1) {
					if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
						filter = FILTER_NEAREST;
					} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
						filter = FILTER_LINEAR;
					}
				}
				gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
			}
			if (flags & TEXPROPERTY_MAG_FILTER) {
				gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
			}
			if (flags & TEXPROPERTY_ADDRESS_U) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
			}
			if (flags & TEXPROPERTY_ADDRESS_V) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
			}
			if (flags & TEXPROPERTY_ADDRESS_W) {
				gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
			}
			if (flags & TEXPROPERTY_COMPARE_ON_READ) {
				gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
			}
			if (flags & TEXPROPERTY_COMPARE_FUNC) {
				gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
			}
			if (flags & TEXPROPERTY_ANISOTROPY) {
				var ext = this.extTextureFilterAnisotropic;
				if (ext) {
					gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, math.clamp(Math.round(texture._anisotropy), 1, this.maxAnisotropy));
				}
			}
		};
		_proto.setTexture = function setTexture(texture, textureUnit) {
			var impl = texture.impl;
			if (!impl._glTexture) {
				impl.initialize(this, texture);
			}
			if (impl.dirtyParameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {
				this.activeTexture(textureUnit);
				this.bindTexture(texture);
				if (impl.dirtyParameterFlags) {
					this.setTextureParameters(texture);
					impl.dirtyParameterFlags = 0;
				}
				if (texture._needsUpload || texture._needsMipmapsUpload) {
					impl.upload(this, texture);
					texture._needsUpload = false;
					texture._needsMipmapsUpload = false;
				}
			} else {
				this.bindTextureOnUnit(texture, textureUnit);
			}
		};
		_proto.createVertexArray = function createVertexArray(vertexBuffers) {
			var key, vao;
			var useCache = vertexBuffers.length > 1;
			if (useCache) {
				key = '';
				for (var i = 0; i < vertexBuffers.length; i++) {
					var vertexBuffer = vertexBuffers[i];
					key += vertexBuffer.id + vertexBuffer.format.renderingHash;
				}
				vao = this._vaoMap.get(key);
			}
			if (!vao) {
				var gl = this.gl;
				vao = gl.createVertexArray();
				gl.bindVertexArray(vao);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
				for (var _i2 = 0; _i2 < vertexBuffers.length; _i2++) {
					var _vertexBuffer = vertexBuffers[_i2];
					gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer.impl.bufferId);
					var elements = _vertexBuffer.format.elements;
					for (var j = 0; j < elements.length; j++) {
						var e = elements[j];
						var loc = semanticToLocation[e.name];
						if (e.asInt) {
							gl.vertexAttribIPointer(loc, e.numComponents, this.glType[e.dataType], e.stride, e.offset);
						} else {
							gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
						}
						gl.enableVertexAttribArray(loc);
						if (_vertexBuffer.format.instancing) {
							gl.vertexAttribDivisor(loc, 1);
						}
					}
				}
				gl.bindVertexArray(null);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
				if (useCache) {
					this._vaoMap.set(key, vao);
				}
			}
			return vao;
		};
		_proto.unbindVertexArray = function unbindVertexArray() {
			if (this.boundVao) {
				this.boundVao = null;
				this.gl.bindVertexArray(null);
			}
		};
		_proto.setBuffers = function setBuffers() {
			var gl = this.gl;
			var vao;
			if (this.vertexBuffers.length === 1) {
				var vertexBuffer = this.vertexBuffers[0];
				if (!vertexBuffer.impl.vao) {
					vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
				}
				vao = vertexBuffer.impl.vao;
			} else {
				vao = this.createVertexArray(this.vertexBuffers);
			}
			if (this.boundVao !== vao) {
				this.boundVao = vao;
				gl.bindVertexArray(vao);
			}
			this.clearVertexBuffer();
			var bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
		};
		_proto.draw = function draw(primitive, numInstances, keepBuffers) {
			var gl = this.gl;
			this.activateShader(this);
			if (!this.shaderValid) {
				return;
			}
			var sampler, samplerValue, texture, numTextures;
			var uniform, scopeId, uniformVersion, programVersion;
			var shader = this.shader;
			if (!shader) {
				return;
			}
			var samplers = shader.impl.samplers;
			var uniforms = shader.impl.uniforms;
			if (!keepBuffers) {
				this.setBuffers();
			}
			var textureUnit = 0;
			for (var i = 0, len = samplers.length; i < len; i++) {
				sampler = samplers[i];
				samplerValue = sampler.scopeId.value;
				if (!samplerValue) {
					var samplerName = sampler.scopeId.name;
					if (samplerName === 'uSceneDepthMap') {
						samplerValue = getBuiltInTexture(this, 'white');
					}
					if (samplerName === 'uSceneColorMap') {
						samplerValue = getBuiltInTexture(this, 'pink');
					}
					if (!samplerValue) {
						samplerValue = getBuiltInTexture(this, 'pink');
					}
				}
				if (samplerValue instanceof Texture) {
					texture = samplerValue;
					this.setTexture(texture, textureUnit);
					if (sampler.slot !== textureUnit) {
						gl.uniform1i(sampler.locationId, textureUnit);
						sampler.slot = textureUnit;
					}
					textureUnit++;
				} else {
					sampler.array.length = 0;
					numTextures = samplerValue.length;
					for (var j = 0; j < numTextures; j++) {
						texture = samplerValue[j];
						this.setTexture(texture, textureUnit);
						sampler.array[j] = textureUnit;
						textureUnit++;
					}
					gl.uniform1iv(sampler.locationId, sampler.array);
				}
			}
			for (var _i3 = 0, _len = uniforms.length; _i3 < _len; _i3++) {
				uniform = uniforms[_i3];
				scopeId = uniform.scopeId;
				uniformVersion = uniform.version;
				programVersion = scopeId.versionObject.version;
				if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
					uniformVersion.globalId = programVersion.globalId;
					uniformVersion.revision = programVersion.revision;
					if (scopeId.value !== null) {
						this.commitFunction[uniform.dataType](uniform, scopeId.value);
					}
				}
			}
			if (this.transformFeedbackBuffer) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
				gl.beginTransformFeedback(gl.POINTS);
			}
			var mode = this.glPrimitive[primitive.type];
			var count = primitive.count;
			if (primitive.indexed) {
				var indexBuffer = this.indexBuffer;
				var format = indexBuffer.impl.glFormat;
				var offset = primitive.base * indexBuffer.bytesPerIndex;
				if (numInstances > 0) {
					gl.drawElementsInstanced(mode, count, format, offset, numInstances);
				} else {
					gl.drawElements(mode, count, format, offset);
				}
			} else {
				var first = primitive.base;
				if (numInstances > 0) {
					gl.drawArraysInstanced(mode, first, count, numInstances);
				} else {
					gl.drawArrays(mode, first, count);
				}
			}
			if (this.transformFeedbackBuffer) {
				gl.endTransformFeedback();
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
			}
			this._drawCallsPerFrame++;
		};
		_proto.clear = function clear(options) {
			var _options$flags;
			var defaultOptions = this.defaultClearOptions;
			options = options || defaultOptions;
			var flags = (_options$flags = options.flags) != null ? _options$flags : defaultOptions.flags;
			if (flags !== 0) {
				var gl = this.gl;
				if (flags & CLEARFLAG_COLOR) {
					var _options$color;
					var color = (_options$color = options.color) != null ? _options$color : defaultOptions.color;
					var r = color[0];
					var g = color[1];
					var b = color[2];
					var a = color[3];
					var c = this.clearColor;
					if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
						this.gl.clearColor(r, g, b, a);
						this.clearColor.set(r, g, b, a);
					}
					this.setBlendState(BlendState.NOBLEND);
				}
				if (flags & CLEARFLAG_DEPTH) {
					var _options$depth;
					var depth = (_options$depth = options.depth) != null ? _options$depth : defaultOptions.depth;
					if (depth !== this.clearDepth) {
						this.gl.clearDepth(depth);
						this.clearDepth = depth;
					}
					this.setDepthState(DepthState.WRITEDEPTH);
				}
				if (flags & CLEARFLAG_STENCIL) {
					var _options$stencil;
					var stencil = (_options$stencil = options.stencil) != null ? _options$stencil : defaultOptions.stencil;
					if (stencil !== this.clearStencil) {
						this.gl.clearStencil(stencil);
						this.clearStencil = stencil;
					}
					gl.stencilMask(0xFF);
					this.stencilWriteMaskFront = 0xFF;
					this.stencilWriteMaskBack = 0xFF;
				}
				gl.clear(this.glClearFlag[flags]);
			}
		};
		_proto.submit = function submit() {
			this.gl.flush();
		};
		_proto.readPixels = function readPixels(x, y, w, h, pixels) {
			var gl = this.gl;
			gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
		};
		_proto.readPixelsAsync = function () {
			var _readPixelsAsync = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(x, y, w, h, pixels) {
				var _this2 = this,
					_this$renderTarget$co,
					_impl$_glFormat,
					_impl$_glPixelType;
				var gl, clientWaitAsync, impl, format, pixelType, buf;
				return _regeneratorRuntime().wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							gl = this.gl;
							clientWaitAsync = function clientWaitAsync(flags, interval_ms) {
								var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
								_this2.submit();
								return new Promise(function (resolve, reject) {
									function test() {
										var res = gl.clientWaitSync(sync, flags, 0);
										if (res === gl.WAIT_FAILED) {
											gl.deleteSync(sync);
											reject(new Error('webgl clientWaitSync sync failed'));
										} else if (res === gl.TIMEOUT_EXPIRED) {
											setTimeout(test, interval_ms);
										} else {
											gl.deleteSync(sync);
											resolve();
										}
									}
									test();
								});
							};
							impl = (_this$renderTarget$co = this.renderTarget.colorBuffer) == null ? void 0 : _this$renderTarget$co.impl;
							format = (_impl$_glFormat = impl == null ? void 0 : impl._glFormat) != null ? _impl$_glFormat : gl.RGBA;
							pixelType = (_impl$_glPixelType = impl == null ? void 0 : impl._glPixelType) != null ? _impl$_glPixelType : gl.UNSIGNED_BYTE;
							buf = gl.createBuffer();
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
							gl.bufferData(gl.PIXEL_PACK_BUFFER, pixels.byteLength, gl.STREAM_READ);
							gl.readPixels(x, y, w, h, format, pixelType, 0);
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
							_context.next = 12;
							return clientWaitAsync(0, 20);
						case 12:
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
							gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, pixels);
							gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
							gl.deleteBuffer(buf);
							return _context.abrupt("return", pixels);
						case 17:
						case "end":
							return _context.stop();
					}
				}, _callee, this);
			}));
			function readPixelsAsync(_x, _x2, _x3, _x4, _x5) {
				return _readPixelsAsync.apply(this, arguments);
			}
			return readPixelsAsync;
		}();
		_proto.readTextureAsync = function readTextureAsync(texture, x, y, width, height, options) {
			var _options$face,
				_options$renderTarget,
				_options$data,
				_this3 = this;
			var face = (_options$face = options.face) != null ? _options$face : 0;
			var renderTarget = (_options$renderTarget = options.renderTarget) != null ? _options$renderTarget : new RenderTarget({
				colorBuffer: texture,
				depth: false,
				face: face
			});
			var buffer = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, 1, texture._format));
			var data = (_options$data = options.data) != null ? _options$data : new (getPixelFormatArrayType(texture._format))(buffer);
			this.setRenderTarget(renderTarget);
			this.initRenderTarget(renderTarget);
			return new Promise(function (resolve, reject) {
				_this3.readPixelsAsync(x, y, width, height, data).then(function (data) {
					if (!options.renderTarget) {
						renderTarget.destroy();
					}
					resolve(data);
				}).catch(reject);
			});
		};
		_proto.setAlphaToCoverage = function setAlphaToCoverage(state) {
			if (this.alphaToCoverage !== state) {
				this.alphaToCoverage = state;
				if (state) {
					this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
				} else {
					this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
				}
			}
		};
		_proto.setTransformFeedbackBuffer = function setTransformFeedbackBuffer(tf) {
			if (this.transformFeedbackBuffer !== tf) {
				this.transformFeedbackBuffer = tf;
				var _gl = this.gl;
				if (tf) {
					if (!this.feedback) {
						this.feedback = _gl.createTransformFeedback();
					}
					_gl.bindTransformFeedback(_gl.TRANSFORM_FEEDBACK, this.feedback);
				} else {
					_gl.bindTransformFeedback(_gl.TRANSFORM_FEEDBACK, null);
				}
			}
		};
		_proto.setRaster = function setRaster(on) {
			if (this.raster !== on) {
				this.raster = on;
				if (on) {
					this.gl.disable(this.gl.RASTERIZER_DISCARD);
				} else {
					this.gl.enable(this.gl.RASTERIZER_DISCARD);
				}
			}
		};
		_proto.setStencilTest = function setStencilTest(enable) {
			if (this.stencil !== enable) {
				var _gl2 = this.gl;
				if (enable) {
					_gl2.enable(_gl2.STENCIL_TEST);
				} else {
					_gl2.disable(_gl2.STENCIL_TEST);
				}
				this.stencil = enable;
			}
		};
		_proto.setStencilFunc = function setStencilFunc(func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				this.gl.stencilFunc(this.glComparison[func], ref, mask);
				this.stencilFuncFront = this.stencilFuncBack = func;
				this.stencilRefFront = this.stencilRefBack = ref;
				this.stencilMaskFront = this.stencilMaskBack = mask;
			}
		};
		_proto.setStencilFuncFront = function setStencilFuncFront(func, ref, mask) {
			if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
				var _gl3 = this.gl;
				_gl3.stencilFuncSeparate(_gl3.FRONT, this.glComparison[func], ref, mask);
				this.stencilFuncFront = func;
				this.stencilRefFront = ref;
				this.stencilMaskFront = mask;
			}
		};
		_proto.setStencilFuncBack = function setStencilFuncBack(func, ref, mask) {
			if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
				var _gl4 = this.gl;
				_gl4.stencilFuncSeparate(_gl4.BACK, this.glComparison[func], ref, mask);
				this.stencilFuncBack = func;
				this.stencilRefBack = ref;
				this.stencilMaskBack = mask;
			}
		};
		_proto.setStencilOperation = function setStencilOperation(fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = this.stencilFailBack = fail;
				this.stencilZfailFront = this.stencilZfailBack = zfail;
				this.stencilZpassFront = this.stencilZpassBack = zpass;
			}
			if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMask(writeMask);
				this.stencilWriteMaskFront = writeMask;
				this.stencilWriteMaskBack = writeMask;
			}
		};
		_proto.setStencilOperationFront = function setStencilOperationFront(fail, zfail, zpass, writeMask) {
			if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
				this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailFront = fail;
				this.stencilZfailFront = zfail;
				this.stencilZpassFront = zpass;
			}
			if (this.stencilWriteMaskFront !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
				this.stencilWriteMaskFront = writeMask;
			}
		};
		_proto.setStencilOperationBack = function setStencilOperationBack(fail, zfail, zpass, writeMask) {
			if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
				this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
				this.stencilFailBack = fail;
				this.stencilZfailBack = zfail;
				this.stencilZpassBack = zpass;
			}
			if (this.stencilWriteMaskBack !== writeMask) {
				this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
				this.stencilWriteMaskBack = writeMask;
			}
		};
		_proto.setBlendState = function setBlendState(blendState) {
			var currentBlendState = this.blendState;
			if (!currentBlendState.equals(blendState)) {
				var _gl5 = this.gl;
				var blend = blendState.blend,
					colorOp = blendState.colorOp,
					alphaOp = blendState.alphaOp,
					colorSrcFactor = blendState.colorSrcFactor,
					colorDstFactor = blendState.colorDstFactor,
					alphaSrcFactor = blendState.alphaSrcFactor,
					alphaDstFactor = blendState.alphaDstFactor;
				if (currentBlendState.blend !== blend) {
					if (blend) {
						_gl5.enable(_gl5.BLEND);
					} else {
						_gl5.disable(_gl5.BLEND);
					}
				}
				if (currentBlendState.colorOp !== colorOp || currentBlendState.alphaOp !== alphaOp) {
					var glBlendEquation = this.glBlendEquation;
					_gl5.blendEquationSeparate(glBlendEquation[colorOp], glBlendEquation[alphaOp]);
				}
				if (currentBlendState.colorSrcFactor !== colorSrcFactor || currentBlendState.colorDstFactor !== colorDstFactor || currentBlendState.alphaSrcFactor !== alphaSrcFactor || currentBlendState.alphaDstFactor !== alphaDstFactor) {
					_gl5.blendFuncSeparate(this.glBlendFunctionColor[colorSrcFactor], this.glBlendFunctionColor[colorDstFactor], this.glBlendFunctionAlpha[alphaSrcFactor], this.glBlendFunctionAlpha[alphaDstFactor]);
				}
				if (currentBlendState.allWrite !== blendState.allWrite) {
					this.gl.colorMask(blendState.redWrite, blendState.greenWrite, blendState.blueWrite, blendState.alphaWrite);
				}
				currentBlendState.copy(blendState);
			}
		};
		_proto.setBlendColor = function setBlendColor(r, g, b, a) {
			var c = this.blendColor;
			if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
				this.gl.blendColor(r, g, b, a);
				c.set(r, g, b, a);
			}
		};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {
			if (stencilFront || stencilBack) {
				this.setStencilTest(true);
				if (stencilFront === stencilBack) {
					this.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
					this.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
				} else {
					var _stencilFront, _stencilBack;
					(_stencilFront = stencilFront) != null ? _stencilFront : stencilFront = StencilParameters.DEFAULT;
					this.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
					this.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
					(_stencilBack = stencilBack) != null ? _stencilBack : stencilBack = StencilParameters.DEFAULT;
					this.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
					this.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
				}
			} else {
				this.setStencilTest(false);
			}
		};
		_proto.setDepthState = function setDepthState(depthState) {
			var currentDepthState = this.depthState;
			if (!currentDepthState.equals(depthState)) {
				var _gl6 = this.gl;
				var write = depthState.write;
				if (currentDepthState.write !== write) {
					_gl6.depthMask(write);
				}
				var func = depthState.func,
					test = depthState.test;
				if (!test && write) {
					test = true;
					func = FUNC_ALWAYS;
				}
				if (currentDepthState.func !== func) {
					_gl6.depthFunc(this.glComparison[func]);
				}
				if (currentDepthState.test !== test) {
					if (test) {
						_gl6.enable(_gl6.DEPTH_TEST);
					} else {
						_gl6.disable(_gl6.DEPTH_TEST);
					}
				}
				var depthBias = depthState.depthBias,
					depthBiasSlope = depthState.depthBiasSlope;
				if (depthBias || depthBiasSlope) {
					if (!this.depthBiasEnabled) {
						this.depthBiasEnabled = true;
						this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
					}
					_gl6.polygonOffset(depthBiasSlope, depthBias);
				} else {
					if (this.depthBiasEnabled) {
						this.depthBiasEnabled = false;
						this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
					}
				}
				currentDepthState.copy(depthState);
			}
		};
		_proto.setCullMode = function setCullMode(cullMode) {
			if (this.cullMode !== cullMode) {
				if (cullMode === CULLFACE_NONE) {
					this.gl.disable(this.gl.CULL_FACE);
				} else {
					if (this.cullMode === CULLFACE_NONE) {
						this.gl.enable(this.gl.CULL_FACE);
					}
					var mode = this.glCull[cullMode];
					if (this.cullFace !== mode) {
						this.gl.cullFace(mode);
						this.cullFace = mode;
					}
				}
				this.cullMode = cullMode;
			}
		};
		_proto.setShader = function setShader(shader, asyncCompile) {
			if (asyncCompile === void 0) {
				asyncCompile = false;
			}
			if (shader !== this.shader) {
				this.shader = shader;
				this.shaderAsyncCompile = asyncCompile;
				this.shaderValid = undefined;
			}
		};
		_proto.activateShader = function activateShader(device) {
			var shader = this.shader;
			var impl = shader.impl;
			if (this.shaderValid === undefined) {
				if (shader.failed) {
					this.shaderValid = false;
				} else if (!shader.ready) {
					if (this.shaderAsyncCompile) {
						if (impl.isLinked(device)) {
							if (!impl.finalize(this, shader)) {
								shader.failed = true;
								this.shaderValid = false;
							}
						} else {
							this.shaderValid = false;
						}
					} else {
						if (!impl.finalize(this, shader)) {
							shader.failed = true;
							this.shaderValid = false;
						}
					}
				}
			}
			if (this.shaderValid === undefined) {
				this.gl.useProgram(impl.glProgram);
				this.shaderValid = true;
			}
		};
		_proto.clearVertexArrayObjectCache = function clearVertexArrayObjectCache() {
			var gl = this.gl;
			this._vaoMap.forEach(function (item, key, mapObj) {
				gl.deleteVertexArray(item);
			});
			this._vaoMap.clear();
		};
		return _createClass(WebglGraphicsDevice, [{
			key: "extDisjointTimerQuery",
			get: function get() {
				if (!this._extDisjointTimerQuery) {
					this._extDisjointTimerQuery = this.getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
				}
				return this._extDisjointTimerQuery;
			}
		}, {
			key: "defaultFramebuffer",
			get: function get() {
				return this._defaultFramebuffer;
			},
			set: function set(value) {
				if (this._defaultFramebuffer !== value) {
					this._defaultFramebuffer = value;
					this._defaultFramebufferChanged = true;
				}
			}
		}, {
			key: "fullscreen",
			get: function get() {
				return !!document.fullscreenElement;
			},
			set: function set(fullscreen) {
				if (fullscreen) {
					var canvas = this.gl.canvas;
					canvas.requestFullscreen();
				} else {
					document.exitFullscreen();
				}
			}
		}]);
	}(GraphicsDevice);

	var NullIndexBuffer = function () {
		function NullIndexBuffer() {}
		var _proto = NullIndexBuffer.prototype;
		_proto.unlock = function unlock(indexBuffer) {};
		return NullIndexBuffer;
	}();

	var NullRenderTarget = function () {
		function NullRenderTarget() {}
		var _proto = NullRenderTarget.prototype;
		_proto.destroy = function destroy(device) {};
		_proto.init = function init(device, renderTarget) {};
		_proto.loseContext = function loseContext() {};
		_proto.resolve = function resolve(device, target, color, depth) {};
		return NullRenderTarget;
	}();

	var NullShader = function () {
		function NullShader() {}
		var _proto = NullShader.prototype;
		_proto.destroy = function destroy(shader) {};
		_proto.loseContext = function loseContext() {};
		_proto.restoreContext = function restoreContext(device, shader) {};
		return NullShader;
	}();

	var NullTexture = function () {
		function NullTexture() {}
		var _proto = NullTexture.prototype;
		_proto.destroy = function destroy(device) {};
		_proto.propertyChanged = function propertyChanged(flag) {};
		_proto.loseContext = function loseContext() {};
		return NullTexture;
	}();

	var NullVertexBuffer = function () {
		function NullVertexBuffer() {}
		var _proto = NullVertexBuffer.prototype;
		_proto.destroy = function destroy(device) {};
		_proto.unlock = function unlock(vertexBuffer) {};
		return NullVertexBuffer;
	}();

	var NullGraphicsDevice = function (_GraphicsDevice) {
		function NullGraphicsDevice(canvas, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _GraphicsDevice.call(this, canvas, options) || this;
			options = _this.initOptions;
			_this.isNull = true;
			_this._deviceType = DEVICETYPE_NULL;
			_this.samples = 1;
			return _this;
		}
		_inheritsLoose(NullGraphicsDevice, _GraphicsDevice);
		var _proto = NullGraphicsDevice.prototype;
		_proto.destroy = function destroy() {
			_GraphicsDevice.prototype.destroy.call(this);
		};
		_proto.initDeviceCaps = function initDeviceCaps() {
			this.disableParticleSystem = true;
			this.precision = 'highp';
			this.maxPrecision = 'highp';
			this.maxSamples = 4;
			this.maxTextures = 16;
			this.maxTextureSize = 4096;
			this.maxCubeMapSize = 4096;
			this.maxVolumeSize = 4096;
			this.maxColorAttachments = 8;
			this.maxPixelRatio = 1;
			this.maxAnisotropy = 16;
			this.supportsUniformBuffers = false;
			this.supportsAreaLights = true;
			this.supportsGpuParticles = false;
			this.textureFloatRenderable = true;
			this.textureHalfFloatRenderable = true;
			this.supportsImageBitmap = true;
		};
		_proto.postInit = function postInit() {
			_GraphicsDevice.prototype.postInit.call(this);
		};
		_proto.frameStart = function frameStart() {
			_GraphicsDevice.prototype.frameStart.call(this);
		};
		_proto.frameEnd = function frameEnd() {
			_GraphicsDevice.prototype.frameEnd.call(this);
		};
		_proto.updateBegin = function updateBegin() {};
		_proto.updateEnd = function updateEnd() {};
		_proto.readPixels = function readPixels(x, y, w, h, pixels) {};
		_proto.createVertexBufferImpl = function createVertexBufferImpl(vertexBuffer, format) {
			return new NullVertexBuffer(vertexBuffer, format);
		};
		_proto.createIndexBufferImpl = function createIndexBufferImpl(indexBuffer) {
			return new NullIndexBuffer(indexBuffer);
		};
		_proto.createShaderImpl = function createShaderImpl(shader) {
			return new NullShader(shader);
		};
		_proto.createTextureImpl = function createTextureImpl(texture) {
			return new NullTexture(texture);
		};
		_proto.createRenderTargetImpl = function createRenderTargetImpl(renderTarget) {
			return new NullRenderTarget(renderTarget);
		};
		_proto.draw = function draw(primitive, numInstances, keepBuffers) {
		};
		_proto.setShader = function setShader(shader, asyncCompile) {
		};
		_proto.setBlendState = function setBlendState(blendState) {};
		_proto.setDepthState = function setDepthState(depthState) {};
		_proto.setStencilState = function setStencilState(stencilFront, stencilBack) {};
		_proto.setBlendColor = function setBlendColor(r, g, b, a) {};
		_proto.setCullMode = function setCullMode(cullMode) {};
		_proto.setAlphaToCoverage = function setAlphaToCoverage(state) {};
		_proto.initializeContextCaches = function initializeContextCaches() {
			_GraphicsDevice.prototype.initializeContextCaches.call(this);
		};
		_proto.clear = function clear(options) {};
		_proto.setViewport = function setViewport(x, y, w, h) {};
		_proto.setScissor = function setScissor(x, y, w, h) {};
		_proto.copyRenderTarget = function copyRenderTarget(source, dest, color, depth) {
			return true;
		};
		return NullGraphicsDevice;
	}(GraphicsDevice);

	function createGraphicsDevice(canvas, options) {
		var _options$deviceTypes;
		if (options === void 0) {
			options = {};
		}
		var deviceTypes = (_options$deviceTypes = options.deviceTypes) != null ? _options$deviceTypes : [];
		if (!deviceTypes.includes(DEVICETYPE_WEBGL2)) {
			deviceTypes.push(DEVICETYPE_WEBGL2);
		}
		if (!deviceTypes.includes(DEVICETYPE_NULL)) {
			deviceTypes.push(DEVICETYPE_NULL);
		}
		if (platform.browser && !!navigator.xr) {
			var _options, _options$xrCompatible;
			(_options$xrCompatible = (_options = options).xrCompatible) != null ? _options$xrCompatible : _options.xrCompatible = true;
		}
		var deviceCreateFuncs = [];
		for (var i = 0; i < deviceTypes.length; i++) {
			var _window;
			var deviceType = deviceTypes[i];
			if (deviceType === DEVICETYPE_WEBGPU && (_window = window) != null && (_window = _window.navigator) != null && _window.gpu) {
				deviceCreateFuncs.push(function () {
					var device = new WebgpuGraphicsDevice(canvas, options);
					return device.initWebGpu(options.glslangUrl, options.twgslUrl);
				});
			}
			if (deviceType === DEVICETYPE_WEBGL2) {
				deviceCreateFuncs.push(function () {
					return new WebglGraphicsDevice(canvas, options);
				});
			}
			if (deviceType === DEVICETYPE_NULL) {
				deviceCreateFuncs.push(function () {
					return new NullGraphicsDevice(canvas, options);
				});
			}
		}
		return new Promise(function (resolve, reject) {
			var attempt = 0;
			var _next = function next() {
				if (attempt >= deviceCreateFuncs.length) {
					reject(new Error('Failed to create a graphics device'));
				} else {
					Promise.resolve(deviceCreateFuncs[attempt++]()).then(function (device) {
						if (device) {
							resolve(device);
						} else {
							_next();
						}
					}).catch(function (err) {
						console.log(err);
						_next();
					});
				}
			};
			_next();
		});
	}

	var ComputeParameter = function ComputeParameter() {
		this.value = void 0;
		this.scopeId = null;
	};
	var Compute = function () {
		function Compute(graphicsDevice, shader, name) {
			if (name === void 0) {
				name = 'Unnamed';
			}
			this.shader = null;
			this.name = void 0;
			this.parameters = new Map();
			this.countX = 1;
			this.countY = void 0;
			this.countZ = void 0;
			this.device = graphicsDevice;
			this.shader = shader;
			this.name = name;
			if (graphicsDevice.supportsCompute) {
				this.impl = graphicsDevice.createComputeImpl(this);
			}
		}
		var _proto = Compute.prototype;
		_proto.setParameter = function setParameter(name, value) {
			var param = this.parameters.get(name);
			if (!param) {
				param = new ComputeParameter();
				param.scopeId = this.device.scope.resolve(name);
				this.parameters.set(name, param);
			}
			param.value = value;
		};
		_proto.getParameter = function getParameter(name) {
			var _this$parameters$get;
			return (_this$parameters$get = this.parameters.get(name)) == null ? void 0 : _this$parameters$get.value;
		};
		_proto.deleteParameter = function deleteParameter(name) {
			this.parameters.delete(name);
		};
		_proto.applyParameters = function applyParameters() {
			for (var _iterator = _createForOfIteratorHelperLoose(this.parameters), _step; !(_step = _iterator()).done;) {
				var _step$value = _step.value,
					param = _step$value[1];
				param.scopeId.setValue(param.value);
			}
		};
		_proto.setupDispatch = function setupDispatch(x, y, z) {
			this.countX = x;
			this.countY = y;
			this.countZ = z;
		};
		return Compute;
	}();

	var id$5 = 0;
	var IndexBuffer = function () {
		function IndexBuffer(graphicsDevice, format, numIndices, usage, initialData, options) {
			if (usage === void 0) {
				usage = BUFFER_STATIC;
			}
			this.device = graphicsDevice;
			this.format = format;
			this.numIndices = numIndices;
			this.usage = usage;
			this.id = id$5++;
			this.impl = graphicsDevice.createIndexBufferImpl(this, options);
			var bytesPerIndex = typedArrayIndexFormatsByteSize[format];
			this.bytesPerIndex = bytesPerIndex;
			this.numBytes = this.numIndices * bytesPerIndex;
			if (initialData) {
				this.setData(initialData);
			} else {
				this.storage = new ArrayBuffer(this.numBytes);
			}
			this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
			this.device.buffers.push(this);
		}
		var _proto = IndexBuffer.prototype;
		_proto.destroy = function destroy() {
			var device = this.device;
			var idx = device.buffers.indexOf(this);
			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}
			if (this.device.indexBuffer === this) {
				this.device.indexBuffer = null;
			}
			if (this.impl.initialized) {
				this.impl.destroy(device);
				this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
			}
		};
		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.ib += size;
		};
		_proto.loseContext = function loseContext() {
			this.impl.loseContext();
		};
		_proto.getFormat = function getFormat() {
			return this.format;
		};
		_proto.getNumIndices = function getNumIndices() {
			return this.numIndices;
		};
		_proto.lock = function lock() {
			return this.storage;
		};
		_proto.unlock = function unlock() {
			this.impl.unlock(this);
		};
		_proto.setData = function setData(data) {
			if (data.byteLength !== this.numBytes) {
				return false;
			}
			this.storage = data;
			this.unlock();
			return true;
		};
		_proto._lockTypedArray = function _lockTypedArray() {
			var lock = this.lock();
			var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
			return indices;
		};
		_proto.writeData = function writeData(data, count) {
			var indices = this._lockTypedArray();
			if (data.length > count) {
				if (ArrayBuffer.isView(data)) {
					data = data.subarray(0, count);
					indices.set(data);
				} else {
					for (var i = 0; i < count; i++) {
						indices[i] = data[i];
					}
				}
			} else {
				indices.set(data);
			}
			this.unlock();
		};
		_proto.readData = function readData(data) {
			var indices = this._lockTypedArray();
			var count = this.numIndices;
			if (ArrayBuffer.isView(data)) {
				data.set(indices);
			} else {
				data.length = 0;
				for (var i = 0; i < count; i++) {
					data[i] = indices[i];
				}
			}
			return count;
		};
		return IndexBuffer;
	}();

	var ColorAttachmentOps = function ColorAttachmentOps() {
		this.clearValue = new Color(0, 0, 0, 1);
		this.clearValueLinear = new Color(0, 0, 0, 1);
		this.clear = false;
		this.store = false;
		this.resolve = true;
		this.genMipmaps = false;
	};
	var DepthStencilAttachmentOps = function DepthStencilAttachmentOps() {
		this.clearDepthValue = 1;
		this.clearStencilValue = 0;
		this.clearDepth = false;
		this.clearStencil = false;
		this.storeDepth = false;
		this.resolveDepth = false;
		this.storeStencil = false;
	};
	var RenderPass = function () {
		function RenderPass(graphicsDevice) {
			this._name = void 0;
			this.device = void 0;
			this._enabled = true;
			this._skipStart = false;
			this._skipEnd = false;
			this.executeEnabled = true;
			this.renderTarget = void 0;
			this._options = void 0;
			this.samples = 0;
			this.colorArrayOps = [];
			this.depthStencilOps = void 0;
			this.requiresCubemaps = true;
			this.fullSizeClearRect = true;
			this.beforePasses = [];
			this.afterPasses = [];
			this.device = graphicsDevice;
		}
		var _proto = RenderPass.prototype;
		_proto.init = function init(renderTarget, options) {
			if (renderTarget === void 0) {
				renderTarget = null;
			}
			this.options = options;
			this.renderTarget = renderTarget;
			this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);
			this.allocateAttachments();
			this.postInit();
		};
		_proto.allocateAttachments = function allocateAttachments() {
			var _rt$_colorBuffers$len, _rt$_colorBuffers;
			var rt = this.renderTarget;
			this.depthStencilOps = new DepthStencilAttachmentOps();
			if (rt != null && rt.depthBuffer) {
				this.depthStencilOps.storeDepth = true;
			}
			var numColorOps = rt ? (_rt$_colorBuffers$len = (_rt$_colorBuffers = rt._colorBuffers) == null ? void 0 : _rt$_colorBuffers.length) != null ? _rt$_colorBuffers$len : 0 : 1;
			this.colorArrayOps.length = 0;
			for (var i = 0; i < numColorOps; i++) {
				var _this$renderTarget, _this$renderTarget2;
				var colorOps = new ColorAttachmentOps();
				this.colorArrayOps[i] = colorOps;
				if (this.samples === 1) {
					colorOps.store = true;
					colorOps.resolve = false;
				}
				var colorBuffer = (_this$renderTarget = this.renderTarget) == null || (_this$renderTarget = _this$renderTarget._colorBuffers) == null ? void 0 : _this$renderTarget[i];
				if ((_this$renderTarget2 = this.renderTarget) != null && _this$renderTarget2.mipmaps && colorBuffer != null && colorBuffer.mipmaps) {
					var intFormat = isIntegerPixelFormat(colorBuffer._format);
					colorOps.genMipmaps = !intFormat;
				}
			}
		};
		_proto.destroy = function destroy() {};
		_proto.postInit = function postInit() {};
		_proto.frameUpdate = function frameUpdate() {
			if (this._options && this.renderTarget) {
				var _this$_options$resize;
				var resizeSource = (_this$_options$resize = this._options.resizeSource) != null ? _this$_options$resize : this.device.backBuffer;
				var width = Math.floor(resizeSource.width * this.scaleX);
				var height = Math.floor(resizeSource.height * this.scaleY);
				this.renderTarget.resize(width, height);
			}
		};
		_proto.before = function before() {};
		_proto.execute = function execute() {};
		_proto.after = function after() {};
		_proto.onEnable = function onEnable() {};
		_proto.onDisable = function onDisable() {};
		_proto.setClearColor = function setClearColor(color) {
			var count = this.colorArrayOps.length;
			for (var i = 0; i < count; i++) {
				var colorOps = this.colorArrayOps[i];
				if (color) {
					colorOps.clearValue.copy(color);
					colorOps.clearValueLinear.linear(color);
				}
				colorOps.clear = !!color;
			}
		};
		_proto.setClearDepth = function setClearDepth(depthValue) {
			if (depthValue) {
				this.depthStencilOps.clearDepthValue = depthValue;
			}
			this.depthStencilOps.clearDepth = depthValue !== undefined;
		};
		_proto.setClearStencil = function setClearStencil(stencilValue) {
			if (stencilValue) {
				this.depthStencilOps.clearStencilValue = stencilValue;
			}
			this.depthStencilOps.clearStencil = stencilValue !== undefined;
		};
		_proto.render = function render() {
			if (this.enabled) {
				var device = this.device;
				var realPass = this.renderTarget !== undefined;
				this.before();
				if (this.executeEnabled) {
					if (realPass && !this._skipStart) {
						device.startRenderPass(this);
					}
					this.execute();
					if (realPass && !this._skipEnd) {
						device.endRenderPass(this);
					}
				}
				this.after();
				device.renderPassIndex++;
			}
		};
		return _createClass(RenderPass, [{
			key: "colorOps",
			get: function get() {
				return this.colorArrayOps[0];
			}
		}, {
			key: "name",
			get: function get() {
				if (!this._name) {
					this._name = this.constructor.name;
				}
				return this._name;
			},
			set: function set(value) {
				this._name = value;
			}
		}, {
			key: "scaleX",
			get: function get() {
				return this._options.scaleX;
			},
			set: function set(value) {
				this._options.scaleX = value;
			}
		}, {
			key: "scaleY",
			get: function get() {
				return this._options.scaleY;
			},
			set: function set(value) {
				this._options.scaleY = value;
			}
		}, {
			key: "options",
			get: function get() {
				return this._options;
			},
			set: function set(value) {
				this._options = value;
				if (value) {
					var _this$scaleX, _this$scaleY;
					this.scaleX = (_this$scaleX = this.scaleX) != null ? _this$scaleX : 1;
					this.scaleY = (_this$scaleY = this.scaleY) != null ? _this$scaleY : 1;
				}
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				if (this._enabled !== value) {
					this._enabled = value;
					if (value) {
						this.onEnable();
					} else {
						this.onDisable();
					}
				}
			}
		}]);
	}();

	var id$4 = 0;
	var StorageBuffer = function () {
		function StorageBuffer(graphicsDevice, byteSize, bufferUsage) {
			if (bufferUsage === void 0) {
				bufferUsage = 0;
			}
			this.id = id$4++;
			this.device = graphicsDevice;
			this.byteSize = byteSize;
			this.bufferUsage = bufferUsage;
			this.impl = graphicsDevice.createBufferImpl(BUFFERUSAGE_STORAGE | bufferUsage);
			this.impl.allocate(graphicsDevice, byteSize);
			this.device.buffers.push(this);
			this.adjustVramSizeTracking(graphicsDevice._vram, this.byteSize);
		}
		var _proto = StorageBuffer.prototype;
		_proto.destroy = function destroy() {
			var device = this.device;
			var idx = device.buffers.indexOf(this);
			if (idx !== -1) {
				device.buffers.splice(idx, 1);
			}
			this.adjustVramSizeTracking(device._vram, -this.byteSize);
			this.impl.destroy(device);
		};
		_proto.adjustVramSizeTracking = function adjustVramSizeTracking(vram, size) {
			vram.sb += size;
		};
		_proto.read = function read(offset, size, data) {
			if (offset === void 0) {
				offset = 0;
			}
			if (size === void 0) {
				size = this.byteSize;
			}
			if (data === void 0) {
				data = null;
			}
			return this.impl.read(this.device, offset, size, data);
		};
		_proto.write = function write(bufferOffset, data, dataOffset, size) {
			if (bufferOffset === void 0) {
				bufferOffset = 0;
			}
			if (dataOffset === void 0) {
				dataOffset = 0;
			}
			this.impl.write(this.device, bufferOffset, data, dataOffset, size);
		};
		_proto.clear = function clear(offset, size) {
			if (offset === void 0) {
				offset = 0;
			}
			if (size === void 0) {
				size = this.byteSize;
			}
			this.impl.clear(this.device, offset, size);
		};
		return StorageBuffer;
	}();

	var TransformFeedback = function () {
		function TransformFeedback(inputBuffer, usage) {
			if (usage === void 0) {
				usage = BUFFER_GPUDYNAMIC;
			}
			this.device = inputBuffer.device;
			var gl = this.device.gl;
			this._inputBuffer = inputBuffer;
			if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
				gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.impl.bufferId);
				gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
			}
			this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, {
				usage: usage,
				data: inputBuffer.storage
			});
		}
		TransformFeedback.createShader = function createShader(graphicsDevice, vertexCode, name) {
			return new Shader(graphicsDevice, ShaderUtils.createDefinition(graphicsDevice, {
				name: name,
				vertexCode: vertexCode,
				useTransformFeedback: true
			}));
		};
		var _proto = TransformFeedback.prototype;
		_proto.destroy = function destroy() {
			this._outputBuffer.destroy();
		};
		_proto.process = function process(shader, swap) {
			if (swap === void 0) {
				swap = true;
			}
			var device = this.device;
			var oldRt = device.getRenderTarget();
			device.setRenderTarget(null);
			device.updateBegin();
			device.setVertexBuffer(this._inputBuffer, 0);
			device.setRaster(false);
			device.setTransformFeedbackBuffer(this._outputBuffer);
			device.setShader(shader);
			device.draw({
				type: PRIMITIVE_POINTS,
				base: 0,
				count: this._inputBuffer.numVertices,
				indexed: false
			});
			device.setTransformFeedbackBuffer(null);
			device.setRaster(true);
			device.updateEnd();
			device.setRenderTarget(oldRt);
			if (swap) {
				var tmp = this._inputBuffer.impl.bufferId;
				this._inputBuffer.impl.bufferId = this._outputBuffer.impl.bufferId;
				this._outputBuffer.impl.bufferId = tmp;
				tmp = this._inputBuffer.impl.vao;
				this._inputBuffer.impl.vao = this._outputBuffer.impl.vao;
				this._outputBuffer.impl.vao = tmp;
			}
		};
		return _createClass(TransformFeedback, [{
			key: "inputBuffer",
			get: function get() {
				return this._inputBuffer;
			}
		}, {
			key: "outputBuffer",
			get: function get() {
				return this._outputBuffer;
			}
		}]);
	}();

	function set1(a) {
		this.array[this.index] = a;
	}
	function set2(a, b) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
	}
	function set3(a, b, c) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
	}
	function set4(a, b, c, d) {
		this.array[this.index] = a;
		this.array[this.index + 1] = b;
		this.array[this.index + 2] = c;
		this.array[this.index + 3] = d;
	}
	function arraySet1(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
	}
	function arraySet2(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
	}
	function arraySet3(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
	}
	function arraySet4(index, inputArray, inputIndex) {
		this.array[index] = inputArray[inputIndex];
		this.array[index + 1] = inputArray[inputIndex + 1];
		this.array[index + 2] = inputArray[inputIndex + 2];
		this.array[index + 3] = inputArray[inputIndex + 3];
	}
	function arrayGet1(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
	}
	function arrayGet2(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
	}
	function arrayGet3(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
	}
	function arrayGet4(offset, outputArray, outputIndex) {
		outputArray[outputIndex] = this.array[offset];
		outputArray[outputIndex + 1] = this.array[offset + 1];
		outputArray[outputIndex + 2] = this.array[offset + 2];
		outputArray[outputIndex + 3] = this.array[offset + 3];
	}
	var VertexIteratorAccessor = function () {
		function VertexIteratorAccessor(buffer, vertexElement, vertexFormat) {
			this.index = 0;
			this.numComponents = vertexElement.numComponents;
			if (vertexFormat.interleaved) {
				this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
			} else {
				this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
			}
			this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;
			switch (vertexElement.numComponents) {
				case 1:
					this.set = set1;
					this.getToArray = arrayGet1;
					this.setFromArray = arraySet1;
					break;
				case 2:
					this.set = set2;
					this.getToArray = arrayGet2;
					this.setFromArray = arraySet2;
					break;
				case 3:
					this.set = set3;
					this.getToArray = arrayGet3;
					this.setFromArray = arraySet3;
					break;
				case 4:
					this.set = set4;
					this.getToArray = arrayGet4;
					this.setFromArray = arraySet4;
					break;
			}
		}
		var _proto = VertexIteratorAccessor.prototype;
		_proto.get = function get(offset) {
			return this.array[this.index + offset];
		};
		_proto.set = function set(a, b, c, d) {};
		_proto.getToArray = function getToArray(offset, outputArray, outputIndex) {};
		_proto.setFromArray = function setFromArray(index, inputArray, inputIndex) {};
		return VertexIteratorAccessor;
	}();
	var VertexIterator = function () {
		function VertexIterator(vertexBuffer) {
			this.vertexBuffer = vertexBuffer;
			this.vertexFormatSize = vertexBuffer.getFormat().size;
			this.buffer = this.vertexBuffer.lock();
			this.accessors = [];
			this.element = {};
			var vertexFormat = this.vertexBuffer.getFormat();
			for (var i = 0; i < vertexFormat.elements.length; i++) {
				var vertexElement = vertexFormat.elements[i];
				this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
				this.element[vertexElement.name] = this.accessors[i];
			}
		}
		var _proto2 = VertexIterator.prototype;
		_proto2.next = function next(count) {
			if (count === void 0) {
				count = 1;
			}
			var i = 0;
			var accessors = this.accessors;
			var numAccessors = this.accessors.length;
			while (i < numAccessors) {
				var accessor = accessors[i++];
				accessor.index += count * accessor.stride;
			}
		};
		_proto2.end = function end() {
			this.vertexBuffer.unlock();
		};
		_proto2.writeData = function writeData(semantic, data, numVertices) {
			var element = this.element[semantic];
			if (element) {
				if (numVertices > this.vertexBuffer.numVertices) {
					numVertices = this.vertexBuffer.numVertices;
				}
				var numComponents = element.numComponents;
				if (this.vertexBuffer.getFormat().interleaved) {
					var index = 0;
					for (var i = 0; i < numVertices; i++) {
						element.setFromArray(index, data, i * numComponents);
						index += element.stride;
					}
				} else {
					if (data.length > numVertices * numComponents) {
						var copyCount = numVertices * numComponents;
						if (ArrayBuffer.isView(data)) {
							data = data.subarray(0, copyCount);
							element.array.set(data);
						} else {
							for (var _i = 0; _i < copyCount; _i++) {
								element.array[_i] = data[_i];
							}
						}
					} else {
						element.array.set(data);
					}
				}
			}
		};
		_proto2.readData = function readData(semantic, data) {
			var element = this.element[semantic];
			var count = 0;
			if (element) {
				count = this.vertexBuffer.numVertices;
				var i;
				var numComponents = element.numComponents;
				if (this.vertexBuffer.getFormat().interleaved) {
					if (Array.isArray(data)) {
						data.length = 0;
					}
					element.index = 0;
					var offset = 0;
					for (i = 0; i < count; i++) {
						element.getToArray(offset, data, i * numComponents);
						offset += element.stride;
					}
				} else {
					if (ArrayBuffer.isView(data)) {
						data.set(element.array);
					} else {
						data.length = 0;
						var copyCount = count * numComponents;
						for (i = 0; i < copyCount; i++) {
							data[i] = element.array[i];
						}
					}
				}
			}
			return count;
		};
		return VertexIterator;
	}();

	var ACTION_MOUSE = 'mouse';
	var ACTION_KEYBOARD = 'keyboard';
	var ACTION_GAMEPAD = 'gamepad';
	var AXIS_MOUSE_X = 'mousex';
	var AXIS_MOUSE_Y = 'mousey';
	var AXIS_PAD_L_X = 'padlx';
	var AXIS_PAD_L_Y = 'padly';
	var AXIS_PAD_R_X = 'padrx';
	var AXIS_PAD_R_Y = 'padry';
	var AXIS_KEY = 'key';
	var EVENT_KEYDOWN = 'keydown';
	var EVENT_KEYUP = 'keyup';
	var EVENT_MOUSEDOWN = 'mousedown';
	var EVENT_MOUSEMOVE = 'mousemove';
	var EVENT_MOUSEUP = 'mouseup';
	var EVENT_MOUSEWHEEL = 'mousewheel';
	var EVENT_TOUCHSTART = 'touchstart';
	var EVENT_TOUCHEND = 'touchend';
	var EVENT_TOUCHMOVE = 'touchmove';
	var EVENT_TOUCHCANCEL = 'touchcancel';
	var EVENT_SELECT = 'select';
	var EVENT_SELECTSTART = 'selectstart';
	var EVENT_SELECTEND = 'selectend';
	var KEY_BACKSPACE = 8;
	var KEY_TAB = 9;
	var KEY_RETURN = 13;
	var KEY_ENTER = 13;
	var KEY_SHIFT = 16;
	var KEY_CONTROL = 17;
	var KEY_ALT = 18;
	var KEY_PAUSE = 19;
	var KEY_CAPS_LOCK = 20;
	var KEY_ESCAPE = 27;
	var KEY_SPACE = 32;
	var KEY_PAGE_UP = 33;
	var KEY_PAGE_DOWN = 34;
	var KEY_END = 35;
	var KEY_HOME = 36;
	var KEY_LEFT = 37;
	var KEY_UP = 38;
	var KEY_RIGHT = 39;
	var KEY_DOWN = 40;
	var KEY_PRINT_SCREEN = 44;
	var KEY_INSERT = 45;
	var KEY_DELETE = 46;
	var KEY_0 = 48;
	var KEY_1 = 49;
	var KEY_2 = 50;
	var KEY_3 = 51;
	var KEY_4 = 52;
	var KEY_5 = 53;
	var KEY_6 = 54;
	var KEY_7 = 55;
	var KEY_8 = 56;
	var KEY_9 = 57;
	var KEY_SEMICOLON = 59;
	var KEY_EQUAL = 61;
	var KEY_A = 65;
	var KEY_B = 66;
	var KEY_C = 67;
	var KEY_D = 68;
	var KEY_E = 69;
	var KEY_F = 70;
	var KEY_G = 71;
	var KEY_H = 72;
	var KEY_I = 73;
	var KEY_J = 74;
	var KEY_K = 75;
	var KEY_L = 76;
	var KEY_M = 77;
	var KEY_N = 78;
	var KEY_O = 79;
	var KEY_P = 80;
	var KEY_Q = 81;
	var KEY_R = 82;
	var KEY_S = 83;
	var KEY_T = 84;
	var KEY_U = 85;
	var KEY_V = 86;
	var KEY_W = 87;
	var KEY_X = 88;
	var KEY_Y = 89;
	var KEY_Z = 90;
	var KEY_WINDOWS = 91;
	var KEY_CONTEXT_MENU = 93;
	var KEY_NUMPAD_0 = 96;
	var KEY_NUMPAD_1 = 97;
	var KEY_NUMPAD_2 = 98;
	var KEY_NUMPAD_3 = 99;
	var KEY_NUMPAD_4 = 100;
	var KEY_NUMPAD_5 = 101;
	var KEY_NUMPAD_6 = 102;
	var KEY_NUMPAD_7 = 103;
	var KEY_NUMPAD_8 = 104;
	var KEY_NUMPAD_9 = 105;
	var KEY_MULTIPLY = 106;
	var KEY_ADD = 107;
	var KEY_SEPARATOR = 108;
	var KEY_SUBTRACT = 109;
	var KEY_DECIMAL = 110;
	var KEY_DIVIDE = 111;
	var KEY_F1 = 112;
	var KEY_F2 = 113;
	var KEY_F3 = 114;
	var KEY_F4 = 115;
	var KEY_F5 = 116;
	var KEY_F6 = 117;
	var KEY_F7 = 118;
	var KEY_F8 = 119;
	var KEY_F9 = 120;
	var KEY_F10 = 121;
	var KEY_F11 = 122;
	var KEY_F12 = 123;
	var KEY_COMMA = 188;
	var KEY_PERIOD = 190;
	var KEY_SLASH = 191;
	var KEY_OPEN_BRACKET = 219;
	var KEY_BACK_SLASH = 220;
	var KEY_CLOSE_BRACKET = 221;
	var KEY_META = 224;
	var MOUSEBUTTON_NONE = -1;
	var MOUSEBUTTON_LEFT = 0;
	var MOUSEBUTTON_MIDDLE = 1;
	var MOUSEBUTTON_RIGHT = 2;
	var PAD_1 = 0;
	var PAD_2 = 1;
	var PAD_3 = 2;
	var PAD_4 = 3;
	var PAD_FACE_1 = 0;
	var PAD_FACE_2 = 1;
	var PAD_FACE_3 = 2;
	var PAD_FACE_4 = 3;
	var PAD_L_SHOULDER_1 = 4;
	var PAD_R_SHOULDER_1 = 5;
	var PAD_L_SHOULDER_2 = 6;
	var PAD_R_SHOULDER_2 = 7;
	var PAD_SELECT = 8;
	var PAD_START = 9;
	var PAD_L_STICK_BUTTON = 10;
	var PAD_R_STICK_BUTTON = 11;
	var PAD_UP = 12;
	var PAD_DOWN = 13;
	var PAD_LEFT = 14;
	var PAD_RIGHT = 15;
	var PAD_VENDOR = 16;
	var PAD_L_STICK_X = 0;
	var PAD_L_STICK_Y = 1;
	var PAD_R_STICK_X = 2;
	var PAD_R_STICK_Y = 3;
	var EVENT_GAMEPADCONNECTED = 'gamepadconnected';
	var EVENT_GAMEPADDISCONNECTED = 'gamepaddisconnected';
	var XRPAD_TOUCHPAD_X = 0;
	var XRPAD_TOUCHPAD_Y = 1;
	var XRPAD_STICK_X = 2;
	var XRPAD_STICK_Y = 3;
	var XRPAD_TOUCHPAD_BUTTON = 2;
	var XRPAD_TRIGGER = 0;
	var XRPAD_SQUEEZE = 1;
	var XRPAD_STICK_BUTTON = 3;
	var XRPAD_A = 4;
	var XRPAD_B = 5;

	var KeyboardEvent = function KeyboardEvent(keyboard, event) {
		this.key = null;
		this.element = null;
		this.event = null;
		if (event) {
			this.key = event.keyCode;
			this.element = event.target;
			this.event = event;
		}
	};

	var _keyboardEvent = new KeyboardEvent();
	function makeKeyboardEvent(event) {
		_keyboardEvent.key = event.keyCode;
		_keyboardEvent.element = event.target;
		_keyboardEvent.event = event;
		return _keyboardEvent;
	}
	function toKeyCode(s) {
		if (typeof s === 'string') {
			return s.toUpperCase().charCodeAt(0);
		}
		return s;
	}
	var _keyCodeToKeyIdentifier = {
		'9': 'Tab',
		'13': 'Enter',
		'16': 'Shift',
		'17': 'Control',
		'18': 'Alt',
		'27': 'Escape',
		'37': 'Left',
		'38': 'Up',
		'39': 'Right',
		'40': 'Down',
		'46': 'Delete',
		'91': 'Win'
	};
	var Keyboard = function (_EventHandler) {
		function Keyboard(element, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _EventHandler.call(this) || this;
			_this._element = null;
			_this._keymap = {};
			_this._lastmap = {};
			_this._keyDownHandler = _this._handleKeyDown.bind(_this);
			_this._keyUpHandler = _this._handleKeyUp.bind(_this);
			_this._keyPressHandler = _this._handleKeyPress.bind(_this);
			_this._visibilityChangeHandler = _this._handleVisibilityChange.bind(_this);
			_this._windowBlurHandler = _this._handleWindowBlur.bind(_this);
			if (element) {
				_this.attach(element);
			}
			_this.preventDefault = options.preventDefault || false;
			_this.stopPropagation = options.stopPropagation || false;
			return _this;
		}
		_inheritsLoose(Keyboard, _EventHandler);
		var _proto = Keyboard.prototype;
		_proto.attach = function attach(element) {
			if (this._element) {
				this.detach();
			}
			this._element = element;
			this._element.addEventListener('keydown', this._keyDownHandler, false);
			this._element.addEventListener('keypress', this._keyPressHandler, false);
			this._element.addEventListener('keyup', this._keyUpHandler, false);
			document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
			window.addEventListener('blur', this._windowBlurHandler, false);
		};
		_proto.detach = function detach() {
			if (!this._element) {
				return;
			}
			this._element.removeEventListener('keydown', this._keyDownHandler);
			this._element.removeEventListener('keypress', this._keyPressHandler);
			this._element.removeEventListener('keyup', this._keyUpHandler);
			this._element = null;
			document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
			window.removeEventListener('blur', this._windowBlurHandler, false);
		};
		_proto.toKeyIdentifier = function toKeyIdentifier(keyCode) {
			keyCode = toKeyCode(keyCode);
			var id = _keyCodeToKeyIdentifier[keyCode.toString()];
			if (id) {
				return id;
			}
			var hex = keyCode.toString(16).toUpperCase();
			var length = hex.length;
			for (var count = 0; count < 4 - length; count++) {
				hex = "0" + hex;
			}
			return "U+" + hex;
		};
		_proto._handleKeyDown = function _handleKeyDown(event) {
			var code = event.keyCode || event.charCode;
			if (code === undefined) return;
			var id = this.toKeyIdentifier(code);
			this._keymap[id] = true;
			this.fire('keydown', makeKeyboardEvent(event));
			if (this.preventDefault) {
				event.preventDefault();
			}
			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};
		_proto._handleKeyUp = function _handleKeyUp(event) {
			var code = event.keyCode || event.charCode;
			if (code === undefined) return;
			var id = this.toKeyIdentifier(code);
			delete this._keymap[id];
			this.fire('keyup', makeKeyboardEvent(event));
			if (this.preventDefault) {
				event.preventDefault();
			}
			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};
		_proto._handleKeyPress = function _handleKeyPress(event) {
			this.fire('keypress', makeKeyboardEvent(event));
			if (this.preventDefault) {
				event.preventDefault();
			}
			if (this.stopPropagation) {
				event.stopPropagation();
			}
		};
		_proto._handleVisibilityChange = function _handleVisibilityChange() {
			if (document.visibilityState === 'hidden') {
				this._handleWindowBlur();
			}
		};
		_proto._handleWindowBlur = function _handleWindowBlur() {
			this._keymap = {};
			this._lastmap = {};
		};
		_proto.update = function update() {
			for (var prop in this._lastmap) {
				delete this._lastmap[prop];
			}
			for (var _prop in this._keymap) {
				if (this._keymap.hasOwnProperty(_prop)) {
					this._lastmap[_prop] = this._keymap[_prop];
				}
			}
		};
		_proto.isPressed = function isPressed(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!this._keymap[id];
		};
		_proto.wasPressed = function wasPressed(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!this._keymap[id] && !!!this._lastmap[id];
		};
		_proto.wasReleased = function wasReleased(key) {
			var keyCode = toKeyCode(key);
			var id = this.toKeyIdentifier(keyCode);
			return !!!this._keymap[id] && !!this._lastmap[id];
		};
		return Keyboard;
	}(EventHandler);
	Keyboard.EVENT_KEYDOWN = 'keydown';
	Keyboard.EVENT_KEYUP = 'keyup';

	function isMousePointerLocked() {
		return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
	}
	var MouseEvent = function MouseEvent(mouse, event) {
		var _event$ctrlKey, _event$altKey, _event$shiftKey, _event$metaKey;
		this.x = 0;
		this.y = 0;
		this.dx = 0;
		this.dy = 0;
		this.button = MOUSEBUTTON_NONE;
		this.wheelDelta = 0;
		this.element = void 0;
		this.ctrlKey = false;
		this.altKey = false;
		this.shiftKey = false;
		this.metaKey = false;
		this.event = void 0;
		var coords = {
			x: 0,
			y: 0
		};
		if (event) {
			if (event instanceof MouseEvent) {
				throw Error('Expected MouseEvent');
			}
			coords = mouse._getTargetCoords(event);
		} else {
			event = {};
		}
		if (coords) {
			this.x = coords.x;
			this.y = coords.y;
		} else if (isMousePointerLocked()) {
			this.x = 0;
			this.y = 0;
		} else {
			return;
		}
		if (event.type === 'wheel') {
			if (event.deltaY > 0) {
				this.wheelDelta = 1;
			} else if (event.deltaY < 0) {
				this.wheelDelta = -1;
			}
		}
		if (isMousePointerLocked()) {
			this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
			this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
		} else {
			this.dx = this.x - mouse._lastX;
			this.dy = this.y - mouse._lastY;
		}
		if (event.type === 'mousedown' || event.type === 'mouseup') {
			this.button = event.button;
		}
		this.buttons = mouse._buttons.slice(0);
		this.element = event.target;
		this.ctrlKey = (_event$ctrlKey = event.ctrlKey) != null ? _event$ctrlKey : false;
		this.altKey = (_event$altKey = event.altKey) != null ? _event$altKey : false;
		this.shiftKey = (_event$shiftKey = event.shiftKey) != null ? _event$shiftKey : false;
		this.metaKey = (_event$metaKey = event.metaKey) != null ? _event$metaKey : false;
		this.event = event;
	};

	var Mouse = function (_EventHandler) {
		function Mouse(element) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._lastX = 0;
			_this._lastY = 0;
			_this._buttons = [false, false, false];
			_this._lastbuttons = [false, false, false];
			_this._target = null;
			_this._attached = false;
			_this._upHandler = _this._handleUp.bind(_this);
			_this._downHandler = _this._handleDown.bind(_this);
			_this._moveHandler = _this._handleMove.bind(_this);
			_this._wheelHandler = _this._handleWheel.bind(_this);
			_this._contextMenuHandler = function (event) {
				event.preventDefault();
			};
			_this.attach(element);
			return _this;
		}
		_inheritsLoose(Mouse, _EventHandler);
		Mouse.isPointerLocked = function isPointerLocked() {
			return isMousePointerLocked();
		};
		var _proto = Mouse.prototype;
		_proto.attach = function attach(element) {
			this._target = element;
			if (this._attached) return;
			this._attached = true;
			var passiveOptions = {
				passive: false
			};
			var options = platform.passiveEvents ? passiveOptions : false;
			window.addEventListener('mouseup', this._upHandler, options);
			window.addEventListener('mousedown', this._downHandler, options);
			window.addEventListener('mousemove', this._moveHandler, options);
			window.addEventListener('wheel', this._wheelHandler, options);
		};
		_proto.detach = function detach() {
			if (!this._attached) return;
			this._attached = false;
			this._target = null;
			var passiveOptions = {
				passive: false
			};
			var options = platform.passiveEvents ? passiveOptions : false;
			window.removeEventListener('mouseup', this._upHandler, options);
			window.removeEventListener('mousedown', this._downHandler, options);
			window.removeEventListener('mousemove', this._moveHandler, options);
			window.removeEventListener('wheel', this._wheelHandler, options);
		};
		_proto.disableContextMenu = function disableContextMenu() {
			if (!this._target) return;
			this._target.addEventListener('contextmenu', this._contextMenuHandler);
		};
		_proto.enableContextMenu = function enableContextMenu() {
			if (!this._target) return;
			this._target.removeEventListener('contextmenu', this._contextMenuHandler);
		};
		_proto.enablePointerLock = function enablePointerLock(success, error) {
			if (!document.body.requestPointerLock) {
				if (error) {
					error();
				}
				return;
			}
			var _s = function s() {
				success();
				document.removeEventListener('pointerlockchange', _s);
			};
			var _e = function e() {
				error();
				document.removeEventListener('pointerlockerror', _e);
			};
			if (success) {
				document.addEventListener('pointerlockchange', _s, false);
			}
			if (error) {
				document.addEventListener('pointerlockerror', _e, false);
			}
			document.body.requestPointerLock();
		};
		_proto.disablePointerLock = function disablePointerLock(success) {
			if (!document.exitPointerLock) {
				return;
			}
			var _s2 = function s() {
				success();
				document.removeEventListener('pointerlockchange', _s2);
			};
			if (success) {
				document.addEventListener('pointerlockchange', _s2, false);
			}
			document.exitPointerLock();
		};
		_proto.update = function update() {
			this._lastbuttons[0] = this._buttons[0];
			this._lastbuttons[1] = this._buttons[1];
			this._lastbuttons[2] = this._buttons[2];
		};
		_proto.isPressed = function isPressed(button) {
			return this._buttons[button];
		};
		_proto.wasPressed = function wasPressed(button) {
			return this._buttons[button] && !this._lastbuttons[button];
		};
		_proto.wasReleased = function wasReleased(button) {
			return !this._buttons[button] && this._lastbuttons[button];
		};
		_proto._handleUp = function _handleUp(event) {
			this._buttons[event.button] = false;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEUP, e);
		};
		_proto._handleDown = function _handleDown(event) {
			this._buttons[event.button] = true;
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEDOWN, e);
		};
		_proto._handleMove = function _handleMove(event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEMOVE, e);
			this._lastX = e.x;
			this._lastY = e.y;
		};
		_proto._handleWheel = function _handleWheel(event) {
			var e = new MouseEvent(this, event);
			if (!e.event) return;
			this.fire(EVENT_MOUSEWHEEL, e);
		};
		_proto._getTargetCoords = function _getTargetCoords(event) {
			var rect = this._target.getBoundingClientRect();
			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);
			if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
				return null;
			}
			return {
				x: event.clientX - left,
				y: event.clientY - top
			};
		};
		return Mouse;
	}(EventHandler);
	Mouse.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
	Mouse.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
	Mouse.EVENT_MOUSEUP = EVENT_MOUSEUP;
	Mouse.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;

	var Controller = function () {
		function Controller(element, options) {
			if (options === void 0) {
				options = {};
			}
			this._keyboard = void 0;
			this._mouse = void 0;
			this._gamepads = void 0;
			this._element = null;
			this._actions = {};
			this._axes = {};
			this._axesValues = {};
			this._keyboard = options.keyboard || null;
			this._mouse = options.mouse || null;
			this._gamepads = options.gamepads || null;
			if (element) {
				this.attach(element);
			}
		}
		var _proto = Controller.prototype;
		_proto.attach = function attach(element) {
			this._element = element;
			if (this._keyboard) {
				this._keyboard.attach(element);
			}
			if (this._mouse) {
				this._mouse.attach(element);
			}
		};
		_proto.detach = function detach() {
			if (this._keyboard) {
				this._keyboard.detach();
			}
			if (this._mouse) {
				this._mouse.detach();
			}
			this._element = null;
		};
		_proto.disableContextMenu = function disableContextMenu() {
			if (!this._mouse) {
				this._enableMouse();
			}
			this._mouse.disableContextMenu();
		};
		_proto.enableContextMenu = function enableContextMenu() {
			if (!this._mouse) {
				this._enableMouse();
			}
			this._mouse.enableContextMenu();
		};
		_proto.update = function update(dt) {
			if (this._keyboard) {
				this._keyboard.update();
			}
			if (this._mouse) {
				this._mouse.update();
			}
			if (this._gamepads) {
				this._gamepads.update();
			}
			this._axesValues = {};
			for (var key in this._axes) {
				this._axesValues[key] = [];
			}
		};
		_proto.appendAction = function appendAction(action_name, action) {
			this._actions[action_name] = this._actions[action_name] || [];
			this._actions[action_name].push(action);
		};
		_proto.registerKeys = function registerKeys(action, keys) {
			if (!this._keyboard) {
				this._enableKeyboard();
			}
			if (this._actions[action]) {
				throw new Error("Action: " + action + " already registered");
			}
			if (keys === undefined) {
				throw new Error('Invalid button');
			}
			if (!keys.length) {
				keys = [keys];
			}
			this.appendAction(action, {
				type: ACTION_KEYBOARD,
				keys: keys
			});
		};
		_proto.registerMouse = function registerMouse(action, button) {
			if (!this._mouse) {
				this._enableMouse();
			}
			if (button === undefined) {
				throw new Error('Invalid button');
			}
			this.appendAction(action, {
				type: ACTION_MOUSE,
				button: button
			});
		};
		_proto.registerPadButton = function registerPadButton(action, pad, button) {
			if (button === undefined) {
				throw new Error('Invalid button');
			}
			this.appendAction(action, {
				type: ACTION_GAMEPAD,
				button: button,
				pad: pad
			});
		};
		_proto.registerAxis = function registerAxis(options) {
			var name = options.name;
			if (!this._axes[name]) {
				this._axes[name] = [];
			}
			var i = this._axes[name].push(name);
			options = options || {};
			options.pad = options.pad || PAD_1;
			var bind = function bind(controller, source, value, key) {
				switch (source) {
					case 'mousex':
						controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
							controller._axesValues[name][i] = e.dx / 10;
						});
						break;
					case 'mousey':
						controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
							controller._axesValues[name][i] = e.dy / 10;
						});
						break;
					case 'key':
						controller._axes[name].push(function () {
							return controller._keyboard.isPressed(key) ? value : 0;
						});
						break;
					case 'padrx':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
						});
						break;
					case 'padry':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
						});
						break;
					case 'padlx':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
						});
						break;
					case 'padly':
						controller._axes[name].push(function () {
							return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
						});
						break;
					default:
						throw new Error('Unknown axis');
				}
			};
			bind(this, options.positive, 1, options.positiveKey);
			if (options.negativeKey || options.negative !== options.positive) {
				bind(this, options.negative, -1, options.negativeKey);
			}
		};
		_proto.isPressed = function isPressed(actionName) {
			if (!this._actions[actionName]) {
				return false;
			}
			var length = this._actions[actionName].length;
			for (var index = 0; index < length; ++index) {
				var action = this._actions[actionName][index];
				switch (action.type) {
					case ACTION_KEYBOARD:
						if (this._keyboard) {
							var len = action.keys.length;
							for (var i = 0; i < len; i++) {
								if (this._keyboard.isPressed(action.keys[i])) {
									return true;
								}
							}
						}
						break;
					case ACTION_MOUSE:
						if (this._mouse && this._mouse.isPressed(action.button)) {
							return true;
						}
						break;
					case ACTION_GAMEPAD:
						if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
							return true;
						}
						break;
				}
			}
			return false;
		};
		_proto.wasPressed = function wasPressed(actionName) {
			if (!this._actions[actionName]) {
				return false;
			}
			var length = this._actions[actionName].length;
			for (var index = 0; index < length; ++index) {
				var action = this._actions[actionName][index];
				switch (action.type) {
					case ACTION_KEYBOARD:
						if (this._keyboard) {
							var len = action.keys.length;
							for (var i = 0; i < len; i++) {
								if (this._keyboard.wasPressed(action.keys[i])) {
									return true;
								}
							}
						}
						break;
					case ACTION_MOUSE:
						if (this._mouse && this._mouse.wasPressed(action.button)) {
							return true;
						}
						break;
					case ACTION_GAMEPAD:
						if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
							return true;
						}
						break;
				}
			}
			return false;
		};
		_proto.getAxis = function getAxis(name) {
			var value = 0;
			if (this._axes[name]) {
				var len = this._axes[name].length;
				for (var i = 0; i < len; i++) {
					if (typeof this._axes[name][i] === 'function') {
						var v = this._axes[name][i]();
						if (Math.abs(v) > Math.abs(value)) {
							value = v;
						}
					} else if (this._axesValues[name]) {
						if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
							value = this._axesValues[name][i];
						}
					}
				}
			}
			return value;
		};
		_proto._enableMouse = function _enableMouse() {
			this._mouse = new Mouse();
			if (!this._element) {
				throw new Error('Controller must be attached to an Element');
			}
			this._mouse.attach(this._element);
		};
		_proto._enableKeyboard = function _enableKeyboard() {
			this._keyboard = new Keyboard();
			if (!this._element) {
				throw new Error('Controller must be attached to an Element');
			}
			this._keyboard.attach(this._element);
		};
		return Controller;
	}();

	var dummyArray = Object.freeze([]);
	var getGamepads = function getGamepads() {
		return dummyArray;
	};
	if (typeof navigator !== 'undefined') {
		getGamepads = (navigator.getGamepads || navigator.webkitGetGamepads || getGamepads).bind(navigator);
	}
	var MAPS_INDEXES = {
		buttons: {
			PAD_FACE_1: PAD_FACE_1,
			PAD_FACE_2: PAD_FACE_2,
			PAD_FACE_3: PAD_FACE_3,
			PAD_FACE_4: PAD_FACE_4,
			PAD_L_SHOULDER_1: PAD_L_SHOULDER_1,
			PAD_R_SHOULDER_1: PAD_R_SHOULDER_1,
			PAD_L_SHOULDER_2: PAD_L_SHOULDER_2,
			PAD_R_SHOULDER_2: PAD_R_SHOULDER_2,
			PAD_SELECT: PAD_SELECT,
			PAD_START: PAD_START,
			PAD_L_STICK_BUTTON: PAD_L_STICK_BUTTON,
			PAD_R_STICK_BUTTON: PAD_R_STICK_BUTTON,
			PAD_UP: PAD_UP,
			PAD_DOWN: PAD_DOWN,
			PAD_LEFT: PAD_LEFT,
			PAD_RIGHT: PAD_RIGHT,
			PAD_VENDOR: PAD_VENDOR,
			XRPAD_TRIGGER: XRPAD_TRIGGER,
			XRPAD_SQUEEZE: XRPAD_SQUEEZE,
			XRPAD_TOUCHPAD_BUTTON: XRPAD_TOUCHPAD_BUTTON,
			XRPAD_STICK_BUTTON: XRPAD_STICK_BUTTON,
			XRPAD_A: XRPAD_A,
			XRPAD_B: XRPAD_B
		},
		axes: {
			PAD_L_STICK_X: PAD_L_STICK_X,
			PAD_L_STICK_Y: PAD_L_STICK_Y,
			PAD_R_STICK_X: PAD_R_STICK_X,
			PAD_R_STICK_Y: PAD_R_STICK_Y,
			XRPAD_TOUCHPAD_X: XRPAD_TOUCHPAD_X,
			XRPAD_TOUCHPAD_Y: XRPAD_TOUCHPAD_Y,
			XRPAD_STICK_X: XRPAD_STICK_X,
			XRPAD_STICK_Y: XRPAD_STICK_Y
		}
	};
	var MAPS = {
		DEFAULT: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']
		},
		DEFAULT_DUAL: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y'],
			synthesizedButtons: {
				PAD_UP: {
					axis: 0,
					min: 0,
					max: 1
				},
				PAD_DOWN: {
					axis: 0,
					min: -1,
					max: 0
				},
				PAD_LEFT: {
					axis: 0,
					min: -1,
					max: 0
				},
				PAD_RIGHT: {
					axis: 0,
					min: 0,
					max: 1
				}
			}
		},
		PS3: {
			buttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_4', 'PAD_FACE_3', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],
			axes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y'],
			mapping: 'standard'
		},
		DEFAULT_XR: {
			buttons: ['XRPAD_TRIGGER', 'XRPAD_SQUEEZE', 'XRPAD_TOUCHPAD_BUTTON', 'XRPAD_STICK_BUTTON', 'XRPAD_A', 'XRPAD_B'],
			axes: ['XRPAD_TOUCHPAD_X', 'XRPAD_TOUCHPAD_Y', 'XRPAD_STICK_X', 'XRPAD_STICK_Y'],
			mapping: 'xr-standard'
		}
	};
	var PRODUCT_CODES = {
		'Product: 0268': 'PS3'
	};
	var custom_maps = {};
	function _getMap(pad) {
		var custom = custom_maps[pad.id];
		if (custom) {
			return custom;
		}
		for (var code in PRODUCT_CODES) {
			if (pad.id.indexOf(code) !== -1) {
				var product = PRODUCT_CODES[code];
				if (!pad.mapping) {
					var raw = MAPS["RAW_" + product];
					if (raw) {
						return raw;
					}
				}
				return MAPS[product];
			}
		}
		if (pad.mapping === 'xr-standard') {
			return MAPS.DEFAULT_XR;
		}
		var defaultmap = MAPS.DEFAULT;
		var map = pad.buttons.length < defaultmap.buttons.length ? MAPS.DEFAULT_DUAL : defaultmap;
		map.mapping = pad.mapping;
		return map;
	}
	var deadZone = 0.25;
	function sleep(ms) {
		return new Promise(function (resolve) {
			setTimeout(resolve, ms);
		});
	}
	var GamePadButton = function () {
		function GamePadButton(current, previous) {
			this.value = 0;
			this.pressed = false;
			this.touched = false;
			this.wasPressed = false;
			this.wasReleased = false;
			this.wasTouched = false;
			if (typeof current === 'number') {
				this.value = current;
				this.pressed = current === 1;
				this.touched = current > 0;
			} else {
				var _current$touched;
				this.value = current.value;
				this.pressed = current.pressed;
				this.touched = (_current$touched = current.touched) != null ? _current$touched : current.value > 0;
			}
			if (previous) {
				if (typeof previous === 'number') {
					this.wasPressed = previous !== 1 && this.pressed;
					this.wasReleased = previous === 1 && !this.pressed;
					this.wasTouched = previous === 0 && this.touched;
				} else {
					var _previous$touched;
					this.wasPressed = !previous.pressed && this.pressed;
					this.wasReleased = previous.pressed && !this.pressed;
					this.wasTouched = !((_previous$touched = previous.touched) != null ? _previous$touched : previous.value > 0) && this.touched;
				}
			}
		}
		var _proto = GamePadButton.prototype;
		_proto.update = function update(button) {
			var _button$touched;
			var value = button.value,
				pressed = button.pressed;
			var touched = (_button$touched = button.touched) != null ? _button$touched : value > 0;
			this.wasPressed = !this.pressed && pressed;
			this.wasReleased = this.pressed && !pressed;
			this.wasTouched = !this.touched && touched;
			this.value = value;
			this.pressed = pressed;
			this.touched = touched;
		};
		return GamePadButton;
	}();
	var dummyButton = Object.freeze(new GamePadButton(0));
	var GamePad = function () {
		function GamePad(gamepad, map) {
			this._compiledMapping = {
				buttons: [],
				axes: []
			};
			this.id = gamepad.id;
			this.index = gamepad.index;
			this._buttons = gamepad.buttons.map(function (b) {
				return new GamePadButton(b);
			});
			this._axes = [].concat(gamepad.axes);
			this._previousAxes = [].concat(gamepad.axes);
			this.mapping = map.mapping;
			this.map = map;
			this.hand = gamepad.hand || 'none';
			this.pad = gamepad;
			this._compileMapping();
		}
		var _proto2 = GamePad.prototype;
		_proto2._compileMapping = function _compileMapping() {
			var _this = this;
			var _this$_compiledMappin = this._compiledMapping,
				axes = _this$_compiledMappin.axes,
				buttons = _this$_compiledMappin.buttons;
			var axesIndexes = MAPS_INDEXES.axes;
			var buttonsIndexes = MAPS_INDEXES.buttons;
			axes.length = 0;
			buttons.length = 0;
			var axesMap = this.map.axes;
			if (axesMap) {
				this.map.axes.forEach(function (axis, i) {
					axes[axesIndexes[axis]] = function () {
						return _this.pad.axes[i] || 0;
					};
				});
			}
			for (var i = 0, l = axes.length; i < l; i++) {
				if (!axes[i]) {
					axes[i] = function () {
						return 0;
					};
				}
			}
			var buttonsMap = this.map.buttons;
			if (buttonsMap) {
				buttonsMap.forEach(function (button, i) {
					buttons[buttonsIndexes[button]] = function () {
						return _this._buttons[i] || dummyButton;
					};
				});
			}
			var synthesizedButtonsMap = this.map.synthesizedButtons;
			if (synthesizedButtonsMap) {
				Object.entries(synthesizedButtonsMap).forEach(function (button) {
					var _button$ = button[1],
						axis = _button$.axis,
						max = _button$.max,
						min = _button$.min;
					buttons[buttonsIndexes[button[0]]] = function () {
						var _this$_axes$axis, _this$_previousAxes$a;
						return new GamePadButton(Math.abs(math.clamp((_this$_axes$axis = _this._axes[axis]) != null ? _this$_axes$axis : 0, min, max)), Math.abs(math.clamp((_this$_previousAxes$a = _this._previousAxes[axis]) != null ? _this$_previousAxes$a : 0, min, max)));
					};
				});
			}
			for (var _i = 0, _l = buttons.length; _i < _l; _i++) {
				if (!buttons[_i]) {
					buttons[_i] = function () {
						return dummyButton;
					};
				}
			}
		};
		_proto2.update = function update(gamepad) {
			this.pad = gamepad;
			var previousAxes = this._previousAxes;
			var axes = this._axes;
			previousAxes.length = 0;
			previousAxes.push.apply(previousAxes, axes);
			axes.length = 0;
			axes.push.apply(axes, gamepad.axes);
			var buttons = this._buttons;
			for (var i = 0, l = buttons.length; i < l; i++) {
				buttons[i].update(gamepad.buttons[i]);
			}
			return this;
		};
		_proto2.updateMap = function updateMap(map) {
			map.mapping = 'custom';
			custom_maps[this.id] = map;
			this.map = map;
			this.mapping = 'custom';
			this._compileMapping();
		};
		_proto2.resetMap = function resetMap() {
			if (custom_maps[this.id]) {
				delete custom_maps[this.id];
				var map = _getMap(this.pad);
				this.map = map;
				this.mapping = map.mapping;
				this._compileMapping();
			}
		};
		_proto2.pulse = function () {
			var _pulse = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(intensity, duration, options) {
				var actuators, _options$startDelay, _options$strongMagnit, _options$weakMagnitud, startDelay, strongMagnitude, weakMagnitude, results;
				return _regeneratorRuntime().wrap(function _callee2$(_context2) {
					while (1) switch (_context2.prev = _context2.next) {
						case 0:
							actuators = this.pad.vibrationActuator ? [this.pad.vibrationActuator] : this.pad.hapticActuators || dummyArray;
							if (!actuators.length) {
								_context2.next = 9;
								break;
							}
							startDelay = (_options$startDelay = options == null ? void 0 : options.startDelay) != null ? _options$startDelay : 0;
							strongMagnitude = (_options$strongMagnit = options == null ? void 0 : options.strongMagnitude) != null ? _options$strongMagnit : intensity;
							weakMagnitude = (_options$weakMagnitud = options == null ? void 0 : options.weakMagnitude) != null ? _options$weakMagnitud : intensity;
							_context2.next = 7;
							return Promise.all(actuators.map(function () {
								var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(actuator) {
									return _regeneratorRuntime().wrap(function _callee$(_context) {
										while (1) switch (_context.prev = _context.next) {
											case 0:
												if (actuator) {
													_context.next = 2;
													break;
												}
												return _context.abrupt("return", true);
											case 2:
												if (!actuator.playEffect) {
													_context.next = 6;
													break;
												}
												return _context.abrupt("return", actuator.playEffect(actuator.type, {
													duration: duration,
													startDelay: startDelay,
													strongMagnitude: strongMagnitude,
													weakMagnitude: weakMagnitude
												}));
											case 6:
												if (!actuator.pulse) {
													_context.next = 10;
													break;
												}
												_context.next = 9;
												return sleep(startDelay);
											case 9:
												return _context.abrupt("return", actuator.pulse(intensity, duration));
											case 10:
												return _context.abrupt("return", false);
											case 11:
											case "end":
												return _context.stop();
										}
									}, _callee);
								}));
								return function (_x4) {
									return _ref.apply(this, arguments);
								};
							}()));
						case 7:
							results = _context2.sent;
							return _context2.abrupt("return", results.some(function (r) {
								return r === true || r === 'complete';
							}));
						case 9:
							return _context2.abrupt("return", false);
						case 10:
						case "end":
							return _context2.stop();
					}
				}, _callee2, this);
			}));
			function pulse(_x, _x2, _x3) {
				return _pulse.apply(this, arguments);
			}
			return pulse;
		}();
		_proto2.getButton = function getButton(index) {
			var button = this._compiledMapping.buttons[index];
			return button ? button() : dummyButton;
		};
		_proto2.isPressed = function isPressed(button) {
			return this.getButton(button).pressed;
		};
		_proto2.wasPressed = function wasPressed(button) {
			return this.getButton(button).wasPressed;
		};
		_proto2.wasReleased = function wasReleased(button) {
			return this.getButton(button).wasReleased;
		};
		_proto2.isTouched = function isTouched(button) {
			return this.getButton(button).touched;
		};
		_proto2.wasTouched = function wasTouched(button) {
			return this.getButton(button).wasTouched;
		};
		_proto2.getValue = function getValue(button) {
			return this.getButton(button).value;
		};
		_proto2.getAxis = function getAxis(axis) {
			var a = this.axes[axis];
			return a && Math.abs(a) > deadZone ? a : 0;
		};
		return _createClass(GamePad, [{
			key: "connected",
			get: function get() {
				return this.pad.connected;
			}
		}, {
			key: "axes",
			get: function get() {
				return this._compiledMapping.axes.map(function (a) {
					return a();
				});
			}
		}, {
			key: "buttons",
			get: function get() {
				return this._compiledMapping.buttons.map(function (b) {
					return b();
				});
			}
		}]);
	}();
	var GamePads = function (_EventHandler) {
		function GamePads() {
			var _this2;
			_this2 = _EventHandler.call(this) || this;
			_this2.gamepadsSupported = platform.gamepads;
			_this2.current = [];
			_this2._previous = [];
			_this2._ongamepadconnectedHandler = _this2._ongamepadconnected.bind(_this2);
			_this2._ongamepaddisconnectedHandler = _this2._ongamepaddisconnected.bind(_this2);
			window.addEventListener('gamepadconnected', _this2._ongamepadconnectedHandler, false);
			window.addEventListener('gamepaddisconnected', _this2._ongamepaddisconnectedHandler, false);
			_this2.poll();
			return _this2;
		}
		_inheritsLoose(GamePads, _EventHandler);
		var _proto3 = GamePads.prototype;
		_proto3._ongamepadconnected = function _ongamepadconnected(event) {
			var pad = new GamePad(event.gamepad, this.getMap(event.gamepad));
			var current = this.current;
			var padIndex = current.findIndex(function (gp) {
				return gp.index === pad.index;
			});
			while (padIndex !== -1) {
				current.splice(padIndex, 1);
				padIndex = current.findIndex(function (gp) {
					return gp.index === pad.index;
				});
			}
			current.push(pad);
			this.fire(EVENT_GAMEPADCONNECTED, pad);
		};
		_proto3._ongamepaddisconnected = function _ongamepaddisconnected(event) {
			var current = this.current;
			var padIndex = current.findIndex(function (gp) {
				return gp.index === event.gamepad.index;
			});
			if (padIndex !== -1) {
				this.fire(EVENT_GAMEPADDISCONNECTED, current[padIndex]);
				current.splice(padIndex, 1);
			}
		};
		_proto3.update = function update() {
			this.poll();
		};
		_proto3.poll = function poll(pads) {
			if (pads === void 0) {
				pads = [];
			}
			if (pads.length > 0) {
				pads.length = 0;
			}
			var padDevices = getGamepads();
			for (var i = 0, len = padDevices.length; i < len; i++) {
				if (padDevices[i]) {
					var pad = this.findByIndex(padDevices[i].index);
					if (pad) {
						pads.push(pad.update(padDevices[i]));
					} else {
						var nPad = new GamePad(padDevices[i], this.getMap(padDevices[i]));
						this.current.push(nPad);
						pads.push(nPad);
					}
				}
			}
			return pads;
		};
		_proto3.destroy = function destroy() {
			window.removeEventListener('gamepadconnected', this._ongamepadconnectedHandler, false);
			window.removeEventListener('gamepaddisconnected', this._ongamepaddisconnectedHandler, false);
		};
		_proto3.getMap = function getMap(pad) {
			return _getMap(pad);
		};
		_proto3.isPressed = function isPressed(orderIndex, button) {
			var _this$current$orderIn;
			return ((_this$current$orderIn = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn.isPressed(button)) || false;
		};
		_proto3.wasPressed = function wasPressed(orderIndex, button) {
			var _this$current$orderIn2;
			return ((_this$current$orderIn2 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn2.wasPressed(button)) || false;
		};
		_proto3.wasReleased = function wasReleased(orderIndex, button) {
			var _this$current$orderIn3;
			return ((_this$current$orderIn3 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn3.wasReleased(button)) || false;
		};
		_proto3.getAxis = function getAxis(orderIndex, axis) {
			var _this$current$orderIn4;
			return ((_this$current$orderIn4 = this.current[orderIndex]) == null ? void 0 : _this$current$orderIn4.getAxis(axis)) || 0;
		};
		_proto3.pulse = function pulse(orderIndex, intensity, duration, options) {
			var pad = this.current[orderIndex];
			return pad ? pad.pulse(intensity, duration, options) : Promise.resolve(false);
		};
		_proto3.pulseAll = function pulseAll(intensity, duration, options) {
			return Promise.all(this.current.map(function (pad) {
				return pad.pulse(intensity, duration, options);
			}));
		};
		_proto3.findById = function findById(id) {
			return this.current.find(function (gp) {
				return gp && gp.id === id;
			}) || null;
		};
		_proto3.findByIndex = function findByIndex(index) {
			return this.current.find(function (gp) {
				return gp && gp.index === index;
			}) || null;
		};
		return _createClass(GamePads, [{
			key: "deadZone",
			get: function get() {
				return deadZone;
			},
			set: function set(value) {
				deadZone = value;
			}
		}, {
			key: "previous",
			get: function get() {
				var current = this.current;
				for (var i = 0, l = current.length; i < l; i++) {
					var buttons = current[i]._buttons;
					if (!this._previous[i]) {
						this._previous[i] = [];
					}
					for (var j = 0, m = buttons.length; j < m; j++) {
						var button = buttons[i];
						this.previous[i][j] = button ? !button.wasPressed && button.pressed || button.wasReleased : false;
					}
				}
				this._previous.length = this.current.length;
				return this._previous;
			}
		}]);
	}(EventHandler);
	GamePads.EVENT_GAMEPADCONNECTED = 'gamepadconnected';
	GamePads.EVENT_GAMEPADDISCONNECTED = 'gamepaddisconnected';

	function getTouchTargetCoords(touch) {
		var totalOffsetX = 0;
		var totalOffsetY = 0;
		var target = touch.target;
		while (!(target instanceof HTMLElement) && target) {
			target = target.parentNode;
		}
		while (target) {
			totalOffsetX += target.offsetLeft - target.scrollLeft;
			totalOffsetY += target.offsetTop - target.scrollTop;
			target = target.offsetParent;
		}
		return {
			x: touch.pageX - totalOffsetX,
			y: touch.pageY - totalOffsetY
		};
	}
	var Touch = function Touch(touch) {
		this.id = void 0;
		this.x = void 0;
		this.y = void 0;
		this.target = void 0;
		this.touch = void 0;
		var coords = getTouchTargetCoords(touch);
		this.id = touch.identifier;
		this.x = coords.x;
		this.y = coords.y;
		this.target = touch.target;
		this.touch = touch;
	};
	var TouchEvent = function () {
		function TouchEvent(device, event) {
			this.element = void 0;
			this.event = void 0;
			this.touches = [];
			this.changedTouches = [];
			this.element = event.target;
			this.event = event;
			this.touches = Array.from(event.touches).map(function (touch) {
				return new Touch(touch);
			});
			this.changedTouches = Array.from(event.changedTouches).map(function (touch) {
				return new Touch(touch);
			});
		}
		var _proto = TouchEvent.prototype;
		_proto.getTouchById = function getTouchById(id, list) {
			return list.find(function (touch) {
				return touch.id === id;
			}) || null;
		};
		return TouchEvent;
	}();

	var TouchDevice = function (_EventHandler) {
		function TouchDevice(element) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._element = null;
			_this._startHandler = _this._handleTouchStart.bind(_this);
			_this._endHandler = _this._handleTouchEnd.bind(_this);
			_this._moveHandler = _this._handleTouchMove.bind(_this);
			_this._cancelHandler = _this._handleTouchCancel.bind(_this);
			_this.attach(element);
			return _this;
		}
		_inheritsLoose(TouchDevice, _EventHandler);
		var _proto = TouchDevice.prototype;
		_proto.attach = function attach(element) {
			if (this._element) {
				this.detach();
			}
			this._element = element;
			this._element.addEventListener('touchstart', this._startHandler, false);
			this._element.addEventListener('touchend', this._endHandler, false);
			this._element.addEventListener('touchmove', this._moveHandler, false);
			this._element.addEventListener('touchcancel', this._cancelHandler, false);
		};
		_proto.detach = function detach() {
			if (this._element) {
				this._element.removeEventListener('touchstart', this._startHandler, false);
				this._element.removeEventListener('touchend', this._endHandler, false);
				this._element.removeEventListener('touchmove', this._moveHandler, false);
				this._element.removeEventListener('touchcancel', this._cancelHandler, false);
			}
			this._element = null;
		};
		_proto._handleTouchStart = function _handleTouchStart(e) {
			this.fire('touchstart', new TouchEvent(this, e));
		};
		_proto._handleTouchEnd = function _handleTouchEnd(e) {
			this.fire('touchend', new TouchEvent(this, e));
		};
		_proto._handleTouchMove = function _handleTouchMove(e) {
			e.preventDefault();
			this.fire('touchmove', new TouchEvent(this, e));
		};
		_proto._handleTouchCancel = function _handleTouchCancel(e) {
			this.fire('touchcancel', new TouchEvent(this, e));
		};
		return TouchDevice;
	}(EventHandler);

	var Http = function () {
		function Http() {}
		var _proto = Http.prototype;
		_proto.get = function get(url, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			return this.request('GET', url, options, callback);
		};
		_proto.post = function post(url, data, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			options.postdata = data;
			return this.request('POST', url, options, callback);
		};
		_proto.put = function put(url, data, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			options.postdata = data;
			return this.request('PUT', url, options, callback);
		};
		_proto.del = function del(url, options, callback) {
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			return this.request('DELETE', url, options, callback);
		};
		_proto.request = function request(method, url, options, callback) {
			var _this = this;
			var uri, query, postdata;
			var errored = false;
			if (typeof options === 'function') {
				callback = options;
				options = {};
			}
			if (options.retry) {
				options = Object.assign({
					retries: 0,
					maxRetries: 5
				}, options);
			}
			options.callback = callback;
			if (options.async == null) {
				options.async = true;
			}
			if (options.headers == null) {
				options.headers = {};
			}
			if (options.postdata != null) {
				if (options.postdata instanceof Document) {
					postdata = options.postdata;
				} else if (options.postdata instanceof FormData) {
					postdata = options.postdata;
				} else if (options.postdata instanceof Object) {
					var contentType = options.headers['Content-Type'];
					if (contentType === undefined) {
						options.headers['Content-Type'] = Http.ContentType.FORM_URLENCODED;
						contentType = options.headers['Content-Type'];
					}
					switch (contentType) {
						case Http.ContentType.FORM_URLENCODED:
							{
								postdata = '';
								var bFirstItem = true;
								for (var key in options.postdata) {
									if (options.postdata.hasOwnProperty(key)) {
										if (bFirstItem) {
											bFirstItem = false;
										} else {
											postdata += '&';
										}
										var encodedKey = encodeURIComponent(key);
										var encodedValue = encodeURIComponent(options.postdata[key]);
										postdata += encodedKey + "=" + encodedValue;
									}
								}
								break;
							}
						default:
						case Http.ContentType.JSON:
							if (contentType == null) {
								options.headers['Content-Type'] = Http.ContentType.JSON;
							}
							postdata = JSON.stringify(options.postdata);
							break;
					}
				} else {
					postdata = options.postdata;
				}
			}
			if (options.cache === false) {
				var timestamp = now();
				uri = new URI(url);
				if (!uri.query) {
					uri.query = "ts=" + timestamp;
				} else {
					uri.query = uri.query + "&ts=" + timestamp;
				}
				url = uri.toString();
			}
			if (options.query) {
				uri = new URI(url);
				query = extend(uri.getQuery(), options.query);
				uri.setQuery(query);
				url = uri.toString();
			}
			var xhr = new XMLHttpRequest();
			xhr.open(method, url, options.async);
			xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
			xhr.responseType = options.responseType || this._guessResponseType(url);
			for (var header in options.headers) {
				if (options.headers.hasOwnProperty(header)) {
					xhr.setRequestHeader(header, options.headers[header]);
				}
			}
			xhr.onreadystatechange = function () {
				_this._onReadyStateChange(method, url, options, xhr);
			};
			xhr.onerror = function () {
				_this._onError(method, url, options, xhr);
				errored = true;
			};
			try {
				xhr.send(postdata);
			} catch (e) {
				if (!errored) {
					options.error(xhr.status, xhr, e);
				}
			}
			return xhr;
		};
		_proto._guessResponseType = function _guessResponseType(url) {
			var uri = new URI(url);
			var ext = path.getExtension(uri.path).toLowerCase();
			if (Http.binaryExtensions.indexOf(ext) >= 0) {
				return Http.ResponseType.ARRAY_BUFFER;
			} else if (ext === '.json') {
				return Http.ResponseType.JSON;
			} else if (ext === '.xml') {
				return Http.ResponseType.DOCUMENT;
			}
			return Http.ResponseType.TEXT;
		};
		_proto._isBinaryContentType = function _isBinaryContentType(contentType) {
			var binTypes = [Http.ContentType.BASIS, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.GLB, Http.ContentType.MP3, Http.ContentType.MP4, Http.ContentType.OGG, Http.ContentType.OPUS, Http.ContentType.WAV];
			if (binTypes.indexOf(contentType) >= 0) {
				return true;
			}
			return false;
		};
		_proto._isBinaryResponseType = function _isBinaryResponseType(responseType) {
			return responseType === Http.ResponseType.ARRAY_BUFFER || responseType === Http.ResponseType.BLOB || responseType === Http.ResponseType.JSON;
		};
		_proto._onReadyStateChange = function _onReadyStateChange(method, url, options, xhr) {
			if (xhr.readyState === 4) {
				switch (xhr.status) {
					case 0:
						{
							if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
								this._onSuccess(method, url, options, xhr);
							} else {
								this._onError(method, url, options, xhr);
							}
							break;
						}
					case 200:
					case 201:
					case 206:
					case 304:
						{
							this._onSuccess(method, url, options, xhr);
							break;
						}
					default:
						{
							this._onError(method, url, options, xhr);
							break;
						}
				}
			}
		};
		_proto._onSuccess = function _onSuccess(method, url, options, xhr) {
			var response;
			var contentType;
			var header = xhr.getResponseHeader('Content-Type');
			if (header) {
				var parts = header.split(';');
				contentType = parts[0].trim();
			}
			try {
				if (this._isBinaryContentType(contentType) || this._isBinaryResponseType(xhr.responseType)) {
					response = xhr.response;
				} else if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith('.json')) {
					response = JSON.parse(xhr.responseText);
				} else if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
					response = xhr.responseXML;
				} else {
					response = xhr.responseText;
				}
				options.callback(null, response);
			} catch (err) {
				options.callback(err);
			}
		};
		_proto._onError = function _onError(method, url, options, xhr) {
			var _this2 = this;
			if (options.retrying) {
				return;
			}
			if (options.retry && options.retries < options.maxRetries) {
				options.retries++;
				options.retrying = true;
				var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
				console.log(method + ": " + url + " - Error " + xhr.status + ". Retrying in " + retryDelay + " ms");
				setTimeout(function () {
					options.retrying = false;
					_this2.request(method, url, options, options.callback);
				}, retryDelay);
			} else {
				options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
			}
		};
		return Http;
	}();
	Http.ContentType = {
		AAC: 'audio/aac',
		BASIS: 'image/basis',
		BIN: 'application/octet-stream',
		DDS: 'image/dds',
		FORM_URLENCODED: 'application/x-www-form-urlencoded',
		GIF: 'image/gif',
		GLB: 'model/gltf-binary',
		JPEG: 'image/jpeg',
		JSON: 'application/json',
		MP3: 'audio/mpeg',
		MP4: 'audio/mp4',
		OGG: 'audio/ogg',
		OPUS: 'audio/ogg; codecs="opus"',
		PNG: 'image/png',
		TEXT: 'text/plain',
		WAV: 'audio/x-wav',
		XML: 'application/xml'
	};
	Http.ResponseType = {
		TEXT: 'text',
		ARRAY_BUFFER: 'arraybuffer',
		BLOB: 'blob',
		DOCUMENT: 'document',
		JSON: 'json'
	};
	Http.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb', '.opus'];
	Http.retryDelay = 100;
	var http = new Http();

	function hasAudioContext() {
		return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
	}

	var Channel = function () {
		function Channel(manager, sound, options) {
			var _options$volume, _options$loop, _options$pitch;
			if (options === void 0) {
				options = {};
			}
			this.volume = (_options$volume = options.volume) != null ? _options$volume : 1;
			this.loop = (_options$loop = options.loop) != null ? _options$loop : false;
			this.pitch = (_options$pitch = options.pitch) != null ? _options$pitch : 1;
			this.sound = sound;
			this.paused = false;
			this.suspended = false;
			this.manager = manager;
			this.source = null;
			if (hasAudioContext()) {
				this.startTime = 0;
				this.startOffset = 0;
				var context = manager.context;
				this.gain = context.createGain();
			} else if (sound.audio) {
				this.source = sound.audio.cloneNode(false);
				this.source.pause();
			}
		}
		var _proto = Channel.prototype;
		_proto.getVolume = function getVolume() {
			return this.volume;
		};
		_proto.getLoop = function getLoop() {
			return this.loop;
		};
		_proto.setLoop = function setLoop(loop) {
			this.loop = loop;
			if (this.source) {
				this.source.loop = loop;
			}
		};
		_proto.getPitch = function getPitch() {
			return this.pitch;
		};
		_proto.onManagerVolumeChange = function onManagerVolumeChange() {
			this.setVolume(this.getVolume());
		};
		_proto.onManagerSuspend = function onManagerSuspend() {
			if (this.isPlaying() && !this.suspended) {
				this.suspended = true;
				this.pause();
			}
		};
		_proto.onManagerResume = function onManagerResume() {
			if (this.suspended) {
				this.suspended = false;
				this.unpause();
			}
		};
		_proto.play = function play() {
			if (this.source) {
				throw new Error('Call stop() before calling play()');
			}
			this._createSource();
			if (!this.source) {
				return;
			}
			this.startTime = this.manager.context.currentTime;
			this.source.start(0, this.startOffset % this.source.buffer.duration);
			this.setVolume(this.volume);
			this.setLoop(this.loop);
			this.setPitch(this.pitch);
			this.manager.on('volumechange', this.onManagerVolumeChange, this);
			this.manager.on('suspend', this.onManagerSuspend, this);
			this.manager.on('resume', this.onManagerResume, this);
			if (this.manager.suspended) {
				this.onManagerSuspend();
			}
		};
		_proto.pause = function pause() {
			if (this.source) {
				this.paused = true;
				this.startOffset += this.manager.context.currentTime - this.startTime;
				this.source.stop(0);
				this.source = null;
			}
		};
		_proto.unpause = function unpause() {
			if (this.source || !this.paused) {
				console.warn('Call pause() before unpausing.');
				return;
			}
			this._createSource();
			if (!this.source) {
				return;
			}
			this.startTime = this.manager.context.currentTime;
			this.source.start(0, this.startOffset % this.source.buffer.duration);
			this.setVolume(this.volume);
			this.setLoop(this.loop);
			this.setPitch(this.pitch);
			this.paused = false;
		};
		_proto.stop = function stop() {
			if (this.source) {
				this.source.stop(0);
				this.source = null;
			}
			this.manager.off('volumechange', this.onManagerVolumeChange, this);
			this.manager.off('suspend', this.onManagerSuspend, this);
			this.manager.off('resume', this.onManagerResume, this);
		};
		_proto.setVolume = function setVolume(volume) {
			volume = math.clamp(volume, 0, 1);
			this.volume = volume;
			if (this.gain) {
				this.gain.gain.value = volume * this.manager.volume;
			}
		};
		_proto.setPitch = function setPitch(pitch) {
			this.pitch = pitch;
			if (this.source) {
				this.source.playbackRate.value = pitch;
			}
		};
		_proto.isPlaying = function isPlaying() {
			return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
		};
		_proto.getDuration = function getDuration() {
			return this.source ? this.source.buffer.duration : 0;
		};
		_proto._createSource = function _createSource() {
			var context = this.manager.context;
			if (this.sound.buffer) {
				this.source = context.createBufferSource();
				this.source.buffer = this.sound.buffer;
				this.source.connect(this.gain);
				this.gain.connect(context.destination);
				if (!this.loop) {
					this.source.onended = this.pause.bind(this);
				}
			}
		};
		return Channel;
	}();
	if (!hasAudioContext()) {
		Object.assign(Channel.prototype, {
			play: function play() {
				if (this.source) {
					this.paused = false;
					this.setVolume(this.volume);
					this.setLoop(this.loop);
					this.setPitch(this.pitch);
					this.source.play();
				}
				this.manager.on('volumechange', this.onManagerVolumeChange, this);
				this.manager.on('suspend', this.onManagerSuspend, this);
				this.manager.on('resume', this.onManagerResume, this);
				if (this.manager.suspended) {
					this.onManagerSuspend();
				}
			},
			pause: function pause() {
				if (this.source) {
					this.paused = true;
					this.source.pause();
				}
			},
			unpause: function unpause() {
				if (this.source) {
					this.paused = false;
					this.source.play();
				}
			},
			stop: function stop() {
				if (this.source) {
					this.source.pause();
				}
				this.manager.off('volumechange', this.onManagerVolumeChange, this);
				this.manager.off('suspend', this.onManagerSuspend, this);
				this.manager.off('resume', this.onManagerResume, this);
			},
			setVolume: function setVolume(volume) {
				volume = math.clamp(volume, 0, 1);
				this.volume = volume;
				if (this.source) {
					this.source.volume = volume * this.manager.volume;
				}
			},
			setPitch: function setPitch(pitch) {
				this.pitch = pitch;
				if (this.source) {
					this.source.playbackRate = pitch;
				}
			},
			getDuration: function getDuration() {
				return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
			},
			isPlaying: function isPlaying() {
				return !this.source.paused;
			}
		});
	}

	var MAX_DISTANCE$1 = 10000;
	var Channel3d = function (_Channel) {
		function Channel3d(manager, sound, options) {
			var _this;
			_this = _Channel.call(this, manager, sound, options) || this;
			_this.position = new Vec3();
			_this.velocity = new Vec3();
			if (hasAudioContext()) {
				_this.panner = manager.context.createPanner();
			} else {
				_this.maxDistance = MAX_DISTANCE$1;
				_this.minDistance = 1;
				_this.rollOffFactor = 1;
				_this.distanceModel = DISTANCE_INVERSE;
			}
			return _this;
		}
		_inheritsLoose(Channel3d, _Channel);
		var _proto = Channel3d.prototype;
		_proto.getPosition = function getPosition() {
			return this.position;
		};
		_proto.setPosition = function setPosition(position) {
			this.position.copy(position);
			var panner = this.panner;
			if ('positionX' in panner) {
				panner.positionX.value = position.x;
				panner.positionY.value = position.y;
				panner.positionZ.value = position.z;
			} else if (panner.setPosition) {
				panner.setPosition(position.x, position.y, position.z);
			}
		};
		_proto.getVelocity = function getVelocity() {
			return this.velocity;
		};
		_proto.setVelocity = function setVelocity(velocity) {
			this.velocity.copy(velocity);
		};
		_proto.getMaxDistance = function getMaxDistance() {
			return this.panner.maxDistance;
		};
		_proto.setMaxDistance = function setMaxDistance(max) {
			this.panner.maxDistance = max;
		};
		_proto.getMinDistance = function getMinDistance() {
			return this.panner.refDistance;
		};
		_proto.setMinDistance = function setMinDistance(min) {
			this.panner.refDistance = min;
		};
		_proto.getRollOffFactor = function getRollOffFactor() {
			return this.panner.rolloffFactor;
		};
		_proto.setRollOffFactor = function setRollOffFactor(factor) {
			this.panner.rolloffFactor = factor;
		};
		_proto.getDistanceModel = function getDistanceModel() {
			return this.panner.distanceModel;
		};
		_proto.setDistanceModel = function setDistanceModel(distanceModel) {
			this.panner.distanceModel = distanceModel;
		};
		_proto._createSource = function _createSource() {
			var context = this.manager.context;
			this.source = context.createBufferSource();
			this.source.buffer = this.sound.buffer;
			this.source.connect(this.panner);
			this.panner.connect(this.gain);
			this.gain.connect(context.destination);
			if (!this.loop) {
				this.source.onended = this.pause.bind(this);
			}
		};
		return Channel3d;
	}(Channel);
	if (!hasAudioContext()) {
		var offset$1 = new Vec3();
		var fallOff$1 = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
			offset$1 = offset$1.sub2(posOne, posTwo);
			var distance = offset$1.length();
			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}
			var result = 0;
			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rolloffFactor);
			}
			return math.clamp(result, 0, 1);
		};
		Object.assign(Channel3d.prototype, {
			setPosition: function setPosition(position) {
				this.position.copy(position);
				if (this.source) {
					var listener = this.manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff$1(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.getVolume();
					this.source.volume = v * factor;
				}
			},
			getMaxDistance: function getMaxDistance() {
				return this.maxDistance;
			},
			setMaxDistance: function setMaxDistance(max) {
				this.maxDistance = max;
			},
			getMinDistance: function getMinDistance() {
				return this.minDistance;
			},
			setMinDistance: function setMinDistance(min) {
				this.minDistance = min;
			},
			getRollOffFactor: function getRollOffFactor() {
				return this.rollOffFactor;
			},
			setRollOffFactor: function setRollOffFactor(factor) {
				this.rollOffFactor = factor;
			},
			getDistanceModel: function getDistanceModel() {
				return this.distanceModel;
			},
			setDistanceModel: function setDistanceModel(distanceModel) {
				this.distanceModel = distanceModel;
			}
		});
	}

	var Listener = function () {
		function Listener(manager) {
			this._manager = void 0;
			this.position = new Vec3();
			this.orientation = new Mat4();
			this._manager = manager;
		}
		var _proto = Listener.prototype;
		_proto.getPosition = function getPosition() {
			return this.position;
		};
		_proto.setPosition = function setPosition(position) {
			this.position.copy(position);
			var listener = this.listener;
			if (listener) {
				if ('positionX' in listener) {
					listener.positionX.value = position.x;
					listener.positionY.value = position.y;
					listener.positionZ.value = position.z;
				} else if (listener.setPosition) {
					listener.setPosition(position.x, position.y, position.z);
				}
			}
		};
		_proto.setOrientation = function setOrientation(orientation) {
			this.orientation.copy(orientation);
			var listener = this.listener;
			if (listener) {
				var m = orientation.data;
				if ('forwardX' in listener) {
					listener.forwardX.value = -m[8];
					listener.forwardY.value = -m[9];
					listener.forwardZ.value = -m[10];
					listener.upX.value = m[4];
					listener.upY.value = m[5];
					listener.upZ.value = m[6];
				} else if (listener.setOrientation) {
					listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);
				}
			}
		};
		_proto.getOrientation = function getOrientation() {
			return this.orientation;
		};
		return _createClass(Listener, [{
			key: "listener",
			get: function get() {
				var context = this._manager.context;
				return context ? context.listener : null;
			}
		}]);
	}();

	var CONTEXT_STATE_RUNNING = 'running';
	var USER_INPUT_EVENTS = ['click', 'touchstart', 'mousedown'];
	var SoundManager = function (_EventHandler) {
		function SoundManager() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._context = null;
			_this.AudioContext = typeof AudioContext !== 'undefined' && AudioContext || typeof webkitAudioContext !== 'undefined' && webkitAudioContext;
			if (!_this.AudioContext) ;
			_this._unlockHandlerFunc = _this._unlockHandler.bind(_this);
			_this._userSuspended = false;
			_this.listener = new Listener(_this);
			_this._volume = 1;
			return _this;
		}
		_inheritsLoose(SoundManager, _EventHandler);
		var _proto = SoundManager.prototype;
		_proto.suspend = function suspend() {
			if (!this._userSuspended) {
				this._userSuspended = true;
				if (this._context && this._context.state === CONTEXT_STATE_RUNNING) {
					this._suspend();
				}
			}
		};
		_proto.resume = function resume() {
			if (this._userSuspended) {
				this._userSuspended = false;
				if (this._context && this._context.state !== CONTEXT_STATE_RUNNING) {
					this._resume();
				}
			}
		};
		_proto.destroy = function destroy() {
			this.fire('destroy');
			if (this._context) {
				var _this$_context;
				this._removeUnlockListeners();
				(_this$_context = this._context) == null || _this$_context.close();
				this._context = null;
			}
		};
		_proto.playSound = function playSound(sound, options) {
			if (options === void 0) {
				options = {};
			}
			var channel = null;
			{
				channel = new Channel(this, sound, options);
				channel.play();
			}
			return channel;
		};
		_proto.playSound3d = function playSound3d(sound, position, options) {
			if (options === void 0) {
				options = {};
			}
			var channel = null;
			{
				channel = new Channel3d(this, sound, options);
				channel.setPosition(position);
				if (options.volume) {
					channel.setVolume(options.volume);
				}
				if (options.loop) {
					channel.setLoop(options.loop);
				}
				if (options.maxDistance) {
					channel.setMaxDistance(options.maxDistance);
				}
				if (options.minDistance) {
					channel.setMinDistance(options.minDistance);
				}
				if (options.rollOffFactor) {
					channel.setRollOffFactor(options.rollOffFactor);
				}
				if (options.distanceModel) {
					channel.setDistanceModel(options.distanceModel);
				}
				channel.play();
			}
			return channel;
		};
		_proto._resume = function _resume() {
			var _this2 = this;
			this._context.resume().then(function () {
				var source = _this2._context.createBufferSource();
				source.buffer = _this2._context.createBuffer(1, 1, _this2._context.sampleRate);
				source.connect(_this2._context.destination);
				source.start(0);
				source.onended = function (event) {
					source.disconnect(0);
					_this2.fire('resume');
				};
			}, function (e) {}).catch(function (e) {});
		};
		_proto._suspend = function _suspend() {
			var _this3 = this;
			this._context.suspend().then(function () {
				_this3.fire('suspend');
			}, function (e) {}).catch(function (e) {});
		};
		_proto._unlockHandler = function _unlockHandler() {
			this._removeUnlockListeners();
			if (!this._userSuspended && this._context.state !== CONTEXT_STATE_RUNNING) {
				this._resume();
			}
		};
		_proto._registerUnlockListeners = function _registerUnlockListeners() {
			var _this4 = this;
			USER_INPUT_EVENTS.forEach(function (eventName) {
				window.addEventListener(eventName, _this4._unlockHandlerFunc, false);
			});
		};
		_proto._removeUnlockListeners = function _removeUnlockListeners() {
			var _this5 = this;
			USER_INPUT_EVENTS.forEach(function (eventName) {
				window.removeEventListener(eventName, _this5._unlockHandlerFunc, false);
			});
		};
		return _createClass(SoundManager, [{
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				this.fire('volumechange', volume);
			}
		}, {
			key: "suspended",
			get: function get() {
				return this._userSuspended;
			}
		}, {
			key: "context",
			get: function get() {
				if (!this._context && this.AudioContext) {
					this._context = new this.AudioContext();
					if (this._context.state !== CONTEXT_STATE_RUNNING) {
						this._registerUnlockListeners();
					}
				}
				return this._context;
			}
		}]);
	}(EventHandler);

	var Sound = function () {
		function Sound(resource) {
			this.audio = void 0;
			this.buffer = void 0;
			if (resource instanceof Audio) {
				this.audio = resource;
			} else {
				this.buffer = resource;
			}
		}
		return _createClass(Sound, [{
			key: "duration",
			get: function get() {
				var duration = 0;
				if (this.buffer) {
					duration = this.buffer.duration;
				} else if (this.audio) {
					duration = this.audio.duration;
				}
				return duration || 0;
			}
		}]);
	}();

	var STATE_PLAYING = 0;
	var STATE_PAUSED = 1;
	var STATE_STOPPED = 2;
	function capTime(time, duration) {
		return time % duration || 0;
	}
	var SoundInstance = function (_EventHandler) {
		function SoundInstance(manager, sound, options) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.source = null;
			_this._manager = manager;
			_this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			_this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			_this._loop = !!(options.loop !== undefined ? options.loop : false);
			_this._sound = sound;
			_this._state = STATE_STOPPED;
			_this._suspended = false;
			_this._suspendEndEvent = 0;
			_this._suspendInstanceEvents = false;
			_this._playWhenLoaded = true;
			_this._startTime = Math.max(0, Number(options.startTime) || 0);
			_this._duration = Math.max(0, Number(options.duration) || 0);
			_this._startOffset = null;
			_this._onPlayCallback = options.onPlay;
			_this._onPauseCallback = options.onPause;
			_this._onResumeCallback = options.onResume;
			_this._onStopCallback = options.onStop;
			_this._onEndCallback = options.onEnd;
			if (hasAudioContext()) {
				_this._startedAt = 0;
				_this._currentTime = 0;
				_this._currentOffset = 0;
				_this._inputNode = null;
				_this._connectorNode = null;
				_this._firstNode = null;
				_this._lastNode = null;
				_this._waitingContextSuspension = false;
				_this._initializeNodes();
				_this._endedHandler = _this._onEnded.bind(_this);
			} else {
				_this._isReady = false;
				_this._loadedMetadataHandler = _this._onLoadedMetadata.bind(_this);
				_this._timeUpdateHandler = _this._onTimeUpdate.bind(_this);
				_this._endedHandler = _this._onEnded.bind(_this);
				_this._createSource();
			}
			return _this;
		}
		_inheritsLoose(SoundInstance, _EventHandler);
		var _proto = SoundInstance.prototype;
		_proto._onPlay = function _onPlay() {
			this.fire('play');
			if (this._onPlayCallback) {
				this._onPlayCallback(this);
			}
		};
		_proto._onPause = function _onPause() {
			this.fire('pause');
			if (this._onPauseCallback) {
				this._onPauseCallback(this);
			}
		};
		_proto._onResume = function _onResume() {
			this.fire('resume');
			if (this._onResumeCallback) {
				this._onResumeCallback(this);
			}
		};
		_proto._onStop = function _onStop() {
			this.fire('stop');
			if (this._onStopCallback) {
				this._onStopCallback(this);
			}
		};
		_proto._onEnded = function _onEnded() {
			if (this._suspendEndEvent > 0) {
				this._suspendEndEvent--;
				return;
			}
			this.fire('end');
			if (this._onEndCallback) {
				this._onEndCallback(this);
			}
			this.stop();
		};
		_proto._onManagerVolumeChange = function _onManagerVolumeChange() {
			this.volume = this._volume;
		};
		_proto._onManagerSuspend = function _onManagerSuspend() {
			if (this._state === STATE_PLAYING && !this._suspended) {
				this._suspended = true;
				this.pause();
			}
		};
		_proto._onManagerResume = function _onManagerResume() {
			if (this._suspended) {
				this._suspended = false;
				this.resume();
			}
		};
		_proto._initializeNodes = function _initializeNodes() {
			this.gain = this._manager.context.createGain();
			this._inputNode = this.gain;
			this._connectorNode = this.gain;
			this._connectorNode.connect(this._manager.context.destination);
		};
		_proto.play = function play() {
			if (this._state !== STATE_STOPPED) {
				this.stop();
			}
			this._state = STATE_PLAYING;
			this._playWhenLoaded = false;
			if (this._waitingContextSuspension) {
				return false;
			}
			if (this._manager.suspended) {
				this._manager.once('resume', this._playAudioImmediate, this);
				this._waitingContextSuspension = true;
				return false;
			}
			this._playAudioImmediate();
			return true;
		};
		_proto._playAudioImmediate = function _playAudioImmediate() {
			this._waitingContextSuspension = false;
			if (this._state !== STATE_PLAYING) {
				return;
			}
			if (!this.source) {
				this._createSource();
			}
			var offset = capTime(this._startOffset, this.duration);
			offset = capTime(this._startTime + offset, this._sound.duration);
			this._startOffset = null;
			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}
			this._startedAt = this._manager.context.currentTime;
			this._currentTime = 0;
			this._currentOffset = offset;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;
			this._manager.on('volumechange', this._onManagerVolumeChange, this);
			this._manager.on('suspend', this._onManagerSuspend, this);
			this._manager.on('resume', this._onManagerResume, this);
			this._manager.on('destroy', this._onManagerDestroy, this);
			if (!this._suspendInstanceEvents) {
				this._onPlay();
			}
		};
		_proto.pause = function pause() {
			this._playWhenLoaded = false;
			if (this._state !== STATE_PLAYING) {
				return false;
			}
			this._state = STATE_PAUSED;
			if (this._waitingContextSuspension) {
				return true;
			}
			this._updateCurrentTime();
			this._suspendEndEvent++;
			this.source.stop(0);
			this.source = null;
			this._startOffset = null;
			if (!this._suspendInstanceEvents) {
				this._onPause();
			}
			return true;
		};
		_proto.resume = function resume() {
			if (this._state !== STATE_PAUSED) {
				return false;
			}
			var offset = this.currentTime;
			this._state = STATE_PLAYING;
			if (this._waitingContextSuspension) {
				return true;
			}
			if (!this.source) {
				this._createSource();
			}
			if (this._startOffset !== null) {
				offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
			}
			if (this._duration) {
				this.source.start(0, offset, this._duration);
			} else {
				this.source.start(0, offset);
			}
			this._startedAt = this._manager.context.currentTime;
			this._currentOffset = offset;
			this.volume = this._volume;
			this.loop = this._loop;
			this.pitch = this._pitch;
			this._playWhenLoaded = false;
			if (!this._suspendInstanceEvents) {
				this._onResume();
			}
			return true;
		};
		_proto.stop = function stop() {
			this._playWhenLoaded = false;
			if (this._state === STATE_STOPPED) {
				return false;
			}
			var wasPlaying = this._state === STATE_PLAYING;
			this._state = STATE_STOPPED;
			if (this._waitingContextSuspension) {
				return true;
			}
			this._manager.off('volumechange', this._onManagerVolumeChange, this);
			this._manager.off('suspend', this._onManagerSuspend, this);
			this._manager.off('resume', this._onManagerResume, this);
			this._manager.off('destroy', this._onManagerDestroy, this);
			this._startedAt = 0;
			this._currentTime = 0;
			this._currentOffset = 0;
			this._startOffset = null;
			this._suspendEndEvent++;
			if (wasPlaying && this.source) {
				this.source.stop(0);
			}
			this.source = null;
			if (!this._suspendInstanceEvents) {
				this._onStop();
			}
			return true;
		};
		_proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
			if (!firstNode) {
				console.error('The firstNode must be a valid Audio Node');
				return;
			}
			if (!lastNode) {
				lastNode = firstNode;
			}
			var speakers = this._manager.context.destination;
			if (this._firstNode !== firstNode) {
				if (this._firstNode) {
					this._connectorNode.disconnect(this._firstNode);
				} else {
					this._connectorNode.disconnect(speakers);
				}
				this._firstNode = firstNode;
				this._connectorNode.connect(firstNode);
			}
			if (this._lastNode !== lastNode) {
				if (this._lastNode) {
					this._lastNode.disconnect(speakers);
				}
				this._lastNode = lastNode;
				this._lastNode.connect(speakers);
			}
		};
		_proto.clearExternalNodes = function clearExternalNodes() {
			var speakers = this._manager.context.destination;
			if (this._firstNode) {
				this._connectorNode.disconnect(this._firstNode);
				this._firstNode = null;
			}
			if (this._lastNode) {
				this._lastNode.disconnect(speakers);
				this._lastNode = null;
			}
			this._connectorNode.connect(speakers);
		};
		_proto.getExternalNodes = function getExternalNodes() {
			return [this._firstNode, this._lastNode];
		};
		_proto._createSource = function _createSource() {
			if (!this._sound) {
				return null;
			}
			var context = this._manager.context;
			if (this._sound.buffer) {
				this.source = context.createBufferSource();
				this.source.buffer = this._sound.buffer;
				this.source.connect(this._inputNode);
				this.source.onended = this._endedHandler;
				this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
				if (this._duration) {
					this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
				}
			}
			return this.source;
		};
		_proto._updateCurrentTime = function _updateCurrentTime() {
			this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
		};
		_proto._onManagerDestroy = function _onManagerDestroy() {
			if (this.source && this._state === STATE_PLAYING) {
				this.source.stop(0);
				this.source = null;
			}
		};
		return _createClass(SoundInstance, [{
			key: "currentTime",
			get: function get() {
				if (this._startOffset !== null) {
					return this._startOffset;
				}
				if (this._state === STATE_PAUSED) {
					return this._currentTime;
				}
				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}
				this._updateCurrentTime();
				return this._currentTime;
			},
			set: function set(value) {
				if (value < 0) return;
				if (this._state === STATE_PLAYING) {
					var suspend = this._suspendInstanceEvents;
					this._suspendInstanceEvents = true;
					this.stop();
					this._startOffset = value;
					this.play();
					this._suspendInstanceEvents = suspend;
				} else {
					this._startOffset = value;
					this._currentTime = value;
				}
			}
		}, {
			key: "duration",
			get: function get() {
				if (!this._sound) {
					return 0;
				}
				if (this._duration) {
					return capTime(this._duration, this._sound.duration);
				}
				return this._sound.duration;
			},
			set: function set(value) {
				this._duration = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();
				if (isPlaying) {
					this.play();
				}
			}
		}, {
			key: "isPaused",
			get: function get() {
				return this._state === STATE_PAUSED;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				return this._state === STATE_PLAYING;
			}
		}, {
			key: "isStopped",
			get: function get() {
				return this._state === STATE_STOPPED;
			}
		}, {
			key: "isSuspended",
			get: function get() {
				return this._suspended;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = !!value;
				if (this.source) {
					this.source.loop = this._loop;
				}
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(pitch) {
				this._currentOffset = this.currentTime;
				this._startedAt = this._manager.context.currentTime;
				this._pitch = Math.max(Number(pitch) || 0, 0.01);
				if (this.source) {
					this.source.playbackRate.value = this._pitch;
				}
			}
		}, {
			key: "sound",
			get: function get() {
				return this._sound;
			},
			set: function set(value) {
				this._sound = value;
				if (this._state !== STATE_STOPPED) {
					this.stop();
				} else {
					this._createSource();
				}
			}
		}, {
			key: "startTime",
			get: function get() {
				return this._startTime;
			},
			set: function set(value) {
				this._startTime = Math.max(0, Number(value) || 0);
				var isPlaying = this._state === STATE_PLAYING;
				this.stop();
				if (isPlaying) {
					this.play();
				}
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				if (this.gain) {
					this.gain.gain.value = volume * this._manager.volume;
				}
			}
		}]);
	}(EventHandler);
	SoundInstance.EVENT_PLAY = 'play';
	SoundInstance.EVENT_PAUSE = 'pause';
	SoundInstance.EVENT_RESUME = 'resume';
	SoundInstance.EVENT_STOP = 'stop';
	SoundInstance.EVENT_END = 'end';
	if (!hasAudioContext()) {
		Object.assign(SoundInstance.prototype, {
			play: function play() {
				if (this._state !== STATE_STOPPED) {
					this.stop();
				}
				if (!this.source) {
					if (!this._createSource()) {
						return false;
					}
				}
				this.volume = this._volume;
				this.pitch = this._pitch;
				this.loop = this._loop;
				this.source.play();
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				this._manager.on('volumechange', this._onManagerVolumeChange, this);
				this._manager.on('suspend', this._onManagerSuspend, this);
				this._manager.on('resume', this._onManagerResume, this);
				this._manager.on('destroy', this._onManagerDestroy, this);
				if (this._manager.suspended) {
					this._onManagerSuspend();
				}
				if (!this._suspendInstanceEvents) {
					this._onPlay();
				}
				return true;
			},
			pause: function pause() {
				if (!this.source || this._state !== STATE_PLAYING) {
					return false;
				}
				this._suspendEndEvent++;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_PAUSED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents) {
					this._onPause();
				}
				return true;
			},
			resume: function resume() {
				if (!this.source || this._state !== STATE_PAUSED) {
					return false;
				}
				this._state = STATE_PLAYING;
				this._playWhenLoaded = false;
				if (this.source.paused) {
					this.source.play();
					if (!this._suspendInstanceEvents) {
						this._onResume();
					}
				}
				return true;
			},
			stop: function stop() {
				if (!this.source || this._state === STATE_STOPPED) {
					return false;
				}
				this._manager.off('volumechange', this._onManagerVolumeChange, this);
				this._manager.off('suspend', this._onManagerSuspend, this);
				this._manager.off('resume', this._onManagerResume, this);
				this._manager.off('destroy', this._onManagerDestroy, this);
				this._suspendEndEvent++;
				this.source.pause();
				this._playWhenLoaded = false;
				this._state = STATE_STOPPED;
				this._startOffset = null;
				if (!this._suspendInstanceEvents) {
					this._onStop();
				}
				return true;
			},
			setExternalNodes: function setExternalNodes() {},
			clearExternalNodes: function clearExternalNodes() {},
			getExternalNodes: function getExternalNodes() {
				return [null, null];
			},
			_onLoadedMetadata: function _onLoadedMetadata() {
				this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
				this._isReady = true;
				var offset = capTime(this._startOffset, this.duration);
				offset = capTime(this._startTime + offset, this._sound.duration);
				this._startOffset = null;
				this.source.currentTime = offset;
			},
			_createSource: function _createSource() {
				if (this._sound && this._sound.audio) {
					this._isReady = false;
					this.source = this._sound.audio.cloneNode(true);
					this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
					this.source.addEventListener('timeupdate', this._timeUpdateHandler);
					this.source.onended = this._endedHandler;
				}
				return this.source;
			},
			_onTimeUpdate: function _onTimeUpdate() {
				if (!this._duration) {
					return;
				}
				if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
					if (this.loop) {
						this.source.currentTime = capTime(this._startTime, this.source.duration);
					} else {
						this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
						this.source.pause();
						this._onEnded();
					}
				}
			},
			_onManagerDestroy: function _onManagerDestroy() {
				if (this.source) {
					this.source.pause();
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'volume', {
			get: function get() {
				return this._volume;
			},
			set: function set(volume) {
				volume = math.clamp(volume, 0, 1);
				this._volume = volume;
				if (this.source) {
					this.source.volume = volume * this._manager.volume;
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'pitch', {
			get: function get() {
				return this._pitch;
			},
			set: function set(pitch) {
				this._pitch = Math.max(Number(pitch) || 0, 0.01);
				if (this.source) {
					this.source.playbackRate = this._pitch;
				}
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'sound', {
			get: function get() {
				return this._sound;
			},
			set: function set(value) {
				this.stop();
				this._sound = value;
			}
		});
		Object.defineProperty(SoundInstance.prototype, 'currentTime', {
			get: function get() {
				if (this._startOffset !== null) {
					return this._startOffset;
				}
				if (this._state === STATE_STOPPED || !this.source) {
					return 0;
				}
				return this.source.currentTime - this._startTime;
			},
			set: function set(value) {
				if (value < 0) return;
				this._startOffset = value;
				if (this.source && this._isReady) {
					this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
					this._startOffset = null;
				}
			}
		});
	}

	var MAX_DISTANCE = 10000;
	var SoundInstance3d = function (_SoundInstance) {
		function SoundInstance3d(manager, sound, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _SoundInstance.call(this, manager, sound, options) || this;
			_this._position = new Vec3();
			_this._velocity = new Vec3();
			if (options.position) {
				_this.position = options.position;
			}
			_this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
			_this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
			_this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
			_this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
			return _this;
		}
		_inheritsLoose(SoundInstance3d, _SoundInstance);
		var _proto = SoundInstance3d.prototype;
		_proto._initializeNodes = function _initializeNodes() {
			this.gain = this._manager.context.createGain();
			this.panner = this._manager.context.createPanner();
			this.panner.connect(this.gain);
			this._inputNode = this.panner;
			this._connectorNode = this.gain;
			this._connectorNode.connect(this._manager.context.destination);
		};
		return _createClass(SoundInstance3d, [{
			key: "position",
			get: function get() {
				return this._position;
			},
			set: function set(value) {
				this._position.copy(value);
				var panner = this.panner;
				if ('positionX' in panner) {
					panner.positionX.value = value.x;
					panner.positionY.value = value.y;
					panner.positionZ.value = value.z;
				} else if (panner.setPosition) {
					panner.setPosition(value.x, value.y, value.z);
				}
			}
		}, {
			key: "velocity",
			get: function get() {
				return this._velocity;
			},
			set: function set(velocity) {
				this._velocity.copy(velocity);
			}
		}, {
			key: "maxDistance",
			get: function get() {
				return this.panner.maxDistance;
			},
			set: function set(value) {
				this.panner.maxDistance = value;
			}
		}, {
			key: "refDistance",
			get: function get() {
				return this.panner.refDistance;
			},
			set: function set(value) {
				this.panner.refDistance = value;
			}
		}, {
			key: "rollOffFactor",
			get: function get() {
				return this.panner.rolloffFactor;
			},
			set: function set(value) {
				this.panner.rolloffFactor = value;
			}
		}, {
			key: "distanceModel",
			get: function get() {
				return this.panner.distanceModel;
			},
			set: function set(value) {
				this.panner.distanceModel = value;
			}
		}]);
	}(SoundInstance);
	if (!hasAudioContext()) {
		var offset = new Vec3();
		var fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
			offset = offset.sub2(posOne, posTwo);
			var distance = offset.length();
			if (distance < refDistance) {
				return 1;
			} else if (distance > maxDistance) {
				return 0;
			}
			var result = 0;
			if (distanceModel === DISTANCE_LINEAR) {
				result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
			} else if (distanceModel === DISTANCE_INVERSE) {
				result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
			} else if (distanceModel === DISTANCE_EXPONENTIAL) {
				result = Math.pow(distance / refDistance, -rollOffFactor);
			}
			return math.clamp(result, 0, 1);
		};
		Object.defineProperty(SoundInstance3d.prototype, 'position', {
			get: function get() {
				return this._position;
			},
			set: function set(position) {
				this._position.copy(position);
				if (this.source) {
					var listener = this._manager.listener;
					var lpos = listener.getPosition();
					var factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
					var v = this.volume;
					this.source.volume = v * factor * this._manager.volume;
				}
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
			get: function get() {
				return this._maxDistance;
			},
			set: function set(value) {
				this._maxDistance = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
			get: function get() {
				return this._refDistance;
			},
			set: function set(value) {
				this._refDistance = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
			get: function get() {
				return this._rollOffFactor;
			},
			set: function set(value) {
				this._rollOffFactor = value;
			}
		});
		Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
			get: function get() {
				return this._distanceModel;
			},
			set: function set(value) {
				this._distanceModel = value;
			}
		});
	}

	var BLEND_SUBTRACTIVE = 0;
	var BLEND_ADDITIVE = 1;
	var BLEND_NORMAL = 2;
	var BLEND_NONE = 3;
	var BLEND_PREMULTIPLIED = 4;
	var BLEND_MULTIPLICATIVE = 5;
	var BLEND_ADDITIVEALPHA = 6;
	var BLEND_MULTIPLICATIVE2X = 7;
	var BLEND_SCREEN = 8;
	var BLEND_MIN = 9;
	var BLEND_MAX = 10;
	var FOG_NONE = 'none';
	var FOG_LINEAR = 'linear';
	var FOG_EXP = 'exp';
	var FOG_EXP2 = 'exp2';
	var FRESNEL_NONE = 0;
	var FRESNEL_SCHLICK = 2;
	var LAYER_HUD = 0;
	var LAYER_GIZMO = 1;
	var LAYER_FX = 2;
	var LAYER_WORLD = 15;
	var LAYERID_WORLD = 0;
	var LAYERID_DEPTH = 1;
	var LAYERID_SKYBOX = 2;
	var LAYERID_IMMEDIATE = 3;
	var LAYERID_UI = 4;
	var LIGHTTYPE_DIRECTIONAL = 0;
	var LIGHTTYPE_OMNI = 1;
	var LIGHTTYPE_POINT = LIGHTTYPE_OMNI;
	var LIGHTTYPE_SPOT = 2;
	var LIGHTTYPE_COUNT = 3;
	var LIGHTSHAPE_PUNCTUAL = 0;
	var LIGHTSHAPE_RECT = 1;
	var LIGHTSHAPE_DISK = 2;
	var LIGHTSHAPE_SPHERE = 3;
	var LIGHTFALLOFF_LINEAR = 0;
	var LIGHTFALLOFF_INVERSESQUARED = 1;
	var SHADOW_PCF3_32F = 0;
	var SHADOW_PCF3 = 0;
	var SHADOW_VSM_16F = 2;
	var SHADOW_VSM16 = 2;
	var SHADOW_VSM_32F = 3;
	var SHADOW_VSM32 = 3;
	var SHADOW_PCF5_32F = 4;
	var SHADOW_PCF5 = 4;
	var SHADOW_PCF1_32F = 5;
	var SHADOW_PCF1 = 5;
	var SHADOW_PCSS_32F = 6;
	var SHADOW_PCF1_16F = 7;
	var SHADOW_PCF3_16F = 8;
	var SHADOW_PCF5_16F = 9;
	var shadowTypeInfo = new Map([[SHADOW_PCF1_32F, {
		name: 'PCF1_32F',
		format: PIXELFORMAT_DEPTH,
		pcf: true
	}], [SHADOW_PCF3_32F, {
		name: 'PCF3_32F',
		format: PIXELFORMAT_DEPTH,
		pcf: true
	}], [SHADOW_PCF5_32F, {
		name: 'PCF5_32F',
		format: PIXELFORMAT_DEPTH,
		pcf: true
	}], [SHADOW_PCF1_16F, {
		name: 'PCF1_16F',
		format: PIXELFORMAT_DEPTH16,
		pcf: true
	}], [SHADOW_PCF3_16F, {
		name: 'PCF3_16F',
		format: PIXELFORMAT_DEPTH16,
		pcf: true
	}], [SHADOW_PCF5_16F, {
		name: 'PCF5_16F',
		format: PIXELFORMAT_DEPTH16,
		pcf: true
	}], [SHADOW_VSM_16F, {
		name: 'VSM_16F',
		format: PIXELFORMAT_RGBA16F,
		vsm: true
	}], [SHADOW_VSM_32F, {
		name: 'VSM_32F',
		format: PIXELFORMAT_RGBA32F,
		vsm: true
	}], [SHADOW_PCSS_32F, {
		name: 'PCSS_32F',
		format: PIXELFORMAT_R32F,
		pcss: true
	}]]);
	var BLUR_BOX = 0;
	var BLUR_GAUSSIAN = 1;
	var PARTICLESORT_NONE = 0;
	var PARTICLESORT_DISTANCE = 1;
	var PARTICLESORT_NEWER_FIRST = 2;
	var PARTICLESORT_OLDER_FIRST = 3;
	var PARTICLEMODE_GPU = 0;
	var PARTICLEMODE_CPU = 1;
	var EMITTERSHAPE_BOX = 0;
	var EMITTERSHAPE_SPHERE = 1;
	var PARTICLEORIENTATION_SCREEN = 0;
	var PARTICLEORIENTATION_WORLD = 1;
	var PARTICLEORIENTATION_EMITTER = 2;
	var PROJECTION_PERSPECTIVE = 0;
	var PROJECTION_ORTHOGRAPHIC = 1;
	var RENDERSTYLE_SOLID = 0;
	var RENDERSTYLE_WIREFRAME = 1;
	var RENDERSTYLE_POINTS = 2;
	var CUBEPROJ_NONE = 0;
	var CUBEPROJ_BOX = 1;
	var DETAILMODE_MUL = 'mul';
	var DETAILMODE_ADD = 'add';
	var DETAILMODE_SCREEN = 'screen';
	var DETAILMODE_OVERLAY = 'overlay';
	var DETAILMODE_MIN = 'min';
	var DETAILMODE_MAX = 'max';
	var GAMMA_NONE = 0;
	var GAMMA_SRGB = 1;
	var TONEMAP_LINEAR = 0;
	var TONEMAP_FILMIC = 1;
	var TONEMAP_HEJL = 2;
	var TONEMAP_ACES = 3;
	var TONEMAP_ACES2 = 4;
	var TONEMAP_NEUTRAL = 5;
	var TONEMAP_NONE = 6;
	var tonemapNames = ['LINEAR', 'FILMIC', 'HEJL', 'ACES', 'ACES2', 'NEUTRAL', 'NONE'];
	var SPECOCC_NONE = 0;
	var SPECOCC_AO = 1;
	var SPECOCC_GLOSSDEPENDENT = 2;
	var SHADERDEF_NOSHADOW = 1;
	var SHADERDEF_SKIN = 2;
	var SHADERDEF_UV0 = 4;
	var SHADERDEF_UV1 = 8;
	var SHADERDEF_VCOLOR = 16;
	var SHADERDEF_INSTANCING = 32;
	var SHADERDEF_LM = 64;
	var SHADERDEF_DIRLM = 128;
	var SHADERDEF_SCREENSPACE = 256;
	var SHADERDEF_TANGENTS = 512;
	var SHADERDEF_MORPH_POSITION = 1024;
	var SHADERDEF_MORPH_NORMAL = 2048;
	var SHADERDEF_LMAMBIENT = 4096;
	var SHADERDEF_MORPH_TEXTURE_BASED_INT = 8192;
	var SHADERDEF_BATCH = 16384;
	var SHADOWUPDATE_NONE = 0;
	var SHADOWUPDATE_THISFRAME = 1;
	var SHADOWUPDATE_REALTIME = 2;
	var SORTKEY_FORWARD = 0;
	var SORTKEY_DEPTH = 1;
	var MASK_AFFECT_DYNAMIC = 1;
	var MASK_AFFECT_LIGHTMAPPED = 2;
	var MASK_BAKE = 4;
	var SHADER_FORWARD = 0;
	var SHADER_PREPASS = 1;
	var SHADER_DEPTH = 2;
	var SHADER_PICK = 3;
	var SHADER_SHADOW = 4;
	var SHADERPASS_FORWARD = 'forward';
	var SHADERPASS_ALBEDO = 'debug_albedo';
	var SHADERPASS_WORLDNORMAL = 'debug_world_normal';
	var SHADERPASS_OPACITY = 'debug_opacity';
	var SHADERPASS_SPECULARITY = 'debug_specularity';
	var SHADERPASS_GLOSS = 'debug_gloss';
	var SHADERPASS_METALNESS = 'debug_metalness';
	var SHADERPASS_AO = 'debug_ao';
	var SHADERPASS_EMISSION = 'debug_emission';
	var SHADERPASS_LIGHTING = 'debug_lighting';
	var SHADERPASS_UV0 = 'debug_uv0';
	var SPRITE_RENDERMODE_SIMPLE = 0;
	var SPRITE_RENDERMODE_SLICED = 1;
	var SPRITE_RENDERMODE_TILED = 2;
	var BAKE_COLOR = 0;
	var BAKE_COLORDIR = 1;
	var VIEW_CENTER = 0;
	var VIEW_LEFT = 1;
	var VIEW_RIGHT = 2;
	var SORTMODE_NONE = 0;
	var SORTMODE_MANUAL = 1;
	var SORTMODE_MATERIALMESH = 2;
	var SORTMODE_BACK2FRONT = 3;
	var SORTMODE_FRONT2BACK = 4;
	var SORTMODE_CUSTOM = 5;
	var ASPECT_AUTO = 0;
	var ASPECT_MANUAL = 1;
	var ORIENTATION_HORIZONTAL = 0;
	var ORIENTATION_VERTICAL = 1;
	var SKYTYPE_INFINITE = 'infinite';
	var SKYTYPE_BOX = 'box';
	var SKYTYPE_DOME = 'dome';
	var DITHER_NONE = 'none';
	var DITHER_BAYER8 = 'bayer8';
	var DITHER_BLUENOISE = 'bluenoise';
	var DITHER_IGNNOISE = 'ignnoise';
	var EVENT_PRERENDER = 'prerender';
	var EVENT_POSTRENDER = 'postrender';
	var EVENT_PRERENDER_LAYER = 'prerender:layer';
	var EVENT_POSTRENDER_LAYER = 'postrender:layer';
	var EVENT_PRECULL = 'precull';
	var EVENT_POSTCULL = 'postcull';

	var ShaderProcessorOptions = function () {
		function ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat) {
			this.uniformFormats = [];
			this.bindGroupFormats = [];
			this.vertexFormat = void 0;
			this.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;
			this.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;
			this.vertexFormat = vertexFormat;
		}
		var _proto = ShaderProcessorOptions.prototype;
		_proto.hasUniform = function hasUniform(name) {
			for (var i = 0; i < this.uniformFormats.length; i++) {
				var uniformFormat = this.uniformFormats[i];
				if (uniformFormat != null && uniformFormat.get(name)) {
					return true;
				}
			}
			return false;
		};
		_proto.hasTexture = function hasTexture(name) {
			for (var i = 0; i < this.bindGroupFormats.length; i++) {
				var groupFormat = this.bindGroupFormats[i];
				if (groupFormat != null && groupFormat.getTexture(name)) {
					return true;
				}
			}
			return false;
		};
		_proto.getVertexElement = function getVertexElement(semantic) {
			var _this$vertexFormat;
			return (_this$vertexFormat = this.vertexFormat) == null ? void 0 : _this$vertexFormat.elements.find(function (element) {
				return element.name === semantic;
			});
		};
		_proto.generateKey = function generateKey(device) {
			var key = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);
			if (device.isWebGPU) {
				var _this$vertexFormat2;
				key += (_this$vertexFormat2 = this.vertexFormat) == null ? void 0 : _this$vertexFormat2.shaderProcessingHashString;
			}
			return key;
		};
		return ShaderProcessorOptions;
	}();

	var alphaTestPS = "\nuniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n";

	var ambientConstantPS = "\nvoid addAmbient(vec3 worldNormal) {\n\tdDiffuseLight += light_globalAmbient;\n}\n";

	var ambientEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nvoid addAmbient(vec3 worldNormal) {\n\tvec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));\n\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\tvec4 raw = texture2D(texture_envAtlas, uv);\n\tvec3 linear = $DECODE(raw);\n\tdDiffuseLight += processEnvironment(linear);\n}\n";

	var ambientSHPS = "\nuniform vec3 ambientSH[9];\nvoid addAmbient(vec3 worldNormal) {\n\tvec3 n = cubeMapRotate(worldNormal);\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n";

	var aoPS = "\n#ifdef MAPTEXTURE\n\t#define AO_INTENSITY\n#endif\n#ifdef MAPVERTEX\n\t#define AO_INTENSITY\n#endif\n#ifdef AO_INTENSITY\n\tuniform float material_aoIntensity;\n#endif\nvoid getAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\t\tfloat aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t\tdAo *= addAoDetail(aoBase);\n\t#endif\n\t#ifdef MAPVERTEX\n\t\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef AO_INTENSITY\n\t\tdAo = mix(1.0, dAo, material_aoIntensity);\n\t#endif\n}\n";

	var aoDetailMapPS = "\nfloat addAoDetail(float ao) {\n#ifdef MAPTEXTURE\n\tfloat aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\treturn detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;\n#else\n\treturn ao;\n#endif\n}\n";

	var aoDiffuseOccPS = "\nvoid occludeDiffuse(float ao) {\n\tdDiffuseLight *= ao;\n}\n";

	var aoSpecOccPS = "\nuniform float material_occludeSpecularIntensity;\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specPow = exp2(gloss * 11.0);\n\tfloat specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n\t\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n";

	var aoSpecOccConstPS = "\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specPow = exp2(gloss * 11.0);\n\tfloat specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n\t\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n";

	var aoSpecOccConstSimplePS = "\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tdSpecularLight *= ao;\n\tdReflection *= ao;\n#ifdef LIT_SHEEN\n\tsSpecularLight *= ao;\n\tsReflection *= ao;\n#endif\n}\n";

	var aoSpecOccSimplePS = "\nuniform float material_occludeSpecularIntensity;\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specOcc = mix(1.0, ao, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n";

	var basePS = "\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n";

	var baseVS = "\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nvec3 dPositionW;\nmat4 dModelMatrix;\n#include \"transformCore\"\n";

	var baseNineSlicedPS = "\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

	var baseNineSlicedVS = "\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

	var baseNineSlicedTiledPS = "\n#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";

	var bayerPS = "\nfloat bayer2(vec2 p) {\n\treturn mod(2.0 * p.y + p.x + 1.0, 4.0);\n}\nfloat bayer4(vec2 p) {\n\tvec2 p1 = mod(p, 2.0);\n\tvec2 p2 = floor(0.5 * mod(p, 4.0));\n\treturn 4.0 * bayer2(p1) + bayer2(p2);\n}\nfloat bayer8(vec2 p) {\n\tvec2 p1 = mod(p, 2.0);\n\tvec2 p2 = floor(0.5 * mod(p, 4.0));\n\tvec2 p4 = floor(0.25 * mod(p, 8.0));\n\treturn 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);\n}\n";

	var blurVSMPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n}\n";

	var clearCoatPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var clearCoatGlossPS = "\n#ifdef MAPFLOAT\nuniform float material_clearCoatGloss;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tccGlossiness = 1.0 - ccGlossiness;\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n";

	var clearCoatNormalPS = "\n#ifdef MAPTEXTURE\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);\n\tccNormalW = normalize(dTBN * normalMap);\n#else\n\tccNormalW = dVertexNormalW;\n#endif\n}\n";

	var clusteredLightUtilsPS = "\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n\tvec3 vAbs = abs(dir);\n\tfloat ma;\n\tvec2 uv;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n\t\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\t\ttileOffset.x = 2.0;\n\t\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\t} else if(vAbs.y >= vAbs.x) {\n\t\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\t\ttileOffset.x = 1.0;\n\t\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\t} else {\n\t\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\t\ttileOffset.x = 0.0;\n\t\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\t}\n\treturn uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\tfloat faceIndex;\n\tvec2 tileOffset;\n\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\tfloat atlasFaceSize = omniAtlasViewport.z;\n\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\n\tfloat offset = shadowEdgePixels / tileSize;\n\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\tuv *= atlasFaceSize;\n\tuv += tileOffset * atlasFaceSize;\n\tuv += omniAtlasViewport.xy;\n\treturn uv;\n}\n";

	var clusteredLightCookiesPS = "\nvec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 pixel = mix(vec4(1.0), texture2DLod(tex, uv, 0.0), intensity);\n\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 projPos = transform * vec4(worldPosition, 1.0);\n\treturn _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\nvec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\treturn _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);\n}\n";

	var clusteredLightShadowsPS = "\nvoid _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {\n\tvec3 wPos = vPositionW + normal * shadowParams.y;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\tfloat distScale = length(lightDir);\n\tvec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - lightPos;\n\treturn dir;\n}\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\nfloat getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\tfloat shadowTextureResolution = shadowParams.x;\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\treturn textureShadow(shadowMap, vec3(uv, shadowZ));\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF3)\nfloat getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\tfloat shadowTextureResolution = shadowParams.x;\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\tvec3 shadowCoord = vec3(uv, shadowZ);\n\treturn getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF5)\nfloat getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\tfloat shadowTextureResolution = shadowParams.x;\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\tvec3 shadowCoord = vec3(uv, shadowZ);\n\treturn getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\nfloat getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn textureShadow(shadowMap, shadowCoord);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF3)\nfloat getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF5)\nfloat getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n";

	var clusteredLightPS = "\nuniform highp sampler2D clusterWorldTexture;\nuniform highp sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n#if defined(CLUSTER_COOKIES)\n\t#define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#if defined(CLUSTER_SHADOWS)\n\t#define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#ifdef CLUSTER_SHADOWS\n\tuniform sampler2DShadow shadowAtlasTexture;\n#endif\n#ifdef CLUSTER_COOKIES\n\tuniform sampler2D cookieAtlasTexture;\n#endif\nuniform int clusterMaxCells;\nuniform float clusterSkip;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\nstruct ClusterLightData {\n\tvec3 halfWidth;\n\tfloat lightType;\n\tvec3 halfHeight;\n\tint lightIndex;\n\tvec3 position;\n\tfloat shape;\n\tvec3 direction;\n\tfloat falloffMode;\n\tvec3 color;\n\tfloat shadowIntensity;\n\tvec3 omniAtlasViewport;\n\tfloat range;\n\tvec4 cookieChannelMask;\n\tfloat shadowBias;\n\tfloat shadowNormalBias;\n\tfloat innerConeAngleCos;\n\tfloat outerConeAngleCos;\n\tfloat cookie;\n\tfloat cookieRgb;\n\tfloat cookieIntensity;\n\tfloat mask;\n};\nmat4 lightProjectionMatrix;\n#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.lightType > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n\t#define acceptLightMask(light) ( light.mask < 0.75)\n#else\n\t#define acceptLightMask(light) ( light.mask > 0.25)\n#endif\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n\treturn vec4(\n\t\tbytes2floatRange4(d0, -2.0, 2.0),\n\t\tbytes2floatRange4(d1, -2.0, 2.0),\n\t\tbytes2floatRange4(d2, -2.0, 2.0),\n\t\tbytes2floatRange4(d3, -2.0, 2.0)\n\t);\n}\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {\n\treturn texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);\n}\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {\n\treturn texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);\n}\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\tclusterLightData.lightIndex = int(lightIndex);\n\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n\tclusterLightData.lightType = lightInfo.x;\n\tclusterLightData.shape = lightInfo.y;\n\tclusterLightData.falloffMode = lightInfo.z;\n\tclusterLightData.shadowIntensity = lightInfo.w;\n\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\tclusterLightData.cookie = colorB.z;\n\tclusterLightData.mask = colorB.w;\n\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n\tclusterLightData.position = lightPosRange.xyz;\n\tclusterLightData.range = lightPosRange.w;\n\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n\tclusterLightData.direction = lightDir_Unused.xyz;\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n\t\n\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n\t\n\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n\tclusterLightData.cookieIntensity = cookieA.x;\n\tclusterLightData.cookieRgb = cookieA.y;\n\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\nvoid evaluateLight(\n\tClusterLightData light, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir,\n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tvec3 cookieAttenuation = vec3(1.0);\n\tfloat diffuseAttenuation = 1.0;\n\tfloat falloffAttenuation = 1.0;\n\tgetLightDirPoint(light.position);\n\t#ifdef CLUSTER_AREALIGHTS\n\tif (isClusteredLightArea(light)) {\n\t\tdecodeClusterLightAreaData(light);\n\t\tif (isClusteredLightRect(light)) {\n\t\t\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else {\n\t\t\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t}\n\t\tfalloffAttenuation = getFalloffWindow(light.range, dLightDirW);\n\t} else\n\t#endif\n\t{\n\t\tif (isClusteredLightFalloffLinear(light))\n\t\t\tfalloffAttenuation = getFalloffLinear(light.range, dLightDirW);\n\t\telse\n\t\t\tfalloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);\n\t}\n\tif (falloffAttenuation > 0.00001) {\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\tdiffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\tdiffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t} else {\n\t\t\t\tdiffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t}\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\tfalloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); \n\t\t}\n\t\tif (isClusteredLightSpot(light)) {\n\t\t\tdecodeClusterLightSpot(light);\n\t\t\tfalloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);\n\t\t}\n\t\t#if defined(CLUSTER_COOKIES_OR_SHADOWS)\n\t\tif (falloffAttenuation > 0.00001) {\n\t\t\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\tdecodeClusterLightProjectionMatrixData(light);\n\t\t\t\t} else {\n\t\t\t\t\tdecodeClusterLightOmniAtlasViewport(light);\n\t\t\t\t}\n\t\t\t\tfloat shadowTextureResolution = shadowAtlasParams.x;\n\t\t\t\tfloat shadowEdgePixels = shadowAtlasParams.y;\n\t\t\t\t#ifdef CLUSTER_COOKIES\n\t\t\t\tif (isClusteredLightCookie(light)) {\n\t\t\t\t\tdecodeClusterLightCookieData(light);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tcookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef CLUSTER_SHADOWS\n\t\t\t\tif (isClusteredLightCastShadow(light)) {\n\t\t\t\t\tdecodeClusterLightShadowData(light);\n\t\t\t\t\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);\n\t\t\t\t\t\t\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCSS)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tfalloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tfalloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\t{\n\t\t\t\tvec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;\n\t\t\t\t#if defined(LIT_SPECULAR)\n\t\t\t\t\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += areaDiffuse;\n\t\t\t}\n\t\t\t#ifdef LIT_SPECULAR\n\t\t\t\tfloat areaLightSpecular;\n\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\tareaLightSpecular = getRectLightSpecular(worldNormal, viewDir);\n\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\tareaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);\n\t\t\t\t} else {\n\t\t\t\t\tareaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);\n\t\t\t\t}\n\t\t\t\tdSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#ifdef LIT_CLEARCOAT\n\t\t\t\t\tfloat areaLightSpecularCC;\n\t\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tareaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t}\n\t\t\t\t\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\t{\n\t\t\t\tvec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t#if defined(LIT_SPECULAR)\n\t\t\t\t\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);\n\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += punctualDiffuse;\n\t\t\t}\n   \n\t\t\t#ifdef LIT_SPECULAR\n\t\t\t\tvec3 halfDir = normalize(-dLightDirNormW + viewDir);\n\t\t\t\t\n\t\t\t\t#ifdef LIT_SPECULAR_FRESNEL\n\t\t\t\t\tdSpecularLight += \n\t\t\t\t\t\tgetLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * \n\t\t\t\t\t\tgetFresnel(\n\t\t\t\t\t\t\tdot(viewDir, halfDir), \n\t\t\t\t\t\t\tgloss, \n\t\t\t\t\t\t\tspecularity\n\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t, iridescenceFresnel,\n\t\t\t\t\t\t\tiridescence_intensity\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t);\n\t\t\t\t#else\n\t\t\t\t\tdSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;\n\t\t\t\t#endif\n\t\t\t\t#ifdef LIT_CLEARCOAT\n\t\t\t\t\t#ifdef LIT_SPECULAR_FRESNEL\n\t\t\t\t\t\tccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));\n\t\t\t\t\t#else\n\t\t\t\t\t\tccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; \n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t#ifdef LIT_SHEEN\n\t\t\t\t\tsSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t}\n\tdAtten = falloffAttenuation;\n\tdAttenD = diffuseAttenuation;\n\tdAtten3 = cookieAttenuation;\n}\nvoid evaluateClusterLight(\n\tfloat lightIndex, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tClusterLightData clusterLightData;\n\tdecodeClusterLightCore(clusterLightData, lightIndex);\n\tif (acceptLightMask(clusterLightData))\n\t\tevaluateLight(\n\t\t\tclusterLightData, \n\t\t\tworldNormal, \n\t\t\tviewDir, \n\t\t\treflectionDir, \n#if defined(LIT_CLEARCOAT)\n\t\t\tclearcoatReflectionDir, \n#endif\n\t\t\tgloss, \n\t\t\tspecularity, \n\t\t\tgeometricNormal, \n\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\tiridescenceFresnel,\n#endif\n\t\t\tclearcoat_worldNormal,\n\t\t\tclearcoat_gloss,\n\t\t\tsheen_gloss,\n\t\t\tiridescence_intensity\n\t\t);\n}\nvoid addClusteredLights(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tif (clusterSkip > 0.5)\n\t\treturn;\n\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\t\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\n\t\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\n\t\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\t\tfor (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {\n\t\t\tfloat lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;\n\t\t\tif (lightIndex <= 0.0)\n\t\t\t\t\treturn;\n\t\t\tevaluateClusterLight(\n\t\t\t\tlightIndex * 255.0, \n\t\t\t\tworldNormal, \n\t\t\t\tviewDir, \n\t\t\t\treflectionDir,\n#if defined(LIT_CLEARCOAT)\n\t\t\t\tclearcoatReflectionDir,\n#endif\n\t\t\t\tgloss, \n\t\t\t\tspecularity, \n\t\t\t\tgeometricNormal, \n\t\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\t\tiridescenceFresnel,\n#endif\n\t\t\t\tclearcoat_worldNormal,\n\t\t\t\tclearcoat_gloss,\n\t\t\t\tsheen_gloss,\n\t\t\t\tiridescence_intensity\n\t\t\t); \n\t\t}\n\t}\n}\n";

	var combinePS = "\nvec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {\n\tvec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n\tret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;\n#else\n\tret += albedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n\tret += dSpecularLight;\n#endif\n#ifdef LIT_REFLECTIONS\n\tret += dReflection.rgb * dReflection.a;\n#endif\n#ifdef LIT_SHEEN\n\tfloat sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;\n\tret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;\n#endif\n#ifdef LIT_CLEARCOAT\n\tfloat clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;\n\tret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;\n#endif\n\treturn ret;\n}\n";

	var cookiePS = "\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";

	var cubeMapProjectBoxPS = "\nuniform vec3 envBoxMin;\nuniform vec3 envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn normalize(posonbox - envBoxPos);\n}\n";

	var cubeMapProjectNonePS = "\nvec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n";

	var cubeMapRotatePS = "\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n";

	var debugOutputPS = "\n#ifdef DEBUG_ALBEDO_PASS\ngl_FragColor = vec4(gammaCorrectOutput(dAlbedo), 1.0);\n#endif\n#ifdef DEBUG_UV0_PASS\ngl_FragColor = vec4(litArgs_albedo , 1.0);\n#endif\n#ifdef DEBUG_WORLD_NORMAL_PASS\ngl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);\n#endif\n#ifdef DEBUG_OPACITY_PASS\ngl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);\n#endif\n#ifdef DEBUG_SPECULARITY_PASS\ngl_FragColor = vec4(litArgs_specularity, 1.0);\n#endif\n#ifdef DEBUG_GLOSS_PASS\ngl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);\n#endif\n#ifdef DEBUG_METALNESS_PASS\ngl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);\n#endif\n#ifdef DEBUG_AO_PASS\ngl_FragColor = vec4(vec3(litArgs_ao) , 1.0);\n#endif\n#ifdef DEBUG_EMISSION_PASS\ngl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);\n#endif\n";

	var debugProcessFrontendPS = "\n#ifdef DEBUG_LIGHTING_PASS\nlitArgs_albedo = vec3(0.5);\n#endif\n#ifdef DEBUG_UV0_PASS\n#ifdef VARYING_VUV0\nlitArgs_albedo = vec3(vUv0, 0);\n#else\nlitArgs_albedo = vec3(0);\n#endif\n#endif\n";

	var decodePS = "\nvec3 decodeLinear(vec4 raw) {\n\treturn raw.rgb;\n}\nfloat decodeGamma(float raw) {\n\treturn pow(raw, 2.2);\n}\nvec3 decodeGamma(vec3 raw) {\n\treturn pow(raw, vec3(2.2));\n}\nvec3 decodeGamma(vec4 raw) {\n\treturn pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n\tvec3 color = (8.0 * raw.a) * raw.rgb;\n\treturn color * color;\n}\nvec3 decodeRGBP(vec4 raw) {\n\tvec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);\n\treturn color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n\tif (raw.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n\t}\n}\nvec4 passThrough(vec4 raw) {\n\treturn raw;\n}\n";

	var detailModesPS = "\nvec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n";

	var diffusePS = "\nuniform vec3 material_diffuse;\nvoid getAlbedo() {\n\tdAlbedo = material_diffuse.rgb;\n#ifdef MAPTEXTURE\n\tvec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\tdAlbedo *= addAlbedoDetail(albedoBase);\n#endif\n#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n#endif\n}\n";

	var diffuseDetailMapPS = "\nvec3 addAlbedoDetail(vec3 albedo) {\n#ifdef MAPTEXTURE\n\tvec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n#else\n\treturn albedo;\n#endif\n}\n";

	var emissivePS = "\nuniform vec3 material_emissive;\nuniform float material_emissiveIntensity;\nvoid getEmission() {\n\tdEmission = material_emissive * material_emissiveIntensity;\n\t#ifdef MAPTEXTURE\n\tdEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n";

	var encodePS = "\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec4 encodeRGBP(vec3 source) {\n\tvec3 gamma = pow(source, vec3(0.5));\n\tfloat maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\tfloat v = 1.0 - ((maxVal - 1.0) / 7.0);\n\tv = ceil(v * 255.0) / 255.0;\n\treturn vec4(gamma / (-v * 7.0 + 8.0), v);\t\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\n";

	var endPS = "\n\tgl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);\n\tgl_FragColor.rgb += litArgs_emission;\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n";

	var endVS = "\n";

	var envAtlasPS = "\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n\t\t\t\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapShinyUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";

	var envConstPS = "\nvec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n";

	var envMultiplyPS = "\nuniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n";

	var falloffInvSquaredPS = "\nfloat getFalloffWindow(float lightRadius, vec3 lightDir) {\n\tfloat sqrDist = dot(lightDir, lightDir);\n\tfloat invRadius = 1.0 / lightRadius;\n\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius, vec3 lightDir) {\n\tfloat sqrDist = dot(lightDir, lightDir);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n";

	var falloffLinearPS = "\nfloat getFalloffLinear(float lightRadius, vec3 lightDir) {\n\tfloat d = length(lightDir);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n";

	var floatUnpackingPS = "\nfloat bytes2float2(vec2 data) {\n\treturn dot(data, vec2(1.0, 1.0 / 255.0));\n}\nfloat bytes2float3(vec3 data) {\n\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\nfloat bytes2float4(vec4 data) {\n\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n\treturn mix(min, max, bytes2float2(data));\n}\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n\treturn mix(min, max, bytes2float3(data));\n}\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n\treturn mix(min, max, bytes2float4(data));\n}\nfloat mantissaExponent2Float(vec4 pack)\n{\n\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n\tfloat exponent = floor(pack.w * 255.0 - 127.0);\n\treturn value * exp2(exponent);\n}\n";

	var fogExpPS = "\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogExp2PS = "\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogLinearPS = "\nuniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n";

	var fogNonePS = "\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n";

	var fresnelSchlickPS = "\nvec3 getFresnel(\n\t\tfloat cosTheta, \n\t\tfloat gloss, \n\t\tvec3 specularity\n#if defined(LIT_IRIDESCENCE)\n\t\t, vec3 iridescenceFresnel, \n\t\tfloat iridescenceIntensity\n#endif\n\t) {\n\tfloat fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n\tfloat glossSq = gloss * gloss;\n\tvec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;\n#if defined(LIT_IRIDESCENCE)\n\treturn mix(ret, iridescenceFresnel, iridescenceIntensity);\n#else\n\treturn ret;\n#endif\t\n}\nfloat getFresnelCC(float cosTheta) {\n\tfloat fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n\treturn 0.04 + (1.0 - 0.04) * fresnel;\n}\n";

	var fullscreenQuadPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var fullscreenQuadVS = "\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n";

	var gamma1_0PS = "\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\n";

	var gamma2_2PS = "\nfloat gammaCorrectInput(float color) {\n\treturn decodeGamma(color);\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn decodeGamma(color);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(decodeGamma(color.xyz), color.w);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn pow(color + 0.0000001, vec3(1.0 / 2.2));\n}\n";

	var glossPS = "\n#ifdef MAPFLOAT\nuniform float material_gloss;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_gloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tdGlossiness = 1.0 - dGlossiness;\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n";

	var gsplatCenterVS = "\nuniform mat4 matrix_model;\nuniform mat4 matrix_view;\nuniform mat4 matrix_projection;\nbool initCenter(SplatSource source, vec3 modelCenter, out SplatCenter center) {\n\tmat4 modelView = matrix_view * matrix_model;\n\tvec4 centerView = modelView * vec4(modelCenter, 1.0);\n\tif (centerView.z > 0.0) {\n\t\treturn false;\n\t}\n\tvec4 centerProj = matrix_projection * centerView;\n\tcenterProj.z = clamp(centerProj.z, -abs(centerProj.w), abs(centerProj.w));\n\tcenter.view = centerView.xyz / centerView.w;\n\tcenter.proj = centerProj;\n\tcenter.projMat00 = matrix_projection[0][0];\n\tcenter.modelView = modelView;\n\treturn true;\n}\n";

	var gsplatColorVS = "\nuniform mediump sampler2D splatColor;\nvec4 readColor(in SplatSource source) {\n\treturn texelFetch(splatColor, source.uv, 0);\n}\n";

	var gsplatCommonVS = "\nstruct SplatSource {\n\tuint order;\n\tuint id;\n\tivec2 uv;\n\tvec2 cornerUV;\n};\nstruct SplatCenter {\n\tvec3 view;\n\tvec4 proj;\n\tmat4 modelView;\n\tfloat projMat00;\n};\nstruct SplatCorner {\n\tvec2 offset;\n\tvec2 uv;\n};\n#if SH_BANDS > 0\n\t#if SH_BANDS == 1\n\t\t#define SH_COEFFS 3\n\t#elif SH_BANDS == 2\n\t\t#define SH_COEFFS 8\n\t#elif SH_BANDS == 3\n\t\t#define SH_COEFFS 15\n\t#endif\n#endif\n#if GSPLAT_COMPRESSED_DATA == true\n\t#include \"gsplatCompressedDataVS\"\n\t#include \"gsplatCompressedSHVS\"\n#else\n\t#include \"gsplatDataVS\"\n\t#include \"gsplatColorVS\"\n\t#include \"gsplatSHVS\"\n#endif\n#include \"gsplatSourceVS\"\n#include \"gsplatCenterVS\"\n#include \"gsplatCornerVS\"\n#include \"gsplatOutputVS\"\nvoid clipCorner(inout SplatCorner corner, float alpha) {\n\tfloat clip = min(1.0, sqrt(-log(1.0 / 255.0 / alpha)) / 2.0);\n\tcorner.offset *= clip;\n\tcorner.uv *= clip;\n}\n#if SH_BANDS > 0\n#define SH_C1 0.4886025119029199f\n#if SH_BANDS > 1\n\t#define SH_C2_0 1.0925484305920792f\n\t#define SH_C2_1 -1.0925484305920792f\n\t#define SH_C2_2 0.31539156525252005f\n\t#define SH_C2_3 -1.0925484305920792f\n\t#define SH_C2_4 0.5462742152960396f\n#endif\n#if SH_BANDS > 2\n\t#define SH_C3_0 -0.5900435899266435f\n\t#define SH_C3_1 2.890611442640554f\n\t#define SH_C3_2 -0.4570457994644658f\n\t#define SH_C3_3 0.3731763325901154f\n\t#define SH_C3_4 -0.4570457994644658f\n\t#define SH_C3_5 1.445305721320277f\n\t#define SH_C3_6 -0.5900435899266435f\n#endif\nvec3 evalSH(in SplatSource source, in vec3 dir) {\n\tvec3 sh[SH_COEFFS];\n\tfloat scale;\n\treadSHData(source, sh, scale);\n\tfloat x = dir.x;\n\tfloat y = dir.y;\n\tfloat z = dir.z;\n\tvec3 result = SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);\n#if SH_BANDS > 1\n\tfloat xx = x * x;\n\tfloat yy = y * y;\n\tfloat zz = z * z;\n\tfloat xy = x * y;\n\tfloat yz = y * z;\n\tfloat xz = x * z;\n\tresult +=\n\t\tsh[3] * (SH_C2_0 * xy) *  +\n\t\tsh[4] * (SH_C2_1 * yz) +\n\t\tsh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +\n\t\tsh[6] * (SH_C2_3 * xz) +\n\t\tsh[7] * (SH_C2_4 * (xx - yy));\n#endif\n#if SH_BANDS > 2\n\tresult +=\n\t\tsh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +\n\t\tsh[9]  * (SH_C3_1 * xy * z) +\n\t\tsh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +\n\t\tsh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +\n\t\tsh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +\n\t\tsh[13] * (SH_C3_5 * z * (xx - yy)) +\n\t\tsh[14] * (SH_C3_6 * x * (xx - 3.0 * yy));\n#endif\n\treturn result * scale;\n}\n#endif\n";

	var gsplatCompressedDataVS = "\nuniform highp usampler2D packedTexture;\nuniform highp sampler2D chunkTexture;\nvec4 chunkDataA;\nvec4 chunkDataB;\nvec4 chunkDataC;\nvec4 chunkDataD;\nvec4 chunkDataE;\nuvec4 packedData;\nvec3 unpack111011(uint bits) {\n\treturn vec3(\n\t\tfloat(bits >> 21u) / 2047.0,\n\t\tfloat((bits >> 11u) & 0x3ffu) / 1023.0,\n\t\tfloat(bits & 0x7ffu) / 2047.0\n\t);\n}\nvec4 unpack8888(uint bits) {\n\treturn vec4(\n\t\tfloat(bits >> 24u) / 255.0,\n\t\tfloat((bits >> 16u) & 0xffu) / 255.0,\n\t\tfloat((bits >> 8u) & 0xffu) / 255.0,\n\t\tfloat(bits & 0xffu) / 255.0\n\t);\n}\nconst float norm = 1.0 / (sqrt(2.0) * 0.5);\nvec4 unpackRotation(uint bits) {\n\tfloat a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n\tfloat b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n\tfloat c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;\n\tfloat m = sqrt(1.0 - (a * a + b * b + c * c));\n\tuint mode = bits >> 30u;\n\tif (mode == 0u) return vec4(m, a, b, c);\n\tif (mode == 1u) return vec4(a, m, b, c);\n\tif (mode == 2u) return vec4(a, b, m, c);\n\treturn vec4(a, b, c, m);\n}\nmat3 quatToMat3(vec4 R) {\n\tfloat x = R.x;\n\tfloat y = R.y;\n\tfloat z = R.z;\n\tfloat w = R.w;\n\treturn mat3(\n\t\t1.0 - 2.0 * (z * z + w * w),\n\t\t\t  2.0 * (y * z + x * w),\n\t\t\t  2.0 * (y * w - x * z),\n\t\t\t  2.0 * (y * z - x * w),\n\t\t1.0 - 2.0 * (y * y + w * w),\n\t\t\t  2.0 * (z * w + x * y),\n\t\t\t  2.0 * (y * w + x * z),\n\t\t\t  2.0 * (z * w - x * y),\n\t\t1.0 - 2.0 * (y * y + z * z)\n\t);\n}\nvec3 readCenter(SplatSource source) {\n\tuint w = uint(textureSize(chunkTexture, 0).x) / 5u;\n\tuint chunkId = source.id / 256u;\n\tivec2 chunkUV = ivec2((chunkId % w) * 5u, chunkId / w);\n\tchunkDataA = texelFetch(chunkTexture, chunkUV, 0);\n\tchunkDataB = texelFetch(chunkTexture, chunkUV + ivec2(1, 0), 0);\n\tchunkDataC = texelFetch(chunkTexture, chunkUV + ivec2(2, 0), 0);\n\tchunkDataD = texelFetch(chunkTexture, chunkUV + ivec2(3, 0), 0);\n\tchunkDataE = texelFetch(chunkTexture, chunkUV + ivec2(4, 0), 0);\n\tpackedData = texelFetch(packedTexture, source.uv, 0);\n\treturn mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));\n}\nvec4 readColor(in SplatSource source) {\n\tvec4 r = unpack8888(packedData.w);\n\treturn vec4(mix(chunkDataD.xyz, vec3(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);\n}\nvec4 getRotation() {\n\treturn unpackRotation(packedData.y);\n}\nvec3 getScale() {\n\treturn exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));\n}\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n\tmat3 rot = quatToMat3(getRotation());\n\tvec3 scale = getScale();\n\tmat3 M = transpose(mat3(\n\t\tscale.x * rot[0],\n\t\tscale.y * rot[1],\n\t\tscale.z * rot[2]\n\t));\n\tcovA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n\tcovB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";

	var gsplatCompressedSHVS = "\n#if SH_BANDS > 0\nuniform highp usampler2D shTexture0;\nuniform highp usampler2D shTexture1;\nuniform highp usampler2D shTexture2;\nvec4 unpack8888s(in uint bits) {\n\treturn vec4((uvec4(bits) >> uvec4(0u, 8u, 16u, 24u)) & 0xffu) * (8.0 / 255.0) - 4.0;\n}\nvoid readSHData(in SplatSource source, out vec3 sh[15], out float scale) {\n\tuvec4 shData0 = texelFetch(shTexture0, source.uv, 0);\n\tuvec4 shData1 = texelFetch(shTexture1, source.uv, 0);\n\tuvec4 shData2 = texelFetch(shTexture2, source.uv, 0);\n\tvec4 r0 = unpack8888s(shData0.x);\n\tvec4 r1 = unpack8888s(shData0.y);\n\tvec4 r2 = unpack8888s(shData0.z);\n\tvec4 r3 = unpack8888s(shData0.w);\n\tvec4 g0 = unpack8888s(shData1.x);\n\tvec4 g1 = unpack8888s(shData1.y);\n\tvec4 g2 = unpack8888s(shData1.z);\n\tvec4 g3 = unpack8888s(shData1.w);\n\tvec4 b0 = unpack8888s(shData2.x);\n\tvec4 b1 = unpack8888s(shData2.y);\n\tvec4 b2 = unpack8888s(shData2.z);\n\tvec4 b3 = unpack8888s(shData2.w);\n\tsh[0] =  vec3(r0.x, g0.x, b0.x);\n\tsh[1] =  vec3(r0.y, g0.y, b0.y);\n\tsh[2] =  vec3(r0.z, g0.z, b0.z);\n\tsh[3] =  vec3(r0.w, g0.w, b0.w);\n\tsh[4] =  vec3(r1.x, g1.x, b1.x);\n\tsh[5] =  vec3(r1.y, g1.y, b1.y);\n\tsh[6] =  vec3(r1.z, g1.z, b1.z);\n\tsh[7] =  vec3(r1.w, g1.w, b1.w);\n\tsh[8] =  vec3(r2.x, g2.x, b2.x);\n\tsh[9] =  vec3(r2.y, g2.y, b2.y);\n\tsh[10] = vec3(r2.z, g2.z, b2.z);\n\tsh[11] = vec3(r2.w, g2.w, b2.w);\n\tsh[12] = vec3(r3.x, g3.x, b3.x);\n\tsh[13] = vec3(r3.y, g3.y, b3.y);\n\tsh[14] = vec3(r3.z, g3.z, b3.z);\n\tscale = 1.0;\n}\n#endif\n";

	var gsplatCornerVS = "\nuniform vec2 viewport;\nuniform vec4 camera_params;\nbool initCorner(SplatSource source, SplatCenter center, out SplatCorner corner) {\n\tvec3 covA, covB;\n\treadCovariance(source, covA, covB);\n\tmat3 Vrk = mat3(\n\t\tcovA.x, covA.y, covA.z, \n\t\tcovA.y, covB.x, covB.y,\n\t\tcovA.z, covB.y, covB.z\n\t);\n\tfloat focal = viewport.x * center.projMat00;\n\tvec3 v = camera_params.w == 1.0 ? vec3(0.0, 0.0, 1.0) : center.view.xyz;\n\tfloat J1 = focal / v.z;\n\tvec2 J2 = -J1 / v.z * v.xy;\n\tmat3 J = mat3(\n\t\tJ1, 0.0, J2.x, \n\t\t0.0, J1, J2.y, \n\t\t0.0, 0.0, 0.0\n\t);\n\tmat3 W = transpose(mat3(center.modelView));\n\tmat3 T = W * J;\n\tmat3 cov = transpose(T) * Vrk * T;\n\tfloat diagonal1 = cov[0][0] + 0.3;\n\tfloat offDiagonal = cov[0][1];\n\tfloat diagonal2 = cov[1][1] + 0.3;\n\tfloat mid = 0.5 * (diagonal1 + diagonal2);\n\tfloat radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n\tfloat lambda1 = mid + radius;\n\tfloat lambda2 = max(mid - radius, 0.1);\n\tfloat l1 = 2.0 * min(sqrt(2.0 * lambda1), 1024.0);\n\tfloat l2 = 2.0 * min(sqrt(2.0 * lambda2), 1024.0);\n\tif (l1 < 2.0 && l2 < 2.0) {\n\t\treturn false;\n\t}\n\tif (any(greaterThan(abs(center.proj.xy) - vec2(l1, l2) / viewport * center.proj.w, center.proj.ww))) {\n\t\treturn false;\n\t}\n\tvec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n\tvec2 v1 = l1 * diagonalVector;\n\tvec2 v2 = l2 * vec2(diagonalVector.y, -diagonalVector.x);\n\tcorner.offset = (source.cornerUV.x * v1 + source.cornerUV.y * v2) / viewport * center.proj.w;\n\tcorner.uv = source.cornerUV;\n\treturn true;\n}\n";

	var gsplatDataVS = "\nuniform highp usampler2D transformA;\nuniform highp sampler2D transformB;\nuint tAw;\nvec3 readCenter(SplatSource source) {\n\tuvec4 tA = texelFetch(transformA, source.uv, 0);\n\ttAw = tA.w;\n\treturn uintBitsToFloat(tA.xyz);\n}\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n\tvec4 tB = texelFetch(transformB, source.uv, 0);\n\tvec2 tC = unpackHalf2x16(tAw);\n\tcovA = tB.xyz;\n\tcovB = vec3(tC.x, tC.y, tB.w);\n}\n";

	var gsplatOutputVS = "\n#include \"tonemappingPS\"\n#if TONEMAP != NONE\n\t#if GAMMA == SRGB\n\t\t#include \"decodePS\"\n\t\t#include \"gamma2_2PS\"\n\t#else\n\t\t#include \"gamma1_0PS\"\n\t#endif\n#endif\nvec3 prepareOutputFromGamma(vec3 gammaColor) {\n\t#if TONEMAP == NONE\n\t\t#if GAMMA == NONE\n\t\t\treturn decodeGamma(gammaColor);\n\t\t#else\n\t\t\treturn gammaColor;\n\t\t#endif\n\t#else\n\t\treturn gammaCorrectOutput(toneMap(decodeGamma(gammaColor)));\n\t#endif\n}\n";

	var gsplatPS = "\n#ifndef DITHER_NONE\n\t#include \"bayerPS\"\n\t#include \"opacityDitherPS\"\n\tvarying float id;\n#endif\n#ifdef PICK_PASS\n\tuniform vec4 uColor;\n#endif\nvarying mediump vec2 gaussianUV;\nvarying mediump vec4 gaussianColor;\nvoid main(void) {\n\tmediump float A = dot(gaussianUV, gaussianUV);\n\tif (A > 1.0) {\n\t\tdiscard;\n\t}\n\tmediump float alpha = exp(-A * 4.0) * gaussianColor.a;\n\t#ifdef PICK_PASS\n\t\tif (alpha < 0.3) {\n\t\t\tdiscard;\n\t\t}\n\t\tgl_FragColor = uColor;\n\t#else\n\t\tif (alpha < 1.0 / 255.0) {\n\t\t\tdiscard;\n\t\t}\n\t\t#ifndef DITHER_NONE\n\t\t\topacityDither(alpha, id * 0.013);\n\t\t#endif\n\t\tgl_FragColor = vec4(gaussianColor.xyz, alpha);\n\t#endif\n}\n";

	var gsplatSHVS = "\n#if SH_BANDS > 0\nvec3 unpack111011s(uint bits) {\n\treturn vec3((uvec3(bits) >> uvec3(21u, 11u, 0u)) & uvec3(0x7ffu, 0x3ffu, 0x7ffu)) / vec3(2047.0, 1023.0, 2047.0) * 2.0 - 1.0;\n}\nvoid fetchScale(in uvec4 t, out float scale, out vec3 a, out vec3 b, out vec3 c) {\n\tscale = uintBitsToFloat(t.x);\n\ta = unpack111011s(t.y);\n\tb = unpack111011s(t.z);\n\tc = unpack111011s(t.w);\n}\nvoid fetch(in uvec4 t, out vec3 a, out vec3 b, out vec3 c, out vec3 d) {\n\ta = unpack111011s(t.x);\n\tb = unpack111011s(t.y);\n\tc = unpack111011s(t.z);\n\td = unpack111011s(t.w);\n}\nvoid fetch(in uint t, out vec3 a) {\n\ta = unpack111011s(t);\n}\n#if SH_BANDS == 1\n\tuniform highp usampler2D splatSH_1to3;\n\tvoid readSHData(in SplatSource source, out vec3 sh[3], out float scale) {\n\t\tfetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n\t}\n#elif SH_BANDS == 2\n\tuniform highp usampler2D splatSH_1to3;\n\tuniform highp usampler2D splatSH_4to7;\n\tuniform highp usampler2D splatSH_8to11;\n\tvoid readSHData(in SplatSource source, out vec3 sh[8], out float scale) {\n\t\tfetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n\t\tfetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);\n\t\tfetch(texelFetch(splatSH_8to11, source.uv, 0).x, sh[7]);\n\t}\n#else\n\tuniform highp usampler2D splatSH_1to3;\n\tuniform highp usampler2D splatSH_4to7;\n\tuniform highp usampler2D splatSH_8to11;\n\tuniform highp usampler2D splatSH_12to15;\n\tvoid readSHData(in SplatSource source, out vec3 sh[15], out float scale) {\n\t\tfetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n\t\tfetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);\n\t\tfetch(texelFetch(splatSH_8to11, source.uv, 0), sh[7], sh[8], sh[9], sh[10]);\n\t\tfetch(texelFetch(splatSH_12to15, source.uv, 0), sh[11], sh[12], sh[13], sh[14]);\n\t}\n#endif\n#endif\n";

	var gsplatSourceVS = "\nattribute vec3 vertex_position;\nattribute uint vertex_id_attrib;\nuniform uint numSplats;\nuniform highp usampler2D splatOrder;\nbool initSource(out SplatSource source) {\n\tuint w = uint(textureSize(splatOrder, 0).x);\n\tsource.order = vertex_id_attrib + uint(vertex_position.z);\n\tif (source.order >= numSplats) {\n\t\treturn false;\n\t}\n\tivec2 orderUV = ivec2(source.order % w, source.order / w);\n\tsource.id = texelFetch(splatOrder, orderUV, 0).r;\n\tsource.uv = ivec2(source.id % w, source.id / w);\n\tsource.cornerUV = vertex_position.xy;\n\treturn true;\n}\n";

	var gsplatVS = "\n#include \"gsplatCommonVS\"\nvarying mediump vec2 gaussianUV;\nvarying mediump vec4 gaussianColor;\n#ifndef DITHER_NONE\n\tvarying float id;\n#endif\nmediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);\nvoid main(void) {\n\tSplatSource source;\n\tif (!initSource(source)) {\n\t\tgl_Position = discardVec;\n\t\treturn;\n\t}\n\tvec3 modelCenter = readCenter(source);\n\tSplatCenter center;\n\tif (!initCenter(source, modelCenter, center)) {\n\t\tgl_Position = discardVec;\n\t\treturn;\n\t}\n\tSplatCorner corner;\n\tif (!initCorner(source, center, corner)) {\n\t\tgl_Position = discardVec;\n\t\treturn;\n\t}\n\tvec4 clr = readColor(source);\n\t#if SH_BANDS > 0\n\t\tvec3 dir = normalize(center.view * mat3(center.modelView));\n\t\tclr.xyz += evalSH(source, dir);\n\t#endif\n\tclipCorner(corner, clr.w);\n\tgl_Position = center.proj + vec4(corner.offset, 0, 0);\n\tgaussianUV = corner.uv;\n\tgaussianColor = vec4(prepareOutputFromGamma(max(clr.xyz, 0.0)), clr.w);\n\t#ifndef DITHER_NONE\n\t\tid = float(source.id);\n\t#endif\n}\n";

	var iridescenceDiffractionPS = "\nuniform float material_iridescenceRefractionIndex;\n#ifndef PI\n#define PI 3.14159265\n#endif\nfloat iridescence_iorToFresnel(float transmittedIor, float incidentIor) {\n\treturn pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);\n}\nvec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {\n\treturn pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));\n}\nvec3 iridescence_fresnelToIor(vec3 f0) {\n\tvec3 sqrtF0 = sqrt(f0);\n\treturn (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\nvec3 iridescence_sensitivity(float opd, vec3 shift) {\n\tfloat phase = 2.0 * PI * opd * 1.0e-9;\n\tconst vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n\tconst vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n\tconst vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\tvec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);\n\txyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));\n\txyz /= vec3(1.0685e-07);\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t   -1.5371385,  1.8760108, -0.2040259,\n\t   -0.4985314,  0.0415560,  1.0572252\n\t);\n\treturn XYZ_TO_REC709 * xyz;\n}\nfloat iridescence_fresnel(float cosTheta, float f0) {\n\tfloat x = clamp(1.0 - cosTheta, 0.0, 1.0);\n\tfloat x2 = x * x;\n\tfloat x5 = x * x2 * x2;\n\treturn f0 + (1.0 - f0) * x5;\n} \nvec3 iridescence_fresnel(float cosTheta, vec3 f0) {\n\tfloat x = clamp(1.0 - cosTheta, 0.0, 1.0);\n\tfloat x2 = x * x;\n\tfloat x5 = x * x2 * x2; \n\treturn f0 + (vec3(1.0) - f0) * x5;\n}\nvec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {\n\tfloat iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));\n\tfloat sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));\n\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\tif (cosTheta2Sq < 0.0) {\n\t\treturn vec3(1.0);\n\t}\n\tfloat cosTheta2 = sqrt(cosTheta2Sq);\n\tfloat r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);\n\tfloat r12 = iridescence_fresnel(cosTheta, r0);\n\tfloat r21 = r12;\n\tfloat t121 = 1.0 - r12;\n\tfloat phi12 = iridescenceIor < outsideIor ? PI : 0.0;\n\tfloat phi21 = PI - phi12;\n\tvec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));\n\tvec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);\n\tvec3 r23 = iridescence_fresnel(cosTheta2, r1);\n\tvec3 phi23 = vec3(0.0);\n\tif (baseIor[0] < iridescenceIor) phi23[0] = PI;\n\tif (baseIor[1] < iridescenceIor) phi23[1] = PI;\n\tif (baseIor[2] < iridescenceIor) phi23[2] = PI;\n\tfloat opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;\n\tvec3 phi = vec3(phi21) + phi23; \n\tvec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);\n\tvec3 r123 = sqrt(r123Sq);\n\tvec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);\n\tvec3 c0 = r12 + rs;\n\tvec3 i = c0;\n\tvec3 cm = rs - t121;\n\tfor (int m = 1; m <= 2; m++) {\n\t\tcm *= r123;\n\t\tvec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);\n\t\ti += cm * sm;\n\t}\n\treturn max(i, vec3(0.0));\n}\nvec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {\n\treturn calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);\n}\n";

	var iridescencePS = "\n#ifdef MAPFLOAT\nuniform float material_iridescence;\n#endif\nvoid getIridescence() {\n\tfloat iridescence = 1.0;\n\t#ifdef MAPFLOAT\n\tiridescence *= material_iridescence;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tiridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\tdIridescence = iridescence; \n}\n";

	var iridescenceThicknessPS = "\nuniform float material_iridescenceThicknessMax;\n#ifdef MAPTEXTURE\nuniform float material_iridescenceThicknessMin;\n#endif\nvoid getIridescenceThickness() {\n\t#ifdef MAPTEXTURE\n\tfloat blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\tfloat iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);\n\t#else\n\tfloat iridescenceThickness = material_iridescenceThicknessMax;\n\t#endif\n\tdIridescenceThickness = iridescenceThickness; \n}\n";

	var iorPS = "\n#ifdef MAPFLOAT\nuniform float material_refractionIndex;\n#endif\nvoid getIor() {\n#ifdef MAPFLOAT\n\tdIor = material_refractionIndex;\n#else\n\tdIor = 1.0 / 1.5;\n#endif\n}\n";

	var lightDiffuseLambertPS = "\nfloat getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn max(dot(worldNormal, -lightDirNorm), 0.0);\n}\n";

	var lightDirPointPS = "\nvoid getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n";

	var lightmapAddPS = "\nvoid addLightMap(\n\tvec3 lightmap, \n\tvec3 dir, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 vertexNormal, \n\tmat3 tbn\n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel, \n\tfloat iridescenceIntensity\n#endif\n) {\n\tdDiffuseLight += lightmap;\n}\n";

	var lightmapDirAddPS = "\nvoid addLightMap(\n\tvec3 lightmap, \n\tvec3 dir, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 vertexNormal, \n\tmat3 tbn\n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel, \n\tfloat iridescenceIntensity\n#endif\n) {\n\tif (dot(dir, dir) < 0.0001) {\n\t\tdDiffuseLight += lightmap;\n\t} else {\n\t\tfloat vlight = saturate(dot(dir, -vertexNormal));\n\t\tfloat flight = saturate(dot(dir, -worldNormal));\n\t\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\n\t\tdDiffuseLight += lightmap * nlight * 2.0;\n\t\tvec3 halfDir = normalize(-dir + viewDir);\n\t\tvec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);\n#ifdef LIT_SPECULAR_FRESNEL\n\t\tspecularLight *= \n\t\t\tgetFresnel(dot(viewDir, halfDir), \n\t\t\tgloss, \n\t\t\tspecularity\n\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t, iridescenceFresnel,\n\t\t\tiridescenceIntensity\n\t\t#endif\n\t\t\t);\n#endif\n\t\tdSpecularLight += specularLight;\n\t}\n}\n";

	var lightmapDirPS = "\nuniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid getLightMap() {\n\tdLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;\n\tvec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;\n\tfloat dirDot = dot(dir, dir);\n\tdLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);\n}\n";

	var lightmapSinglePS = "\nvoid getLightMap() {\n\tdLightmap = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tdLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdLightmap *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var lightSpecularAnisoGGXPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n \n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tfloat NoH = dot(worldNormal, h);\n\tfloat ToH = dot(tbn[0], h);\n\tfloat BoH = dot(tbn[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(tbn[0], viewDir);\n\tfloat BoV = dot(tbn[1], viewDir);\n\tfloat ToL = dot(tbn[0], -lightDirNorm);\n\tfloat BoL = dot(tbn[1], -lightDirNorm);\n\tfloat NoV = dot(worldNormal, viewDir);\n\tfloat NoL = dot(worldNormal, -lightDirNorm);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);\n}\n";

	var lightSpecularBlinnPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {\n\tfloat nh = max( dot( h, worldNormal ), 0.0 );\n\tfloat specPow = exp2(gloss * 11.0);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, worldNormal, h);\n}\n";

	var lightSheenPS = "\nfloat sheenD(vec3 normal, vec3 h, float roughness) {\n\tfloat invR = 1.0 / (roughness * roughness);\n\tfloat cos2h = max(dot(normal, h), 0.0);\n\tcos2h *= cos2h;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\n\treturn (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\nfloat sheenV(vec3 normal, vec3 viewDir, vec3 light) {\n\tfloat NoV = max(dot(normal, viewDir), 0.000001);\n\tfloat NoL = max(dot(normal, light), 0.000001);\n\treturn 1.0 / (4.0 * (NoL + NoV - NoL * NoV));\n}\nfloat getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {\n\tfloat D = sheenD(worldNormal, h, sheenGloss);\n\tfloat V = sheenV(worldNormal, viewDir, -lightDirNorm);\n\treturn D * V;\n}\n";

	var linearizeDepthPS = "\n#ifndef LINEARIZE_DEPTH\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z, vec4 cameraParams) {\n\tif (cameraParams.w == 0.0)\n\t\treturn (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));\n\telse\n\t\treturn cameraParams.z + z * (cameraParams.y - cameraParams.z);\n}\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nfloat linearizeDepth(float z) {\n\treturn linearizeDepth(z, camera_params);\n}\n#endif\n";

	var litShaderArgsPS = "\nvec3 litArgs_albedo;\nfloat litArgs_opacity;\nvec3 litArgs_emission;\nvec3 litArgs_worldNormal;\nfloat litArgs_ao;\nvec3 litArgs_lightmap;\nvec3 litArgs_lightmapDir;\nfloat litArgs_metalness;\nvec3 litArgs_specularity;\nfloat litArgs_specularityFactor;\nfloat litArgs_gloss;\nfloat litArgs_sheen_gloss;\nvec3 litArgs_sheen_specularity;\nfloat litArgs_transmission;\nfloat litArgs_thickness;\nfloat litArgs_ior;\nfloat litArgs_dispersion;\nfloat litArgs_iridescence_intensity;\nfloat litArgs_iridescence_thickness;\nvec3 litArgs_clearcoat_worldNormal;\nfloat litArgs_clearcoat_specularity;\nfloat litArgs_clearcoat_gloss;\n";

	var ltcPS = "\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n\tvec3 coord0;\n\tvec3 coord1;\n\tvec3 coord2;\n\tvec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\t\n\tvec3 lightNormal = cross( v1, v2 );\n\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 =  factor * cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tCoords coords;\n\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\treturn coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\tvec3 w = normalize(cross(f, halfHeight));\n\tvec3 h = normalize(cross(f, w));\n\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)\n{\n\tfloat roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n\treturn LTC_Uv( worldNormal, viewDir, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)\n{\n\tvec4 t2 = texture2DLod(areaLightsLutTex2, uv, 0.0);\n\treturn specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;\n}\nvoid calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)\n{\n\tdLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);\n\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); \n#ifdef LIT_CLEARCOAT\n\tccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);\n\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n\tfloat pi = 3.14159;\n\tCoefficient.xyz /= Coefficient.w;\n\tCoefficient.yz /= 3.0;\n\tfloat A = Coefficient.w;\n\tfloat B = Coefficient.z;\n\tfloat C = Coefficient.y;\n\tfloat D = Coefficient.x;\n\tvec3 Delta = vec3(\n\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t);\n\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\tvec3 RootsA, RootsD;\n\tvec2 xlc, xsc;\n\t{\n\t\tfloat A_a = 1.0;\n\t\tfloat C_a = Delta.x;\n\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xl;\n\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\txl = x_1a;\n\t\telse\n\t\t\txl = x_3a;\n\t\txlc = vec2(xl - B, A);\n\t}\n\t{\n\t\tfloat A_d = D;\n\t\tfloat C_d = Delta.z;\n\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xs;\n\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\txs = x_1d;\n\t\telse\n\t\t\txs = x_3d;\n\t\txsc = vec2(-D, xs + C);\n\t}\n\tfloat E =  xlc.y * xsc.y;\n\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\tfloat G =  xlc.x * xsc.x;\n\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\tif (Root.x < Root.y && Root.x < Root.z)\n\t\tRoot.xyz = Root.yxz;\n\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\tRoot.xyz = Root.xzy;\n\treturn Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot(V, N));\n\tT2 = cross(N, T1);\n\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\tvec3 L_[ 3 ];\n\tL_[ 0 ] = R * ( points.coord0 - P );\n\tL_[ 1 ] = R * ( points.coord1 - P );\n\tL_[ 2 ] = R * ( points.coord2 - P );\n\tvec3 Lo_i = vec3(0);\n\tvec3 C  = 0.5 * (L_[0] + L_[2]);\n\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\tC  = Minv * C;\n\tV1 = Minv * V1;\n\tV2 = Minv * V2;\n\tfloat a, b;\n\tfloat d11 = dot(V1, V1);\n\tfloat d22 = dot(V2, V2);\n\tfloat d12 = dot(V1, V2);\n\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t{\n\t\tfloat tr = d11 + d22;\n\t\tfloat det = -d12 * d12 + d11 * d22;\n\t\tdet = sqrt(det);\n\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\tfloat e_max = (u + v) * (u + v);\n\t\tfloat e_min = (u - v) * (u - v);\n\t\tvec3 V1_, V2_;\n\t\tif (d11 > d22)\n\t\t{\n\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t}\n\t\ta = 1.0 / e_max;\n\t\tb = 1.0 / e_min;\n\t\tV1 = normalize(V1_);\n\t\tV2 = normalize(V2_);\n\t}\n\telse\n\t{\n\t\ta = 1.0 / dot(V1, V1);\n\t\tb = 1.0 / dot(V2, V2);\n\t\tV1 *= sqrt(a);\n\t\tV2 *= sqrt(b);\n\t}\n\tvec3 V3 = normalize(cross(V1, V2));\n\tif (dot(C, V3) < 0.0)\n\t\tV3 *= -1.0;\n\tfloat L  = dot(V3, C);\n\tfloat x0 = dot(V1, C) / L;\n\tfloat y0 = dot(V2, C) / L;\n\tfloat E1 = inversesqrt(a);\n\tfloat E2 = inversesqrt(b);\n\ta *= L * L;\n\tb *= L * L;\n\tfloat c0 = a * b;\n\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\tfloat c3 = 1.0;\n\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\tfloat e1 = roots.x;\n\tfloat e2 = roots.y;\n\tfloat e3 = roots.z;\n\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\tmat3 rotate = mat3(V1, V2, V3);\n\tavgDir = rotate * avgDir;\n\tavgDir = normalize(avgDir);\n\tfloat L1 = sqrt(-e2 / e3);\n\tfloat L2 = sqrt(-e2 / e1);\n\tfloat formFactor = max(0.0, L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2)));\n\t\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\tuv = uv*LUT_SCALE + LUT_BIAS;\n\tfloat scale = texture2DLod(areaLightsLutTex2, uv, 0.0).w;\n\treturn formFactor*scale;\n}\nfloat getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\tfloat falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);\n\treturn getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\tvec4 t1 = texture2DLod(areaLightsLutTex1, uv, 0.0);\n\treturn mat3(\n\t\tvec3( t1.x, 0, t1.y ),\n\t\tvec3(\t0, 1,\t0 ),\n\t\tvec3( t1.z, 0, t1.w )\n\t);\n}\nfloat calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcRectLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n";

	var metalnessPS = "\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\nvoid getMetalness() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdMetalness = metalness;\n}\n";

	var msdfPS = "\nuniform sampler2D texture_msdfMap;\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\n#ifdef UNIFORM_TEXT_PARAMETERS\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n#else\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n#endif\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\tfloat smoothingMax = 0.2;\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\t\n\treturn tcolor;\n}\n";

	var metalnessModulatePS = "\nvec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {\n\tvec3 dielectricF0 = f0 * specularity;\n\treturn mix(dielectricF0, albedo, metalness);\n}\nvec3 getAlbedoModulate(in vec3 albedo, in float metalness) {\n\treturn albedo * (1.0 - metalness);\n}\n";

	var msdfVS = "\nattribute vec3 vertex_outlineParameters;\nattribute vec3 vertex_shadowParameters;\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\nvoid unpackMsdfParams() {\n\tvec3 little = mod(vertex_outlineParameters, 256.);\n\tvec3 big = (vertex_outlineParameters - little) / 256.;\n\toutline_color.rb = little.xy / 255.;\n\toutline_color.ga = big.xy / 255.;\n\toutline_thickness = little.z / 255. * 0.2;\n\tlittle = mod(vertex_shadowParameters, 256.);\n\tbig = (vertex_shadowParameters - little) / 256.;\n\tshadow_color.rb = little.xy / 255.;\n\tshadow_color.ga = big.xy / 255.;\n\tshadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;\n}\n";

	var normalVS = "\nmat3 dNormalMatrix;\nvec3 getNormal() {\n\tdNormalMatrix = getNormalMatrix(dModelMatrix);\n\tvec3 localNormal = getLocalNormal(vertex_normal);\n\treturn normalize(dNormalMatrix * localNormal);\n}\n";

	var normalCoreVS = "\nattribute vec3 vertex_normal;\n#ifdef MORPHING_NORMAL\n\t#ifdef MORPHING_INT\n\t\tuniform highp usampler2D morphNormalTex;\n\t#else\n\t\tuniform highp sampler2D morphNormalTex;\n\t#endif\n#endif\nvec3 getLocalNormal(vec3 vertexNormal) {\n\tvec3 localNormal = vertex_normal;\n\t#ifdef MORPHING_NORMAL\n\t\tivec2 morphUV = getTextureMorphCoords();\n\t\t#ifdef MORPHING_INT\n\t\t\tvec3 morphNormal = vec3(texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz) / 65535.0 * 2.0 - 1.0;\n\t\t#else\n\t\t\tvec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;\n\t\t#endif\n\t\tlocalNormal += morphNormal;\n\t#endif\n\treturn localNormal;\n}\n#ifdef SKIN\n\tmat3 getNormalMatrix(mat4 modelMatrix) {\n\t\treturn mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n\t}\n#elif defined(INSTANCING)\n\tmat3 getNormalMatrix(mat4 modelMatrix) {\n\t\treturn mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n\t}\n#else\n\tmat3 getNormalMatrix(mat4 modelMatrix) {\n\t\treturn matrix_normal;\n\t}\n#endif\n";

	var normalDetailMapPS = "\n#ifdef MAPTEXTURE\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn n1 * dot(n1, n2) / n1.z - n2;\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);\n\treturn blendNormals(normalMap, normalDetailMap);\n#else\n\treturn normalMap;\n#endif\n}\n";

	var normalMapPS = "\n#ifdef MAPTEXTURE\nuniform float material_bumpiness;\n#endif\nvoid getNormal() {\n#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n\tdNormalW = normalize(dTBN * addNormalDetail(normalMap));\n#else\n\tdNormalW = dVertexNormalW;\n#endif\n}\n";

	var normalXYPS = "\nvec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n";

	var normalXYZPS = "\nvec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n";

	var opacityPS = "\nuniform float material_opacity;\nvoid getOpacity() {\n\tdAlpha = material_opacity;\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n";

	var opacityDitherPS = "\nuniform vec4 blueNoiseJitter;\n#ifdef DITHER_BLUENOISE\n\tuniform sampler2D blueNoiseTex32;\n#endif\nvoid opacityDither(float alpha, float id) {\n\t#ifdef DITHER_BAYER8\n\t\tfloat noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;\n\t#else\n\t\t#ifdef DITHER_BLUENOISE\n\t\t\tvec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);\n\t\t\tfloat noise = texture2DLod(blueNoiseTex32, uv, 0.0).y;\n\t\t#endif\n\t\t#ifdef DITHER_IGNNOISE\n\t\t\tvec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\t\tfloat noise = fract(magic.z * fract(dot(gl_FragCoord.xy + blueNoiseJitter.xy + id, magic.xy)));\n\t\t#endif\n\t#endif\n\tnoise = pow(noise, 2.2);\n\tif (alpha < noise)\n\t\tdiscard;\n}\n";

	var outputPS = "\n";

	var outputAlphaPS = "\ngl_FragColor.a = litArgs_opacity;\n";

	var outputAlphaOpaquePS = "\n\tgl_FragColor.a = 1.0;\n";

	var outputAlphaPremulPS = "\ngl_FragColor.rgb *= litArgs_opacity;\ngl_FragColor.a = litArgs_opacity;\n";

	var outputTex2DPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n";

	var sheenPS = "\nuniform vec3 material_sheen;\nvoid getSheen() {\n\tvec3 sheenColor = material_sheen;\n\t#ifdef MAPTEXTURE\n\tsheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tsheenColor *= saturate(vVertexColor.$VC);\n\t#endif\n\tsSpecularity = sheenColor;\n}\n";

	var sheenGlossPS = "\nuniform float material_sheenGloss;\nvoid getSheenGlossiness() {\n\tfloat sheenGlossiness = material_sheenGloss;\n\t#ifdef MAPTEXTURE\n\tsheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tsheenGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tsheenGlossiness = 1.0 - sheenGlossiness;\n\t#endif\n\tsheenGlossiness += 0.0000001;\n\tsGlossiness = sheenGlossiness;\n}\n";

	var parallaxPS = "\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";

	var particlePS = "\nvarying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvoid main(void) {\n\tvec4 tex  = texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\n\tvec4 ramp = texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a  = tex.a * ramp.a;\n";

	var particleVS = "\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n";

	var particleAnimFrameClampVS = "\n\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";

	var particleAnimFrameLoopVS = "\n\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";

	var particleAnimTexVS = "\n\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";

	var particleInputFloatPS = "\nvoid readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n";

	var particleInputRgba8PS = "\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";

	var particleOutputFloatPS = "\nvoid writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n";

	var particleOutputRgba8PS = "\nuniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n";

	var particleUpdaterAABBPS = "\nuniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n";

	var particleUpdaterEndPS = "\n\twriteOutput();\n}\n";

	var particleUpdaterInitPS = "\nvarying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix;\nuniform mat3 emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 frameRandom;\nuniform vec3 localVelocityDivMult;\nuniform vec3 velocityDivMult;\nuniform float delta;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float numParticles;\nuniform float rotSpeedDivMult;\nuniform float radialSpeedDivMult;\nuniform float seed;\nuniform float startAngle;\nuniform float startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

	var particleUpdaterNoRespawnPS = "\n\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n";

	var particleUpdaterOnStopPS = "\n\tvisMode = outLife < 0.0? -1.0: visMode;\n";

	var particleUpdaterRespawnPS = "\n\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n";

	var particleUpdaterSpherePS = "\nuniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";

	var particleUpdaterStartPS = "\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(TEXTURE_PASS(internalTex0), vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t  tex1Dlod_lerp(TEXTURE_PASS(internalTex1), vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(TEXTURE_PASS(internalTex3), vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n";

	var particle_billboardVS = "\n\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n";

	var particle_blendAddPS = "\n\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";

	var particle_blendMultiplyPS = "\n\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";

	var particle_blendNormalPS = "\n\tif (a < 0.01) discard;\n";

	var particle_cpuVS = "\nattribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\nattribute vec2 particle_vertexData5;\n#else\nattribute vec4 particle_vertexData5;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\n#ifdef PARTICLE_GPU\n\tuniform highp sampler2D internalTex0;\n\tuniform highp sampler2D internalTex1;\n\tuniform highp sampler2D internalTex2;\n#endif\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n";

	var particle_cpu_endVS = "\n\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

	var particle_customFaceVS = "\n\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n";

	var particle_endPS = "\n\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n";

	var particle_endVS = "\n\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n";

	var particle_halflambertPS = "\n\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n";

	var particle_initVS = "\nattribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles;\nuniform float numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float deltaRandomnessStatic;\nuniform float scaleDivMult;\nuniform float alphaDivMult;\nuniform float seed;\nuniform float delta;\nuniform sampler2D particleTexOUT;\nuniform sampler2D particleTexIN;\n#ifdef PARTICLE_GPU\n\tuniform highp sampler2D internalTex0;\n\tuniform highp sampler2D internalTex1;\n\tuniform highp sampler2D internalTex2;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";

	var particle_lambertPS = "\n\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n";

	var particle_lightingPS = "\n\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n";

	var particle_localShiftVS = "\n\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";

	var particle_meshVS = "\n\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n";

	var particle_normalVS = "\n\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

	var particle_normalMapPS = "\n\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n";

	var particle_pointAlongVS = "\n\tinAngle = atan(velocityV.x, velocityV.y);\n";

	var particle_softPS = "\n\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n";

	var particle_softVS = "\n\tvDepth = getLinearDepth(localPos);\n";

	var particle_stretchVS = "\n\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n";

	var particle_TBNVS = "\n\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";

	var particle_wrapVS = "\n\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n";

	var pickPS = "\nuniform uint meshInstanceId;\nvec4 getPickOutput() {\n\tconst vec4 inv = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tconst uvec4 shifts = uvec4(16, 8, 0, 24);\n\tuvec4 col = (uvec4(meshInstanceId) >> shifts) & uvec4(0xff);\n\treturn vec4(col) * inv;\n}\n";

	var reflDirPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n\tdReflDirW = normalize(-reflect(viewDir, worldNormal));\n}\n";

	var reflDirAnisoPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n\tfloat roughness = sqrt(1.0 - min(gloss, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, viewDir);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-viewDir, bentNormal);\n}\n";

	var reflectionCCPS = "\n#ifdef LIT_CLEARCOAT\nvoid addReflectionCC(vec3 reflDir, float gloss) {\n\tccReflection += calcReflection(reflDir, gloss);\n}\n#endif\n";

	var reflectionCubePS = "\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 lookupVec = cubeMapProject(reflDir);\n\tlookupVec.x *= -1.0;\n\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionEnvHQPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - gloss) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat flevel = level - ilevel;\n\tvec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, dir));\n\tvec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));\n\tvec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\tvec2 dx2 = dFdx(uv2);\n\tvec2 dy2 = dFdy(uv2);\n\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\treturn clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - gloss) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\tfloat ilevel2 = floor(level2);\n\tvec2 uv0, uv1;\n\tfloat weight;\n\tif (ilevel == 0.0) {\n\t\tuv0 = mapShinyUv(uv, ilevel2);\n\t\tuv1 = mapShinyUv(uv, ilevel2 + 1.0);\n\t\tweight = level2 - ilevel2;\n\t} else {\n\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\tweight = 0.0;\n\t}\n\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\tvec3 linear0 = mix(linearA, linearB, weight);\n\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionSpherePS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";

	var reflectionSheenPS = "\nvoid addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {\n\tfloat NoV = dot(worldNormal, viewDir);\n\tfloat alphaG = gloss * gloss;\n\tfloat a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;\n\tfloat b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;\n\tfloat DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );\n\tsReflection += calcReflection(worldNormal, 0.0) * saturate(DG);\n}\n";

	var refractionCubePS = "\nvec3 refract2(vec3 viewVec, vec3 normal, float IOR) {\n\tfloat vn = dot(viewVec, normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;\n\treturn refrVec;\n}\nvoid addRefraction(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tfloat thickness, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 albedo, \n\tfloat transmission,\n\tfloat refractionIndex,\n\tfloat dispersion\n#if defined(LIT_IRIDESCENCE)\n\t, vec3 iridescenceFresnel,\n\tfloat iridescenceIntensity\n#endif \n) {\n\tvec4 tmpRefl = dReflection;\n\tvec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);\n\tdReflection = vec4(0);\n\taddReflection(reflectionDir, gloss);\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);\n\tdReflection = tmpRefl;\n}\n";

	var refractionDynamicPS = "\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\nvec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {\n\tvec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n\tvec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n\tvec2 uv = getGrabScreenPos(projectionPoint);\n\tfloat iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n\tfloat refractionLod = log2(uScreenSize.x) * iorToRoughness;\n\tvec3 refraction = texture2DLod(uSceneColorMap, uv, refractionLod).rgb;\n\treturn refraction;\n}\nvoid addRefraction(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tfloat thickness, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 albedo, \n\tfloat transmission,\n\tfloat refractionIndex,\n\tfloat dispersion\n#if defined(LIT_IRIDESCENCE)\n\t, vec3 iridescenceFresnel,\n\tfloat iridescenceIntensity\n#endif\n) {\n\tvec3 modelScale;\n\tmodelScale.x = length(vec3(matrix_model[0].xyz));\n\tmodelScale.y = length(vec3(matrix_model[1].xyz));\n\tmodelScale.z = length(vec3(matrix_model[2].xyz));\n\tvec3 scale = thickness * modelScale;\n\tvec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;\n\tvec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);\n\t#ifdef DISPERSION\n\t\tfloat halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;\n\t\tfloat refractionIndexR = refractionIndex - halfSpread;\n\t\trefractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;\n\t\trefraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;\n\t\tfloat refractionIndexB = refractionIndex + halfSpread;\n\t\trefractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;\n\t\trefraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;\n\t#endif\n\tvec3 transmittance;\n\tif (material_invAttenuationDistance != 0.0)\n\t{\n\t\tvec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n\t\ttransmittance = exp(-attenuation * length(refractionVector));\n\t}\n\telse\n\t{\n\t\ttransmittance = refraction;\n\t}\n\tvec3 fresnel = vec3(1.0) - \n\t\tgetFresnel(\n\t\t\tdot(viewDir, worldNormal), \n\t\t\tgloss, \n\t\t\tspecularity\n\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t, iridescenceFresnel,\n\t\t\tiridescenceIntensity\n\t\t#endif\n\t\t);\n\tdDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);\n}\n";

	var reprojectPS = "\nvarying vec2 vUv0;\n#ifdef CUBEMAP_SOURCE\n\tuniform samplerCube sourceCube;\n#else\n\tuniform sampler2D sourceTex;\n#endif\n#ifdef USE_SAMPLES_TEX\n\tuniform sampler2D samplesTex;\n\tuniform vec2 samplesTexInverseSize;\n#endif\nuniform vec3 params;\nfloat targetFace() { return params.x; }\nfloat targetTotalPixels() { return params.y; }\nfloat sourceTotalPixels() { return params.z; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n" + decodePS + "\n" + encodePS + "\nvec3 modifySeams(vec3 dir, float scale) {\n\tvec3 adir = abs(dir);\n\tfloat M = max(max(adir.x, adir.y), adir.z);\n\treturn dir / M * vec3(\n\t\tadir.x == M ? 1.0 : scale,\n\t\tadir.y == M ? 1.0 : scale,\n\t\tadir.z == M ? 1.0 : scale\n\t);\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * sin(uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nfloat signNotZero(float k){\n\treturn(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n\treturn vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n\tif (v.y < 0.0) {\n\t\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n\t}\n\treturn normalize(v);\n}\nvec3 getDirectionOctahedral() {\n\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n\tvec2 result = v.xz * (1.0 / l1norm);\n\tif (v.y < 0.0) {\n\t\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n\t}\n\treturn result;\n}\n#ifdef CUBEMAP_SOURCE\n\tvec4 sampleCubemap(vec3 dir) {\n\t\treturn textureCube(sourceCube, modifySeams(dir, 1.0));\n\t}\n\tvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\n\tvec4 sampleCubemap(vec3 dir, float mipLevel) {\n\t\treturn textureCubeLod(sourceCube, modifySeams(dir, 1.0), mipLevel);\n\t}\n\tvec4 sampleCubemap(vec2 sph, float mipLevel) {\n\t\treturn sampleCubemap(fromSpherical(sph), mipLevel);\n\t}\n#else\n\tvec4 sampleEquirect(vec2 sph) {\n\t\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\t\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n\t}\n\tvec4 sampleEquirect(vec3 dir) {\n\t\treturn sampleEquirect(toSpherical(dir));\n\t}\n\tvec4 sampleEquirect(vec2 sph, float mipLevel) {\n\t\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\t\treturn texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n\t}\n\tvec4 sampleEquirect(vec3 dir, float mipLevel) {\n\t\treturn sampleEquirect(toSpherical(dir), mipLevel);\n\t}\n\tvec4 sampleOctahedral(vec3 dir) {\n\t\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\t\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n\t}\n\tvec4 sampleOctahedral(vec2 sph) {\n\t\treturn sampleOctahedral(fromSpherical(sph));\n\t}\n\tvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n\t\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\t\treturn texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n\t}\n\tvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n\t\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\n\t}\n#endif\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(modifySeams(vec, 1.0));\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 x = normalize(cross(up, n));\n\tvec3 y = cross(n, x);\n\treturn mat3(x, y, n);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec3 t = TARGET_FUNC();\n\t\tvec3 tu = dFdx(t);\n\t\tvec3 tv = dFdy(t);\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n\t\t\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(normalize(t +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttu * (u / NUM_SAMPLES_SQRT - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttv * (v / NUM_SAMPLES_SQRT - 0.5))));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n\t}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n#ifdef USE_SAMPLES_TEX\n\tvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n\t\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n\t\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\t\tvec4 raw;\n\t\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\t\tL.xyz = raw.xyz * 2.0 - 1.0;\n\t\tmipLevel = raw.w * 8.0;\n\t}\n\tvec4 prefilterSamples() {\n\t\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\t\tvec3 L;\n\t\tfloat mipLevel;\n\t\tvec3 result = vec3(0.0);\n\t\tfloat totalWeight = 0.0;\n\t\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\t\tunpackSample(i, L, mipLevel);\n\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n\t\t\ttotalWeight += L.z;\n\t\t}\n\t\treturn ENCODE_FUNC(result / totalWeight);\n\t}\n\tvec4 prefilterSamplesUnweighted() {\n\t\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\t\tvec3 L;\n\t\tfloat mipLevel;\n\t\tvec3 result = vec3(0.0);\n\t\tfloat totalWeight = 0.0;\n\t\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\t\tunpackSample(i, L, mipLevel);\n\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n\t\t}\n\t\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n\t}\n#endif\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n";

	var sampleCatmullRomPS = "\nvec4 SampleTextureCatmullRom(TEXTURE_ACCEPT(tex), vec2 uv, vec2 texSize) {\n\tvec2 samplePos = uv * texSize;\n\tvec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\tvec2 f = samplePos - texPos1;\n\tvec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));\n\tvec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);\n\tvec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));\n\tvec2 w3 = f * f * (-0.5 + 0.5 * f);\n\tvec2 w12 = w1 + w2;\n\tvec2 offset12 = w2 / (w1 + w2);\n\tvec2 texPos0 = (texPos1 - 1.0) / texSize;\n\tvec2 texPos3 = (texPos1 + 2.0) / texSize;\n\tvec2 texPos12 = (texPos1 + offset12) / texSize;\n\tvec4 result = vec4(0.0);\n\tresult += texture2DLod(tex, vec2(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;\n\tresult += texture2DLod(tex, vec2(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;\n\tresult += texture2DLod(tex, vec2(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;\n\tresult += texture2DLod(tex, vec2(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;\n\tresult += texture2DLod(tex, vec2(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;\n\tresult += texture2DLod(tex, vec2(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;\n\tresult += texture2DLod(tex, vec2(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;\n\tresult += texture2DLod(tex, vec2(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;\n\tresult += texture2DLod(tex, vec2(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;\n\treturn result;\n}\n";

	var screenDepthPS = "\nuniform highp sampler2D uSceneDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef LINEARIZE_DEPTH\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z) {\n\tif (camera_params.w == 0.0)\n\t\treturn (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));\n\telse\n\t\treturn camera_params.z + z * (camera_params.y - camera_params.z);\n}\n#endif\nfloat delinearizeDepth(float linearDepth) {\n\tif (camera_params.w == 0.0) {\n\t\treturn (camera_params.y * (camera_params.z - linearDepth)) / (linearDepth * (camera_params.z - camera_params.y));\n\t} else {\n\t\treturn (linearDepth - camera_params.z) / (camera_params.y - camera_params.z);\n\t}\n}\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef SCENE_DEPTHMAP_LINEAR\n\t\t#ifdef SCENE_DEPTHMAP_FLOAT\n\t\t\treturn texture2D(uSceneDepthMap, uv).r;\n\t\t#else\n\t\t\tivec2 textureSize = textureSize(uSceneDepthMap, 0);\n\t\t\tivec2 texel = ivec2(uv * vec2(textureSize));\n\t\t\tvec4 data = texelFetch(uSceneDepthMap, texel, 0);\n\t\t\tuint intBits = \n\t\t\t\t(uint(data.r * 255.0) << 24u) |\n\t\t\t\t(uint(data.g * 255.0) << 16u) |\n\t\t\t\t(uint(data.b * 255.0) << 8u) |\n\t\t\t\tuint(data.a * 255.0);\n\t\t\treturn uintBitsToFloat(intBits);\n\t\t#endif\n\t#else\n\t\treturn linearizeDepth(texture2D(uSceneDepthMap, uv).r);\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

	var shadowCascadesPS = "\nint getShadowCascadeIndex(vec4 shadowCascadeDistances, int shadowCascadeCount) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tvec4 comparisons = step(shadowCascadeDistances, vec4(depth));\n\tint cascadeIndex = int(dot(comparisons, vec4(1.0)));\n\treturn min(cascadeIndex, shadowCascadeCount - 1);\n}\nint ditherShadowCascadeIndex(int cascadeIndex, vec4 shadowCascadeDistances, int shadowCascadeCount, float blendFactor) {\n \n\tif (cascadeIndex < shadowCascadeCount - 1) {\n\t\tfloat currentRangeEnd = shadowCascadeDistances[cascadeIndex];\n\t\tfloat transitionStart = blendFactor * currentRangeEnd;\n\t\tfloat depth = 1.0 / gl_FragCoord.w;\n\t\tif (depth > transitionStart) {\n\t\t\tfloat transitionFactor = smoothstep(transitionStart, currentRangeEnd, depth);\n\t\t\tfloat dither = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\t\t\tif (dither < transitionFactor) {\n\t\t\t\tcascadeIndex += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cascadeIndex;\n}\nvoid fadeShadow(vec4 shadowCascadeDistances) {\t\t\t\t  \n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tif (depth > shadowCascadeDistances.w) {\n\t\tdShadowCoord.z = -9999999.0;\n\t}\n}\n";

	var shadowEVSMPS = "\nfloat VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowEVSMnPS = "\nfloat VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";

	var shadowPCSSPS = "\n#define PCSS_SAMPLE_COUNT 16\nuniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];\nuniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];\nvec2 vogelDisk(int sampleIndex, float count, float phi, float r) {\n\tconst float GoldenAngle = 2.4;\n\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\tfloat sine = sin(theta);\n\tfloat cosine = cos(theta);\n\treturn vec2(r * cosine, r * sine);\n}\nvec3 vogelSphere(int sampleIndex, float count, float phi, float r) {\n\tconst float GoldenAngle = 2.4;\n\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\tfloat weight = float(sampleIndex) / count;\n\treturn vec3(cos(theta) * r, weight, sin(theta) * r);\n}\nfloat noise(vec2 screenPos) {\n\tconst float PHI = 1.61803398874989484820459;\n\treturn fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);\n}\nfloat viewSpaceDepth(float depth, mat4 invProjection) {\n\tfloat z = depth * 2.0 - 1.0;\n\tvec4 clipSpace = vec4(0.0, 0.0, z, 1.0);\n\tvec4 viewSpace = invProjection * clipSpace;\n\treturn viewSpace.z;\n}\nfloat PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z, vec4 cameraParams) {\n\tfloat blockers = 0.0;\n\tfloat averageBlocker = 0.0;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tvec2 offset = sampleCoords[i] * searchSize;\n\t\tvec2 sampleUV = shadowCoords + offset;\n\t\tfloat blocker = textureLod(shadowMap, sampleUV, 0.0).r;\n\t\tfloat isBlocking = step(blocker, z);\n\t\tblockers += isBlocking;\n\t\taverageBlocker += blocker * isBlocking;\n\t}\n\tif (blockers > 0.0)\n\t\treturn averageBlocker / blockers;\n\treturn -1.0;\n}\nfloat PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n\tfloat receiverDepth = linearizeDepth(shadowCoords.z, cameraParams);\n\tvec2 samplePoints[PCSS_SAMPLE_COUNT];\n\tfloat noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tfloat pcssPresample = pcssDiskSamples[i];\n\t\tsamplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n\t}\n\tfloat averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth, cameraParams);\n\tif (averageBlocker == -1.0) {\n\t\treturn 1.0;\n\t} else {\n\t\tfloat depthDifference = (receiverDepth - averageBlocker) / 3.0;\n\t\tvec2 filterRadius = depthDifference * shadowSearchArea;\n\t\tfloat shadow = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n\t\t{\n\t\t\tvec2 sampleUV = samplePoints[i] * filterRadius;\n\t\t\tsampleUV = shadowCoords.xy + sampleUV;\n\t\t\tfloat depth = textureLod(shadowMap, sampleUV, 0.0).r;\n\t\t\tshadow += step(receiverDepth, depth);\n\t\t}\n\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t} \n}\nfloat PCSSDirectional(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n\tfloat receiverDepth = linearizeDepth(shadowCoords.z, cameraParams);\n\tvec2 samplePoints[PCSS_SAMPLE_COUNT];\n\tfloat noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tfloat pcssPresample = pcssDiskSamples[i];\n\t\tsamplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n\t}\n\tfloat averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth, cameraParams);\n\tif (averageBlocker == -1.0) {\n\t\treturn 1.0;\n\t} else {\n\t\tfloat depthDifference = saturate((receiverDepth - averageBlocker) / cameraParams.x);\n\t\tvec2 filterRadius = depthDifference * shadowSearchArea;\n\t\tfloat shadow = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n\t\t{\n\t\t\tvec2 sampleUV = samplePoints[i] * filterRadius;\n\t\t\tsampleUV = shadowCoords.xy + sampleUV;\n\t\t#ifdef GL2\n\t\t\tfloat depth = texture(shadowMap, sampleUV).r;\n\t\t#else\n\t\t\tfloat depth = unpackFloat(texture2D(shadowMap, sampleUV));\n\t\t#endif\n\t\t\tshadow += step(receiverDepth, depth);\n\t\t}\n\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t} \n}\nfloat PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {\n\tfloat blockers = 0.0;\n\tfloat averageBlocker = 0.0;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tvec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;\n\t\tsampleDir = normalize(sampleDir);\n\t\tfloat blocker = textureCubeLod(shadowMap, sampleDir, 0.0).r;\n\t\tfloat isBlocking = step(blocker, z);\n\t\tblockers += isBlocking;\n\t\taverageBlocker += blocker * isBlocking;\n\t}\n\tif (blockers > 0.0)\n\t\treturn averageBlocker / blockers;\n\treturn -1.0;\n}\nfloat PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {\n\t\n\tvec3 samplePoints[PCSS_SAMPLE_COUNT];\n\tfloat noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tfloat r = pcssSphereSamples[i];\n\t\tsamplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);\n\t}\n\tfloat receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;\n\tvec3 lightDirNorm = normalize(lightDir);\n\t\n\tfloat averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);\n\tif (averageBlocker == -1.0) {\n\t\treturn 1.0;\n\t} else {\n\t\tfloat filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n\t\tfloat shadow = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++)\n\t\t{\n\t\t\tvec3 offset = samplePoints[i] * filterRadius;\n\t\t\tvec3 sampleDir = lightDirNorm + offset;\n\t\t\tsampleDir = normalize(sampleDir);\n\t\t\tfloat depth = textureCubeLod(shadowMap, sampleDir, 0.0).r;\n\t\t\tshadow += step(receiverDepth, depth);\n\t\t}\n\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t}\n}\nfloat getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);\n}\nfloat getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSSDirectional(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n";

	var shadowSampleCoordPS = "\nvec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\tvec3 surfacePosition = worldPosition;\n#ifdef SHADOW_SAMPLE_POINT\n\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\tfloat distScale = length(lightDir);\n\t\tsurfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\tlightDir = surfacePosition - lightPos;\n\t\treturn lightDir;\n\t#endif\n#else\n\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\tsurfacePosition = surfacePosition + normal * shadowParams.y;\n\t\t#endif\n\t#else\n\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\t\t\tfloat distScale = 1.0;\n\t\t\t#else\n\t\t\t\tfloat distScale = abs(dot(vPositionW - lightPos, lightDirNorm));\n\t\t\t#endif\n\t\t\tsurfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\t#endif\n\t#endif\n\tvec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);\n\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\tpositionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n\t#else\n\t\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t\tpositionInShadowSpace.xyz /= positionInShadowSpace.w;\n\t\t#else\n\t\t\tpositionInShadowSpace.xy /= positionInShadowSpace.w;\n\t\t\tpositionInShadowSpace.z = length(lightDir) * shadowParams.w;\n\t\t#endif\n\t#endif\n\t#ifdef SHADOW_SAMPLE_Z_BIAS\n\t\tpositionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n\tsurfacePosition = positionInShadowSpace.xyz;\n#endif\n\treturn surfacePosition;\n}\n";

	var shadowStandardPS = "\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n\tfloat z = shadowCoord.z;\n\tvec2 uv = shadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn textureShadow(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn textureShadow(shadowMap, shadowCoord);\n}\n#ifndef WEBGPU\nfloat getShadowPointPCF3x3(samplerCubeShadow shadowMap, vec4 shadowParams, vec3 dir) {\n\t\n\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n\tfloat z = 1.0 / float(textureSize(shadowMap, 0));\n\tvec3 tc = normalize(dir);\n\tmediump vec4 shadows;\n\tshadows.x = texture(shadowMap, vec4(tc + vec3( z, z, z), shadowZ));\n\tshadows.y = texture(shadowMap, vec4(tc + vec3(-z,-z, z), shadowZ));\n\tshadows.z = texture(shadowMap, vec4(tc + vec3(-z, z,-z), shadowZ));\n\tshadows.w = texture(shadowMap, vec4(tc + vec3( z,-z,-z), shadowZ));\n\treturn dot(shadows, vec4(0.25));\n}\nfloat getShadowPointPCF1x1(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\treturn texture(shadowMap, vec4(lightDir, shadowZ));\n}\nfloat getShadowPointPCF3x3(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n\treturn getShadowPointPCF3x3(shadowMap, shadowParams, lightDir);\n}\n#endif\n";

	var shadowStandardGL2PS = "\nfloat _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n\tfloat z = shadowCoord.z;\n\tvec2 uv = shadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n";

	var shadowVSM_commonPS = "\nfloat linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n";

	var skinBatchTexVS = "\nattribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n";

	var skinTexVS = "\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat i = float(index);\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\t\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n";

	var skyboxPS = "\n\t#include \"decodePS\"\n\t#include \"gamma\"\n\t#include \"tonemappingPS\"\n\t#include \"envMultiplyPS\"\n\tvarying vec3 vViewDir;\n\tuniform float skyboxHighlightMultiplier;\n\t#ifdef SKY_CUBEMAP\n\t\tuniform samplerCube texture_cubeMap;\n\t\t#ifdef SKYMESH\n\t\t\tvarying vec3 vWorldPos;\n\t\t\tuniform mat3 cubeMapRotationMatrix;\n\t\t\tuniform vec3 projectedSkydomeCenter;\n\t\t#endif\n\t#else\n\t\t#include \"sphericalPS\"\n\t\t#include \"envAtlasPS\"\n\t\tuniform sampler2D texture_envAtlas;\n\t\tuniform float mipLevel;\n\t#endif\n\tvoid main(void) {\n\t\t#ifdef SKY_CUBEMAP\n\t\t\t#ifdef SKYMESH\n\t\t\t\tvec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);\n\t\t\t\tvec3 dir = envDir * cubeMapRotationMatrix;\n\t\t\t#else\n\t\t\t\tvec3 dir = vViewDir;\n\t\t\t#endif\n\t\t\tdir.x *= -1.0;\n\t\t\tvec3 linear = SKYBOX_DECODE_FNC(textureCube(texture_cubeMap, dir));\n\t\t#else\n\t\t\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n\t\t\tvec2 uv = toSphericalUv(normalize(dir));\n\t\t\tvec3 linear = SKYBOX_DECODE_FNC(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\t\t#endif\n\t\tif (any(greaterThanEqual(linear, vec3(64.0)))) {\n\t\t\tlinear *= skyboxHighlightMultiplier;\n\t\t}\n\t\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n\t}\n";

	var skyboxVS = "\nattribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\n#ifdef SKYMESH\n\tuniform mat4 matrix_model;\n\tvarying vec3 vWorldPos;\n#endif\nvoid main(void) {\n\tmat4 view = matrix_view;\n\t#ifdef SKYMESH\n\t\tvec4 worldPos = matrix_model * vec4(aPosition, 1.0);\n\t\tvWorldPos = worldPos.xyz;\n\t\tgl_Position = matrix_projectionSkybox * view * worldPos;\n\t#else\n\t\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\t\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\t\tvViewDir = aPosition * cubeMapRotationMatrix;\n\t#endif\n\tgl_Position.z = gl_Position.w - 1.0e-7;\n}\n";

	var specularPS = "\n#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\nvoid getSpecularity() {\n\tvec3 specularColor = vec3(1,1,1);\n\t#ifdef MAPCOLOR\n\tspecularColor *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tspecularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tspecularColor *= saturate(vVertexColor.$VC);\n\t#endif\n\tdSpecularity = specularColor;\n}\n";

	var sphericalPS = "\nconst float PI = 3.141592653589793;\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n\treturn vec2(uv.x, 1.0 - uv.y);\n}\n";

	var specularityFactorPS = "\n#ifdef MAPFLOAT\nuniform float material_specularityFactor;\n#endif\nvoid getSpecularityFactor() {\n\tfloat specularityFactor = 1.0;\n\t#ifdef MAPFLOAT\n\tspecularityFactor *= material_specularityFactor;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tspecularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tspecularityFactor *= saturate(vVertexColor.$VC);\n\t#endif\n\tdSpecularityFactor = specularityFactor;\n}\n";

	var spotPS = "\nfloat getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {\n\tfloat cosAngle = dot(lightDirNorm, lightSpotDir);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";

	var startPS = "\nvoid main(void) {\n\tdReflection = vec4(0);\n\t#ifdef LIT_CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec3(0);\n\t#endif\n";

	var startVS = "\nvoid main(void) {\n\tgl_Position = getPosition();\n";

	var startNineSlicedPS = "\n\tnineSlicedUv = vUv0;\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";

	var startNineSlicedTiledPS = "\n\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n\t\n";

	var storeEVSMPS = "\nfloat exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n";

	var tangentBinormalVS = "\nvec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n";

	var TBNPS = "\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tdTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));\n}\n";

	var TBNderivativePS = "\nuniform float tbnBasis;\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, normal );\n\tvec3 dp1perp = cross( normal, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat denom = max( dot(T,T), dot(B,B) );\n\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n\tdTBN = mat3(T * invmax, -B * invmax, normal );\n}\n";

	var TBNObjectSpacePS = "\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tvec3 B = cross(normal, vObjectSpaceUpW);\n\tvec3 T = cross(normal, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(normal.x, normal.y), normal.z);\n\t\tif (normal.x == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(0,1,0));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t\telse if (normal.y == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(0,0,1));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t\telse if (normal.z == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(1,0,0));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(normal));\n}\n";

	var thicknessPS = "\n#ifdef MAPFLOAT\nuniform float material_thickness;\n#endif\nvoid getThickness() {\n\tdThickness = 1.0;\n\t#ifdef MAPFLOAT\n\tdThickness *= material_thickness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdThickness *= saturate(vVertexColor.$VC);\n\t#endif\n}\n";

	var tonemappingPS = "\n#if (TONEMAP == NONE)\n\t#include \"tonemappingNonePS\"\n#elif TONEMAP == FILMIC\n\t#include \"tonemappingFilmicPS\"\n#elif TONEMAP == LINEAR\n\t#include \"tonemappingLinearPS\"\n#elif TONEMAP == HEJL\n\t#include \"tonemappingHejlPS\"\n#elif TONEMAP == ACES\n\t#include \"tonemappingAcesPS\"\n#elif TONEMAP == ACES2\n\t#include \"tonemappingAces2PS\"\n#elif TONEMAP == NEUTRAL\n\t#include \"tonemappingNeutralPS\"\n#endif\n";

	var tonemappingAcesPS = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

	var tonemappingAces2PS = "\nuniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,  1.10813, -0.00605,\n\t-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure / 0.6;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n";

	var tonemappingFilmicPS = "\nconst float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n";

	var tonemappingHejlPS = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";

	var tonemappingLinearPS = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n";

	var tonemappingNeutralPS = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tfloat startCompression = 0.8 - 0.04;\n\tfloat desaturation = 0.15;\n\tfloat x = min(color.r, min(color.g, color.b));\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max(color.r, max(color.g, color.b));\n\tif (peak < startCompression) return color;\n\tfloat d = 1. - startCompression;\n\tfloat newPeak = 1. - d * d / (peak + d - startCompression);\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n\treturn mix(color, newPeak * vec3(1, 1, 1), g);\n}\n";

	var tonemappingNonePS = "\nvec3 toneMap(vec3 color) {\n\treturn color;\n}\n";

	var transformVS = "\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\nvec4 evalWorldPosition(vec3 vertexPosition, mat4 modelMatrix) {\n\tvec3 localPos = getLocalPosition(vertexPosition);\n\t#ifdef NINESLICED\n\t\tlocalPos.xz *= outerScale;\n\t\tvec2 positiveUnitOffset = clamp(vertexPosition.xz, vec2(0.0), vec2(1.0));\n\t\tvec2 negativeUnitOffset = clamp(-vertexPosition.xz, vec2(0.0), vec2(1.0));\n\t\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\t\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\t\tlocalPos.xz *= -0.5;\n\t\tlocalPos = localPos.xzy;\n\t#endif\n\tvec4 posW = modelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\t\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\treturn posW;\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec4 posW = evalWorldPosition(vertex_position.xyz, dModelMatrix);\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t\t#ifdef WEBGPU\n\t\tscreenPos.y *= -1.0;\n\t\t#endif\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\tscreenPos.y *= projectionFlipY;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n";

	var transformCoreVS = "\nattribute vec4 vertex_position;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\n#ifdef MORPHING\n\tuniform vec2 morph_tex_params;\n\tattribute uint morph_vertex_id;\n\tivec2 getTextureMorphCoords() {\n\t\tivec2 textureSize = ivec2(morph_tex_params);\n\t\tint morphGridV = int(morph_vertex_id) / textureSize.x;\n\t\tint morphGridU = int(morph_vertex_id) - (morphGridV * textureSize.x);\n\t\t#ifdef WEBGPU\n\t\t\tmorphGridV = textureSize.y - morphGridV - 1;\n\t\t#endif\n\t\treturn ivec2(morphGridU, morphGridV);\n\t}\n\t#ifdef MORPHING_POSITION\n\t\t#ifdef MORPHING_INT\n\t\t\tuniform vec3 aabbSize;\n\t\t\tuniform vec3 aabbMin;\n\t\t\tuniform usampler2D morphPositionTex;\n\t\t#else\n\t\t\tuniform highp sampler2D morphPositionTex;\n\t\t#endif\n\t#endif\n#endif\n#ifdef defined(BATCH)\n\t#include \"skinBatchTexVS\"\n\tmat4 getModelMatrix() {\n\t\treturn getBoneMatrix(vertex_boneIndices);\n\t}\n#elif defined(SKIN)\n\t#include \"skinTexVS\"\n\tmat4 getModelMatrix() {\n\t\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t}\n#elif defined(INSTANCING)\n\t#include \"transformInstancing\"\n#else\n\tmat4 getModelMatrix() {\n\t\treturn matrix_model;\n\t}\n#endif\nvec3 getLocalPosition(vec3 vertexPosition) {\n\tvec3 localPos = vertexPosition;\n\t#ifdef MORPHING_POSITION\n\t\tivec2 morphUV = getTextureMorphCoords();\n\t\t#ifdef MORPHING_INT\n\t\t\tvec3 morphPos = vec3(texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz) / 65535.0 * aabbSize + aabbMin;\n\t\t#else\n\t\t\tvec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;\n\t\t#endif\n\t\tlocalPos += morphPos;\n\t#endif\n\treturn localPos;\n}\n";

	var transformInstancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\nmat4 getModelMatrix() {\n\treturn matrix_model * mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n}\n";

	var transmissionPS = "\n#ifdef MAPFLOAT\nuniform float material_refraction;\n#endif\nvoid getRefraction() {\n\tfloat refraction = 1.0;\n\t#ifdef MAPFLOAT\n\trefraction = material_refraction;\n\t#endif\n\t#ifdef MAPTEXTURE\n\trefraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\trefraction *= saturate(vVertexColor.$VC);\n\t#endif\n\tdTransmission = refraction;\n}\n";

	var twoSidedLightingPS = "\nuniform float twoSidedLightingNegScaleFactor;\nvoid handleTwoSidedLighting() {\n\tdTBN[2] *= gl_FrontFacing ? twoSidedLightingNegScaleFactor : -twoSidedLightingNegScaleFactor;\n}\n";

	var uv0VS = "\n#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n";

	var uv1VS = "\nvec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n";

	var viewDirPS = "\nvoid getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n";

	var viewNormalVS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n";

	var shaderChunks = {
		alphaTestPS: alphaTestPS,
		ambientConstantPS: ambientConstantPS,
		ambientEnvPS: ambientEnvPS,
		ambientSHPS: ambientSHPS,
		aoPS: aoPS,
		aoDetailMapPS: aoDetailMapPS,
		aoDiffuseOccPS: aoDiffuseOccPS,
		aoSpecOccPS: aoSpecOccPS,
		aoSpecOccConstPS: aoSpecOccConstPS,
		aoSpecOccConstSimplePS: aoSpecOccConstSimplePS,
		aoSpecOccSimplePS: aoSpecOccSimplePS,
		basePS: basePS,
		baseVS: baseVS,
		baseNineSlicedPS: baseNineSlicedPS,
		baseNineSlicedVS: baseNineSlicedVS,
		baseNineSlicedTiledPS: baseNineSlicedTiledPS,
		bayerPS: bayerPS,
		blurVSMPS: blurVSMPS,
		clearCoatPS: clearCoatPS,
		clearCoatGlossPS: clearCoatGlossPS,
		clearCoatNormalPS: clearCoatNormalPS,
		clusteredLightCookiesPS: clusteredLightCookiesPS,
		clusteredLightShadowsPS: clusteredLightShadowsPS,
		clusteredLightUtilsPS: clusteredLightUtilsPS,
		clusteredLightPS: clusteredLightPS,
		combinePS: combinePS,
		cookiePS: cookiePS,
		cubeMapProjectBoxPS: cubeMapProjectBoxPS,
		cubeMapProjectNonePS: cubeMapProjectNonePS,
		cubeMapRotatePS: cubeMapRotatePS,
		debugOutputPS: debugOutputPS,
		debugProcessFrontendPS: debugProcessFrontendPS,
		detailModesPS: detailModesPS,
		diffusePS: diffusePS,
		diffuseDetailMapPS: diffuseDetailMapPS,
		decodePS: decodePS,
		emissivePS: emissivePS,
		encodePS: encodePS,
		endPS: endPS,
		endVS: endVS,
		envAtlasPS: envAtlasPS,
		envConstPS: envConstPS,
		envMultiplyPS: envMultiplyPS,
		falloffInvSquaredPS: falloffInvSquaredPS,
		falloffLinearPS: falloffLinearPS,
		floatUnpackingPS: floatUnpackingPS,
		fogExpPS: fogExpPS,
		fogExp2PS: fogExp2PS,
		fogLinearPS: fogLinearPS,
		fogNonePS: fogNonePS,
		fresnelSchlickPS: fresnelSchlickPS,
		fullscreenQuadPS: fullscreenQuadPS,
		fullscreenQuadVS: fullscreenQuadVS,
		gamma1_0PS: gamma1_0PS,
		gamma2_2PS: gamma2_2PS,
		gles3PS: gles3PS,
		gles3VS: gles3VS,
		glossPS: glossPS,
		gsplatCenterVS: gsplatCenterVS,
		gsplatCornerVS: gsplatCornerVS,
		gsplatColorVS: gsplatColorVS,
		gsplatCommonVS: gsplatCommonVS,
		gsplatCompressedDataVS: gsplatCompressedDataVS,
		gsplatCompressedSHVS: gsplatCompressedSHVS,
		gsplatDataVS: gsplatDataVS,
		gsplatOutputVS: gsplatOutputVS,
		gsplatPS: gsplatPS,
		gsplatSHVS: gsplatSHVS,
		gsplatSourceVS: gsplatSourceVS,
		gsplatVS: gsplatVS,
		iridescenceDiffractionPS: iridescenceDiffractionPS,
		iridescencePS: iridescencePS,
		iridescenceThicknessPS: iridescenceThicknessPS,
		iorPS: iorPS,
		lightDiffuseLambertPS: lightDiffuseLambertPS,
		lightDirPointPS: lightDirPointPS,
		lightmapAddPS: lightmapAddPS,
		lightmapDirAddPS: lightmapDirAddPS,
		lightmapDirPS: lightmapDirPS,
		lightmapSinglePS: lightmapSinglePS,
		lightSpecularAnisoGGXPS: lightSpecularAnisoGGXPS,
		lightSpecularBlinnPS: lightSpecularBlinnPS,
		lightSheenPS: lightSheenPS,
		linearizeDepthPS: linearizeDepthPS,
		litShaderArgsPS: litShaderArgsPS,
		ltcPS: ltcPS,
		metalnessPS: metalnessPS,
		metalnessModulatePS: metalnessModulatePS,
		msdfPS: msdfPS,
		msdfVS: msdfVS,
		normalVS: normalVS,
		normalCoreVS: normalCoreVS,
		normalDetailMapPS: normalDetailMapPS,
		normalMapPS: normalMapPS,
		normalXYPS: normalXYPS,
		normalXYZPS: normalXYZPS,
		opacityPS: opacityPS,
		opacityDitherPS: opacityDitherPS,
		outputPS: outputPS,
		outputAlphaPS: outputAlphaPS,
		outputAlphaOpaquePS: outputAlphaOpaquePS,
		outputAlphaPremulPS: outputAlphaPremulPS,
		outputTex2DPS: outputTex2DPS,
		sheenPS: sheenPS,
		sheenGlossPS: sheenGlossPS,
		parallaxPS: parallaxPS,
		particlePS: particlePS,
		particleVS: particleVS,
		particleAnimFrameClampVS: particleAnimFrameClampVS,
		particleAnimFrameLoopVS: particleAnimFrameLoopVS,
		particleAnimTexVS: particleAnimTexVS,
		particleInputFloatPS: particleInputFloatPS,
		particleInputRgba8PS: particleInputRgba8PS,
		particleOutputFloatPS: particleOutputFloatPS,
		particleOutputRgba8PS: particleOutputRgba8PS,
		particleUpdaterAABBPS: particleUpdaterAABBPS,
		particleUpdaterEndPS: particleUpdaterEndPS,
		particleUpdaterInitPS: particleUpdaterInitPS,
		particleUpdaterNoRespawnPS: particleUpdaterNoRespawnPS,
		particleUpdaterOnStopPS: particleUpdaterOnStopPS,
		particleUpdaterRespawnPS: particleUpdaterRespawnPS,
		particleUpdaterSpherePS: particleUpdaterSpherePS,
		particleUpdaterStartPS: particleUpdaterStartPS,
		particle_billboardVS: particle_billboardVS,
		particle_blendAddPS: particle_blendAddPS,
		particle_blendMultiplyPS: particle_blendMultiplyPS,
		particle_blendNormalPS: particle_blendNormalPS,
		particle_cpuVS: particle_cpuVS,
		particle_cpu_endVS: particle_cpu_endVS,
		particle_customFaceVS: particle_customFaceVS,
		particle_endPS: particle_endPS,
		particle_endVS: particle_endVS,
		particle_halflambertPS: particle_halflambertPS,
		particle_initVS: particle_initVS,
		particle_lambertPS: particle_lambertPS,
		particle_lightingPS: particle_lightingPS,
		particle_localShiftVS: particle_localShiftVS,
		particle_meshVS: particle_meshVS,
		particle_normalVS: particle_normalVS,
		particle_normalMapPS: particle_normalMapPS,
		particle_pointAlongVS: particle_pointAlongVS,
		particle_softPS: particle_softPS,
		particle_softVS: particle_softVS,
		particle_stretchVS: particle_stretchVS,
		particle_TBNVS: particle_TBNVS,
		particle_wrapVS: particle_wrapVS,
		pickPS: pickPS,
		reflDirPS: reflDirPS,
		reflDirAnisoPS: reflDirAnisoPS,
		reflectionCCPS: reflectionCCPS,
		reflectionCubePS: reflectionCubePS,
		reflectionEnvHQPS: reflectionEnvHQPS,
		reflectionEnvPS: reflectionEnvPS,
		reflectionSpherePS: reflectionSpherePS,
		reflectionSheenPS: reflectionSheenPS,
		refractionCubePS: refractionCubePS,
		refractionDynamicPS: refractionDynamicPS,
		reprojectPS: reprojectPS,
		sampleCatmullRomPS: sampleCatmullRomPS,
		screenDepthPS: screenDepthPS,
		shadowCascadesPS: shadowCascadesPS,
		shadowEVSMPS: shadowEVSMPS,
		shadowEVSMnPS: shadowEVSMnPS,
		shadowPCSSPS: shadowPCSSPS,
		shadowSampleCoordPS: shadowSampleCoordPS,
		shadowStandardPS: shadowStandardPS,
		shadowStandardGL2PS: shadowStandardGL2PS,
		shadowVSM_commonPS: shadowVSM_commonPS,
		skinBatchTexVS: skinBatchTexVS,
		skinTexVS: skinTexVS,
		skyboxPS: skyboxPS,
		skyboxVS: skyboxVS,
		specularPS: specularPS,
		sphericalPS: sphericalPS,
		specularityFactorPS: specularityFactorPS,
		spotPS: spotPS,
		startPS: startPS,
		startVS: startVS,
		startNineSlicedPS: startNineSlicedPS,
		startNineSlicedTiledPS: startNineSlicedTiledPS,
		storeEVSMPS: storeEVSMPS,
		tangentBinormalVS: tangentBinormalVS,
		TBNPS: TBNPS,
		TBNderivativePS: TBNderivativePS,
		TBNObjectSpacePS: TBNObjectSpacePS,
		thicknessPS: thicknessPS,
		tonemappingPS: tonemappingPS,
		tonemappingAcesPS: tonemappingAcesPS,
		tonemappingAces2PS: tonemappingAces2PS,
		tonemappingFilmicPS: tonemappingFilmicPS,
		tonemappingHejlPS: tonemappingHejlPS,
		tonemappingLinearPS: tonemappingLinearPS,
		tonemappingNeutralPS: tonemappingNeutralPS,
		tonemappingNonePS: tonemappingNonePS,
		transformVS: transformVS,
		transformCoreVS: transformCoreVS,
		transformInstancingVS: transformInstancingVS,
		transmissionPS: transmissionPS,
		twoSidedLightingPS: twoSidedLightingPS,
		uv0VS: uv0VS,
		uv1VS: uv1VS,
		viewDirPS: viewDirPS,
		viewNormalVS: viewNormalVS,
		webgpuPS: webgpuPS,
		webgpuVS: webgpuVS
	};

	var programLibraryDeviceCache = new DeviceCache();
	function getProgramLibrary(device) {
		var library = programLibraryDeviceCache.get(device);
		return library;
	}
	function setProgramLibrary(device, library) {
		programLibraryDeviceCache.get(device, function () {
			return library;
		});
	}

	var ShaderGenerator = function () {
		function ShaderGenerator() {}
		ShaderGenerator.begin = function begin() {
			return 'void main(void)\n{\n';
		};
		ShaderGenerator.end = function end() {
			return '}\n';
		};
		ShaderGenerator.definesHash = function definesHash(defines) {
			var sortedArray = Array.from(defines).sort(function (a, b) {
				return a[0] > b[0] ? 1 : -1;
			});
			return hashCode(JSON.stringify(sortedArray));
		};
		ShaderGenerator.fogCode = function fogCode(value, chunks) {
			if (chunks === void 0) {
				chunks = shaderChunks;
			}
			if (value === 'linear') {
				var _chunks$fogLinearPS;
				return (_chunks$fogLinearPS = chunks.fogLinearPS) != null ? _chunks$fogLinearPS : shaderChunks.fogLinearPS;
			} else if (value === 'exp') {
				var _chunks$fogExpPS;
				return (_chunks$fogExpPS = chunks.fogExpPS) != null ? _chunks$fogExpPS : shaderChunks.fogExpPS;
			} else if (value === 'exp2') {
				var _chunks$fogExp2PS;
				return (_chunks$fogExp2PS = chunks.fogExp2PS) != null ? _chunks$fogExp2PS : shaderChunks.fogExp2PS;
			}
			return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
		};
		ShaderGenerator.gammaCode = function gammaCode(value, chunks) {
			var _chunks$gamma1_0PS;
			if (chunks === void 0) {
				chunks = shaderChunks;
			}
			if (value === GAMMA_SRGB) {
				var _chunks$gamma2_2PS;
				return (_chunks$gamma2_2PS = chunks.gamma2_2PS) != null ? _chunks$gamma2_2PS : shaderChunks.gamma2_2PS;
			}
			return (_chunks$gamma1_0PS = chunks.gamma1_0PS) != null ? _chunks$gamma1_0PS : shaderChunks.gamma1_0PS;
		};
		ShaderGenerator.tonemapCode = function tonemapCode(value, chunks) {
			var _chunks$tonemappingFi, _chunks$tonemappingLi, _chunks$tonemappingHe, _chunks$tonemappingAc, _chunks$tonemappingAc2, _chunks$tonemappingNe, _chunks$tonemapingNon;
			if (chunks === void 0) {
				chunks = shaderChunks;
			}
			switch (value) {
				case TONEMAP_FILMIC:
					return (_chunks$tonemappingFi = chunks.tonemappingFilmicPS) != null ? _chunks$tonemappingFi : shaderChunks.tonemappingFilmicPS;
				case TONEMAP_LINEAR:
					return (_chunks$tonemappingLi = chunks.tonemappingLinearPS) != null ? _chunks$tonemappingLi : shaderChunks.tonemappingLinearPS;
				case TONEMAP_HEJL:
					return (_chunks$tonemappingHe = chunks.tonemappingHejlPS) != null ? _chunks$tonemappingHe : shaderChunks.tonemappingHejlPS;
				case TONEMAP_ACES:
					return (_chunks$tonemappingAc = chunks.tonemappingAcesPS) != null ? _chunks$tonemappingAc : shaderChunks.tonemappingAcesPS;
				case TONEMAP_ACES2:
					return (_chunks$tonemappingAc2 = chunks.tonemappingAces2PS) != null ? _chunks$tonemappingAc2 : shaderChunks.tonemappingAces2PS;
				case TONEMAP_NEUTRAL:
					return (_chunks$tonemappingNe = chunks.tonemappingNeutralPS) != null ? _chunks$tonemappingNe : shaderChunks.tonemappingNeutralPS;
			}
			return (_chunks$tonemapingNon = chunks.tonemapingNonePS) != null ? _chunks$tonemapingNon : shaderChunks.tonemappingNonePS;
		};
		return ShaderGenerator;
	}();

	function createShader(device, vsName, fsName, useTransformFeedback, shaderDefinitionOptions) {
		if (useTransformFeedback === void 0) {
			useTransformFeedback = false;
		}
		if (shaderDefinitionOptions === void 0) {
			shaderDefinitionOptions = {};
		}
		if (typeof useTransformFeedback === 'boolean') {
			shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
		} else if (typeof useTransformFeedback === 'object') {
			shaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);
		}
		return new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {
			name: vsName + "_" + fsName,
			vertexCode: shaderChunks[vsName],
			fragmentCode: shaderChunks[fsName]
		})));
	}
	function createShaderFromCode(device, vsCode, fsCode, uniqueName, attributes, useTransformFeedback, shaderDefinitionOptions) {
		if (useTransformFeedback === void 0) {
			useTransformFeedback = false;
		}
		if (shaderDefinitionOptions === void 0) {
			shaderDefinitionOptions = {};
		}
		if (typeof useTransformFeedback === 'boolean') {
			shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
		} else if (typeof useTransformFeedback === 'object') {
			shaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);
		}
		var programLibrary = getProgramLibrary(device);
		var shader = programLibrary.getCachedShader(uniqueName);
		if (!shader) {
			shader = new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {
				name: uniqueName,
				vertexCode: vsCode,
				fragmentCode: fsCode,
				attributes: attributes
			})));
			programLibrary.setCachedShader(uniqueName, shader);
		}
		return shader;
	}
	var ShaderGeneratorPassThrough = function (_ShaderGenerator) {
		function ShaderGeneratorPassThrough(key, shaderDefinition) {
			var _this;
			_this = _ShaderGenerator.call(this) || this;
			_this.key = key;
			_this.shaderDefinition = shaderDefinition;
			return _this;
		}
		_inheritsLoose(ShaderGeneratorPassThrough, _ShaderGenerator);
		var _proto = ShaderGeneratorPassThrough.prototype;
		_proto.generateKey = function generateKey(options) {
			return this.key;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			return this.shaderDefinition;
		};
		return ShaderGeneratorPassThrough;
	}(ShaderGenerator);
	function processShader(shader, processingOptions) {
		var _shaderDefinition$nam;
		var shaderDefinition = shader.definition;
		var name = (_shaderDefinition$nam = shaderDefinition.name) != null ? _shaderDefinition$nam : 'shader';
		var key = name + "-id-" + shader.id;
		var materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);
		var libraryModuleName = 'shader';
		var library = getProgramLibrary(shader.device);
		library.register(libraryModuleName, materialGenerator);
		var variant = library.getProgram(libraryModuleName, {}, processingOptions);
		if (shader.definition.shaderLanguage === SHADERLANGUAGE_WGSL) {
			variant.meshUniformBufferFormat = shaderDefinition.meshUniformBufferFormat;
			variant.meshBindGroupFormat = shaderDefinition.meshBindGroupFormat;
		}
		library.unregister(libraryModuleName);
		return variant;
	}
	var getMaterialShaderDefines = function getMaterialShaderDefines(material, cameraShaderParams) {
		var defines = new Map(material.defines);
		cameraShaderParams.defines.forEach(function (value, key) {
			return defines.set(key, value);
		});
		return defines;
	};

	var _quadPrimitive = {
		type: PRIMITIVE_TRISTRIP,
		base: 0,
		count: 4,
		indexed: false
	};
	var _tempViewport = new Vec4();
	var _tempScissor = new Vec4();
	var _dynamicBindGroup$1 = new DynamicBindGroup();
	var QuadRender = function () {
		function QuadRender(shader) {
			this.uniformBuffer = void 0;
			this.bindGroup = void 0;
			var device = shader.device;
			this.shader = shader;
			if (device.supportsUniformBuffers) {
				var processingOptions = new ShaderProcessorOptions();
				this.shader = processShader(shader, processingOptions);
				var ubFormat = this.shader.meshUniformBufferFormat;
				if (ubFormat) {
					this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
				}
				var bindGroupFormat = this.shader.meshBindGroupFormat;
				this.bindGroup = new BindGroup(device, bindGroupFormat);
			}
		}
		var _proto = QuadRender.prototype;
		_proto.destroy = function destroy() {
			var _this$uniformBuffer, _this$bindGroup;
			(_this$uniformBuffer = this.uniformBuffer) == null || _this$uniformBuffer.destroy();
			this.uniformBuffer = null;
			(_this$bindGroup = this.bindGroup) == null || _this$bindGroup.destroy();
			this.bindGroup = null;
		};
		_proto.render = function render(viewport, scissor) {
			var device = this.shader.device;
			if (viewport) {
				var _scissor;
				_tempViewport.set(device.vx, device.vy, device.vw, device.vh);
				_tempScissor.set(device.sx, device.sy, device.sw, device.sh);
				scissor = (_scissor = scissor) != null ? _scissor : viewport;
				device.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
				device.setScissor(scissor.x, scissor.y, scissor.z, scissor.w);
			}
			device.setVertexBuffer(device.quadVertexBuffer, 0);
			var shader = this.shader;
			device.setShader(shader);
			if (device.supportsUniformBuffers) {
				device.setBindGroup(BINDGROUP_VIEW, device.emptyBindGroup);
				var bindGroup = this.bindGroup;
				bindGroup.update();
				device.setBindGroup(BINDGROUP_MESH, bindGroup);
				var uniformBuffer = this.uniformBuffer;
				if (uniformBuffer) {
					uniformBuffer.update(_dynamicBindGroup$1);
					device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup$1.bindGroup, _dynamicBindGroup$1.offsets);
				} else {
					device.setBindGroup(BINDGROUP_MESH_UB, device.emptyBindGroup);
				}
			}
			device.draw(_quadPrimitive);
			if (viewport) {
				device.setViewport(_tempViewport.x, _tempViewport.y, _tempViewport.z, _tempViewport.w);
				device.setScissor(_tempScissor.x, _tempScissor.y, _tempScissor.z, _tempScissor.w);
			}
		};
		return QuadRender;
	}();

	var RenderPassQuad = function (_RenderPass) {
		function RenderPassQuad(device, quad, rect, scissorRect) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.quad = quad;
			_this.rect = rect;
			_this.scissorRect = scissorRect;
			return _this;
		}
		_inheritsLoose(RenderPassQuad, _RenderPass);
		var _proto = RenderPassQuad.prototype;
		_proto.execute = function execute() {
			var device = this.device;
			device.setCullMode(CULLFACE_NONE);
			device.setDepthState(DepthState.NODEPTH);
			device.setStencilState(null, null);
			this.quad.render(this.rect, this.scissorRect);
		};
		return RenderPassQuad;
	}(RenderPass);

	var _tempRect = new Vec4();
	function drawQuadWithShader(device, target, shader, rect, scissorRect) {
		var quad = new QuadRender(shader);
		if (!rect) {
			rect = _tempRect;
			rect.x = 0;
			rect.y = 0;
			rect.z = target ? target.width : device.width;
			rect.w = target ? target.height : device.height;
		}
		var renderPass = new RenderPassQuad(device, quad, rect, scissorRect);
		renderPass.init(target);
		renderPass.colorOps.clear = false;
		renderPass.depthStencilOps.clearDepth = false;
		if (device.isWebGPU && target === null && device.samples > 1) {
			renderPass.colorOps.store = true;
		}
		renderPass.render();
		quad.destroy();
	}

	var Batch = function () {
		function Batch(meshInstances, dynamic, batchGroupId) {
			this._aabb = new BoundingBox();
			this.origMeshInstances = void 0;
			this.meshInstance = null;
			this.dynamic = void 0;
			this.batchGroupId = void 0;
			this.origMeshInstances = meshInstances;
			this.dynamic = dynamic;
			this.batchGroupId = batchGroupId;
		}
		var _proto = Batch.prototype;
		_proto.destroy = function destroy(scene, layers) {
			if (this.meshInstance) {
				this.removeFromLayers(scene, layers);
				this.meshInstance.destroy();
				this.meshInstance = null;
			}
		};
		_proto.addToLayers = function addToLayers(scene, layers) {
			for (var i = 0; i < layers.length; i++) {
				var layer = scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.addMeshInstances([this.meshInstance]);
				}
			}
		};
		_proto.removeFromLayers = function removeFromLayers(scene, layers) {
			for (var i = 0; i < layers.length; i++) {
				var layer = scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.removeMeshInstances([this.meshInstance]);
				}
			}
		};
		_proto.updateBoundingBox = function updateBoundingBox() {
			this._aabb.copy(this.origMeshInstances[0].aabb);
			for (var i = 1; i < this.origMeshInstances.length; i++) {
				this._aabb.add(this.origMeshInstances[i].aabb);
			}
			this.meshInstance.aabb = this._aabb;
			this.meshInstance._aabbVer = 0;
		};
		return _createClass(Batch, [{
			key: "model",
			get: function get() {
				return undefined;
			}
		}]);
	}();

	var BatchGroup = function BatchGroup(id, name, dynamic, maxAabbSize, layers) {
		if (layers === void 0) {
			layers = [LAYERID_WORLD];
		}
		this._ui = false;
		this._sprite = false;
		this._obj = {
			model: [],
			element: [],
			sprite: [],
			render: []
		};
		this.id = void 0;
		this.name = void 0;
		this.dynamic = void 0;
		this.maxAabbSize = void 0;
		this.layers = void 0;
		this.id = id;
		this.name = name;
		this.dynamic = dynamic;
		this.maxAabbSize = maxAabbSize;
		this.layers = layers;
	};
	BatchGroup.MODEL = 'model';
	BatchGroup.ELEMENT = 'element';
	BatchGroup.SPRITE = 'sprite';
	BatchGroup.RENDER = 'render';

	var _invMatrix = new Mat4();
	var SkinInstance = function () {
		function SkinInstance(skin) {
			this.bones = void 0;
			this.boneTextureSize = void 0;
			this._dirty = true;
			this._rootBone = null;
			this._skinUpdateIndex = -1;
			this._updateBeforeCull = true;
			if (skin) {
				this.initSkin(skin);
			}
		}
		var _proto = SkinInstance.prototype;
		_proto.init = function init(device, numBones) {
			var numPixels = numBones * 3;
			var width = Math.ceil(Math.sqrt(numPixels));
			width = math.roundUp(width, 3);
			var height = Math.ceil(numPixels / width);
			this.boneTexture = new Texture(device, {
				width: width,
				height: height,
				format: PIXELFORMAT_RGBA32F,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				name: 'skin'
			});
			this.boneTextureSize = [width, height, 1.0 / width, 1.0 / height];
			this.matrixPalette = this.boneTexture.lock({
				mode: TEXTURELOCK_READ
			});
			this.boneTexture.unlock();
		};
		_proto.destroy = function destroy() {
			if (this.boneTexture) {
				this.boneTexture.destroy();
				this.boneTexture = null;
			}
		};
		_proto.resolve = function resolve(rootBone, entity) {
			this.rootBone = rootBone;
			var skin = this.skin;
			var bones = [];
			for (var j = 0; j < skin.boneNames.length; j++) {
				var boneName = skin.boneNames[j];
				var bone = rootBone.findByName(boneName);
				if (!bone) {
					bone = entity;
				}
				bones.push(bone);
			}
			this.bones = bones;
		};
		_proto.initSkin = function initSkin(skin) {
			this.skin = skin;
			this.bones = [];
			var numBones = skin.inverseBindPose.length;
			this.init(skin.device, numBones);
			this.matrices = [];
			for (var i = 0; i < numBones; i++) {
				this.matrices[i] = new Mat4();
			}
		};
		_proto.uploadBones = function uploadBones(device) {
			this.boneTexture.upload();
		};
		_proto._updateMatrices = function _updateMatrices(rootNode, skinUpdateIndex) {
			if (this._skinUpdateIndex !== skinUpdateIndex) {
				this._skinUpdateIndex = skinUpdateIndex;
				_invMatrix.copy(rootNode.getWorldTransform()).invert();
				for (var i = this.bones.length - 1; i >= 0; i--) {
					this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
					this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
				}
			}
		};
		_proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {
			if (this._updateBeforeCull) {
				this._updateMatrices(rootNode, skinUpdateIndex);
			}
		};
		_proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
			this._updateMatrices(rootNode, skinUpdateIndex);
			var mp = this.matrixPalette;
			var count = this.bones.length;
			for (var i = 0; i < count; i++) {
				var pe = this.matrices[i].data;
				var base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}
			this.uploadBones(this.skin.device);
		};
		return _createClass(SkinInstance, [{
			key: "rootBone",
			get: function get() {
				return this._rootBone;
			},
			set: function set(rootBone) {
				this._rootBone = rootBone;
			}
		}]);
	}();

	var SkinBatchInstance = function (_SkinInstance) {
		function SkinBatchInstance(device, nodes, rootNode) {
			var _this;
			_this = _SkinInstance.call(this) || this;
			var numBones = nodes.length;
			_this.init(device, numBones);
			_this.device = device;
			_this.rootNode = rootNode;
			_this.bones = nodes;
			return _this;
		}
		_inheritsLoose(SkinBatchInstance, _SkinInstance);
		var _proto = SkinBatchInstance.prototype;
		_proto.updateMatrices = function updateMatrices(rootNode, skinUpdateIndex) {};
		_proto.updateMatrixPalette = function updateMatrixPalette(rootNode, skinUpdateIndex) {
			var mp = this.matrixPalette;
			var count = this.bones.length;
			for (var i = 0; i < count; i++) {
				var pe = this.bones[i].getWorldTransform().data;
				var base = i * 12;
				mp[base] = pe[0];
				mp[base + 1] = pe[4];
				mp[base + 2] = pe[8];
				mp[base + 3] = pe[12];
				mp[base + 4] = pe[1];
				mp[base + 5] = pe[5];
				mp[base + 6] = pe[9];
				mp[base + 7] = pe[13];
				mp[base + 8] = pe[2];
				mp[base + 9] = pe[6];
				mp[base + 10] = pe[10];
				mp[base + 11] = pe[14];
			}
			this.uploadBones(this.device);
		};
		return SkinBatchInstance;
	}(SkinInstance);

	var id$3 = 0;
	var GeometryData = function () {
		function GeometryData() {
			this.initDefaults();
		}
		var _proto = GeometryData.prototype;
		_proto.initDefaults = function initDefaults() {
			this.recreate = false;
			this.verticesUsage = BUFFER_STATIC;
			this.indicesUsage = BUFFER_STATIC;
			this.maxVertices = 0;
			this.maxIndices = 0;
			this.vertexCount = 0;
			this.indexCount = 0;
			this.vertexStreamsUpdated = false;
			this.indexStreamUpdated = false;
			this.vertexStreamDictionary = {};
			this.indices = null;
		};
		_proto._changeVertexCount = function _changeVertexCount(count, semantic) {
			if (!this.vertexCount) {
				this.vertexCount = count;
			}
		};
		return GeometryData;
	}();
	GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
	GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
	GeometryData.DEFAULT_COMPONENTS_UV = 2;
	GeometryData.DEFAULT_COMPONENTS_COLORS = 4;
	var GeometryVertexStream = function GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize, asInt) {
		this.data = data;
		this.componentCount = componentCount;
		this.dataType = dataType;
		this.dataTypeNormalize = dataTypeNormalize;
		this.asInt = asInt;
	};
	var Mesh = function (_RefCountedObject) {
		function Mesh(graphicsDevice, options) {
			var _this;
			_this = _RefCountedObject.call(this) || this;
			_this.indexBuffer = [null];
			_this.vertexBuffer = null;
			_this.primitive = [{
				type: 0,
				base: 0,
				count: 0
			}];
			_this.skin = null;
			_this.boneAabb = null;
			_this._aabbVer = 0;
			_this._aabb = new BoundingBox();
			_this._geometryData = null;
			_this._morph = null;
			_this._storageIndex = false;
			_this._storageVertex = false;
			_this.id = id$3++;
			_this.device = graphicsDevice;
			_this._storageIndex = (options == null ? void 0 : options.storageIndex) || false;
			_this._storageVertex = (options == null ? void 0 : options.storageVertex) || false;
			return _this;
		}
		_inheritsLoose(Mesh, _RefCountedObject);
		Mesh.fromGeometry = function fromGeometry(graphicsDevice, geometry, options) {
			if (options === void 0) {
				options = {};
			}
			var mesh = new Mesh(graphicsDevice, options);
			var positions = geometry.positions,
				normals = geometry.normals,
				tangents = geometry.tangents,
				colors = geometry.colors,
				uvs = geometry.uvs,
				uvs1 = geometry.uvs1,
				blendIndices = geometry.blendIndices,
				blendWeights = geometry.blendWeights,
				indices = geometry.indices;
			if (positions) {
				mesh.setPositions(positions);
			}
			if (normals) {
				mesh.setNormals(normals);
			}
			if (tangents) {
				mesh.setVertexStream(SEMANTIC_TANGENT, tangents, 4);
			}
			if (colors) {
				mesh.setColors32(colors);
			}
			if (uvs) {
				mesh.setUvs(0, uvs);
			}
			if (uvs1) {
				mesh.setUvs(1, uvs1);
			}
			if (blendIndices) {
				mesh.setVertexStream(SEMANTIC_BLENDINDICES, blendIndices, 4, blendIndices.length / 4, TYPE_UINT8);
			}
			if (blendWeights) {
				mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, blendWeights, 4);
			}
			if (indices) {
				mesh.setIndices(indices);
			}
			mesh.update();
			return mesh;
		};
		var _proto2 = Mesh.prototype;
		_proto2.destroy = function destroy() {
			var morph = this.morph;
			if (morph) {
				this.morph = null;
				if (morph.refCount < 1) {
					morph.destroy();
				}
			}
			if (this.vertexBuffer) {
				this.vertexBuffer.destroy();
				this.vertexBuffer = null;
			}
			for (var j = 0; j < this.indexBuffer.length; j++) {
				this._destroyIndexBuffer(j);
			}
			this.indexBuffer.length = 0;
			this._geometryData = null;
		};
		_proto2._destroyIndexBuffer = function _destroyIndexBuffer(index) {
			if (this.indexBuffer[index]) {
				this.indexBuffer[index].destroy();
				this.indexBuffer[index] = null;
			}
		};
		_proto2._initBoneAabbs = function _initBoneAabbs(morphTargets) {
			this.boneAabb = [];
			this.boneUsed = [];
			var x, y, z;
			var bMax, bMin;
			var boneMin = [];
			var boneMax = [];
			var boneUsed = this.boneUsed;
			var numBones = this.skin.boneNames.length;
			var maxMorphX, maxMorphY, maxMorphZ;
			for (var i = 0; i < numBones; i++) {
				boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
				boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			}
			var iterator = new VertexIterator(this.vertexBuffer);
			var posElement = iterator.element[SEMANTIC_POSITION];
			var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
			var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
			var numVerts = this.vertexBuffer.numVertices;
			for (var j = 0; j < numVerts; j++) {
				for (var k = 0; k < 4; k++) {
					var boneWeight = weightsElement.array[weightsElement.index + k];
					if (boneWeight > 0) {
						var boneIndex = indicesElement.array[indicesElement.index + k];
						boneUsed[boneIndex] = true;
						x = posElement.array[posElement.index];
						y = posElement.array[posElement.index + 1];
						z = posElement.array[posElement.index + 2];
						bMax = boneMax[boneIndex];
						bMin = boneMin[boneIndex];
						if (bMin.x > x) bMin.x = x;
						if (bMin.y > y) bMin.y = y;
						if (bMin.z > z) bMin.z = z;
						if (bMax.x < x) bMax.x = x;
						if (bMax.y < y) bMax.y = y;
						if (bMax.z < z) bMax.z = z;
						if (morphTargets) {
							var minMorphX = maxMorphX = x;
							var minMorphY = maxMorphY = y;
							var minMorphZ = maxMorphZ = z;
							for (var l = 0; l < morphTargets.length; l++) {
								var target = morphTargets[l];
								var dx = target.deltaPositions[j * 3];
								var dy = target.deltaPositions[j * 3 + 1];
								var dz = target.deltaPositions[j * 3 + 2];
								if (dx < 0) {
									minMorphX += dx;
								} else {
									maxMorphX += dx;
								}
								if (dy < 0) {
									minMorphY += dy;
								} else {
									maxMorphY += dy;
								}
								if (dz < 0) {
									minMorphZ += dz;
								} else {
									maxMorphZ += dz;
								}
							}
							if (bMin.x > minMorphX) bMin.x = minMorphX;
							if (bMin.y > minMorphY) bMin.y = minMorphY;
							if (bMin.z > minMorphZ) bMin.z = minMorphZ;
							if (bMax.x < maxMorphX) bMax.x = maxMorphX;
							if (bMax.y < maxMorphY) bMax.y = maxMorphY;
							if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
						}
					}
				}
				iterator.next();
			}
			var positionElement = this.vertexBuffer.getFormat().elements.find(function (e) {
				return e.name === SEMANTIC_POSITION;
			});
			if (positionElement && positionElement.normalize) {
				var func = function () {
					switch (positionElement.dataType) {
						case TYPE_INT8:
							return function (x) {
								return Math.max(x / 127.0, -1.0);
							};
						case TYPE_UINT8:
							return function (x) {
								return x / 255.0;
							};
						case TYPE_INT16:
							return function (x) {
								return Math.max(x / 32767.0, -1.0);
							};
						case TYPE_UINT16:
							return function (x) {
								return x / 65535.0;
							};
						default:
							return function (x) {
								return x;
							};
					}
				}();
				for (var _i = 0; _i < numBones; _i++) {
					if (boneUsed[_i]) {
						var min = boneMin[_i];
						var max = boneMax[_i];
						min.set(func(min.x), func(min.y), func(min.z));
						max.set(func(max.x), func(max.y), func(max.z));
					}
				}
			}
			for (var _i2 = 0; _i2 < numBones; _i2++) {
				var aabb = new BoundingBox();
				aabb.setMinMax(boneMin[_i2], boneMax[_i2]);
				this.boneAabb.push(aabb);
			}
		};
		_proto2._initGeometryData = function _initGeometryData() {
			if (!this._geometryData) {
				this._geometryData = new GeometryData();
				if (this.vertexBuffer) {
					this._geometryData.vertexCount = this.vertexBuffer.numVertices;
					this._geometryData.maxVertices = this.vertexBuffer.numVertices;
				}
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					this._geometryData.indexCount = this.indexBuffer[0].numIndices;
					this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
				}
			}
		};
		_proto2.clear = function clear(verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
			if (maxVertices === void 0) {
				maxVertices = 0;
			}
			if (maxIndices === void 0) {
				maxIndices = 0;
			}
			this._initGeometryData();
			this._geometryData.initDefaults();
			this._geometryData.recreate = true;
			this._geometryData.maxVertices = maxVertices;
			this._geometryData.maxIndices = maxIndices;
			this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
			this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
		};
		_proto2.setVertexStream = function setVertexStream(semantic, data, componentCount, numVertices, dataType, dataTypeNormalize, asInt) {
			if (dataType === void 0) {
				dataType = TYPE_FLOAT32;
			}
			if (dataTypeNormalize === void 0) {
				dataTypeNormalize = false;
			}
			if (asInt === void 0) {
				asInt = false;
			}
			this._initGeometryData();
			var vertexCount = numVertices || data.length / componentCount;
			this._geometryData._changeVertexCount(vertexCount, semantic);
			this._geometryData.vertexStreamsUpdated = true;
			this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize, asInt);
		};
		_proto2.getVertexStream = function getVertexStream(semantic, data) {
			var count = 0;
			var done = false;
			if (this._geometryData) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				if (stream) {
					done = true;
					count = this._geometryData.vertexCount;
					if (ArrayBuffer.isView(data)) {
						data.set(stream.data);
					} else {
						data.length = 0;
						data.push(stream.data);
					}
				}
			}
			if (!done) {
				if (this.vertexBuffer) {
					var iterator = new VertexIterator(this.vertexBuffer);
					count = iterator.readData(semantic, data);
				}
			}
			return count;
		};
		_proto2.setPositions = function setPositions(positions, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION;
			}
			this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setNormals = function setNormals(normals, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL;
			}
			this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setUvs = function setUvs(channel, uvs, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_UV;
			}
			this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setColors = function setColors(colors, componentCount, numVertices) {
			if (componentCount === void 0) {
				componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS;
			}
			this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
		};
		_proto2.setColors32 = function setColors32(colors, numVertices) {
			this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
		};
		_proto2.setIndices = function setIndices(indices, numIndices) {
			this._initGeometryData();
			this._geometryData.indexStreamUpdated = true;
			this._geometryData.indices = indices;
			this._geometryData.indexCount = numIndices || indices.length;
		};
		_proto2.getPositions = function getPositions(positions) {
			return this.getVertexStream(SEMANTIC_POSITION, positions);
		};
		_proto2.getNormals = function getNormals(normals) {
			return this.getVertexStream(SEMANTIC_NORMAL, normals);
		};
		_proto2.getUvs = function getUvs(channel, uvs) {
			return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
		};
		_proto2.getColors = function getColors(colors) {
			return this.getVertexStream(SEMANTIC_COLOR, colors);
		};
		_proto2.getIndices = function getIndices(indices) {
			var count = 0;
			if (this._geometryData && this._geometryData.indices) {
				var streamIndices = this._geometryData.indices;
				count = this._geometryData.indexCount;
				if (ArrayBuffer.isView(indices)) {
					indices.set(streamIndices);
				} else {
					indices.length = 0;
					for (var i = 0, il = streamIndices.length; i < il; i++) {
						indices.push(streamIndices[i]);
					}
				}
			} else {
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					var indexBuffer = this.indexBuffer[0];
					count = indexBuffer.readData(indices);
				}
			}
			return count;
		};
		_proto2.update = function update(primitiveType, updateBoundingBox) {
			if (primitiveType === void 0) {
				primitiveType = PRIMITIVE_TRIANGLES;
			}
			if (updateBoundingBox === void 0) {
				updateBoundingBox = true;
			}
			if (this._geometryData) {
				if (updateBoundingBox) {
					var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];
					if (stream) {
						if (stream.componentCount === 3) {
							this._aabb.compute(stream.data, this._geometryData.vertexCount);
							this._aabbVer++;
						}
					}
				}
				var destroyVB = this._geometryData.recreate;
				if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
					destroyVB = true;
					this._geometryData.maxVertices = this._geometryData.vertexCount;
				}
				if (destroyVB) {
					if (this.vertexBuffer) {
						this.vertexBuffer.destroy();
						this.vertexBuffer = null;
					}
				}
				var destroyIB = this._geometryData.recreate;
				if (this._geometryData.indexCount > this._geometryData.maxIndices) {
					destroyIB = true;
					this._geometryData.maxIndices = this._geometryData.indexCount;
				}
				if (destroyIB) {
					if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
						this.indexBuffer[0].destroy();
						this.indexBuffer[0] = null;
					}
				}
				if (this._geometryData.vertexStreamsUpdated) {
					this._updateVertexBuffer();
				}
				if (this._geometryData.indexStreamUpdated) {
					this._updateIndexBuffer();
				}
				this.primitive[0].type = primitiveType;
				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
					if (this._geometryData.indexStreamUpdated) {
						this.primitive[0].count = this._geometryData.indexCount;
						this.primitive[0].indexed = true;
					}
				} else {
					if (this._geometryData.vertexStreamsUpdated) {
						this.primitive[0].count = this._geometryData.vertexCount;
						this.primitive[0].indexed = false;
					}
				}
				this._geometryData.vertexCount = 0;
				this._geometryData.indexCount = 0;
				this._geometryData.vertexStreamsUpdated = false;
				this._geometryData.indexStreamUpdated = false;
				this._geometryData.recreate = false;
				this.updateRenderStates();
			}
		};
		_proto2._buildVertexFormat = function _buildVertexFormat(vertexCount) {
			var vertexDesc = [];
			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				vertexDesc.push({
					semantic: semantic,
					components: stream.componentCount,
					type: stream.dataType,
					normalize: stream.dataTypeNormalize,
					asInt: stream.asInt
				});
			}
			return new VertexFormat(this.device, vertexDesc, vertexCount);
		};
		_proto2._updateVertexBuffer = function _updateVertexBuffer() {
			if (!this.vertexBuffer) {
				var allocateVertexCount = this._geometryData.maxVertices;
				var format = this._buildVertexFormat(allocateVertexCount);
				this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, {
					usage: this._geometryData.verticesUsage,
					storage: this._storageVertex
				});
			}
			var iterator = new VertexIterator(this.vertexBuffer);
			var numVertices = this._geometryData.vertexCount;
			for (var semantic in this._geometryData.vertexStreamDictionary) {
				var stream = this._geometryData.vertexStreamDictionary[semantic];
				iterator.writeData(semantic, stream.data, numVertices);
				delete this._geometryData.vertexStreamDictionary[semantic];
			}
			iterator.end();
		};
		_proto2._updateIndexBuffer = function _updateIndexBuffer() {
			if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
				var maxVertices = this._geometryData.maxVertices;
				var createFormat = maxVertices > 0xffff || maxVertices === 0 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
				var options = this._storageIndex ? {
					storage: true
				} : undefined;
				this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage, undefined, options);
			}
			var srcIndices = this._geometryData.indices;
			if (srcIndices) {
				var indexBuffer = this.indexBuffer[0];
				indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
				this._geometryData.indices = null;
			}
		};
		_proto2.prepareRenderState = function prepareRenderState(renderStyle) {
			if (renderStyle === RENDERSTYLE_WIREFRAME) {
				this.generateWireframe();
			} else if (renderStyle === RENDERSTYLE_POINTS) {
				this.primitive[RENDERSTYLE_POINTS] = {
					type: PRIMITIVE_POINTS,
					base: 0,
					count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
					indexed: false
				};
			}
		};
		_proto2.updateRenderStates = function updateRenderStates() {
			if (this.primitive[RENDERSTYLE_POINTS]) {
				this.prepareRenderState(RENDERSTYLE_POINTS);
			}
			if (this.primitive[RENDERSTYLE_WIREFRAME]) {
				this.prepareRenderState(RENDERSTYLE_WIREFRAME);
			}
		};
		_proto2.generateWireframe = function generateWireframe() {
			this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);
			var numVertices = this.vertexBuffer.numVertices;
			var lines = [];
			var format;
			if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
				var offsets = [[0, 1], [1, 2], [2, 0]];
				var base = this.primitive[RENDERSTYLE_SOLID].base;
				var count = this.primitive[RENDERSTYLE_SOLID].count;
				var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
				var srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
				var seen = new Set();
				for (var j = base; j < base + count; j += 3) {
					for (var k = 0; k < 3; k++) {
						var i1 = srcIndices[j + offsets[k][0]];
						var i2 = srcIndices[j + offsets[k][1]];
						var hash = i1 > i2 ? i2 * numVertices + i1 : i1 * numVertices + i2;
						if (!seen.has(hash)) {
							seen.add(hash);
							lines.push(i1, i2);
						}
					}
				}
				format = indexBuffer.format;
			} else {
				for (var i = 0; i < numVertices; i += 3) {
					lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
				}
				format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
			}
			var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
			var dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
			dstIndices.set(lines);
			wireBuffer.unlock();
			this.primitive[RENDERSTYLE_WIREFRAME] = {
				type: PRIMITIVE_LINES,
				base: 0,
				count: lines.length,
				indexed: true
			};
			this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
		};
		return _createClass(Mesh, [{
			key: "morph",
			get: function get() {
				return this._morph;
			},
			set: function set(morph) {
				if (morph !== this._morph) {
					if (this._morph) {
						this._morph.decRefCount();
					}
					this._morph = morph;
					if (morph) {
						morph.incRefCount();
					}
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				return this._aabb;
			},
			set: function set(aabb) {
				this._aabb = aabb;
				this._aabbVer++;
			}
		}]);
	}(RefCountedObject);

	var scaleCompensatePosTransform = new Mat4();
	var scaleCompensatePos = new Vec3();
	var scaleCompensateRot = new Quat();
	var scaleCompensateRot2 = new Quat();
	var scaleCompensateScale = new Vec3();
	var scaleCompensateScaleForParent = new Vec3();
	var tmpMat4 = new Mat4();
	var tmpQuat = new Quat();
	var position$1 = new Vec3();
	var invParentWtm$1 = new Mat4();
	var rotation = new Quat();
	var invParentRot = new Quat();
	var matrix = new Mat4();
	var target = new Vec3();
	var up = new Vec3();
	function createTest(attr, value) {
		if (attr instanceof Function) {
			return attr;
		}
		return function (node) {
			var x = node[attr];
			if (x instanceof Function) {
				x = x();
			}
			return x === value;
		};
	}
	function findNode(node, test) {
		if (test(node)) {
			return node;
		}
		var children = node._children;
		var len = children.length;
		for (var i = 0; i < len; ++i) {
			var result = findNode(children[i], test);
			if (result) {
				return result;
			}
		}
		return null;
	}
	var GraphNode = function (_EventHandler) {
		function GraphNode(name) {
			var _this;
			if (name === void 0) {
				name = 'Untitled';
			}
			_this = _EventHandler.call(this) || this;
			_this.name = void 0;
			_this.tags = new Tags(_this);
			_this.localPosition = new Vec3();
			_this.localRotation = new Quat();
			_this.localScale = new Vec3(1, 1, 1);
			_this.localEulerAngles = new Vec3();
			_this.position = new Vec3();
			_this.rotation = new Quat();
			_this.eulerAngles = new Vec3();
			_this._scale = null;
			_this.localTransform = new Mat4();
			_this._dirtyLocal = false;
			_this._aabbVer = 0;
			_this._frozen = false;
			_this.worldTransform = new Mat4();
			_this._dirtyWorld = false;
			_this._worldScaleSign = 0;
			_this._normalMatrix = new Mat3();
			_this._dirtyNormal = true;
			_this._right = null;
			_this._up = null;
			_this._forward = null;
			_this._parent = null;
			_this._children = [];
			_this._graphDepth = 0;
			_this._enabled = true;
			_this._enabledInHierarchy = false;
			_this.scaleCompensation = false;
			_this.name = name;
			return _this;
		}
		_inheritsLoose(GraphNode, _EventHandler);
		var _proto = GraphNode.prototype;
		_proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
			node._onHierarchyStateChanged(enabled);
			var c = node._children;
			for (var i = 0, len = c.length; i < len; i++) {
				if (c[i]._enabled) {
					this._notifyHierarchyStateChanged(c[i], enabled);
				}
			}
		};
		_proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
			this._enabledInHierarchy = enabled;
			if (enabled && !this._frozen) {
				this._unfreezeParentToRoot();
			}
		};
		_proto._cloneInternal = function _cloneInternal(clone) {
			clone.name = this.name;
			var tags = this.tags._list;
			clone.tags.clear();
			for (var i = 0; i < tags.length; i++) {
				clone.tags.add(tags[i]);
			}
			clone.localPosition.copy(this.localPosition);
			clone.localRotation.copy(this.localRotation);
			clone.localScale.copy(this.localScale);
			clone.localEulerAngles.copy(this.localEulerAngles);
			clone.position.copy(this.position);
			clone.rotation.copy(this.rotation);
			clone.eulerAngles.copy(this.eulerAngles);
			clone.localTransform.copy(this.localTransform);
			clone._dirtyLocal = this._dirtyLocal;
			clone.worldTransform.copy(this.worldTransform);
			clone._dirtyWorld = this._dirtyWorld;
			clone._dirtyNormal = this._dirtyNormal;
			clone._aabbVer = this._aabbVer + 1;
			clone._enabled = this._enabled;
			clone.scaleCompensation = this.scaleCompensation;
			clone._enabledInHierarchy = false;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			this._cloneInternal(clone);
			return clone;
		};
		_proto.copy = function copy(source) {
			source._cloneInternal(this);
			return this;
		};
		_proto.destroy = function destroy() {
			this.remove();
			var children = this._children;
			while (children.length) {
				var child = children.pop();
				child._parent = null;
				child.destroy();
			}
			this.fire('destroy', this);
			this.off();
		};
		_proto.find = function find(attr, value) {
			var results = [];
			var test = createTest(attr, value);
			this.forEach(function (node) {
				if (test(node)) {
					results.push(node);
				}
			});
			return results;
		};
		_proto.findOne = function findOne(attr, value) {
			var test = createTest(attr, value);
			return findNode(this, test);
		};
		_proto.findByTag = function findByTag() {
			var query = arguments;
			var results = [];
			var _queryNode = function queryNode(node, checkNode) {
				var _node$tags;
				if (checkNode && (_node$tags = node.tags).has.apply(_node$tags, query)) {
					results.push(node);
				}
				for (var i = 0; i < node._children.length; i++) {
					_queryNode(node._children[i], true);
				}
			};
			_queryNode(this, false);
			return results;
		};
		_proto.findByName = function findByName(name) {
			return this.findOne('name', name);
		};
		_proto.findByPath = function findByPath(path) {
			var parts = Array.isArray(path) ? path : path.split('/');
			var result = this;
			var _loop = function _loop(i) {
					result = result.children.find(function (c) {
						return c.name === parts[i];
					});
					if (!result) {
						return {
							v: null
						};
					}
				},
				_ret;
			for (var i = 0, imax = parts.length; i < imax; ++i) {
				_ret = _loop(i);
				if (_ret) return _ret.v;
			}
			return result;
		};
		_proto.forEach = function forEach(callback, thisArg) {
			callback.call(thisArg, this);
			var children = this._children;
			var len = children.length;
			for (var i = 0; i < len; ++i) {
				children[i].forEach(callback, thisArg);
			}
		};
		_proto.isDescendantOf = function isDescendantOf(node) {
			var parent = this._parent;
			while (parent) {
				if (parent === node) {
					return true;
				}
				parent = parent._parent;
			}
			return false;
		};
		_proto.isAncestorOf = function isAncestorOf(node) {
			return node.isDescendantOf(this);
		};
		_proto.getEulerAngles = function getEulerAngles() {
			this.getWorldTransform().getEulerAngles(this.eulerAngles);
			return this.eulerAngles;
		};
		_proto.getLocalEulerAngles = function getLocalEulerAngles() {
			this.localRotation.getEulerAngles(this.localEulerAngles);
			return this.localEulerAngles;
		};
		_proto.getLocalPosition = function getLocalPosition() {
			return this.localPosition;
		};
		_proto.getLocalRotation = function getLocalRotation() {
			return this.localRotation;
		};
		_proto.getLocalScale = function getLocalScale() {
			return this.localScale;
		};
		_proto.getLocalTransform = function getLocalTransform() {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}
			return this.localTransform;
		};
		_proto.getPosition = function getPosition() {
			this.getWorldTransform().getTranslation(this.position);
			return this.position;
		};
		_proto.getRotation = function getRotation() {
			this.rotation.setFromMat4(this.getWorldTransform());
			return this.rotation;
		};
		_proto.getScale = function getScale() {
			if (!this._scale) {
				this._scale = new Vec3();
			}
			return this.getWorldTransform().getScale(this._scale);
		};
		_proto.getWorldTransform = function getWorldTransform() {
			if (!this._dirtyLocal && !this._dirtyWorld) {
				return this.worldTransform;
			}
			if (this._parent) {
				this._parent.getWorldTransform();
			}
			this._sync();
			return this.worldTransform;
		};
		_proto.remove = function remove() {
			var _this$_parent;
			(_this$_parent = this._parent) == null || _this$_parent.removeChild(this);
		};
		_proto.reparent = function reparent(parent, index) {
			this.remove();
			if (parent) {
				if (index >= 0) {
					parent.insertChild(this, index);
				} else {
					parent.addChild(this);
				}
			}
		};
		_proto.setLocalEulerAngles = function setLocalEulerAngles(x, y, z) {
			this.localRotation.setFromEulerAngles(x, y, z);
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.setLocalPosition = function setLocalPosition(x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.setLocalRotation = function setLocalRotation(x, y, z, w) {
			if (x instanceof Quat) {
				this.localRotation.copy(x);
			} else {
				this.localRotation.set(x, y, z, w);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.setLocalScale = function setLocalScale(x, y, z) {
			if (x instanceof Vec3) {
				this.localScale.copy(x);
			} else {
				this.localScale.set(x, y, z);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto._dirtifyLocal = function _dirtifyLocal() {
			if (!this._dirtyLocal) {
				this._dirtyLocal = true;
				if (!this._dirtyWorld) {
					this._dirtifyWorld();
				}
			}
		};
		_proto._unfreezeParentToRoot = function _unfreezeParentToRoot() {
			var p = this._parent;
			while (p) {
				p._frozen = false;
				p = p._parent;
			}
		};
		_proto._dirtifyWorld = function _dirtifyWorld() {
			if (!this._dirtyWorld) {
				this._unfreezeParentToRoot();
			}
			this._dirtifyWorldInternal();
		};
		_proto._dirtifyWorldInternal = function _dirtifyWorldInternal() {
			if (!this._dirtyWorld) {
				this._frozen = false;
				this._dirtyWorld = true;
				for (var i = 0; i < this._children.length; i++) {
					if (!this._children[i]._dirtyWorld) {
						this._children[i]._dirtifyWorldInternal();
					}
				}
			}
			this._dirtyNormal = true;
			this._worldScaleSign = 0;
			this._aabbVer++;
		};
		_proto.setPosition = function setPosition(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}
			if (this._parent === null) {
				this.localPosition.copy(position$1);
			} else {
				invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
				invParentWtm$1.transformPoint(position$1, this.localPosition);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.setRotation = function setRotation(x, y, z, w) {
			if (x instanceof Quat) {
				rotation.copy(x);
			} else {
				rotation.set(x, y, z, w);
			}
			if (this._parent === null) {
				this.localRotation.copy(rotation);
			} else {
				var parentRot = this._parent.getRotation();
				invParentRot.copy(parentRot).invert();
				this.localRotation.copy(invParentRot).mul(rotation);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.setPositionAndRotation = function setPositionAndRotation(position, rotation) {
			if (this._parent === null) {
				this.localPosition.copy(position);
				this.localRotation.copy(rotation);
			} else {
				var parentWtm = this._parent.getWorldTransform();
				invParentWtm$1.copy(parentWtm).invert();
				invParentWtm$1.transformPoint(position, this.localPosition);
				this.localRotation.setFromMat4(invParentWtm$1).mul(rotation);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.setEulerAngles = function setEulerAngles(x, y, z) {
			this.localRotation.setFromEulerAngles(x, y, z);
			if (this._parent !== null) {
				var parentRot = this._parent.getRotation();
				invParentRot.copy(parentRot).invert();
				this.localRotation.mul2(invParentRot, this.localRotation);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.addChild = function addChild(node) {
			this._prepareInsertChild(node);
			this._children.push(node);
			this._onInsertChild(node);
		};
		_proto.addChildAndSaveTransform = function addChildAndSaveTransform(node) {
			var wPos = node.getPosition();
			var wRot = node.getRotation();
			this._prepareInsertChild(node);
			node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
			node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));
			this._children.push(node);
			this._onInsertChild(node);
		};
		_proto.insertChild = function insertChild(node, index) {
			this._prepareInsertChild(node);
			this._children.splice(index, 0, node);
			this._onInsertChild(node);
		};
		_proto._prepareInsertChild = function _prepareInsertChild(node) {
			node.remove();
		};
		_proto._fireOnHierarchy = function _fireOnHierarchy(name, nameHierarchy, parent) {
			this.fire(name, parent);
			for (var i = 0; i < this._children.length; i++) {
				this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
			}
		};
		_proto._onInsertChild = function _onInsertChild(node) {
			node._parent = this;
			var enabledInHierarchy = node._enabled && this.enabled;
			if (node._enabledInHierarchy !== enabledInHierarchy) {
				node._enabledInHierarchy = enabledInHierarchy;
				node._notifyHierarchyStateChanged(node, enabledInHierarchy);
			}
			node._updateGraphDepth();
			node._dirtifyWorld();
			if (this._frozen) {
				node._unfreezeParentToRoot();
			}
			node._fireOnHierarchy('insert', 'inserthierarchy', this);
			if (this.fire) this.fire('childinsert', node);
		};
		_proto._updateGraphDepth = function _updateGraphDepth() {
			this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
			for (var i = 0, len = this._children.length; i < len; i++) {
				this._children[i]._updateGraphDepth();
			}
		};
		_proto.removeChild = function removeChild(child) {
			var index = this._children.indexOf(child);
			if (index === -1) {
				return;
			}
			this._children.splice(index, 1);
			child._parent = null;
			child._fireOnHierarchy('remove', 'removehierarchy', this);
			this.fire('childremove', child);
		};
		_proto._sync = function _sync() {
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				this._dirtyLocal = false;
			}
			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this.scaleCompensation) {
						var parentWorldScale;
						var parent = this._parent;
						var scale = this.localScale;
						var parentToUseScaleFrom = parent;
						if (parentToUseScaleFrom) {
							while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;
							}
							if (parentToUseScaleFrom) {
								parentToUseScaleFrom = parentToUseScaleFrom._parent;
								if (parentToUseScaleFrom) {
									parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
									scaleCompensateScale.mul2(parentWorldScale, this.localScale);
									scale = scaleCompensateScale;
								}
							}
						}
						scaleCompensateRot2.setFromMat4(parent.worldTransform);
						scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
						var tmatrix = parent.worldTransform;
						if (parent.scaleCompensation) {
							scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
							scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
							tmatrix = scaleCompensatePosTransform;
						}
						tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
						this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
					} else {
						this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
					}
				}
				this._dirtyWorld = false;
			}
		};
		_proto.syncHierarchy = function syncHierarchy() {
			if (!this._enabled) {
				return;
			}
			if (this._frozen) {
				return;
			}
			this._frozen = true;
			if (this._dirtyLocal || this._dirtyWorld) {
				this._sync();
			}
			var children = this._children;
			for (var i = 0, len = children.length; i < len; i++) {
				children[i].syncHierarchy();
			}
		};
		_proto.lookAt = function lookAt(x, y, z, ux, uy, uz) {
			if (ux === void 0) {
				ux = 0;
			}
			if (uy === void 0) {
				uy = 1;
			}
			if (uz === void 0) {
				uz = 0;
			}
			if (x instanceof Vec3) {
				target.copy(x);
				if (y instanceof Vec3) {
					up.copy(y);
				} else {
					up.copy(Vec3.UP);
				}
			} else if (z === undefined) {
				return;
			} else {
				target.set(x, y, z);
				up.set(ux, uy, uz);
			}
			matrix.setLookAt(this.getPosition(), target, up);
			rotation.setFromMat4(matrix);
			this.setRotation(rotation);
		};
		_proto.translate = function translate(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}
			position$1.add(this.getPosition());
			this.setPosition(position$1);
		};
		_proto.translateLocal = function translateLocal(x, y, z) {
			if (x instanceof Vec3) {
				position$1.copy(x);
			} else {
				position$1.set(x, y, z);
			}
			this.localRotation.transformVector(position$1, position$1);
			this.localPosition.add(position$1);
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.rotate = function rotate(x, y, z) {
			rotation.setFromEulerAngles(x, y, z);
			if (this._parent === null) {
				this.localRotation.mul2(rotation, this.localRotation);
			} else {
				var rot = this.getRotation();
				var parentRot = this._parent.getRotation();
				invParentRot.copy(parentRot).invert();
				rotation.mul2(invParentRot, rotation);
				this.localRotation.mul2(rotation, rot);
			}
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto.rotateLocal = function rotateLocal(x, y, z) {
			rotation.setFromEulerAngles(x, y, z);
			this.localRotation.mul(rotation);
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		return _createClass(GraphNode, [{
			key: "right",
			get: function get() {
				if (!this._right) {
					this._right = new Vec3();
				}
				return this.getWorldTransform().getX(this._right).normalize();
			}
		}, {
			key: "up",
			get: function get() {
				if (!this._up) {
					this._up = new Vec3();
				}
				return this.getWorldTransform().getY(this._up).normalize();
			}
		}, {
			key: "forward",
			get: function get() {
				if (!this._forward) {
					this._forward = new Vec3();
				}
				return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
			}
		}, {
			key: "normalMatrix",
			get: function get() {
				var normalMat = this._normalMatrix;
				if (this._dirtyNormal) {
					normalMat.invertMat4(this.getWorldTransform()).transpose();
					this._dirtyNormal = false;
				}
				return normalMat;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled && this._enabledInHierarchy;
			},
			set: function set(enabled) {
				if (this._enabled !== enabled) {
					var _this$_parent2;
					this._enabled = enabled;
					if (enabled && (_this$_parent2 = this._parent) != null && _this$_parent2.enabled || !enabled) {
						this._notifyHierarchyStateChanged(this, enabled);
					}
				}
			}
		}, {
			key: "parent",
			get: function get() {
				return this._parent;
			}
		}, {
			key: "path",
			get: function get() {
				var node = this._parent;
				if (!node) {
					return '';
				}
				var result = this.name;
				while (node && node._parent) {
					result = node.name + "/" + result;
					node = node._parent;
				}
				return result;
			}
		}, {
			key: "root",
			get: function get() {
				var result = this;
				while (result._parent) {
					result = result._parent;
				}
				return result;
			}
		}, {
			key: "children",
			get: function get() {
				return this._children;
			}
		}, {
			key: "graphDepth",
			get: function get() {
				return this._graphDepth;
			}
		}, {
			key: "worldScaleSign",
			get: function get() {
				if (this._worldScaleSign === 0) {
					this._worldScaleSign = this.getWorldTransform().scaleSign;
				}
				return this._worldScaleSign;
			}
		}]);
	}(EventHandler);

	var defaultMaterialDeviceCache = new DeviceCache();
	function getDefaultMaterial(device) {
		var material = defaultMaterialDeviceCache.get(device);
		return material;
	}
	function setDefaultMaterial(device, material) {
		defaultMaterialDeviceCache.get(device, function () {
			return material;
		});
	}

	var RefCountedCache = function () {
		function RefCountedCache() {
			this.cache = new Map();
		}
		var _proto = RefCountedCache.prototype;
		_proto.destroy = function destroy() {
			this.cache.forEach(function (refCount, object) {
				object.destroy();
			});
			this.cache.clear();
		};
		_proto.incRef = function incRef(object) {
			var refCount = (this.cache.get(object) || 0) + 1;
			this.cache.set(object, refCount);
		};
		_proto.decRef = function decRef(object) {
			if (object) {
				var refCount = this.cache.get(object);
				if (refCount) {
					refCount--;
					if (refCount === 0) {
						this.cache.delete(object);
						object.destroy();
					} else {
						this.cache.set(object, refCount);
					}
				}
			}
		};
		return RefCountedCache;
	}();

	var LightmapCache = function () {
		function LightmapCache() {}
		LightmapCache.incRef = function incRef(texture) {
			this.cache.incRef(texture);
		};
		LightmapCache.decRef = function decRef(texture) {
			this.cache.decRef(texture);
		};
		LightmapCache.destroy = function destroy() {
			this.cache.destroy();
		};
		return LightmapCache;
	}();
	LightmapCache.cache = new RefCountedCache();

	var id$2 = 0;
	var _tmpAabb = new BoundingBox();
	var _tempBoneAabb = new BoundingBox();
	var _tempSphere = new BoundingSphere();
	var _meshSet = new Set();
	var lookupHashes = new Uint32Array(4);
	var InstancingData = function () {
		function InstancingData(numObjects) {
			this.vertexBuffer = null;
			this._destroyVertexBuffer = false;
			this.count = numObjects;
		}
		var _proto = InstancingData.prototype;
		_proto.destroy = function destroy() {
			if (this._destroyVertexBuffer) {
				var _this$vertexBuffer;
				(_this$vertexBuffer = this.vertexBuffer) == null || _this$vertexBuffer.destroy();
			}
			this.vertexBuffer = null;
		};
		return InstancingData;
	}();
	var ShaderInstance = function () {
		function ShaderInstance() {
			this.shader = void 0;
			this.bindGroup = null;
			this.uniformBuffer = null;
			this.hashes = void 0;
		}
		var _proto2 = ShaderInstance.prototype;
		_proto2.getBindGroup = function getBindGroup(device) {
			if (!this.bindGroup) {
				var shader = this.shader;
				var bindGroupFormat = shader.meshBindGroupFormat;
				this.bindGroup = new BindGroup(device, bindGroupFormat);
			}
			return this.bindGroup;
		};
		_proto2.getUniformBuffer = function getUniformBuffer(device) {
			if (!this.uniformBuffer) {
				var shader = this.shader;
				var ubFormat = shader.meshUniformBufferFormat;
				this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
			}
			return this.uniformBuffer;
		};
		_proto2.destroy = function destroy() {
			var _this$bindGroup, _this$uniformBuffer;
			(_this$bindGroup = this.bindGroup) == null || _this$bindGroup.destroy();
			this.bindGroup = null;
			(_this$uniformBuffer = this.uniformBuffer) == null || _this$uniformBuffer.destroy();
			this.uniformBuffer = null;
		};
		return ShaderInstance;
	}();
	var MeshInstance = function () {
		function MeshInstance(mesh, material, node) {
			if (node === void 0) {
				node = null;
			}
			this.castShadow = false;
			this.cull = true;
			this.drawOrder = 0;
			this.node = void 0;
			this.visible = true;
			this.visibleThisFrame = false;
			this.flipFacesFactor = 1;
			this.gsplatInstance = null;
			this.id = id$2++;
			this.isVisibleFunc = null;
			this.instancingData = null;
			this.parameters = {};
			this.pick = true;
			this.stencilFront = null;
			this.stencilBack = null;
			this.transparent = false;
			this._aabb = new BoundingBox();
			this._aabbVer = -1;
			this._aabbMeshVer = -1;
			this._customAabb = null;
			this._updateAabb = true;
			this._updateAabbFunc = null;
			this._key = [0, 0];
			this._layer = LAYER_WORLD;
			this._material = null;
			this._skinInstance = null;
			this._morphInstance = null;
			this._receiveShadow = true;
			this._renderStyle = RENDERSTYLE_SOLID;
			this._screenSpace = false;
			this._shaderCache = new Map();
			this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
			this._calculateSortDistance = null;
			this.node = node;
			this._mesh = mesh;
			mesh.incRefCount();
			this.material = material;
			if (mesh.vertexBuffer) {
				var format = mesh.vertexBuffer.format;
				this._shaderDefs |= format.hasUv0 ? SHADERDEF_UV0 : 0;
				this._shaderDefs |= format.hasUv1 ? SHADERDEF_UV1 : 0;
				this._shaderDefs |= format.hasColor ? SHADERDEF_VCOLOR : 0;
				this._shaderDefs |= format.hasTangents ? SHADERDEF_TANGENTS : 0;
			}
			this.updateKey();
		}
		var _proto3 = MeshInstance.prototype;
		_proto3.clearShaders = function clearShaders() {
			this._shaderCache.forEach(function (shaderInstance) {
				shaderInstance.destroy();
			});
			this._shaderCache.clear();
		};
		_proto3.getShaderInstance = function getShaderInstance(shaderPass, lightHash, scene, cameraShaderParams, viewUniformFormat, viewBindGroupFormat, sortedLights) {
			var shaderDefs = this._shaderDefs;
			lookupHashes[0] = shaderPass;
			lookupHashes[1] = lightHash;
			lookupHashes[2] = shaderDefs;
			lookupHashes[3] = cameraShaderParams.hash;
			var hash = hash32Fnv1a(lookupHashes);
			var shaderInstance = this._shaderCache.get(hash);
			if (!shaderInstance) {
				var mat = this._material;
				shaderInstance = new ShaderInstance();
				shaderInstance.shader = mat.variants.get(hash);
				shaderInstance.hashes = new Uint32Array(lookupHashes);
				if (!shaderInstance.shader) {
					var _this$mesh$vertexBuff;
					var shader = mat.getShaderVariant({
						device: this.mesh.device,
						scene: scene,
						objDefs: shaderDefs,
						cameraShaderParams: cameraShaderParams,
						pass: shaderPass,
						sortedLights: sortedLights,
						viewUniformFormat: viewUniformFormat,
						viewBindGroupFormat: viewBindGroupFormat,
						vertexFormat: (_this$mesh$vertexBuff = this.mesh.vertexBuffer) == null ? void 0 : _this$mesh$vertexBuff.format
					});
					mat.variants.set(hash, shader);
					shaderInstance.shader = shader;
				}
				this._shaderCache.set(hash, shaderInstance);
			}
			return shaderInstance;
		};
		_proto3._updateShaderDefs = function _updateShaderDefs(shaderDefs) {
			if (shaderDefs !== this._shaderDefs) {
				this._shaderDefs = shaderDefs;
				this.clearShaders();
			}
		};
		_proto3.destroy = function destroy() {
			var _this$_skinInstance, _this$morphInstance, _this$instancingData;
			var mesh = this.mesh;
			if (mesh) {
				this.mesh = null;
				if (mesh.refCount < 1) {
					mesh.destroy();
				}
			}
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
			this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
			(_this$_skinInstance = this._skinInstance) == null || _this$_skinInstance.destroy();
			this._skinInstance = null;
			(_this$morphInstance = this.morphInstance) == null || _this$morphInstance.destroy();
			this.morphInstance = null;
			this.clearShaders();
			this.material = null;
			(_this$instancingData = this.instancingData) == null || _this$instancingData.destroy();
		};
		MeshInstance._prepareRenderStyleForArray = function _prepareRenderStyleForArray(meshInstances, renderStyle) {
			if (meshInstances) {
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstances[i]._renderStyle = renderStyle;
					var mesh = meshInstances[i].mesh;
					if (!_meshSet.has(mesh)) {
						_meshSet.add(mesh);
						mesh.prepareRenderState(renderStyle);
					}
				}
				_meshSet.clear();
			}
		};
		_proto3._isVisible = function _isVisible(camera) {
			if (this.visible) {
				if (this.isVisibleFunc) {
					return this.isVisibleFunc(camera);
				}
				_tempSphere.center = this.aabb.center;
				_tempSphere.radius = this._aabb.halfExtents.length();
				return camera.frustum.containsSphere(_tempSphere) > 0;
			}
			return false;
		};
		_proto3.updateKey = function updateKey() {
			var material = this.material;
			var blendType = material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType;
			this._key[SORTKEY_FORWARD] = (this.layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (material.id & 0x1ffffff) << 0;
		};
		_proto3.setInstancing = function setInstancing(vertexBuffer, cull) {
			if (cull === void 0) {
				cull = false;
			}
			if (vertexBuffer) {
				this.instancingData = new InstancingData(vertexBuffer.numVertices);
				this.instancingData.vertexBuffer = vertexBuffer;
				vertexBuffer.format.instancing = true;
				this.cull = cull;
			} else {
				this.instancingData = null;
				this.cull = true;
			}
			this._updateShaderDefs(vertexBuffer ? this._shaderDefs | SHADERDEF_INSTANCING : this._shaderDefs & ~SHADERDEF_INSTANCING);
		};
		_proto3.ensureMaterial = function ensureMaterial(device) {
			if (!this.material) {
				this.material = getDefaultMaterial(device);
			}
		};
		_proto3.clearParameters = function clearParameters() {
			this.parameters = {};
		};
		_proto3.getParameters = function getParameters() {
			return this.parameters;
		};
		_proto3.getParameter = function getParameter(name) {
			return this.parameters[name];
		};
		_proto3.setParameter = function setParameter(name, data, passFlags) {
			if (passFlags === void 0) {
				passFlags = 0xFFFFFFFF;
			}
			var param = this.parameters[name];
			if (param) {
				param.data = data;
				param.passFlags = passFlags;
			} else {
				this.parameters[name] = {
					scopeId: null,
					data: data,
					passFlags: passFlags
				};
			}
		};
		_proto3.setRealtimeLightmap = function setRealtimeLightmap(name, texture) {
			var old = this.getParameter(name);
			if (old === texture) {
				return;
			}
			if (old) {
				LightmapCache.decRef(old.data);
			}
			if (texture) {
				LightmapCache.incRef(texture);
				this.setParameter(name, texture);
			} else {
				this.deleteParameter(name);
			}
		};
		_proto3.deleteParameter = function deleteParameter(name) {
			if (this.parameters[name]) {
				delete this.parameters[name];
			}
		};
		_proto3.setParameters = function setParameters(device, passFlag) {
			var parameters = this.parameters;
			for (var paramName in parameters) {
				var parameter = parameters[paramName];
				if (parameter.passFlags & passFlag) {
					if (!parameter.scopeId) {
						parameter.scopeId = device.scope.resolve(paramName);
					}
					parameter.scopeId.setValue(parameter.data);
				}
			}
		};
		_proto3.setLightmapped = function setLightmapped(value) {
			if (value) {
				this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);
			} else {
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
				this._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);
				this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);
			}
		};
		_proto3.setCustomAabb = function setCustomAabb(aabb) {
			if (aabb) {
				if (this._customAabb) {
					this._customAabb.copy(aabb);
				} else {
					this._customAabb = aabb.clone();
				}
			} else {
				this._customAabb = null;
				this._aabbVer = -1;
			}
			this._setupSkinUpdate();
		};
		_proto3._setupSkinUpdate = function _setupSkinUpdate() {
			if (this._skinInstance) {
				this._skinInstance._updateBeforeCull = !this._customAabb;
			}
		};
		return _createClass(MeshInstance, [{
			key: "renderStyle",
			get: function get() {
				return this._renderStyle;
			},
			set: function set(renderStyle) {
				this._renderStyle = renderStyle;
				this.mesh.prepareRenderState(renderStyle);
			}
		}, {
			key: "mesh",
			get: function get() {
				return this._mesh;
			},
			set: function set(mesh) {
				if (mesh === this._mesh) {
					return;
				}
				if (this._mesh) {
					this._mesh.decRefCount();
				}
				this._mesh = mesh;
				if (mesh) {
					mesh.incRefCount();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (!this._updateAabb) {
					return this._aabb;
				}
				if (this._updateAabbFunc) {
					return this._updateAabbFunc(this._aabb);
				}
				var localAabb = this._customAabb;
				var toWorldSpace = !!localAabb;
				if (!localAabb) {
					localAabb = _tmpAabb;
					if (this.skinInstance) {
						if (!this.mesh.boneAabb) {
							var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
							this.mesh._initBoneAabbs(morphTargets);
						}
						var boneUsed = this.mesh.boneUsed;
						var first = true;
						for (var i = 0; i < this.mesh.boneAabb.length; i++) {
							if (boneUsed[i]) {
								_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
								if (first) {
									first = false;
									localAabb.center.copy(_tempBoneAabb.center);
									localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
								} else {
									localAabb.add(_tempBoneAabb);
								}
							}
						}
						toWorldSpace = true;
					} else if (this.node._aabbVer !== this._aabbVer || this.mesh._aabbVer !== this._aabbMeshVer) {
						if (this.mesh) {
							localAabb.center.copy(this.mesh.aabb.center);
							localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
						} else {
							localAabb.center.set(0, 0, 0);
							localAabb.halfExtents.set(0, 0, 0);
						}
						if (this.mesh && this.mesh.morph) {
							var morphAabb = this.mesh.morph.aabb;
							localAabb._expand(morphAabb.getMin(), morphAabb.getMax());
						}
						toWorldSpace = true;
						this._aabbVer = this.node._aabbVer;
						this._aabbMeshVer = this.mesh._aabbVer;
					}
				}
				if (toWorldSpace) {
					this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
				}
				return this._aabb;
			},
			set: function set(aabb) {
				this._aabb = aabb;
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(material) {
				this.clearShaders();
				var prevMat = this._material;
				if (prevMat) {
					prevMat.removeMeshInstanceRef(this);
				}
				this._material = material;
				if (material) {
					material.addMeshInstanceRef(this);
					this.transparent = material.transparent;
					this.updateKey();
				}
			}
		}, {
			key: "layer",
			get: function get() {
				return this._layer;
			},
			set: function set(layer) {
				this._layer = layer;
				this.updateKey();
			}
		}, {
			key: "calculateSortDistance",
			get: function get() {
				return this._calculateSortDistance;
			},
			set: function set(calculateSortDistance) {
				this._calculateSortDistance = calculateSortDistance;
			}
		}, {
			key: "receiveShadow",
			get: function get() {
				return this._receiveShadow;
			},
			set: function set(val) {
				if (this._receiveShadow !== val) {
					this._receiveShadow = val;
					this._updateShaderDefs(val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW);
				}
			}
		}, {
			key: "batching",
			get: function get() {
				return (this._shaderDefs & SHADERDEF_BATCH) !== 0;
			},
			set: function set(val) {
				this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_BATCH : this._shaderDefs & ~SHADERDEF_BATCH);
			}
		}, {
			key: "skinInstance",
			get: function get() {
				return this._skinInstance;
			},
			set: function set(val) {
				this._skinInstance = val;
				this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN);
				this._setupSkinUpdate();
			}
		}, {
			key: "morphInstance",
			get: function get() {
				return this._morphInstance;
			},
			set: function set(val) {
				var _this$_morphInstance;
				(_this$_morphInstance = this._morphInstance) == null || _this$_morphInstance.destroy();
				this._morphInstance = val;
				var shaderDefs = this._shaderDefs;
				shaderDefs = val && val.morph.morphPositions ? shaderDefs | SHADERDEF_MORPH_POSITION : shaderDefs & ~SHADERDEF_MORPH_POSITION;
				shaderDefs = val && val.morph.morphNormals ? shaderDefs | SHADERDEF_MORPH_NORMAL : shaderDefs & ~SHADERDEF_MORPH_NORMAL;
				shaderDefs = val && val.morph.intRenderFormat ? shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED_INT : shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED_INT;
				this._updateShaderDefs(shaderDefs);
			}
		}, {
			key: "screenSpace",
			get: function get() {
				return this._screenSpace;
			},
			set: function set(val) {
				if (this._screenSpace !== val) {
					this._screenSpace = val;
					this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE);
				}
			}
		}, {
			key: "key",
			get: function get() {
				return this._key[SORTKEY_FORWARD];
			},
			set: function set(val) {
				this._key[SORTKEY_FORWARD] = val;
			}
		}, {
			key: "mask",
			get: function get() {
				return this._shaderDefs >> 16;
			},
			set: function set(val) {
				var toggles = this._shaderDefs & 0x0000FFFF;
				this._updateShaderDefs(toggles | val << 16);
			}
		}, {
			key: "instancingCount",
			get: function get() {
				return this.instancingData ? this.instancingData.count : 0;
			},
			set: function set(value) {
				if (this.instancingData) {
					this.instancingData.count = value;
				}
			}
		}]);
	}();
	MeshInstance.lightmapParamNames = ['texture_lightMap', 'texture_dirLightMap'];

	var _triFanIndices = [0, 1, 3, 2, 3, 1];
	var _triStripIndices = [0, 1, 3, 0, 3, 2];
	var mat3 = new Mat3();
	function paramsIdentical(a, b) {
		if (a && !b) return false;
		if (!a && b) return false;
		a = a.data;
		b = b.data;
		if (a === b) return true;
		if (a instanceof Float32Array && b instanceof Float32Array) {
			if (a.length !== b.length) return false;
			for (var i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) return false;
			}
			return true;
		}
		return false;
	}
	function equalParamSets(params1, params2) {
		for (var param in params1) {
			if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) {
				return false;
			}
		}
		for (var _param in params2) {
			if (params2.hasOwnProperty(_param) && !paramsIdentical(params2[_param], params1[_param])) {
				return false;
			}
		}
		return true;
	}
	function getScaleSign(mi) {
		return mi.node.worldTransform.scaleSign;
	}
	var BatchManager = function () {
		function BatchManager(device, root, scene) {
			this.device = device;
			this.rootNode = root;
			this.scene = scene;
			this._init = false;
			this._batchGroups = {};
			this._batchGroupCounter = 0;
			this._batchList = [];
			this._dirtyGroups = [];
		}
		var _proto = BatchManager.prototype;
		_proto.destroy = function destroy() {
			this.device = null;
			this.rootNode = null;
			this.scene = null;
			this._batchGroups = {};
			this._batchList = [];
			this._dirtyGroups = [];
		};
		_proto.addGroup = function addGroup(name, dynamic, maxAabbSize, id, layers) {
			if (id === undefined) {
				id = this._batchGroupCounter;
				this._batchGroupCounter++;
			}
			if (this._batchGroups[id]) {
				return undefined;
			}
			var group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
			this._batchGroups[id] = group;
			return group;
		};
		_proto.removeGroup = function removeGroup(id) {
			if (!this._batchGroups[id]) {
				return;
			}
			var newBatchList = [];
			for (var i = 0; i < this._batchList.length; i++) {
				if (this._batchList[i].batchGroupId === id) {
					this.destroyBatch(this._batchList[i]);
				} else {
					newBatchList.push(this._batchList[i]);
				}
			}
			this._batchList = newBatchList;
			this._removeModelsFromBatchGroup(this.rootNode, id);
			delete this._batchGroups[id];
		};
		_proto.markGroupDirty = function markGroupDirty(id) {
			if (this._dirtyGroups.indexOf(id) < 0) {
				this._dirtyGroups.push(id);
			}
		};
		_proto.getGroupByName = function getGroupByName(name) {
			var groups = this._batchGroups;
			for (var group in groups) {
				if (!groups.hasOwnProperty(group)) continue;
				if (groups[group].name === name) {
					return groups[group];
				}
			}
			return null;
		};
		_proto.getBatches = function getBatches(batchGroupId) {
			var results = [];
			var len = this._batchList.length;
			for (var i = 0; i < len; i++) {
				var batch = this._batchList[i];
				if (batch.batchGroupId === batchGroupId) {
					results.push(batch);
				}
			}
			return results;
		};
		_proto._removeModelsFromBatchGroup = function _removeModelsFromBatchGroup(node, id) {
			if (!node.enabled) return;
			if (node.model && node.model.batchGroupId === id) {
				node.model.batchGroupId = -1;
			}
			if (node.render && node.render.batchGroupId === id) {
				node.render.batchGroupId = -1;
			}
			if (node.element && node.element.batchGroupId === id) {
				node.element.batchGroupId = -1;
			}
			if (node.sprite && node.sprite.batchGroupId === id) {
				node.sprite.batchGroupId = -1;
			}
			for (var i = 0; i < node._children.length; i++) {
				this._removeModelsFromBatchGroup(node._children[i], id);
			}
		};
		_proto.insert = function insert(type, groupId, node) {
			var group = this._batchGroups[groupId];
			if (group) {
				if (group._obj[type].indexOf(node) < 0) {
					group._obj[type].push(node);
					this.markGroupDirty(groupId);
				}
			}
		};
		_proto.remove = function remove(type, groupId, node) {
			var group = this._batchGroups[groupId];
			if (group) {
				var idx = group._obj[type].indexOf(node);
				if (idx >= 0) {
					group._obj[type].splice(idx, 1);
					this.markGroupDirty(groupId);
				}
			}
		};
		_proto._extractRender = function _extractRender(node, arr, group, groupMeshInstances) {
			if (node.render) {
				arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
				node.render.removeFromLayers();
			}
			return arr;
		};
		_proto._extractModel = function _extractModel(node, arr, group, groupMeshInstances) {
			if (node.model && node.model.model) {
				arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
				node.model.removeModelFromLayers();
			}
			return arr;
		};
		_proto._extractElement = function _extractElement(node, arr, group) {
			if (!node.element) return;
			var valid = false;
			if (node.element._text && node.element._text._model.meshInstances.length > 0) {
				arr.push(node.element._text._model.meshInstances[0]);
				node.element.removeModelFromLayers(node.element._text._model);
				valid = true;
			} else if (node.element._image) {
				arr.push(node.element._image._renderable.meshInstance);
				node.element.removeModelFromLayers(node.element._image._renderable.model);
				if (node.element._image._renderable.unmaskMeshInstance) {
					arr.push(node.element._image._renderable.unmaskMeshInstance);
					if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
						node.element._dirtifyMask();
						node.element._onPrerender();
					}
				}
				valid = true;
			}
			if (valid) {
				group._ui = true;
			}
		};
		_proto._collectAndRemoveMeshInstances = function _collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
			for (var g = 0; g < groupIds.length; g++) {
				var id = groupIds[g];
				var group = this._batchGroups[id];
				if (!group) continue;
				var arr = groupMeshInstances[id];
				if (!arr) arr = groupMeshInstances[id] = [];
				for (var m = 0; m < group._obj.model.length; m++) {
					arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
				}
				for (var r = 0; r < group._obj.render.length; r++) {
					arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
				}
				for (var e = 0; e < group._obj.element.length; e++) {
					this._extractElement(group._obj.element[e], arr, group);
				}
				for (var s = 0; s < group._obj.sprite.length; s++) {
					var node = group._obj.sprite[s];
					if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
						arr.push(node.sprite._meshInstance);
						node.sprite.removeModelFromLayers();
						group._sprite = true;
						node.sprite._batchGroup = group;
					}
				}
			}
		};
		_proto.generate = function generate(groupIds) {
			var groupMeshInstances = {};
			if (!groupIds) {
				groupIds = Object.keys(this._batchGroups);
			}
			var newBatchList = [];
			for (var i = 0; i < this._batchList.length; i++) {
				if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
					newBatchList.push(this._batchList[i]);
					continue;
				}
				this.destroyBatch(this._batchList[i]);
			}
			this._batchList = newBatchList;
			this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);
			if (groupIds === this._dirtyGroups) {
				this._dirtyGroups.length = 0;
			} else {
				var newDirtyGroups = [];
				for (var _i = 0; _i < this._dirtyGroups.length; _i++) {
					if (groupIds.indexOf(this._dirtyGroups[_i]) < 0) newDirtyGroups.push(this._dirtyGroups[_i]);
				}
				this._dirtyGroups = newDirtyGroups;
			}
			var group, lists, groupData, batch;
			for (var groupId in groupMeshInstances) {
				if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
				group = groupMeshInstances[groupId];
				groupData = this._batchGroups[groupId];
				if (!groupData) {
					continue;
				}
				lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);
				for (var _i2 = 0; _i2 < lists.length; _i2++) {
					batch = this.create(lists[_i2], groupData.dynamic, parseInt(groupId, 10));
					if (batch) {
						batch.addToLayers(this.scene, groupData.layers);
					}
				}
			}
		};
		_proto.prepare = function prepare(meshInstances, dynamic, maxAabbSize, translucent) {
			if (maxAabbSize === void 0) {
				maxAabbSize = Number.POSITIVE_INFINITY;
			}
			if (meshInstances.length === 0) return [];
			var halfMaxAabbSize = maxAabbSize * 0.5;
			var maxInstanceCount = 1024;
			var maxNumVertices = 0xffffffff;
			var aabb = new BoundingBox();
			var testAabb = new BoundingBox();
			var skipTranslucentAabb = null;
			var sf;
			var lists = [];
			var j = 0;
			if (translucent) {
				meshInstances.sort(function (a, b) {
					return a.drawOrder - b.drawOrder;
				});
			}
			var meshInstancesLeftA = meshInstances;
			var meshInstancesLeftB;
			var skipMesh = translucent ? function (mi) {
				if (skipTranslucentAabb) {
					skipTranslucentAabb.add(mi.aabb);
				} else {
					skipTranslucentAabb = mi.aabb.clone();
				}
				meshInstancesLeftB.push(mi);
			} : function (mi) {
				meshInstancesLeftB.push(mi);
			};
			while (meshInstancesLeftA.length > 0) {
				lists[j] = [meshInstancesLeftA[0]];
				meshInstancesLeftB = [];
				var material = meshInstancesLeftA[0].material;
				var layer = meshInstancesLeftA[0].layer;
				var defs = meshInstancesLeftA[0]._shaderDefs;
				var params = meshInstancesLeftA[0].parameters;
				var stencil = meshInstancesLeftA[0].stencilFront;
				var vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
				var drawOrder = meshInstancesLeftA[0].drawOrder;
				aabb.copy(meshInstancesLeftA[0].aabb);
				var scaleSign = getScaleSign(meshInstancesLeftA[0]);
				var vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
				var indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
				skipTranslucentAabb = null;
				for (var i = 1; i < meshInstancesLeftA.length; i++) {
					var mi = meshInstancesLeftA[i];
					if (dynamic && lists[j].length >= maxInstanceCount) {
						meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
						break;
					}
					if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
						skipMesh(mi);
						continue;
					}
					testAabb.copy(aabb);
					testAabb.add(mi.aabb);
					if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
						skipMesh(mi);
						continue;
					}
					if (stencil) {
						if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
							skipMesh(mi);
							continue;
						}
					}
					if (scaleSign !== getScaleSign(mi)) {
						skipMesh(mi);
						continue;
					}
					if (!equalParamSets(params, mi.parameters)) {
						skipMesh(mi);
						continue;
					}
					if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
						skipMesh(mi);
						continue;
					}
					aabb.add(mi.aabb);
					vertCount += mi.mesh.vertexBuffer.getNumVertices();
					lists[j].push(mi);
				}
				j++;
				meshInstancesLeftA = meshInstancesLeftB;
			}
			return lists;
		};
		_proto.collectBatchedMeshData = function collectBatchedMeshData(meshInstances, dynamic) {
			var streams = null;
			var batchNumVerts = 0;
			var batchNumIndices = 0;
			var material = null;
			for (var i = 0; i < meshInstances.length; i++) {
				if (meshInstances[i].visible) {
					var mesh = meshInstances[i].mesh;
					var numVerts = mesh.vertexBuffer.numVertices;
					batchNumVerts += numVerts;
					if (mesh.primitive[0].indexed) {
						batchNumIndices += mesh.primitive[0].count;
					} else {
						var primitiveType = mesh.primitive[0].type;
						if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
							if (mesh.primitive[0].count === 4) {
								batchNumIndices += 6;
							}
						}
					}
					if (!streams) {
						material = meshInstances[i].material;
						streams = {};
						var elems = mesh.vertexBuffer.format.elements;
						for (var j = 0; j < elems.length; j++) {
							var semantic = elems[j].name;
							streams[semantic] = {
								numComponents: elems[j].numComponents,
								dataType: elems[j].dataType,
								normalize: elems[j].normalize,
								count: 0
							};
						}
						if (dynamic) {
							streams[SEMANTIC_BLENDINDICES] = {
								numComponents: 1,
								dataType: TYPE_FLOAT32,
								normalize: false,
								count: 0
							};
						}
					}
				}
			}
			return {
				streams: streams,
				batchNumVerts: batchNumVerts,
				batchNumIndices: batchNumIndices,
				material: material
			};
		};
		_proto.create = function create(meshInstances, dynamic, batchGroupId) {
			if (!this._init) {
				this.vertexFormats = {};
				this._init = true;
			}
			var stream = null;
			var semantic;
			var mesh, numVerts;
			var batch = null;
			var batchData = this.collectBatchedMeshData(meshInstances, dynamic);
			if (batchData.streams) {
				var streams = batchData.streams;
				var material = batchData.material;
				var batchNumVerts = batchData.batchNumVerts;
				var batchNumIndices = batchData.batchNumIndices;
				batch = new Batch(meshInstances, dynamic, batchGroupId);
				this._batchList.push(batch);
				var indexBase, numIndices, indexData;
				var verticesOffset = 0;
				var indexOffset = 0;
				var transform;
				var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
				var indices = new indexArrayType(batchNumIndices);
				for (semantic in streams) {
					stream = streams[semantic];
					stream.typeArrayType = typedArrayTypes[stream.dataType];
					stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
					stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
				}
				for (var i = 0; i < meshInstances.length; i++) {
					if (!meshInstances[i].visible) {
						continue;
					}
					mesh = meshInstances[i].mesh;
					numVerts = mesh.vertexBuffer.numVertices;
					if (!dynamic) {
						transform = meshInstances[i].node.getWorldTransform();
					}
					for (semantic in streams) {
						if (semantic !== SEMANTIC_BLENDINDICES) {
							stream = streams[semantic];
							var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
							var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
							stream.count += totalComponents;
							if (!dynamic && stream.numComponents >= 3) {
								if (semantic === SEMANTIC_POSITION) {
									var m = transform.data;
									var m0 = m[0];
									var m1 = m[1];
									var m2 = m[2];
									var m4 = m[4];
									var m5 = m[5];
									var m6 = m[6];
									var m8 = m[8];
									var m9 = m[9];
									var m10 = m[10];
									var m12 = m[12];
									var m13 = m[13];
									var m14 = m[14];
									var x = void 0,
										y = void 0,
										z = void 0;
									for (var j = 0; j < totalComponents; j += stream.numComponents) {
										x = subarray[j];
										y = subarray[j + 1];
										z = subarray[j + 2];
										subarray[j] = x * m0 + y * m4 + z * m8 + m12;
										subarray[j + 1] = x * m1 + y * m5 + z * m9 + m13;
										subarray[j + 2] = x * m2 + y * m6 + z * m10 + m14;
									}
								} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
									mat3.invertMat4(transform).transpose();
									var _mat3$data = mat3.data,
										_m = _mat3$data[0],
										_m2 = _mat3$data[1],
										_m3 = _mat3$data[2],
										m3 = _mat3$data[3],
										_m4 = _mat3$data[4],
										_m5 = _mat3$data[5],
										_m6 = _mat3$data[6],
										m7 = _mat3$data[7],
										_m7 = _mat3$data[8];
									var _x = void 0,
										_y = void 0,
										_z = void 0;
									for (var _j = 0; _j < totalComponents; _j += stream.numComponents) {
										_x = subarray[_j];
										_y = subarray[_j + 1];
										_z = subarray[_j + 2];
										subarray[_j] = _x * _m + _y * m3 + _z * _m6;
										subarray[_j + 1] = _x * _m2 + _y * _m4 + _z * m7;
										subarray[_j + 2] = _x * _m3 + _y * _m5 + _z * _m7;
									}
								}
							}
						}
					}
					if (dynamic) {
						stream = streams[SEMANTIC_BLENDINDICES];
						for (var _j2 = 0; _j2 < numVerts; _j2++) {
							stream.buffer[stream.count++] = i;
						}
					}
					if (mesh.primitive[0].indexed) {
						indexBase = mesh.primitive[0].base;
						numIndices = mesh.primitive[0].count;
						var srcFormat = mesh.indexBuffer[0].getFormat();
						indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
					} else {
						var primitiveType = mesh.primitive[0].type;
						if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
							if (mesh.primitive[0].count === 4) {
								indexBase = 0;
								numIndices = 6;
								indexData = primitiveType === PRIMITIVE_TRIFAN ? _triFanIndices : _triStripIndices;
							} else {
								numIndices = 0;
								continue;
							}
						}
					}
					for (var _j3 = 0; _j3 < numIndices; _j3++) {
						indices[_j3 + indexOffset] = indexData[indexBase + _j3] + verticesOffset;
					}
					indexOffset += numIndices;
					verticesOffset += numVerts;
				}
				mesh = new Mesh(this.device);
				for (semantic in streams) {
					stream = streams[semantic];
					mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
				}
				if (indices.length > 0) {
					mesh.setIndices(indices);
				}
				mesh.update(PRIMITIVE_TRIANGLES, false);
				if (dynamic) {
					material = material.clone();
					material.update();
				}
				var meshInstance = new MeshInstance(mesh, material, this.rootNode);
				meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
				meshInstance.parameters = batch.origMeshInstances[0].parameters;
				meshInstance.layer = batch.origMeshInstances[0].layer;
				meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
				meshInstance.batching = true;
				meshInstance.cull = batch.origMeshInstances[0].cull;
				var batchGroup = this._batchGroups[batchGroupId];
				if (batchGroup && batchGroup._ui) {
					meshInstance.cull = false;
				}
				if (dynamic) {
					var nodes = [];
					for (var _i3 = 0; _i3 < batch.origMeshInstances.length; _i3++) {
						nodes.push(batch.origMeshInstances[_i3].node);
					}
					meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
				}
				meshInstance._updateAabb = false;
				meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
				meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
				meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
				meshInstance.flipFacesFactor = getScaleSign(batch.origMeshInstances[0]);
				meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
				batch.meshInstance = meshInstance;
				batch.updateBoundingBox();
			}
			return batch;
		};
		_proto.updateAll = function updateAll() {
			if (this._dirtyGroups.length > 0) {
				this.generate(this._dirtyGroups);
			}
			for (var i = 0; i < this._batchList.length; i++) {
				if (!this._batchList[i].dynamic) continue;
				this._batchList[i].updateBoundingBox();
			}
		};
		_proto.clone = function clone(batch, clonedMeshInstances) {
			var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
			this._batchList.push(batch2);
			var nodes = [];
			for (var i = 0; i < clonedMeshInstances.length; i++) {
				nodes.push(clonedMeshInstances[i].node);
			}
			batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
			batch2.meshInstance._updateAabb = false;
			batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
			batch2.meshInstance.cull = clonedMeshInstances[0].cull;
			batch2.meshInstance.layer = clonedMeshInstances[0].layer;
			if (batch.dynamic) {
				batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
			}
			batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
			return batch2;
		};
		_proto.destroyBatch = function destroyBatch(batch) {
			batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
		};
		return BatchManager;
	}();

	var _colorUniformName = 'uSceneColorMap';
	var RenderPassColorGrab = function (_RenderPass) {
		function RenderPassColorGrab() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
			_this.colorRenderTarget = null;
			_this.source = null;
			return _this;
		}
		_inheritsLoose(RenderPassColorGrab, _RenderPass);
		var _proto = RenderPassColorGrab.prototype;
		_proto.destroy = function destroy() {
			_RenderPass.prototype.destroy.call(this);
			this.releaseRenderTarget(this.colorRenderTarget);
		};
		_proto.shouldReallocate = function shouldReallocate(targetRT, sourceTexture, sourceFormat) {
			var targetFormat = targetRT == null ? void 0 : targetRT.colorBuffer.format;
			if (targetFormat !== sourceFormat) {
				return true;
			}
			var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
			var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
			return !targetRT || width !== targetRT.width || height !== targetRT.height;
		};
		_proto.allocateRenderTarget = function allocateRenderTarget(renderTarget, sourceRenderTarget, device, format) {
			var texture = new Texture(device, {
				name: _colorUniformName,
				format: format,
				width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
				height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
				mipmaps: true,
				minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			if (renderTarget) {
				renderTarget.destroyFrameBuffers();
				renderTarget._colorBuffer = texture;
				renderTarget._colorBuffers = [texture];
			} else {
				renderTarget = new RenderTarget({
					name: 'ColorGrabRT',
					colorBuffer: texture,
					depth: false,
					stencil: false,
					autoResolve: false
				});
			}
			return renderTarget;
		};
		_proto.releaseRenderTarget = function releaseRenderTarget(rt) {
			if (rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
			}
		};
		_proto.frameUpdate = function frameUpdate() {
			var _sourceRt$colorBuffer;
			var device = this.device;
			var sourceRt = this.source;
			var sourceFormat = (_sourceRt$colorBuffer = sourceRt == null ? void 0 : sourceRt.colorBuffer.format) != null ? _sourceRt$colorBuffer : this.device.backBufferFormat;
			if (this.shouldReallocate(this.colorRenderTarget, sourceRt == null ? void 0 : sourceRt.colorBuffer, sourceFormat)) {
				this.releaseRenderTarget(this.colorRenderTarget);
				this.colorRenderTarget = this.allocateRenderTarget(this.colorRenderTarget, sourceRt, device, sourceFormat);
			}
			var colorBuffer = this.colorRenderTarget.colorBuffer;
			device.scope.resolve(_colorUniformName).setValue(colorBuffer);
		};
		_proto.execute = function execute() {
			var device = this.device;
			var sourceRt = this.source;
			var colorBuffer = this.colorRenderTarget.colorBuffer;
			if (device.isWebGPU) {
				device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
				device.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);
			} else {
				device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
				device.activeTexture(device.maxCombinedTextures - 1);
				device.bindTexture(colorBuffer);
				device.gl.generateMipmap(colorBuffer.impl._glTarget);
			}
		};
		return RenderPassColorGrab;
	}(RenderPass);

	var _depthUniformName = 'uSceneDepthMap';
	var RenderPassDepthGrab = function (_RenderPass) {
		function RenderPassDepthGrab(device, camera) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.depthRenderTarget = null;
			_this.camera = null;
			_this.camera = camera;
			return _this;
		}
		_inheritsLoose(RenderPassDepthGrab, _RenderPass);
		var _proto = RenderPassDepthGrab.prototype;
		_proto.destroy = function destroy() {
			_RenderPass.prototype.destroy.call(this);
			this.releaseRenderTarget(this.depthRenderTarget);
		};
		_proto.shouldReallocate = function shouldReallocate(targetRT, sourceTexture) {
			var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
			var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
			return !targetRT || width !== targetRT.width || height !== targetRT.height;
		};
		_proto.allocateRenderTarget = function allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {
			var texture = new Texture(device, {
				name: _depthUniformName,
				format: format,
				width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
				height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			if (renderTarget) {
				renderTarget.destroyFrameBuffers();
				if (isDepth) {
					renderTarget._depthBuffer = texture;
				} else {
					renderTarget._colorBuffer = texture;
					renderTarget._colorBuffers = [texture];
				}
			} else {
				renderTarget = new RenderTarget({
					name: 'DepthGrabRT',
					colorBuffer: isDepth ? null : texture,
					depthBuffer: isDepth ? texture : null,
					depth: !isDepth,
					stencil: device.supportsStencil,
					autoResolve: false
				});
			}
			return renderTarget;
		};
		_proto.releaseRenderTarget = function releaseRenderTarget(rt) {
			if (rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
			}
		};
		_proto.before = function before() {
			var _camera$renderTarget, _camera$renderTarget$, _camera$renderTarget2, _camera$renderTarget3;
			var camera = this.camera;
			var device = this.device;
			var destinationRt = (_camera$renderTarget = camera == null ? void 0 : camera.renderTarget) != null ? _camera$renderTarget : device.backBuffer;
			var useDepthBuffer = true;
			var format = destinationRt.stencil ? PIXELFORMAT_DEPTHSTENCIL : PIXELFORMAT_DEPTH;
			if (device.isWebGPU) {
				var numSamples = destinationRt.samples;
				if (numSamples > 1) {
					format = PIXELFORMAT_R32F;
					useDepthBuffer = false;
				}
			}
			var sourceTexture = (_camera$renderTarget$ = (_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.depthBuffer) != null ? _camera$renderTarget$ : (_camera$renderTarget3 = camera.renderTarget) == null ? void 0 : _camera$renderTarget3.colorBuffer;
			if (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {
				this.releaseRenderTarget(this.depthRenderTarget);
				this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);
			}
			var colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
			device.scope.resolve(_depthUniformName).setValue(colorBuffer);
		};
		_proto.execute = function execute() {
			var device = this.device;
			if (device.isWebGL2 && device.renderTarget.samples > 1) {
				var src = device.renderTarget.impl._glFrameBuffer;
				var dest = this.depthRenderTarget;
				device.renderTarget = dest;
				device.updateBegin();
				this.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);
			} else {
				device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
			}
		};
		return RenderPassDepthGrab;
	}(RenderPass);

	var CameraShaderParams = function () {
		function CameraShaderParams() {
			this._gammaCorrection = GAMMA_SRGB;
			this._toneMapping = TONEMAP_LINEAR;
			this._srgbRenderTarget = false;
			this._ssaoEnabled = false;
			this._fog = FOG_NONE;
			this._sceneDepthMapLinear = false;
			this._hash = void 0;
			this._defines = new Map();
			this._definesDirty = true;
		}
		var _proto = CameraShaderParams.prototype;
		_proto.markDirty = function markDirty() {
			this._hash = undefined;
			this._definesDirty = true;
		};
		return _createClass(CameraShaderParams, [{
			key: "hash",
			get: function get() {
				if (this._hash === undefined) {
					var key = this.gammaCorrection + "_" + this.toneMapping + "_" + this.srgbRenderTarget + "_" + this.fog + "_" + this.ssaoEnabled + "_" + this.sceneDepthMapLinear;
					this._hash = hashCode(key);
				}
				return this._hash;
			}
		}, {
			key: "defines",
			get: function get() {
				var defines = this._defines;
				if (this._definesDirty) {
					this._definesDirty = false;
					defines.clear();
					if (this._sceneDepthMapLinear) defines.set('SCENE_DEPTHMAP_LINEAR', true);
				}
				return defines;
			}
		}, {
			key: "fog",
			get: function get() {
				return this._fog;
			},
			set: function set(type) {
				if (this._fog !== type) {
					this._fog = type;
					this.markDirty();
				}
			}
		}, {
			key: "ssaoEnabled",
			get: function get() {
				return this._ssaoEnabled;
			},
			set: function set(value) {
				if (this._ssaoEnabled !== value) {
					this._ssaoEnabled = value;
					this.markDirty();
				}
			}
		}, {
			key: "gammaCorrection",
			get: function get() {
				return this._gammaCorrection;
			},
			set: function set(value) {
				this._gammaCorrectionAssigned = true;
				if (this._gammaCorrection !== value) {
					this._gammaCorrection = value;
					this.markDirty();
				}
			}
		}, {
			key: "toneMapping",
			get: function get() {
				return this._toneMapping;
			},
			set: function set(value) {
				if (this._toneMapping !== value) {
					this._toneMapping = value;
					this.markDirty();
				}
			}
		}, {
			key: "srgbRenderTarget",
			get: function get() {
				return this._srgbRenderTarget;
			},
			set: function set(value) {
				if (this._srgbRenderTarget !== value) {
					this._srgbRenderTarget = value;
					this.markDirty();
				}
			}
		}, {
			key: "sceneDepthMapLinear",
			get: function get() {
				return this._sceneDepthMapLinear;
			},
			set: function set(value) {
				if (this._sceneDepthMapLinear !== value) {
					this._sceneDepthMapLinear = value;
					this.markDirty();
				}
			}
		}, {
			key: "shaderOutputGamma",
			get: function get() {
				var gammaOutput = this._gammaCorrection === GAMMA_SRGB && !this._srgbRenderTarget;
				return gammaOutput ? GAMMA_SRGB : GAMMA_NONE;
			}
		}]);
	}();

	var _deviceCoord = new Vec3();
	var _halfSize = new Vec3();
	var _point$1 = new Vec3();
	var _invViewProjMat = new Mat4();
	var _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	var Camera = function () {
		function Camera() {
			this.shaderPassInfo = null;
			this.renderPassColorGrab = null;
			this.renderPassDepthGrab = null;
			this.fogParams = null;
			this.shaderParams = new CameraShaderParams();
			this.renderPasses = [];
			this.jitter = 0;
			this._aspectRatio = 16 / 9;
			this._aspectRatioMode = ASPECT_AUTO;
			this._calculateProjection = null;
			this._calculateTransform = null;
			this._clearColor = new Color(0.75, 0.75, 0.75, 1);
			this._clearColorBuffer = true;
			this._clearDepth = 1;
			this._clearDepthBuffer = true;
			this._clearStencil = 0;
			this._clearStencilBuffer = true;
			this._cullFaces = true;
			this._farClip = 1000;
			this._flipFaces = false;
			this._fov = 45;
			this._frustumCulling = true;
			this._horizontalFov = false;
			this._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];
			this._layersSet = new Set(this._layers);
			this._nearClip = 0.1;
			this._node = null;
			this._orthoHeight = 10;
			this._projection = PROJECTION_PERSPECTIVE;
			this._rect = new Vec4(0, 0, 1, 1);
			this._renderTarget = null;
			this._scissorRect = new Vec4(0, 0, 1, 1);
			this._scissorRectClear = false;
			this._aperture = 16.0;
			this._shutter = 1.0 / 1000.0;
			this._sensitivity = 1000;
			this._projMat = new Mat4();
			this._projMatDirty = true;
			this._projMatSkybox = new Mat4();
			this._viewMat = new Mat4();
			this._viewMatDirty = true;
			this._viewProjMat = new Mat4();
			this._viewProjMatDirty = true;
			this._shaderMatricesVersion = 0;
			this._viewProjInverse = new Mat4();
			this._viewProjCurrent = null;
			this._viewProjPrevious = new Mat4();
			this._jitters = [0, 0, 0, 0];
			this.frustum = new Frustum();
			this._xr = null;
			this._xrProperties = {
				horizontalFov: this._horizontalFov,
				fov: this._fov,
				aspectRatio: this._aspectRatio,
				farClip: this._farClip,
				nearClip: this._nearClip
			};
		}
		var _proto = Camera.prototype;
		_proto.destroy = function destroy() {
			var _this$renderPassColor, _this$renderPassDepth;
			(_this$renderPassColor = this.renderPassColorGrab) == null || _this$renderPassColor.destroy();
			this.renderPassColorGrab = null;
			(_this$renderPassDepth = this.renderPassDepthGrab) == null || _this$renderPassDepth.destroy();
			this.renderPassDepthGrab = null;
			this.renderPasses.length = 0;
		};
		_proto._storeShaderMatrices = function _storeShaderMatrices(viewProjMat, jitterX, jitterY, renderVersion) {
			if (this._shaderMatricesVersion !== renderVersion) {
				var _this$_viewProjCurren, _this$_viewProjCurren2;
				this._shaderMatricesVersion = renderVersion;
				this._viewProjPrevious.copy((_this$_viewProjCurren = this._viewProjCurrent) != null ? _this$_viewProjCurren : viewProjMat);
				(_this$_viewProjCurren2 = this._viewProjCurrent) != null ? _this$_viewProjCurren2 : this._viewProjCurrent = new Mat4();
				this._viewProjCurrent.copy(viewProjMat);
				this._viewProjInverse.invert(viewProjMat);
				this._jitters[2] = this._jitters[0];
				this._jitters[3] = this._jitters[1];
				this._jitters[0] = jitterX;
				this._jitters[1] = jitterY;
			}
		};
		_proto.clone = function clone() {
			return new Camera().copy(this);
		};
		_proto.copy = function copy(other) {
			this._aspectRatio = other._aspectRatio;
			this._farClip = other._farClip;
			this._fov = other._fov;
			this._horizontalFov = other._horizontalFov;
			this._nearClip = other._nearClip;
			this._xrProperties.aspectRatio = other._xrProperties.aspectRatio;
			this._xrProperties.farClip = other._xrProperties.farClip;
			this._xrProperties.fov = other._xrProperties.fov;
			this._xrProperties.horizontalFov = other._xrProperties.horizontalFov;
			this._xrProperties.nearClip = other._xrProperties.nearClip;
			this.aspectRatioMode = other.aspectRatioMode;
			this.calculateProjection = other.calculateProjection;
			this.calculateTransform = other.calculateTransform;
			this.clearColor = other.clearColor;
			this.clearColorBuffer = other.clearColorBuffer;
			this.clearDepth = other.clearDepth;
			this.clearDepthBuffer = other.clearDepthBuffer;
			this.clearStencil = other.clearStencil;
			this.clearStencilBuffer = other.clearStencilBuffer;
			this.cullFaces = other.cullFaces;
			this.flipFaces = other.flipFaces;
			this.frustumCulling = other.frustumCulling;
			this.layers = other.layers;
			this.orthoHeight = other.orthoHeight;
			this.projection = other.projection;
			this.rect = other.rect;
			this.renderTarget = other.renderTarget;
			this.scissorRect = other.scissorRect;
			this.aperture = other.aperture;
			this.shutter = other.shutter;
			this.sensitivity = other.sensitivity;
			this.shaderPassInfo = other.shaderPassInfo;
			this.jitter = other.jitter;
			this._projMatDirty = true;
			return this;
		};
		_proto._enableRenderPassColorGrab = function _enableRenderPassColorGrab(device, enable) {
			if (enable) {
				if (!this.renderPassColorGrab) {
					this.renderPassColorGrab = new RenderPassColorGrab(device);
				}
			} else {
				var _this$renderPassColor2;
				(_this$renderPassColor2 = this.renderPassColorGrab) == null || _this$renderPassColor2.destroy();
				this.renderPassColorGrab = null;
			}
		};
		_proto._enableRenderPassDepthGrab = function _enableRenderPassDepthGrab(device, renderer, enable) {
			if (enable) {
				if (!this.renderPassDepthGrab) {
					this.renderPassDepthGrab = new RenderPassDepthGrab(device, this);
				}
			} else {
				var _this$renderPassDepth2;
				(_this$renderPassDepth2 = this.renderPassDepthGrab) == null || _this$renderPassDepth2.destroy();
				this.renderPassDepthGrab = null;
			}
		};
		_proto._updateViewProjMat = function _updateViewProjMat() {
			if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
				this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);
				this._viewProjMatDirty = false;
			}
		};
		_proto.worldToScreen = function worldToScreen(worldCoord, cw, ch, screenCoord) {
			if (screenCoord === void 0) {
				screenCoord = new Vec3();
			}
			this._updateViewProjMat();
			this._viewProjMat.transformPoint(worldCoord, screenCoord);
			var vpm = this._viewProjMat.data;
			var w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
			screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
			screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
			return screenCoord;
		};
		_proto.screenToWorld = function screenToWorld(x, y, z, cw, ch, worldCoord) {
			if (worldCoord === void 0) {
				worldCoord = new Vec3();
			}
			var range = this.farClip - this.nearClip;
			_deviceCoord.set(x / cw, (ch - y) / ch, z / range);
			_deviceCoord.mulScalar(2);
			_deviceCoord.sub(Vec3.ONE);
			if (this._projection === PROJECTION_PERSPECTIVE) {
				Mat4._getPerspectiveHalfSize(_halfSize, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov);
				_halfSize.x *= _deviceCoord.x;
				_halfSize.y *= _deviceCoord.y;
				var invView = this._node.getWorldTransform();
				_halfSize.z = -this.nearClip;
				invView.transformPoint(_halfSize, _point$1);
				var cameraPos = this._node.getPosition();
				worldCoord.sub2(_point$1, cameraPos);
				worldCoord.normalize();
				worldCoord.mulScalar(z);
				worldCoord.add(cameraPos);
			} else {
				this._updateViewProjMat();
				_invViewProjMat.copy(this._viewProjMat).invert();
				_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
			}
			return worldCoord;
		};
		_proto._evaluateProjectionMatrix = function _evaluateProjectionMatrix() {
			if (this._projMatDirty) {
				if (this._projection === PROJECTION_PERSPECTIVE) {
					this._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov);
					this._projMatSkybox.copy(this._projMat);
				} else {
					var y = this._orthoHeight;
					var x = y * this.aspectRatio;
					this._projMat.setOrtho(-x, x, -y, y, this.nearClip, this.farClip);
					this._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip);
				}
				this._projMatDirty = false;
			}
		};
		_proto.getProjectionMatrixSkybox = function getProjectionMatrixSkybox() {
			this._evaluateProjectionMatrix();
			return this._projMatSkybox;
		};
		_proto.getExposure = function getExposure() {
			var ev100 = Math.log2(this._aperture * this._aperture / this._shutter * 100.0 / this._sensitivity);
			return 1.0 / (Math.pow(2.0, ev100) * 1.2);
		};
		_proto.getScreenSize = function getScreenSize(sphere) {
			if (this._projection === PROJECTION_PERSPECTIVE) {
				var distance = this._node.getPosition().distance(sphere.center);
				if (distance < sphere.radius) {
					return 1;
				}
				var viewAngle = Math.asin(sphere.radius / distance);
				var sphereViewHeight = Math.tan(viewAngle);
				var screenViewHeight = Math.tan(this.fov / 2 * math.DEG_TO_RAD);
				return Math.min(sphereViewHeight / screenViewHeight, 1);
			}
			return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
		};
		_proto.getFrustumCorners = function getFrustumCorners(near, far) {
			if (near === void 0) {
				near = this.nearClip;
			}
			if (far === void 0) {
				far = this.farClip;
			}
			var fov = this.fov * Math.PI / 180.0;
			var x, y;
			if (this.projection === PROJECTION_PERSPECTIVE) {
				if (this.horizontalFov) {
					x = near * Math.tan(fov / 2.0);
					y = x / this.aspectRatio;
				} else {
					y = near * Math.tan(fov / 2.0);
					x = y * this.aspectRatio;
				}
			} else {
				y = this._orthoHeight;
				x = y * this.aspectRatio;
			}
			var points = _frustumPoints;
			points[0].x = x;
			points[0].y = -y;
			points[0].z = -near;
			points[1].x = x;
			points[1].y = y;
			points[1].z = -near;
			points[2].x = -x;
			points[2].y = y;
			points[2].z = -near;
			points[3].x = -x;
			points[3].y = -y;
			points[3].z = -near;
			if (this._projection === PROJECTION_PERSPECTIVE) {
				if (this.horizontalFov) {
					x = far * Math.tan(fov / 2.0);
					y = x / this.aspectRatio;
				} else {
					y = far * Math.tan(fov / 2.0);
					x = y * this.aspectRatio;
				}
			}
			points[4].x = x;
			points[4].y = -y;
			points[4].z = -far;
			points[5].x = x;
			points[5].y = y;
			points[5].z = -far;
			points[6].x = -x;
			points[6].y = y;
			points[6].z = -far;
			points[7].x = -x;
			points[7].y = -y;
			points[7].z = -far;
			return points;
		};
		_proto.setXrProperties = function setXrProperties(properties) {
			Object.assign(this._xrProperties, properties);
			this._projMatDirty = true;
		};
		return _createClass(Camera, [{
			key: "fullSizeClearRect",
			get: function get() {
				var rect = this._scissorRectClear ? this.scissorRect : this._rect;
				return rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;
			}
		}, {
			key: "aspectRatio",
			get: function get() {
				var _this$xr;
				return (_this$xr = this.xr) != null && _this$xr.active ? this._xrProperties.aspectRatio : this._aspectRatio;
			},
			set: function set(newValue) {
				if (this._aspectRatio !== newValue) {
					this._aspectRatio = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "aspectRatioMode",
			get: function get() {
				return this._aspectRatioMode;
			},
			set: function set(newValue) {
				if (this._aspectRatioMode !== newValue) {
					this._aspectRatioMode = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "calculateProjection",
			get: function get() {
				return this._calculateProjection;
			},
			set: function set(newValue) {
				this._calculateProjection = newValue;
				this._projMatDirty = true;
			}
		}, {
			key: "calculateTransform",
			get: function get() {
				return this._calculateTransform;
			},
			set: function set(newValue) {
				this._calculateTransform = newValue;
			}
		}, {
			key: "clearColor",
			get: function get() {
				return this._clearColor;
			},
			set: function set(newValue) {
				this._clearColor.copy(newValue);
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._clearColorBuffer;
			},
			set: function set(newValue) {
				this._clearColorBuffer = newValue;
			}
		}, {
			key: "clearDepth",
			get: function get() {
				return this._clearDepth;
			},
			set: function set(newValue) {
				this._clearDepth = newValue;
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._clearDepthBuffer;
			},
			set: function set(newValue) {
				this._clearDepthBuffer = newValue;
			}
		}, {
			key: "clearStencil",
			get: function get() {
				return this._clearStencil;
			},
			set: function set(newValue) {
				this._clearStencil = newValue;
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._clearStencilBuffer;
			},
			set: function set(newValue) {
				this._clearStencilBuffer = newValue;
			}
		}, {
			key: "cullFaces",
			get: function get() {
				return this._cullFaces;
			},
			set: function set(newValue) {
				this._cullFaces = newValue;
			}
		}, {
			key: "farClip",
			get: function get() {
				var _this$xr2;
				return (_this$xr2 = this.xr) != null && _this$xr2.active ? this._xrProperties.farClip : this._farClip;
			},
			set: function set(newValue) {
				if (this._farClip !== newValue) {
					this._farClip = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "flipFaces",
			get: function get() {
				return this._flipFaces;
			},
			set: function set(newValue) {
				this._flipFaces = newValue;
			}
		}, {
			key: "fov",
			get: function get() {
				var _this$xr3;
				return (_this$xr3 = this.xr) != null && _this$xr3.active ? this._xrProperties.fov : this._fov;
			},
			set: function set(newValue) {
				if (this._fov !== newValue) {
					this._fov = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "frustumCulling",
			get: function get() {
				return this._frustumCulling;
			},
			set: function set(newValue) {
				this._frustumCulling = newValue;
			}
		}, {
			key: "horizontalFov",
			get: function get() {
				var _this$xr4;
				return (_this$xr4 = this.xr) != null && _this$xr4.active ? this._xrProperties.horizontalFov : this._horizontalFov;
			},
			set: function set(newValue) {
				if (this._horizontalFov !== newValue) {
					this._horizontalFov = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(newValue) {
				this._layers = newValue.slice(0);
				this._layersSet = new Set(this._layers);
			}
		}, {
			key: "layersSet",
			get: function get() {
				return this._layersSet;
			}
		}, {
			key: "nearClip",
			get: function get() {
				var _this$xr5;
				return (_this$xr5 = this.xr) != null && _this$xr5.active ? this._xrProperties.nearClip : this._nearClip;
			},
			set: function set(newValue) {
				if (this._nearClip !== newValue) {
					this._nearClip = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "node",
			get: function get() {
				return this._node;
			},
			set: function set(newValue) {
				this._node = newValue;
			}
		}, {
			key: "orthoHeight",
			get: function get() {
				return this._orthoHeight;
			},
			set: function set(newValue) {
				if (this._orthoHeight !== newValue) {
					this._orthoHeight = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "projection",
			get: function get() {
				return this._projection;
			},
			set: function set(newValue) {
				if (this._projection !== newValue) {
					this._projection = newValue;
					this._projMatDirty = true;
				}
			}
		}, {
			key: "projectionMatrix",
			get: function get() {
				this._evaluateProjectionMatrix();
				return this._projMat;
			}
		}, {
			key: "rect",
			get: function get() {
				return this._rect;
			},
			set: function set(newValue) {
				this._rect.copy(newValue);
			}
		}, {
			key: "renderTarget",
			get: function get() {
				return this._renderTarget;
			},
			set: function set(newValue) {
				this._renderTarget = newValue;
			}
		}, {
			key: "scissorRect",
			get: function get() {
				return this._scissorRect;
			},
			set: function set(newValue) {
				this._scissorRect.copy(newValue);
			}
		}, {
			key: "viewMatrix",
			get: function get() {
				if (this._viewMatDirty) {
					var wtm = this._node.getWorldTransform();
					this._viewMat.copy(wtm).invert();
					this._viewMatDirty = false;
				}
				return this._viewMat;
			}
		}, {
			key: "aperture",
			get: function get() {
				return this._aperture;
			},
			set: function set(newValue) {
				this._aperture = newValue;
			}
		}, {
			key: "sensitivity",
			get: function get() {
				return this._sensitivity;
			},
			set: function set(newValue) {
				this._sensitivity = newValue;
			}
		}, {
			key: "shutter",
			get: function get() {
				return this._shutter;
			},
			set: function set(newValue) {
				this._shutter = newValue;
			}
		}, {
			key: "xr",
			get: function get() {
				return this._xr;
			},
			set: function set(newValue) {
				if (this._xr !== newValue) {
					this._xr = newValue;
					this._projMatDirty = true;
				}
			}
		}]);
	}();

	var _viewMat = new Mat4();
	var _viewProjMat = new Mat4();
	var _viewportMatrix = new Mat4();
	var LightCamera = function () {
		function LightCamera() {}
		LightCamera.create = function create(name, lightType, face) {
			var camera = new Camera();
			camera.node = new GraphNode(name);
			camera.aspectRatio = 1;
			camera.aspectRatioMode = ASPECT_MANUAL;
			camera._scissorRectClear = true;
			switch (lightType) {
				case LIGHTTYPE_OMNI:
					camera.node.setRotation(LightCamera.pointLightRotations[face]);
					camera.fov = 90;
					camera.projection = PROJECTION_PERSPECTIVE;
					break;
				case LIGHTTYPE_SPOT:
					camera.projection = PROJECTION_PERSPECTIVE;
					break;
				case LIGHTTYPE_DIRECTIONAL:
					camera.projection = PROJECTION_ORTHOGRAPHIC;
					break;
			}
			return camera;
		};
		LightCamera.evalSpotCookieMatrix = function evalSpotCookieMatrix(light) {
			var cookieCamera = LightCamera._spotCookieCamera;
			if (!cookieCamera) {
				cookieCamera = LightCamera.create('SpotCookieCamera', LIGHTTYPE_SPOT);
				LightCamera._spotCookieCamera = cookieCamera;
			}
			cookieCamera.fov = light._outerConeAngle * 2;
			var cookieNode = cookieCamera._node;
			cookieNode.setPosition(light._node.getPosition());
			cookieNode.setRotation(light._node.getRotation());
			cookieNode.rotateLocal(-90, 0, 0);
			_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();
			_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);
			var cookieMatrix = light.cookieMatrix;
			var rectViewport = light.atlasViewport;
			_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
			cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
			return cookieMatrix;
		};
		return LightCamera;
	}();
	LightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];
	LightCamera._spotCookieCamera = null;

	var epsilon$1 = 0.000001;
	var tempVec3$1 = new Vec3();
	var tempAreaLightSizes = new Float32Array(6);
	var areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
	var areaHalfAxisHeight = new Vec3(0, 0, 0.5);
	var TextureIndex8 = {
		FLAGS: 0,
		COLOR_A: 1,
		COLOR_B: 2,
		SPOT_ANGLES: 3,
		SHADOW_BIAS: 4,
		COOKIE_A: 5,
		COOKIE_B: 6,
		COUNT: 7
	};
	var TextureIndexFloat = {
		POSITION_RANGE: 0,
		SPOT_DIRECTION: 1,
		PROJ_MAT_0: 2,
		ATLAS_VIEWPORT: 2,
		PROJ_MAT_1: 3,
		PROJ_MAT_2: 4,
		PROJ_MAT_3: 5,
		AREA_DATA_WIDTH: 6,
		AREA_DATA_HEIGHT: 7,
		COUNT: 8
	};
	var _defines;
	var LightsBuffer = function () {
		function LightsBuffer(device) {
			this.areaLightsEnabled = false;
			this.device = device;
			this.cookiesEnabled = false;
			this.shadowsEnabled = false;
			this.areaLightsEnabled = false;
			this.maxLights = 255;
			var pixelsPerLight8 = TextureIndex8.COUNT;
			this.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);
			this.lightsTexture8 = this.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_RGBA8, 'LightsTexture8');
			this._lightsTexture8Id = this.device.scope.resolve('lightsTexture8');
			var pixelsPerLightFloat = TextureIndexFloat.COUNT;
			this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
			this.lightsTextureFloat = this.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, 'LightsTextureFloat');
			this._lightsTextureFloatId = this.device.scope.resolve('lightsTextureFloat');
			this.invMaxColorValue = 0;
			this.invMaxAttenuation = 0;
			this.boundsMin = new Vec3();
			this.boundsDelta = new Vec3();
		}
		LightsBuffer.getShaderDefines = function getShaderDefines() {
			var buildShaderDefines = function buildShaderDefines(object, prefix) {
				return Object.keys(object).map(function (key) {
					return "#define " + prefix + key + " " + object[key];
				}).join('\n');
			};
			if (!_defines) {
				_defines = "\n\n                " + buildShaderDefines(TextureIndex8, 'CLUSTER_TEXTURE_8_') + "\n                " + buildShaderDefines(TextureIndexFloat, 'CLUSTER_TEXTURE_F_') + "\n            ";
			}
			return _defines;
		};
		var _proto = LightsBuffer.prototype;
		_proto.destroy = function destroy() {
			var _this$lightsTexture, _this$lightsTextureFl;
			(_this$lightsTexture = this.lightsTexture8) == null || _this$lightsTexture.destroy();
			this.lightsTexture8 = null;
			(_this$lightsTextureFl = this.lightsTextureFloat) == null || _this$lightsTextureFl.destroy();
			this.lightsTextureFloat = null;
		};
		_proto.createTexture = function createTexture(device, width, height, format, name) {
			var tex = new Texture(device, {
				name: name,
				width: width,
				height: height,
				mipmaps: false,
				format: format,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				type: TEXTURETYPE_DEFAULT,
				magFilter: FILTER_NEAREST,
				minFilter: FILTER_NEAREST,
				anisotropy: 1
			});
			return tex;
		};
		_proto.setCompressionRanges = function setCompressionRanges(maxAttenuation, maxColorValue) {
			this.invMaxColorValue = 1 / maxColorValue;
			this.invMaxAttenuation = 1 / maxAttenuation;
		};
		_proto.setBounds = function setBounds(min, delta) {
			this.boundsMin.copy(min);
			this.boundsDelta.copy(delta);
		};
		_proto.uploadTextures = function uploadTextures() {
			this.lightsTextureFloat.lock().set(this.lightsFloat);
			this.lightsTextureFloat.unlock();
			this.lightsTexture8.lock().set(this.lights8);
			this.lightsTexture8.unlock();
		};
		_proto.updateUniforms = function updateUniforms() {
			this._lightsTexture8Id.setValue(this.lightsTexture8);
			this._lightsTextureFloatId.setValue(this.lightsTextureFloat);
		};
		_proto.getSpotDirection = function getSpotDirection(direction, spot) {
			var mat = spot._node.getWorldTransform();
			mat.getY(direction).mulScalar(-1);
			direction.normalize();
		};
		_proto.getLightAreaSizes = function getLightAreaSizes(light) {
			var mat = light._node.getWorldTransform();
			mat.transformVector(areaHalfAxisWidth, tempVec3$1);
			tempAreaLightSizes[0] = tempVec3$1.x;
			tempAreaLightSizes[1] = tempVec3$1.y;
			tempAreaLightSizes[2] = tempVec3$1.z;
			mat.transformVector(areaHalfAxisHeight, tempVec3$1);
			tempAreaLightSizes[3] = tempVec3$1.x;
			tempAreaLightSizes[4] = tempVec3$1.y;
			tempAreaLightSizes[5] = tempVec3$1.z;
			return tempAreaLightSizes;
		};
		_proto.addLightDataFlags = function addLightDataFlags(data8, index, light, isSpot, castShadows, shadowIntensity) {
			data8[index + 0] = isSpot ? 255 : 0;
			data8[index + 1] = this.areaLightsEnabled ? light._shape * 64 : 0;
			data8[index + 2] = light._falloffMode * 255;
			data8[index + 3] = castShadows ? shadowIntensity * 255 : 0;
		};
		_proto.addLightDataColor = function addLightDataColor(data8, index, light, isCookie) {
			var invMaxColorValue = this.invMaxColorValue;
			var color = light._colorLinear;
			FloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);
			FloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);
			FloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);
			data8[index + 6] = isCookie ? 255 : 0;
			var isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);
			var isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);
			data8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;
		};
		_proto.addLightDataSpotAngles = function addLightDataSpotAngles(data8, index, light) {
			FloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);
			FloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);
		};
		_proto.addLightDataShadowBias = function addLightDataShadowBias(data8, index, light) {
			var lightRenderData = light.getRenderData(null, 0);
			var biases = light._getUniformBiasValues(lightRenderData);
			FloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);
			FloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);
		};
		_proto.addLightDataCookies = function addLightDataCookies(data8, index, light) {
			var isRgb = light._cookieChannel === 'rgb';
			data8[index + 0] = Math.floor(light.cookieIntensity * 255);
			data8[index + 1] = isRgb ? 255 : 0;
			if (!isRgb) {
				var channel = light._cookieChannel;
				data8[index + 4] = channel === 'rrr' ? 255 : 0;
				data8[index + 5] = channel === 'ggg' ? 255 : 0;
				data8[index + 6] = channel === 'bbb' ? 255 : 0;
				data8[index + 7] = channel === 'aaa' ? 255 : 0;
			}
		};
		_proto.addLightData = function addLightData(light, lightIndex) {
			var isSpot = light._type === LIGHTTYPE_SPOT;
			var hasAtlasViewport = light.atlasViewportAllocated;
			var isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
			var isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
			var castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;
			var pos = light._node.getPosition();
			var lightProjectionMatrix = null;
			var atlasViewport = null;
			if (isSpot) {
				if (castShadows) {
					var lightRenderData = light.getRenderData(null, 0);
					lightProjectionMatrix = lightRenderData.shadowMatrix;
				} else if (isCookie) {
					lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
				}
			} else {
				if (castShadows || isCookie) {
					atlasViewport = light.atlasViewport;
				}
			}
			var data8 = this.lights8;
			var data8Start = lightIndex * this.lightsTexture8.width * 4;
			this.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows, light.shadowIntensity);
			this.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, isCookie);
			if (isSpot) {
				this.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);
			}
			if (light.castShadows) {
				this.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);
			}
			if (isCookie) {
				this.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);
			}
			var dataFloat = this.lightsFloat;
			var dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
			dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;
			if (isSpot) {
				this.getSpotDirection(tempVec3$1, light);
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;
			}
			if (lightProjectionMatrix) {
				var matData = lightProjectionMatrix.data;
				for (var m = 0; m < 16; m++) {
					dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
				}
			}
			if (atlasViewport) {
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
			}
			if (isArea) {
				var areaSizes = this.getLightAreaSizes(light);
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
				dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
			}
		};
		return LightsBuffer;
	}();

	var tempVec3 = new Vec3();
	var tempMin3 = new Vec3();
	var tempMax3 = new Vec3();
	var tempBox = new BoundingBox();
	var epsilon = 0.000001;
	var ClusterLight = function ClusterLight() {
		this.light = null;
		this.min = new Vec3();
		this.max = new Vec3();
	};
	var WorldClusters = function () {
		function WorldClusters(device) {
			this.clusterTexture = void 0;
			this.device = device;
			this.name = 'Untitled';
			this.reportCount = 0;
			this.boundsMin = new Vec3();
			this.boundsMax = new Vec3();
			this.boundsDelta = new Vec3();
			this._cells = new Vec3(1, 1, 1);
			this._cellsLimit = new Vec3();
			this.cells = this._cells;
			this.maxCellLightCount = 4;
			this._maxAttenuation = 0;
			this._maxColorValue = 0;
			this._usedLights = [];
			this._usedLights.push(new ClusterLight());
			this.lightsBuffer = new LightsBuffer(device);
			this.registerUniforms(device);
		}
		var _proto = WorldClusters.prototype;
		_proto.destroy = function destroy() {
			this.lightsBuffer.destroy();
			this.releaseClusterTexture();
		};
		_proto.releaseClusterTexture = function releaseClusterTexture() {
			if (this.clusterTexture) {
				this.clusterTexture.destroy();
				this.clusterTexture = null;
			}
		};
		_proto.registerUniforms = function registerUniforms(device) {
			this._clusterSkipId = device.scope.resolve('clusterSkip');
			this._clusterMaxCellsId = device.scope.resolve('clusterMaxCells');
			this._clusterWorldTextureId = device.scope.resolve('clusterWorldTexture');
			this._clusterTextureSizeId = device.scope.resolve('clusterTextureSize');
			this._clusterTextureSizeData = new Float32Array(3);
			this._clusterBoundsMinId = device.scope.resolve('clusterBoundsMin');
			this._clusterBoundsMinData = new Float32Array(3);
			this._clusterBoundsDeltaId = device.scope.resolve('clusterBoundsDelta');
			this._clusterBoundsDeltaData = new Float32Array(3);
			this._clusterCellsCountByBoundsSizeId = device.scope.resolve('clusterCellsCountByBoundsSize');
			this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
			this._clusterCellsDotId = device.scope.resolve('clusterCellsDot');
			this._clusterCellsDotData = new Float32Array(3);
			this._clusterCellsMaxId = device.scope.resolve('clusterCellsMax');
			this._clusterCellsMaxData = new Float32Array(3);
			this._clusterCompressionLimit0Id = device.scope.resolve('clusterCompressionLimit0');
			this._clusterCompressionLimit0Data = new Float32Array(2);
		};
		_proto.updateParams = function updateParams(lightingParams) {
			if (lightingParams) {
				this.cells = lightingParams.cells;
				this.maxCellLightCount = lightingParams.maxLightsPerCell;
				this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
				this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
				this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
			}
		};
		_proto.updateCells = function updateCells() {
			if (this._cellsDirty) {
				this._cellsDirty = false;
				var cx = this._cells.x;
				var cy = this._cells.y;
				var cz = this._cells.z;
				var numCells = cx * cy * cz;
				var totalPixels = this.maxCellLightCount * numCells;
				var width = Math.ceil(Math.sqrt(totalPixels));
				width = math.roundUp(width, this.maxCellLightCount);
				var height = Math.ceil(totalPixels / width);
				this._clusterCellsMaxData[0] = cx;
				this._clusterCellsMaxData[1] = cy;
				this._clusterCellsMaxData[2] = cz;
				this._clusterCellsDotData[0] = this.maxCellLightCount;
				this._clusterCellsDotData[1] = cx * cz * this.maxCellLightCount;
				this._clusterCellsDotData[2] = cx * this.maxCellLightCount;
				this.clusters = new Uint8ClampedArray(totalPixels);
				this.counts = new Int32Array(numCells);
				this._clusterTextureSizeData[0] = width;
				this._clusterTextureSizeData[1] = 1.0 / width;
				this._clusterTextureSizeData[2] = 1.0 / height;
				this.releaseClusterTexture();
				this.clusterTexture = this.lightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8, 'ClusterTexture');
			}
		};
		_proto.uploadTextures = function uploadTextures() {
			this.clusterTexture.lock().set(this.clusters);
			this.clusterTexture.unlock();
			this.lightsBuffer.uploadTextures();
		};
		_proto.updateUniforms = function updateUniforms() {
			this._clusterSkipId.setValue(this._usedLights.length > 1 ? 0 : 1);
			this.lightsBuffer.updateUniforms();
			this._clusterWorldTextureId.setValue(this.clusterTexture);
			this._clusterMaxCellsId.setValue(this.maxCellLightCount);
			var boundsDelta = this.boundsDelta;
			this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
			this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
			this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;
			this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);
			this._clusterBoundsMinData[0] = this.boundsMin.x;
			this._clusterBoundsMinData[1] = this.boundsMin.y;
			this._clusterBoundsMinData[2] = this.boundsMin.z;
			this._clusterBoundsDeltaData[0] = boundsDelta.x;
			this._clusterBoundsDeltaData[1] = boundsDelta.y;
			this._clusterBoundsDeltaData[2] = boundsDelta.z;
			this._clusterCompressionLimit0Data[0] = this._maxAttenuation;
			this._clusterCompressionLimit0Data[1] = this._maxColorValue;
			this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);
			this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);
			this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);
			this._clusterCellsDotId.setValue(this._clusterCellsDotData);
			this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);
			this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
		};
		_proto.evalLightCellMinMax = function evalLightCellMinMax(clusteredLight, min, max) {
			min.copy(clusteredLight.min);
			min.sub(this.boundsMin);
			min.div(this.boundsDelta);
			min.mul2(min, this.cells);
			min.floor();
			max.copy(clusteredLight.max);
			max.sub(this.boundsMin);
			max.div(this.boundsDelta);
			max.mul2(max, this.cells);
			max.ceil();
			min.max(Vec3.ZERO);
			max.min(this._cellsLimit);
		};
		_proto.collectLights = function collectLights(lights) {
			var maxLights = this.lightsBuffer.maxLights;
			var usedLights = this._usedLights;
			var lightIndex = 1;
			lights.forEach(function (light) {
				var runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));
				var zeroAngleSpotlight = light.type === LIGHTTYPE_SPOT && light._outerConeAngle === 0;
				if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight && !zeroAngleSpotlight) {
					if (lightIndex < maxLights) {
						var clusteredLight;
						if (lightIndex < usedLights.length) {
							clusteredLight = usedLights[lightIndex];
						} else {
							clusteredLight = new ClusterLight();
							usedLights.push(clusteredLight);
						}
						clusteredLight.light = light;
						light.getBoundingBox(tempBox);
						clusteredLight.min.copy(tempBox.getMin());
						clusteredLight.max.copy(tempBox.getMax());
						lightIndex++;
					}
				}
			});
			usedLights.length = lightIndex;
		};
		_proto.evaluateBounds = function evaluateBounds() {
			var usedLights = this._usedLights;
			var min = this.boundsMin;
			var max = this.boundsMax;
			if (usedLights.length > 1) {
				min.copy(usedLights[1].min);
				max.copy(usedLights[1].max);
				for (var i = 2; i < usedLights.length; i++) {
					min.min(usedLights[i].min);
					max.max(usedLights[i].max);
				}
			} else {
				min.set(0, 0, 0);
				max.set(1, 1, 1);
			}
			this.boundsDelta.sub2(max, min);
			this.lightsBuffer.setBounds(min, this.boundsDelta);
		};
		_proto.evaluateCompressionLimits = function evaluateCompressionLimits() {
			var maxAttenuation = 0;
			var maxColorValue = 0;
			var usedLights = this._usedLights;
			for (var i = 1; i < usedLights.length; i++) {
				var light = usedLights[i].light;
				maxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);
				var color = light._colorLinear;
				maxColorValue = Math.max(color[0], maxColorValue);
				maxColorValue = Math.max(color[1], maxColorValue);
				maxColorValue = Math.max(color[2], maxColorValue);
			}
			this._maxAttenuation = maxAttenuation + epsilon;
			this._maxColorValue = maxColorValue + epsilon;
			this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
		};
		_proto.updateClusters = function updateClusters(lightingParams) {
			this.counts.fill(0);
			this.clusters.fill(0);
			this.lightsBuffer.areaLightsEnabled = lightingParams ? lightingParams.areaLightsEnabled : false;
			var divX = this._cells.x;
			var divZ = this._cells.z;
			var counts = this.counts;
			var limit = this._maxCellLightCount;
			var clusters = this.clusters;
			var pixelsPerCellCount = this.maxCellLightCount;
			var usedLights = this._usedLights;
			for (var i = 1; i < usedLights.length; i++) {
				var clusteredLight = usedLights[i];
				var light = clusteredLight.light;
				this.lightsBuffer.addLightData(light, i);
				this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
				var xStart = tempMin3.x;
				var xEnd = tempMax3.x;
				var yStart = tempMin3.y;
				var yEnd = tempMax3.y;
				var zStart = tempMin3.z;
				var zEnd = tempMax3.z;
				for (var x = xStart; x <= xEnd; x++) {
					for (var z = zStart; z <= zEnd; z++) {
						for (var y = yStart; y <= yEnd; y++) {
							var clusterIndex = x + divX * (z + y * divZ);
							var count = counts[clusterIndex];
							if (count < limit) {
								clusters[pixelsPerCellCount * clusterIndex + count] = i;
								counts[clusterIndex] = count + 1;
							}
						}
					}
				}
			}
		};
		_proto.update = function update(lights, lightingParams) {
			if (lightingParams === void 0) {
				lightingParams = null;
			}
			this.updateParams(lightingParams);
			this.updateCells();
			this.collectLights(lights);
			this.evaluateBounds();
			this.evaluateCompressionLimits();
			this.updateClusters(lightingParams);
			this.uploadTextures();
		};
		_proto.activate = function activate() {
			this.updateUniforms();
		};
		return _createClass(WorldClusters, [{
			key: "maxCellLightCount",
			get: function get() {
				return this._maxCellLightCount;
			},
			set: function set(count) {
				if (count !== this._maxCellLightCount) {
					this._maxCellLightCount = count;
					this._cellsDirty = true;
				}
			}
		}, {
			key: "cells",
			get: function get() {
				return this._cells;
			},
			set: function set(value) {
				tempVec3.copy(value).floor();
				if (!this._cells.equals(tempVec3)) {
					this._cells.copy(tempVec3);
					this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);
					this._cellsDirty = true;
				}
			}
		}]);
	}();

	var shaderPassDeviceCache = new DeviceCache();
	var ShaderPassInfo = function () {
		function ShaderPassInfo(name, index, options) {
			if (options === void 0) {
				options = {};
			}
			this.index = void 0;
			this.name = void 0;
			this.shaderDefines = void 0;
			this.name = name;
			this.index = index;
			Object.assign(this, options);
			this.shaderDefines = this.buildShaderDefines();
		}
		var _proto = ShaderPassInfo.prototype;
		_proto.buildShaderDefines = function buildShaderDefines() {
			var keyword;
			if (this.isShadow) {
				keyword = 'SHADOW';
			} else if (this.isForward) {
				keyword = 'FORWARD';
			} else if (this.index === SHADER_DEPTH) {
				keyword = 'DEPTH';
			} else if (this.index === SHADER_PICK) {
				keyword = 'PICK';
			}
			var define1 = keyword ? "#define " + keyword + "_PASS\n" : '';
			var define2 = "#define " + this.name.toUpperCase() + "_PASS\n";
			return define1 + define2;
		};
		return ShaderPassInfo;
	}();
	var ShaderPass = function () {
		function ShaderPass() {
			var _this = this;
			this.passesNamed = new Map();
			this.passesIndexed = [];
			this.nextIndex = 0;
			var add = function add(name, index, options) {
				_this.allocate(name, options);
			};
			add('forward', SHADER_FORWARD, {
				isForward: true
			});
			add('prepass');
			add('depth');
			add('pick');
			add('shadow');
		}
		ShaderPass.get = function get(device) {
			return shaderPassDeviceCache.get(device, function () {
				return new ShaderPass();
			});
		};
		var _proto2 = ShaderPass.prototype;
		_proto2.allocate = function allocate(name, options) {
			var info = this.passesNamed.get(name);
			if (info === undefined) {
				info = new ShaderPassInfo(name, this.nextIndex, options);
				this.passesNamed.set(info.name, info);
				this.passesIndexed[info.index] = info;
				this.nextIndex++;
			}
			return info;
		};
		_proto2.getByIndex = function getByIndex(index) {
			var info = this.passesIndexed[index];
			return info;
		};
		_proto2.getByName = function getByName(name) {
			return this.passesNamed.get(name);
		};
		return ShaderPass;
	}();

	var _goldenAngle = 2.399963229728653;
	var random = {
		circlePoint: function circlePoint(point) {
			var r = Math.sqrt(Math.random());
			var theta = Math.random() * 2 * Math.PI;
			point.x = r * Math.cos(theta);
			point.y = r * Math.sin(theta);
		},
		circlePointDeterministic: function circlePointDeterministic(point, index, numPoints) {
			var theta = index * _goldenAngle;
			var r = Math.sqrt(index) / Math.sqrt(numPoints);
			point.x = r * Math.cos(theta);
			point.y = r * Math.sin(theta);
		},
		spherePointDeterministic: function spherePointDeterministic(point, index, numPoints, start, end) {
			if (start === void 0) {
				start = 0;
			}
			if (end === void 0) {
				end = 1;
			}
			start = 1 - 2 * start;
			end = 1 - 2 * end;
			var y = math.lerp(start, end, index / numPoints);
			var radius = Math.sqrt(1 - y * y);
			var theta = _goldenAngle * index;
			point.x = Math.cos(theta) * radius;
			point.y = y;
			point.z = Math.sin(theta) * radius;
		},
		radicalInverse: function radicalInverse(i) {
			var bits = (i << 16 | i >>> 16) >>> 0;
			bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
			bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
			bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
			bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
			return bits * 2.3283064365386963e-10;
		}
	};

	var decodeTable = {
		'linear': 'decodeLinear',
		'srgb': 'decodeGamma',
		'rgbm': 'decodeRGBM',
		'rgbe': 'decodeRGBE',
		'rgbp': 'decodeRGBP'
	};
	var encodeTable = {
		'linear': 'encodeLinear',
		'srgb': 'encodeGamma',
		'rgbm': 'encodeRGBM',
		'rgbe': 'encodeRGBE',
		'rgbp': 'encodeRGBP'
	};
	var ChunkUtils = function () {
		function ChunkUtils() {}
		ChunkUtils.decodeFunc = function decodeFunc(encoding) {
			return decodeTable[encoding] || 'decodeGamma';
		};
		ChunkUtils.encodeFunc = function encodeFunc(encoding) {
			return encodeTable[encoding] || 'encodeGamma';
		};
		ChunkUtils.getScreenDepthChunk = function getScreenDepthChunk(device, cameraShaderParams) {
			return "\n            " + (cameraShaderParams.sceneDepthMapLinear ? '#define SCENE_DEPTHMAP_LINEAR' : '') + "\n            " + (device.textureFloatRenderable ? '#define SCENE_DEPTHMAP_FLOAT' : '') + "\n            " + shaderChunks.screenDepthPS + "\n        ";
		};
		return ChunkUtils;
	}();

	var getProjectionName = function getProjectionName(projection) {
		switch (projection) {
			case TEXTUREPROJECTION_CUBE:
				return 'Cubemap';
			case TEXTUREPROJECTION_OCTAHEDRAL:
				return 'Octahedral';
			default:
				return 'Equirect';
		}
	};
	var packFloat32ToRGBA8 = function packFloat32ToRGBA8(value, array, offset) {
		if (value <= 0) {
			array[offset + 0] = 0;
			array[offset + 1] = 0;
			array[offset + 2] = 0;
			array[offset + 3] = 0;
		} else if (value >= 1.0) {
			array[offset + 0] = 255;
			array[offset + 1] = 0;
			array[offset + 2] = 0;
			array[offset + 3] = 0;
		} else {
			var encX = 1 * value % 1;
			var encY = 255 * value % 1;
			var encZ = 65025 * value % 1;
			var encW = 16581375.0 * value % 1;
			encX -= encY / 255;
			encY -= encZ / 255;
			encZ -= encW / 255;
			array[offset + 0] = Math.min(255, Math.floor(encX * 256));
			array[offset + 1] = Math.min(255, Math.floor(encY * 256));
			array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
			array[offset + 3] = Math.min(255, Math.floor(encW * 256));
		}
	};
	var packSamples = function packSamples(samples) {
		var numSamples = samples.length;
		var w = Math.min(numSamples, 512);
		var h = Math.ceil(numSamples / w);
		var data = new Uint8Array(w * h * 4);
		var off = 0;
		for (var i = 0; i < numSamples; i += 4) {
			packFloat32ToRGBA8(samples[i + 0] * 0.5 + 0.5, data, off + 0);
			packFloat32ToRGBA8(samples[i + 1] * 0.5 + 0.5, data, off + 4);
			packFloat32ToRGBA8(samples[i + 2] * 0.5 + 0.5, data, off + 8);
			packFloat32ToRGBA8(samples[i + 3] / 8, data, off + 12);
			off += 16;
		}
		return {
			width: w,
			height: h,
			data: data
		};
	};
	var hemisphereSamplePhong = function hemisphereSamplePhong(dstVec, x, y, specularPower) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};
	var hemisphereSampleLambert = function hemisphereSampleLambert(dstVec, x, y) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt(1 - x);
		var sinTheta = Math.sqrt(x);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};
	var hemisphereSampleGGX = function hemisphereSampleGGX(dstVec, x, y, a) {
		var phi = y * 2 * Math.PI;
		var cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
	};
	var D_GGX = function D_GGX(NoH, linearRoughness) {
		var a = NoH * linearRoughness;
		var k = linearRoughness / (1.0 - NoH * NoH + a * a);
		return k * k * (1 / Math.PI);
	};
	var generatePhongSamples = function generatePhongSamples(numSamples, specularPower) {
		var H = new Vec3();
		var result = [];
		for (var i = 0; i < numSamples; ++i) {
			hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
			result.push(H.x, H.y, H.z, 0);
		}
		return result;
	};
	var generateLambertSamples = function generateLambertSamples(numSamples, sourceTotalPixels) {
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var H = new Vec3();
		var result = [];
		for (var i = 0; i < numSamples; ++i) {
			hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
			var pdf = H.z / Math.PI;
			var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
			result.push(H.x, H.y, H.z, mipLevel);
		}
		return result;
	};
	var requiredSamplesGGX = {
		'16': {
			'2': 26,
			'8': 20,
			'32': 17,
			'128': 16,
			'512': 16
		},
		'32': {
			'2': 53,
			'8': 40,
			'32': 34,
			'128': 32,
			'512': 32
		},
		'128': {
			'2': 214,
			'8': 163,
			'32': 139,
			'128': 130,
			'512': 128
		},
		'1024': {
			'2': 1722,
			'8': 1310,
			'32': 1114,
			'128': 1041,
			'512': 1025
		}
	};
	var getRequiredSamplesGGX = function getRequiredSamplesGGX(numSamples, specularPower) {
		var table = requiredSamplesGGX[numSamples];
		return table && table[specularPower] || numSamples;
	};
	var generateGGXSamples = function generateGGXSamples(numSamples, specularPower, sourceTotalPixels) {
		var pixelsPerSample = sourceTotalPixels / numSamples;
		var roughness = 1 - Math.log2(specularPower) / 11.0;
		var a = roughness * roughness;
		var H = new Vec3();
		var L = new Vec3();
		var N = new Vec3(0, 0, 1);
		var result = [];
		var requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);
		for (var i = 0; i < requiredSamples; ++i) {
			hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
			var NoH = H.z;
			L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);
			if (L.z > 0) {
				var pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
				var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
				result.push(L.x, L.y, L.z, mipLevel);
			}
		}
		while (result.length < numSamples * 4) {
			result.push(0, 0, 0, 0);
		}
		return result;
	};
	var createSamplesTex = function createSamplesTex(device, name, samples) {
		var packedSamples = packSamples(samples);
		return new Texture(device, {
			name: name,
			width: packedSamples.width,
			height: packedSamples.height,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			levels: [packedSamples.data]
		});
	};
	var SimpleCache = function () {
		function SimpleCache(destroyContent) {
			if (destroyContent === void 0) {
				destroyContent = true;
			}
			this.map = new Map();
			this.destroyContent = destroyContent;
		}
		var _proto = SimpleCache.prototype;
		_proto.destroy = function destroy() {
			if (this.destroyContent) {
				this.map.forEach(function (value, key) {
					value.destroy();
				});
			}
		};
		_proto.get = function get(key, missFunc) {
			if (!this.map.has(key)) {
				var result = missFunc();
				this.map.set(key, result);
				return result;
			}
			return this.map.get(key);
		};
		return SimpleCache;
	}();
	var samplesCache = new SimpleCache(false);
	var deviceCache$1 = new DeviceCache();
	var getCachedTexture = function getCachedTexture(device, key, getSamplesFnc) {
		var cache = deviceCache$1.get(device, function () {
			return new SimpleCache();
		});
		return cache.get(key, function () {
			return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
		});
	};
	var generateLambertSamplesTex = function generateLambertSamplesTex(device, numSamples, sourceTotalPixels) {
		var key = "lambert-samples-" + numSamples + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, function () {
			return generateLambertSamples(numSamples, sourceTotalPixels);
		});
	};
	var generatePhongSamplesTex = function generatePhongSamplesTex(device, numSamples, specularPower) {
		var key = "phong-samples-" + numSamples + "-" + specularPower;
		return getCachedTexture(device, key, function () {
			return generatePhongSamples(numSamples, specularPower);
		});
	};
	var generateGGXSamplesTex = function generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) {
		var key = "ggx-samples-" + numSamples + "-" + specularPower + "-" + sourceTotalPixels;
		return getCachedTexture(device, key, function () {
			return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
		});
	};
	var vsCode = "\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);\n}\n";
	function reprojectTexture(source, target, options) {
		var _options$seamPixels, _options$rect$z, _options$rect, _options$rect$w, _options$rect2;
		if (options === void 0) {
			options = {};
		}
		var seamPixels = (_options$seamPixels = options.seamPixels) != null ? _options$seamPixels : 0;
		var innerWidth = ((_options$rect$z = (_options$rect = options.rect) == null ? void 0 : _options$rect.z) != null ? _options$rect$z : target.width) - seamPixels * 2;
		var innerHeight = ((_options$rect$w = (_options$rect2 = options.rect) == null ? void 0 : _options$rect2.w) != null ? _options$rect$w : target.height) - seamPixels * 2;
		if (innerWidth < 1 || innerHeight < 1) {
			return false;
		}
		var funcNames = {
			'none': 'reproject',
			'lambert': 'prefilterSamplesUnweighted',
			'phong': 'prefilterSamplesUnweighted',
			'ggx': 'prefilterSamples'
		};
		var specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
		var face = options.hasOwnProperty('face') ? options.face : null;
		var distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
		var processFunc = funcNames[distribution] || 'reproject';
		var prefilterSamples = processFunc.startsWith('prefilterSamples');
		var decodeFunc = ChunkUtils.decodeFunc(source.encoding);
		var encodeFunc = ChunkUtils.encodeFunc(target.encoding);
		var sourceFunc = "sample" + getProjectionName(source.projection);
		var targetFunc = "getDirection" + getProjectionName(target.projection);
		var numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
		var shaderKey = processFunc + "_" + decodeFunc + "_" + encodeFunc + "_" + sourceFunc + "_" + targetFunc + "_" + numSamples;
		var device = source.device;
		var shader = getProgramLibrary(device).getCachedShader(shaderKey);
		if (!shader) {
			var defines = "#define PROCESS_FUNC " + processFunc + "\n" + (prefilterSamples ? '#define USE_SAMPLES_TEX\n' : '') + (source.cubemap ? '#define CUBEMAP_SOURCE\n' : '') + "#define DECODE_FUNC " + decodeFunc + "\n" + ("#define ENCODE_FUNC " + encodeFunc + "\n") + ("#define SOURCE_FUNC " + sourceFunc + "\n") + ("#define TARGET_FUNC " + targetFunc + "\n") + ("#define NUM_SAMPLES " + numSamples + "\n") + ("#define NUM_SAMPLES_SQRT " + Math.round(Math.sqrt(numSamples)).toFixed(1) + "\n");
			shader = createShaderFromCode(device, vsCode, defines + "\n" + shaderChunks.reprojectPS, shaderKey);
		}
		device.setBlendState(BlendState.NOBLEND);
		var constantSource = device.scope.resolve(source.cubemap ? 'sourceCube' : 'sourceTex');
		constantSource.setValue(source);
		var constantParams = device.scope.resolve('params');
		var uvModParam = device.scope.resolve('uvMod');
		if (seamPixels > 0) {
			uvModParam.setValue([(innerWidth + seamPixels * 2) / innerWidth, (innerHeight + seamPixels * 2) / innerHeight, -seamPixels / innerWidth, -seamPixels / innerHeight]);
		} else {
			uvModParam.setValue([1, 1, 0, 0]);
		}
		var params = [0, target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];
		if (prefilterSamples) {
			var sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
			var samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
			device.scope.resolve('samplesTex').setValue(samplesTex);
			device.scope.resolve('samplesTexInverseSize').setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);
		}
		for (var f = 0; f < (target.cubemap ? 6 : 1); f++) {
			if (face === null || f === face) {
				var _options;
				var renderTarget = new RenderTarget({
					colorBuffer: target,
					face: f,
					depth: false,
					flipY: device.isWebGPU
				});
				params[0] = f;
				constantParams.setValue(params);
				drawQuadWithShader(device, renderTarget, shader, (_options = options) == null ? void 0 : _options.rect);
				renderTarget.destroy();
			}
		}
		return true;
	}

	var calcLevels = function calcLevels(width, height) {
		if (height === void 0) {
			height = 0;
		}
		return 1 + Math.floor(Math.log2(Math.max(width, height)));
	};
	var supportsFloat16 = function supportsFloat16(device) {
		return device.textureHalfFloatRenderable;
	};
	var supportsFloat32 = function supportsFloat32(device) {
		return device.textureFloatRenderable;
	};
	var lightingSourcePixelFormat = function lightingSourcePixelFormat(device) {
		return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA8;
	};
	var lightingPixelFormat = function lightingPixelFormat(device) {
		return PIXELFORMAT_RGBA8;
	};
	var createCubemap = function createCubemap(device, size, format, mipmaps) {
		return new Texture(device, {
			name: "lighting-" + size,
			cubemap: true,
			width: size,
			height: size,
			format: format,
			type: TEXTURETYPE_RGBP ,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			mipmaps: !!mipmaps
		});
	};
	var EnvLighting = function () {
		function EnvLighting() {}
		EnvLighting.generateSkyboxCubemap = function generateSkyboxCubemap(source, size) {
			var device = source.device;
			var result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_RGBA8, false);
			reprojectTexture(source, result, {
				numSamples: 1024
			});
			return result;
		};
		EnvLighting.generateLightingSource = function generateLightingSource(source, options) {
			var device = source.device;
			var format = lightingSourcePixelFormat(device);
			var result = (options == null ? void 0 : options.target) || new Texture(device, {
				name: 'lighting-source',
				cubemap: true,
				width: (options == null ? void 0 : options.size) || 128,
				height: (options == null ? void 0 : options.size) || 128,
				format: format,
				type: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: true
			});
			reprojectTexture(source, result, {
				numSamples: source.mipmaps ? 1 : 1024
			});
			return result;
		};
		EnvLighting.generateAtlas = function generateAtlas(source, options) {
			var device = source.device;
			var format = lightingPixelFormat();
			var result = (options == null ? void 0 : options.target) || new Texture(device, {
				name: 'envAtlas',
				width: (options == null ? void 0 : options.size) || 512,
				height: (options == null ? void 0 : options.size) || 512,
				format: format,
				type: TEXTURETYPE_RGBP ,
				projection: TEXTUREPROJECTION_EQUIRECT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
			});
			var s = result.width / 512;
			var rect = new Vec4(0, 0, 512 * s, 256 * s);
			var levels = calcLevels(256) - calcLevels(4);
			for (var i = 0; i < levels; ++i) {
				reprojectTexture(source, result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.x += rect.w;
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(0, 256 * s, 256 * s, 128 * s);
			for (var _i = 1; _i < 7; ++_i) {
				reprojectTexture(source, result, {
					numSamples: (options == null ? void 0 : options.numReflectionSamples) || 1024,
					distribution: (options == null ? void 0 : options.distribution) || 'ggx',
					specularPower: Math.max(1, 2048 >> _i * 2),
					rect: rect,
					seamPixels: s
				});
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
			reprojectTexture(source, result, {
				numSamples: (options == null ? void 0 : options.numAmbientSamples) || 2048,
				distribution: 'lambert',
				rect: rect,
				seamPixels: s
			});
			return result;
		};
		EnvLighting.generatePrefilteredAtlas = function generatePrefilteredAtlas(sources, options) {
			var device = sources[0].device;
			var format = sources[0].format;
			var type = sources[0].type;
			var result = (options == null ? void 0 : options.target) || new Texture(device, {
				name: 'envPrefilteredAtlas',
				width: (options == null ? void 0 : options.size) || 512,
				height: (options == null ? void 0 : options.size) || 512,
				format: format,
				type: type,
				projection: TEXTUREPROJECTION_EQUIRECT,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				mipmaps: false
			});
			var s = result.width / 512;
			var rect = new Vec4(0, 0, 512 * s, 256 * s);
			var levels = calcLevels(512);
			for (var i = 0; i < levels; ++i) {
				reprojectTexture(sources[0], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.x += rect.w;
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(0, 256 * s, 256 * s, 128 * s);
			for (var _i2 = 1; _i2 < sources.length; ++_i2) {
				reprojectTexture(sources[_i2], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
				rect.y += rect.w;
				rect.z = Math.max(1, Math.floor(rect.z * 0.5));
				rect.w = Math.max(1, Math.floor(rect.w * 0.5));
			}
			rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
			if (options != null && options.legacyAmbient) {
				reprojectTexture(sources[5], result, {
					numSamples: 1,
					rect: rect,
					seamPixels: s
				});
			} else {
				reprojectTexture(sources[0], result, {
					numSamples: (options == null ? void 0 : options.numSamples) || 2048,
					distribution: 'lambert',
					rect: rect,
					seamPixels: s
				});
			}
			return result;
		};
		return EnvLighting;
	}();

	var ChunkBuilder = function () {
		function ChunkBuilder() {
			this.code = '';
		}
		var _proto = ChunkBuilder.prototype;
		_proto.append = function append() {
			var _this = this;
			for (var _len = arguments.length, chunks = new Array(_len), _key = 0; _key < _len; _key++) {
				chunks[_key] = arguments[_key];
			}
			chunks.forEach(function (chunk) {
				if (chunk.endsWith('\n')) {
					_this.code += chunk;
				} else {
					_this.code += chunk + "\n";
				}
			});
		};
		_proto.prepend = function prepend() {
			var _this2 = this;
			for (var _len2 = arguments.length, chunks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				chunks[_key2] = arguments[_key2];
			}
			chunks.forEach(function (chunk) {
				if (chunk.endsWith('\n')) {
					_this2.code = chunk + _this2.code;
				} else {
					_this2.code = chunk + "\n" + _this2.code;
				}
			});
		};
		return ChunkBuilder;
	}();

	var builtinAttributes = {
		vertex_normal: SEMANTIC_NORMAL,
		vertex_tangent: SEMANTIC_TANGENT,
		vertex_texCoord0: SEMANTIC_TEXCOORD0,
		vertex_texCoord1: SEMANTIC_TEXCOORD1,
		vertex_color: SEMANTIC_COLOR,
		vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
		vertex_boneIndices: SEMANTIC_BLENDINDICES
	};
	var builtinVaryings = {
		vVertexColor: 'vec4',
		vPositionW: 'vec3',
		vNormalV: 'vec3',
		vNormalW: 'vec3',
		vTangentW: 'vec3',
		vBinormalW: 'vec3',
		vObjectSpaceUpW: 'vec3',
		vUv0: 'vec2',
		vUv1: 'vec2',
		vLinearDepth: 'float'
	};
	var LitShader = function () {
		function LitShader(device, options) {
			this.device = device;
			this.options = options;
			this.attributes = {
				vertex_position: SEMANTIC_POSITION
			};
			if (options.userAttributes) {
				for (var _i = 0, _Object$entries = Object.entries(options.userAttributes); _i < _Object$entries.length; _i++) {
					var _Object$entries$_i = _Object$entries[_i],
						semantic = _Object$entries$_i[0],
						name = _Object$entries$_i[1];
					this.attributes[name] = semantic;
				}
			}
			if (options.chunks) {
				var userChunks = options.chunks;
				this.chunks = Object.create(shaderChunks);
				for (var chunkName in shaderChunks) {
					if (userChunks.hasOwnProperty(chunkName)) {
						var chunk = userChunks[chunkName];
						for (var a in builtinAttributes) {
							if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
								this.attributes[a] = builtinAttributes[a];
							}
						}
						this.chunks[chunkName] = chunk;
					}
				}
			} else {
				this.chunks = shaderChunks;
			}
			this.shaderPassInfo = ShaderPass.get(this.device).getByIndex(options.pass);
			this.shadowPass = this.shaderPassInfo.isShadow;
			this.lighting = options.lights.length > 0 || options.dirLightMapEnabled || options.clusteredLightingEnabled;
			this.reflections = !!options.reflectionSource;
			this.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.useHeights || options.enableGGXSpecular || options.clusteredLightingEnabled && !this.shadowPass || options.useClearCoatNormals;
			this.needsNormal = this.needsNormal && !this.shadowPass;
			this.needsSceneColor = options.useDynamicRefraction;
			this.needsScreenSize = options.useDynamicRefraction;
			this.needsTransforms = options.useDynamicRefraction;
			this.varyings = '';
			this.varyingDefines = '';
			this.vshader = null;
			this.frontendDecl = null;
			this.frontendCode = null;
			this.frontendFunc = null;
			this.lightingUv = null;
			this.defines = [];
			this.fshader = null;
		}
		var _proto = LitShader.prototype;
		_proto._vsAddBaseCode = function _vsAddBaseCode(code, chunks, options) {
			code += chunks.baseVS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				code += chunks.baseNineSlicedVS;
			}
			return code;
		};
		_proto._setMapTransform = function _setMapTransform(codes, name, id, uv) {
			var checkId = id + uv * 100;
			if (!codes[3][checkId]) {
				var varName = "texture_" + name + "MapTransform";
				codes[0] += "uniform vec3 " + varName + "0;\n";
				codes[0] += "uniform vec3 " + varName + "1;\n";
				codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
				codes[2] += "   vUV" + uv + "_" + id + " = vec2(dot(vec3(uv" + uv + ", 1), " + varName + "0), dot(vec3(uv" + uv + ", 1), " + varName + "1));\n";
				codes[3][checkId] = true;
			}
			return codes;
		};
		_proto._fsGetBaseCode = function _fsGetBaseCode() {
			var options = this.options;
			var chunks = this.chunks;
			var result = this.chunks.basePS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				result += chunks.baseNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				result += chunks.baseNineSlicedTiledPS;
			}
			return result;
		};
		_proto._fsGetStartCode = function _fsGetStartCode(code, device, chunks, options) {
			var result = chunks.startPS;
			if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				result += chunks.startNineSlicedPS;
			} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				result += chunks.startNineSlicedTiledPS;
			}
			return result;
		};
		_proto._getLightSourceShapeString = function _getLightSourceShapeString(shape) {
			switch (shape) {
				case LIGHTSHAPE_RECT:
					return 'Rect';
				case LIGHTSHAPE_DISK:
					return 'Disk';
				case LIGHTSHAPE_SPHERE:
					return 'Sphere';
				default:
					return '';
			}
		};
		_proto.generateVertexShader = function generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {
			var _this = this;
			var device = this.device;
			var options = this.options;
			var chunks = this.chunks;
			var code = '';
			var codeBody = '';
			var codeDefines = '';
			code = this._vsAddBaseCode(code, chunks, options);
			codeBody += '   vPositionW = getWorldPosition();\n';
			if (this.options.linearDepth) {
				codeDefines += "\n                #ifndef VIEWMATRIX\n                #define VIEWMATRIX\n                    uniform mat4 matrix_view;\n                #endif\n            ";
				codeBody += "\n                // linear depth from the worldPosition, see getLinearDepth\n                vLinearDepth = -(matrix_view * vec4(vPositionW, 1.0)).z;\n            ";
			}
			if (this.options.useInstancing) {
				if (this.chunks.transformInstancingVS === shaderChunks.transformInstancingVS) {
					this.attributes.instance_line1 = SEMANTIC_ATTR12;
					this.attributes.instance_line2 = SEMANTIC_ATTR13;
					this.attributes.instance_line3 = SEMANTIC_ATTR14;
					this.attributes.instance_line4 = SEMANTIC_ATTR15;
				}
			}
			code += chunks.transformVS;
			if (this.needsNormal) {
				code += chunks.normalCoreVS;
				code += chunks.normalVS;
			}
			if (this.needsNormal) {
				this.attributes.vertex_normal = SEMANTIC_NORMAL;
				codeBody += '   vNormalW = getNormal();\n';
				if (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {
					code += chunks.viewNormalVS;
					codeBody += '   vNormalV    = getViewNormal();\n';
				}
				if (options.hasTangents && (options.useHeights || options.useNormals || options.enableGGXSpecular)) {
					this.attributes.vertex_tangent = SEMANTIC_TANGENT;
					code += chunks.tangentBinormalVS;
					codeBody += '   vTangentW   = getTangent();\n';
					codeBody += '   vBinormalW  = getBinormal();\n';
				} else if (options.enableGGXSpecular) {
					codeBody += '   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n';
				}
			}
			var maxUvSets = 2;
			for (var i = 0; i < maxUvSets; i++) {
				if (useUv[i]) {
					this.attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
					code += chunks["uv" + i + "VS"];
					codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
				}
				if (useUnmodifiedUv[i]) {
					codeBody += "   vUv" + i + " = uv" + i + ";\n";
				}
			}
			var codes = [code, this.varyings, codeBody, []];
			mapTransforms.forEach(function (mapTransform) {
				_this._setMapTransform(codes, mapTransform.name, mapTransform.id, mapTransform.uv);
			});
			code = codes[0];
			this.varyings = codes[1];
			codeBody = codes[2];
			if (options.vertexColors) {
				this.attributes.vertex_color = SEMANTIC_COLOR;
				codeBody += '   vVertexColor = vertex_color;\n';
			}
			if (options.useMsdf && options.msdfTextAttribute) {
				this.attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
				this.attributes.vertex_shadowParameters = SEMANTIC_ATTR9;
				codeBody += '    unpackMsdfParams();\n';
				code += chunks.msdfVS;
			}
			if (options.useMorphPosition || options.useMorphNormal) {
				codeDefines += '#define MORPHING\n';
				if (options.useMorphTextureBasedInt) {
					codeDefines += '#define MORPHING_INT\n';
				}
				if (options.useMorphPosition) {
					codeDefines += '#define MORPHING_POSITION\n';
				}
				if (options.useMorphNormal) {
					codeDefines += '#define MORPHING_NORMAL\n';
				}
				this.attributes.morph_vertex_id = SEMANTIC_ATTR15;
			}
			if (options.skin) {
				this.attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
				if (options.batch) {
					codeDefines += '#define BATCH\n';
				} else {
					this.attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
					codeDefines += '#define SKIN\n';
				}
			} else if (options.useInstancing) {
				codeDefines += '#define INSTANCING\n';
			}
			if (options.screenSpace) {
				codeDefines += '#define SCREENSPACE\n';
			}
			if (options.pixelSnap) {
				codeDefines += '#define PIXELSNAP\n';
			}
			code += '\n';
			code += chunks.startVS;
			code += codeBody;
			code += chunks.endVS;
			code += '}';
			Object.keys(builtinVaryings).forEach(function (v) {
				if (code.indexOf(v) >= 0) {
					_this.varyings += "varying " + builtinVaryings[v] + " " + v + ";\n";
					_this.varyingDefines += "#define VARYING_" + v.toUpperCase() + "\n";
				}
			});
			var shaderPassDefines = this.shaderPassInfo.shaderDefines;
			this.vshader = shaderPassDefines + codeDefines + this.varyings + code;
		};
		_proto._fsGetBeginCode = function _fsGetBeginCode() {
			var code = this.shaderPassInfo.shaderDefines;
			for (var i = 0; i < this.defines.length; i++) {
				code += "#define " + this.defines[i] + "\n";
			}
			return code;
		};
		_proto._fsGetPickPassCode = function _fsGetPickPassCode() {
			return "\n            " + this._fsGetBeginCode() + "\n            " + this.varyings + "\n            " + this.varyingDefines + "\n            " + this.frontendDecl + "\n            " + this.frontendCode + "\n            " + this.chunks.pickPS + "\n\n            void main(void) {\n                " + this.frontendFunc + "\n                gl_FragColor = getPickOutput();\n            }\n        ";
		};
		_proto._fsGetDepthPassCode = function _fsGetDepthPassCode() {
			var code = this._fsGetBeginCode();
			code += this.varyings;
			code += this.varyingDefines;
			code += this.frontendDecl;
			code += this.frontendCode;
			code += ShaderGenerator.begin();
			code += this.frontendFunc;
			code += '    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n';
			code += ShaderGenerator.end();
			return code;
		};
		_proto._fsGetPrePassCode = function _fsGetPrePassCode() {
			var code = this._fsGetBeginCode();
			code += this.varyings;
			code += this.varyingDefines;
			code += this.frontendDecl;
			code += this.frontendCode;
			code += ShaderGenerator.begin();
			code += this.frontendFunc;
			code += this.device.textureFloatRenderable ? "\n            gl_FragColor = vec4(vLinearDepth, 1.0, 1.0, 1.0);\n        " : "\n            uint intBits = floatBitsToUint(vLinearDepth);\n            gl_FragColor = vec4(\n                float((intBits >> 24u) & 0xFFu) / 255.0,\n                float((intBits >> 16u) & 0xFFu) / 255.0,\n                float((intBits >> 8u) & 0xFFu) / 255.0,\n                float(intBits & 0xFFu) / 255.0\n            );\n        ";
			code += ShaderGenerator.end();
			return code;
		};
		_proto._fsGetShadowPassCode = function _fsGetShadowPassCode() {
			var _shadowInfo$vsm, _shadowInfo$pcss;
			var options = this.options;
			var chunks = this.chunks;
			var varyings = this.varyings;
			var lightType = this.shaderPassInfo.lightType;
			var shadowType = this.shaderPassInfo.shadowType;
			if (lightType !== LIGHTTYPE_DIRECTIONAL && options.clusteredLightingEnabled) {
				if (shadowType === SHADOW_VSM_16F || shadowType === SHADOW_VSM_32F || shadowType === SHADOW_PCSS_32F) {
					shadowType = SHADOW_PCF3_32F;
				}
			}
			var shadowInfo = shadowTypeInfo.get(shadowType);
			var isVsm = (_shadowInfo$vsm = shadowInfo == null ? void 0 : shadowInfo.vsm) != null ? _shadowInfo$vsm : false;
			var isPcss = (_shadowInfo$pcss = shadowInfo == null ? void 0 : shadowInfo.pcss) != null ? _shadowInfo$pcss : false;
			var code = this._fsGetBeginCode();
			if (shadowType === SHADOW_VSM_32F) {
				code += '#define VSM_EXPONENT 15.0\n\n';
			} else if (shadowType === SHADOW_VSM_16F) {
				code += '#define VSM_EXPONENT 5.54\n\n';
			}
			if (lightType !== LIGHTTYPE_DIRECTIONAL) {
				code += 'uniform vec3 view_position;\n';
				code += 'uniform float light_radius;\n';
			}
			code += varyings;
			code += this.varyingDefines;
			code += this.frontendDecl;
			code += this.frontendCode;
			if (shadowType === SHADOW_PCSS_32F) {
				code += shaderChunks.linearizeDepthPS;
			}
			code += ShaderGenerator.begin();
			code += this.frontendFunc;
			var usePerspectiveDepth = lightType === LIGHTTYPE_DIRECTIONAL || !isVsm && lightType === LIGHTTYPE_SPOT;
			var hasModifiedDepth = false;
			if (usePerspectiveDepth) {
				code += '    float depth = gl_FragCoord.z;\n';
				if (isPcss) {
					code += '    depth = linearizeDepth(depth, camera_params);\n';
				}
			} else {
				code += '    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n';
				hasModifiedDepth = true;
			}
			if (!isVsm) {
				var exportR32 = isPcss;
				if (exportR32) {
					code += '    gl_FragColor.r = depth;\n';
				} else {
					if (hasModifiedDepth) {
						code += '    gl_FragDepth = depth;\n';
					}
					code += '    gl_FragColor = vec4(1.0);\n';
				}
			} else {
				code += chunks.storeEVSMPS;
			}
			code += ShaderGenerator.end();
			return code;
		};
		_proto._fsGetLitPassCode = function _fsGetLitPassCode() {
			var device = this.device;
			var options = this.options;
			var chunks = this.chunks;
			var decl = new ChunkBuilder();
			var func = new ChunkBuilder();
			var backend = new ChunkBuilder();
			var code = new ChunkBuilder();
			if (options.opacityFadesSpecular === false) {
				decl.append('uniform float material_alphaFade;');
			}
			if (options.useSpecular) {
				this.defines.push('LIT_SPECULAR');
				if (this.reflections) {
					this.defines.push('LIT_REFLECTIONS');
				}
				if (options.useClearCoat) {
					this.defines.push('LIT_CLEARCOAT');
				}
				if (options.fresnelModel > 0) {
					this.defines.push('LIT_SPECULAR_FRESNEL');
				}
				if (options.useSheen) {
					this.defines.push('LIT_SHEEN');
				}
				if (options.useIridescence) {
					this.defines.push('LIT_IRIDESCENCE');
				}
			}
			var shadowTypeUsed = [];
			var numShadowLights = 0;
			var shadowedDirectionalLightUsed = false;
			var useVsm = false;
			var usePcss = false;
			var hasAreaLights = options.lights.some(function (light) {
				return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
			});
			if (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {
				hasAreaLights = true;
			}
			if (hasAreaLights || options.clusteredLightingEnabled) {
				decl.append('#define AREA_LIGHTS');
				decl.append('uniform highp sampler2D areaLightsLutTex1;');
				decl.append('uniform highp sampler2D areaLightsLutTex2;');
			}
			for (var i = 0; i < options.lights.length; i++) {
				var light = options.lights[i];
				var lightType = light._type;
				if (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
					continue;
				}
				var lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
				decl.append("uniform vec3 light" + i + "_color;");
				if (light._shadowType === SHADOW_PCSS_32F && light.castShadows && !options.noShadow) {
					decl.append("uniform float light" + i + "_shadowSearchArea;");
					decl.append("uniform vec4 light" + i + "_cameraParams;");
				}
				if (lightType === LIGHTTYPE_DIRECTIONAL) {
					decl.append("uniform vec3 light" + i + "_direction;");
				} else {
					decl.append("uniform vec3 light" + i + "_position;");
					decl.append("uniform float light" + i + "_radius;");
					if (lightType === LIGHTTYPE_SPOT) {
						decl.append("uniform vec3 light" + i + "_direction;");
						decl.append("uniform float light" + i + "_innerConeAngle;");
						decl.append("uniform float light" + i + "_outerConeAngle;");
					}
				}
				if (lightShape !== LIGHTSHAPE_PUNCTUAL) {
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						decl.append("uniform vec3 light" + i + "_position;");
					}
					decl.append("uniform vec3 light" + i + "_halfWidth;");
					decl.append("uniform vec3 light" + i + "_halfHeight;");
				}
				if (light.castShadows && !options.noShadow) {
					decl.append("uniform mat4 light" + i + "_shadowMatrix;");
					decl.append("uniform float light" + i + "_shadowIntensity;");
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						decl.append("uniform mat4 light" + i + "_shadowMatrixPalette[4];");
						decl.append("uniform vec4 light" + i + "_shadowCascadeDistances;");
						decl.append("uniform int light" + i + "_shadowCascadeCount;");
						decl.append("uniform float light" + i + "_shadowCascadeBlend;");
					}
					decl.append("uniform vec4 light" + i + "_shadowParams;");
					if (lightType === LIGHTTYPE_DIRECTIONAL) {
						shadowedDirectionalLightUsed = true;
					}
					if (lightType === LIGHTTYPE_OMNI) {
						decl.append("uniform " + (light._isPcf ? 'samplerCubeShadow' : 'samplerCube') + " light" + i + "_shadowMap;");
					} else {
						decl.append("uniform " + (light._isPcf ? 'sampler2DShadow' : 'sampler2D') + " light" + i + "_shadowMap;");
					}
					numShadowLights++;
					shadowTypeUsed[light._shadowType] = true;
					if (light._isVsm) useVsm = true;
					if (light._shadowType === SHADOW_PCSS_32F) usePcss = true;
				}
				if (light._cookie) {
					if (light._cookie._cubemap) {
						if (lightType === LIGHTTYPE_OMNI) {
							decl.append("uniform samplerCube light" + i + "_cookie;");
							decl.append("uniform float light" + i + "_cookieIntensity;");
							if (!light.castShadows || options.noShadow) {
								decl.append("uniform mat4 light" + i + "_shadowMatrix;");
							}
						}
					} else {
						if (lightType === LIGHTTYPE_SPOT) {
							decl.append("uniform sampler2D light" + i + "_cookie;");
							decl.append("uniform float light" + i + "_cookieIntensity;");
							if (!light.castShadows || options.noShadow) {
								decl.append("uniform mat4 light" + i + "_shadowMatrix;");
							}
							if (light._cookieTransform) {
								decl.append("uniform vec4 light" + i + "_cookieMatrix;");
								decl.append("uniform vec2 light" + i + "_cookieOffset;");
							}
						}
					}
				}
			}
			var hasTBN = this.needsNormal && (options.useNormals || options.useClearCoatNormals || options.enableGGXSpecular && !options.useHeights);
			if (hasTBN) {
				if (options.hasTangents) {
					func.append(chunks.TBNPS);
				} else {
					if (options.useNormals || options.useClearCoatNormals) {
						func.append(chunks.TBNderivativePS.replace(/\$UV/g, this.lightingUv));
					} else {
						func.append(chunks.TBNObjectSpacePS);
					}
				}
				if (options.twoSidedLighting) {
					func.append(chunks.twoSidedLightingPS);
				}
			}
			func.append(chunks.sphericalPS);
			func.append(chunks.decodePS);
			func.append(ShaderGenerator.gammaCode(options.gamma, chunks));
			func.append(ShaderGenerator.tonemapCode(options.toneMap, chunks));
			func.append(ShaderGenerator.fogCode(options.fog, chunks));
			func.append(this.frontendCode);
			if (options.useCubeMapRotation) {
				decl.append('#define CUBEMAP_ROTATION');
			}
			if (this.needsNormal) {
				func.append(chunks.cubeMapRotatePS);
				func.append(options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS);
				func.append(options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS);
			}
			if (this.lighting && options.useSpecular || this.reflections) {
				if (options.useMetalness) {
					func.append(chunks.metalnessModulatePS);
				}
				if (options.fresnelModel === FRESNEL_SCHLICK) {
					func.append(chunks.fresnelSchlickPS);
				}
				if (options.useIridescence) {
					func.append(chunks.iridescenceDiffractionPS);
				}
			}
			if (options.useAo) {
				func.append(chunks.aoDiffuseOccPS);
				switch (options.occludeSpecular) {
					case SPECOCC_AO:
						func.append(options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS);
						break;
					case SPECOCC_GLOSSDEPENDENT:
						func.append(options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS);
						break;
				}
			}
			if (options.reflectionSource === 'envAtlasHQ') {
				func.append(chunks.envAtlasPS);
				func.append(chunks.reflectionEnvHQPS.replace(/\$DECODE_CUBEMAP/g, ChunkUtils.decodeFunc(options.reflectionCubemapEncoding)).replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			} else if (options.reflectionSource === 'envAtlas') {
				func.append(chunks.envAtlasPS);
				func.append(chunks.reflectionEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			} else if (options.reflectionSource === 'cubeMap') {
				func.append(chunks.reflectionCubePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			} else if (options.reflectionSource === 'sphereMap') {
				func.append(chunks.reflectionSpherePS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));
			}
			if (this.reflections) {
				if (options.useClearCoat) {
					func.append(chunks.reflectionCCPS);
				}
				if (options.useSheen) {
					func.append(chunks.reflectionSheenPS);
				}
			}
			if (options.useRefraction) {
				if (options.useDynamicRefraction) {
					if (options.dispersion) {
						decl.append('uniform float material_dispersion;');
						decl.append('#define DISPERSION\n');
					}
					func.append(chunks.refractionDynamicPS);
				} else if (this.reflections) {
					func.append(chunks.refractionCubePS);
				}
			}
			if (options.useSheen) {
				func.append(chunks.lightSheenPS);
			}
			if (options.clusteredLightingEnabled) {
				func.append(chunks.clusteredLightUtilsPS);
				if (options.clusteredLightingCookiesEnabled) {
					func.append(chunks.clusteredLightCookiesPS);
				}
				if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
					shadowTypeUsed[SHADOW_PCF3_32F] = true;
					shadowTypeUsed[SHADOW_PCF5_32F] = true;
					shadowTypeUsed[SHADOW_PCSS_32F] = true;
				}
			}
			if (numShadowLights > 0 || options.clusteredLightingEnabled) {
				if (shadowedDirectionalLightUsed) {
					func.append(chunks.shadowCascadesPS);
				}
				if (shadowTypeUsed[SHADOW_PCF1_32F] || shadowTypeUsed[SHADOW_PCF3_32F] || shadowTypeUsed[SHADOW_PCF1_16F] || shadowTypeUsed[SHADOW_PCF3_16F]) {
					func.append(chunks.shadowStandardPS);
				}
				if (shadowTypeUsed[SHADOW_PCF5_32F] || shadowTypeUsed[SHADOW_PCF5_16F]) {
					func.append(chunks.shadowStandardGL2PS);
				}
				if (useVsm) {
					func.append(chunks.shadowVSM_commonPS);
					if (shadowTypeUsed[SHADOW_VSM_16F]) {
						func.append(chunks.shadowEVSMPS.replace(/\$/g, '16'));
					}
					if (shadowTypeUsed[SHADOW_VSM_32F]) {
						func.append(device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, '32') : chunks.shadowEVSMnPS.replace(/\$/g, '32'));
					}
				}
				if (usePcss) {
					func.append(chunks.linearizeDepthPS);
					func.append(chunks.shadowPCSSPS);
				}
			}
			if (options.enableGGXSpecular) func.append('uniform float material_anisotropy;');
			if (this.lighting) {
				func.append(chunks.lightDiffuseLambertPS);
				if (hasAreaLights || options.clusteredLightingAreaLightsEnabled) {
					func.append(chunks.ltcPS);
				}
			}
			var useOldAmbient = false;
			if (options.useSpecular) {
				if (this.lighting) {
					func.append(options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS);
				}
				if (!options.fresnelModel && !this.reflections && !options.diffuseMapEnabled) {
					decl.append('uniform vec3 material_ambient;');
					decl.append('#define LIT_OLD_AMBIENT');
					useOldAmbient = true;
				}
			}
			func.append(chunks.combinePS);
			if (options.lightMapEnabled) {
				func.append(options.useSpecular && options.dirLightMapEnabled ? chunks.lightmapDirAddPS : chunks.lightmapAddPS);
			}
			var addAmbient = !options.lightMapEnabled || options.lightMapWithoutAmbient;
			if (addAmbient) {
				if (options.ambientSource === 'ambientSH') {
					func.append(chunks.ambientSHPS);
				} else if (options.ambientSource === 'envAtlas') {
					if (options.reflectionSource !== 'envAtlas' && options.reflectionSource !== 'envAtlasHQ') {
						func.append(chunks.envAtlasPS);
					}
					func.append(chunks.ambientEnvPS.replace(/\$DECODE/g, ChunkUtils.decodeFunc(options.ambientEncoding)));
				} else {
					func.append(chunks.ambientConstantPS);
				}
			}
			if (!useOldAmbient) {
				decl.append('uniform vec3 material_ambient;');
			}
			if (options.useMsdf) {
				if (!options.msdfTextAttribute) {
					decl.append('#define UNIFORM_TEXT_PARAMETERS');
				}
				func.append(chunks.msdfPS);
			}
			if (this.needsNormal) {
				func.append(chunks.viewDirPS);
				if (options.useSpecular) {
					func.append(options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS);
				}
			}
			var hasPointLights = false;
			var usesLinearFalloff = false;
			var usesInvSquaredFalloff = false;
			var usesSpot = false;
			var usesCookie = false;
			var usesCookieNow;
			if (options.clusteredLightingEnabled && this.lighting) {
				usesSpot = true;
				hasPointLights = true;
				usesLinearFalloff = true;
				usesCookie = true;
				func.append(chunks.floatUnpackingPS);
				if (options.lightMaskDynamic) {
					decl.append('#define CLUSTER_MESH_DYNAMIC_LIGHTS');
				}
				if (options.clusteredLightingCookiesEnabled) {
					decl.append('#define CLUSTER_COOKIES');
				}
				if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
					var _shadowTypeInfo$get;
					var shadowTypeName = (_shadowTypeInfo$get = shadowTypeInfo.get(options.clusteredLightingShadowType)) == null ? void 0 : _shadowTypeInfo$get.name;
					var clusteredSampleType = shadowTypeName.substring(0, 4);
					decl.append('#define CLUSTER_SHADOWS');
					decl.append("#define CLUSTER_SHADOW_TYPE_" + clusteredSampleType);
				}
				if (options.clusteredLightingAreaLightsEnabled) {
					decl.append('#define CLUSTER_AREALIGHTS');
				}
				decl.append(LightsBuffer.getShaderDefines());
				if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
					func.append(chunks.clusteredLightShadowsPS);
				}
				func.append(chunks.clusteredLightPS);
			}
			code.append(this._fsGetStartCode(code, device, chunks, options));
			if (this.needsNormal) {
				code.append('    dVertexNormalW = normalize(vNormalW);');
				if ((options.useHeights || options.useNormals) && options.hasTangents) {
					code.append('    dTangentW = vTangentW;');
					code.append('    dBinormalW = vBinormalW;');
				}
				code.append('    getViewDir();');
				if (hasTBN) {
					code.append('    getTBN(dTangentW, dBinormalW, dVertexNormalW);');
					if (options.twoSidedLighting) {
						code.append('    handleTwoSidedLighting();');
					}
				}
			}
			code.append(this.frontendFunc);
			if (options.ssao) {
				func.append("\n                    uniform sampler2D ssaoTexture;\n                    uniform vec2 ssaoTextureSizeInv;\n                ");
				backend.append('litArgs_ao *= texture2DLod(ssaoTexture, gl_FragCoord.xy * ssaoTextureSizeInv, 0.0).r;');
			}
			if (this.needsNormal) {
				if (options.useSpecular) {
					backend.append('    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);');
				}
				if (options.useClearCoat) {
					backend.append('    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));');
				}
			}
			if (this.lighting && options.useSpecular || this.reflections) {
				if (options.useMetalness) {
					backend.append('    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;');
					backend.append('    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);');
					backend.append('    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);');
				}
				if (options.useIridescence) {
					backend.append('    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);');
				}
			}
			if (addAmbient) {
				backend.append('    addAmbient(litArgs_worldNormal);');
				if (options.useSpecular) {
					backend.append('   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);');
				}
				if (options.separateAmbient) {
					backend.append("\n                    vec3 dAmbientLight = dDiffuseLight;\n                    dDiffuseLight = vec3(0);\n                ");
				}
			}
			if (!useOldAmbient) {
				backend.append('    dDiffuseLight *= material_ambient;');
			}
			if (options.useAo && !options.occludeDirect) {
				backend.append('    occludeDiffuse(litArgs_ao);');
			}
			if (options.lightMapEnabled) {
				backend.append("    addLightMap(\n                litArgs_lightmap, \n                litArgs_lightmapDir, \n                litArgs_worldNormal, \n                dViewDirW, \n                dReflDirW, \n                litArgs_gloss, \n                litArgs_specularity, \n                dVertexNormalW,\n                dTBN\n            #if defined(LIT_IRIDESCENCE)\n                , iridescenceFresnel,\n                litArgs_iridescence_intensity\n            #endif\n                );");
			}
			if (this.lighting || this.reflections) {
				if (this.reflections) {
					if (options.useClearCoat) {
						backend.append('    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);');
						if (options.fresnelModel > 0) {
							backend.append('    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));');
							backend.append('    ccReflection.rgb *= ccFresnel;');
						} else {
							backend.append('    ccFresnel = 0.0;');
						}
					}
					if (options.useSpecularityFactor) {
						backend.append('    ccReflection.rgb *= litArgs_specularityFactor;');
					}
					if (options.useSheen) {
						backend.append('    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);');
					}
					backend.append('    addReflection(dReflDirW, litArgs_gloss);');
					if (options.fresnelModel > 0) {
						backend.append("    dReflection.rgb *= \n                        getFresnel(\n                            dot(dViewDirW, litArgs_worldNormal), \n                            litArgs_gloss, \n                            litArgs_specularity\n                        #if defined(LIT_IRIDESCENCE)\n                            , iridescenceFresnel,\n                            litArgs_iridescence_intensity\n                        #endif\n                            );");
					} else {
						backend.append('    dReflection.rgb *= litArgs_specularity;');
					}
					if (options.useSpecularityFactor) {
						backend.append('    dReflection.rgb *= litArgs_specularityFactor;');
					}
				}
				if (hasAreaLights) {
					backend.append('    dSpecularLight *= litArgs_specularity;');
					if (options.useSpecular) {
						backend.append('    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);');
					}
				}
				for (var _i2 = 0; _i2 < options.lights.length; _i2++) {
					var _light = options.lights[_i2];
					var _lightType = _light._type;
					if (options.clusteredLightingEnabled && _lightType !== LIGHTTYPE_DIRECTIONAL) {
						continue;
					}
					usesCookieNow = false;
					var _lightShape = hasAreaLights && _light._shape ? _light.shape : LIGHTSHAPE_PUNCTUAL;
					var shapeString = hasAreaLights && _light._shape ? this._getLightSourceShapeString(_lightShape) : '';
					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						backend.append("    calc" + shapeString + "LightValues(light" + _i2 + "_position, light" + _i2 + "_halfWidth, light" + _i2 + "_halfHeight);");
					}
					if (_lightType === LIGHTTYPE_DIRECTIONAL) {
						backend.append("    dLightDirNormW = light" + _i2 + "_direction;");
						backend.append('    dAtten = 1.0;');
					} else {
						if (_light._cookie) {
							if (_lightType === LIGHTTYPE_SPOT && !_light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							} else if (_lightType === LIGHTTYPE_OMNI && _light._cookie._cubemap) {
								usesCookie = true;
								usesCookieNow = true;
							}
						}
						backend.append("    getLightDirPoint(light" + _i2 + "_position);");
						hasPointLights = true;
						if (usesCookieNow) {
							if (_lightType === LIGHTTYPE_SPOT) {
								backend.append("    dAtten3 = getCookie2D" + (_light._cookieFalloff ? '' : 'Clip') + (_light._cookieTransform ? 'Xform' : '') + "(light" + _i2 + "_cookie, light" + _i2 + "_shadowMatrix, light" + _i2 + "_cookieIntensity" + (_light._cookieTransform ? ", light" + _i2 + "_cookieMatrix, light" + _i2 + "_cookieOffset" : '') + ")." + _light._cookieChannel + ";");
							} else {
								backend.append("    dAtten3 = getCookieCube(light" + _i2 + "_cookie, light" + _i2 + "_shadowMatrix, light" + _i2 + "_cookieIntensity)." + _light._cookieChannel + ";");
							}
						}
						if (_lightShape === LIGHTSHAPE_PUNCTUAL) {
							if (_light._falloffMode === LIGHTFALLOFF_LINEAR) {
								backend.append("    dAtten = getFalloffLinear(light" + _i2 + "_radius, dLightDirW);");
								usesLinearFalloff = true;
							} else {
								backend.append("    dAtten = getFalloffInvSquared(light" + _i2 + "_radius, dLightDirW);");
								usesInvSquaredFalloff = true;
							}
						} else {
							backend.append("    dAtten = getFalloffWindow(light" + _i2 + "_radius, dLightDirW);");
							usesInvSquaredFalloff = true;
						}
						backend.append('    if (dAtten > 0.00001) {');
						if (_lightType === LIGHTTYPE_SPOT) {
							if (!(usesCookieNow && !_light._cookieFalloff)) {
								backend.append("    dAtten *= getSpotEffect(light" + _i2 + "_direction, light" + _i2 + "_innerConeAngle, light" + _i2 + "_outerConeAngle, dLightDirNormW);");
								usesSpot = true;
							}
						}
					}
					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						if (_lightType === LIGHTTYPE_DIRECTIONAL) {
							backend.append('    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);');
						} else {
							backend.append("    dAttenD = get" + shapeString + "LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;");
						}
					} else {
						backend.append('    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);');
					}
					if (_light.castShadows && !options.noShadow) {
						var shadowInfo = shadowTypeInfo.get(_light._shadowType);
						var pcssShadows = _light._shadowType === SHADOW_PCSS_32F;
						var vsmShadows = shadowInfo == null ? void 0 : shadowInfo.vsm;
						var pcfShadows = shadowInfo == null ? void 0 : shadowInfo.pcf;
						var shadowReadMode = null;
						var evsmExp = void 0;
						switch (_light._shadowType) {
							case SHADOW_VSM_16F:
								shadowReadMode = 'VSM16';
								evsmExp = '5.54';
								break;
							case SHADOW_VSM_32F:
								shadowReadMode = 'VSM32';
								evsmExp = '15.0';
								break;
							case SHADOW_PCF1_32F:
							case SHADOW_PCF1_16F:
								shadowReadMode = 'PCF1x1';
								break;
							case SHADOW_PCF5_32F:
							case SHADOW_PCF5_16F:
								shadowReadMode = 'PCF5x5';
								break;
							case SHADOW_PCSS_32F:
								shadowReadMode = 'PCSS';
								break;
							case SHADOW_PCF3_32F:
							case SHADOW_PCF3_16F:
							default:
								shadowReadMode = 'PCF3x3';
								break;
						}
						if (shadowReadMode !== null) {
							if (_light._normalOffsetBias && !_light._isVsm) {
								func.append('#define SHADOW_SAMPLE_NORMAL_OFFSET');
							}
							if (_lightType === LIGHTTYPE_DIRECTIONAL) {
								func.append('#define SHADOW_SAMPLE_ORTHO');
							}
							if (pcfShadows || pcssShadows || device.isWebGPU) {
								func.append('#define SHADOW_SAMPLE_SOURCE_ZBUFFER');
							}
							if (_lightType === LIGHTTYPE_OMNI) {
								func.append('#define SHADOW_SAMPLE_POINT');
							}
							var coordCode = chunks.shadowSampleCoordPS;
							func.append(coordCode.replace('$LIGHT', _i2));
							func.append('#undef SHADOW_SAMPLE_NORMAL_OFFSET');
							func.append('#undef SHADOW_SAMPLE_ORTHO');
							func.append('#undef SHADOW_SAMPLE_SOURCE_ZBUFFER');
							func.append('#undef SHADOW_SAMPLE_POINT');
							var shadowMatrix = "light" + _i2 + "_shadowMatrix";
							if (_lightType === LIGHTTYPE_DIRECTIONAL && _light.numCascades > 1) {
								backend.append("int cascadeIndex = getShadowCascadeIndex(light" + _i2 + "_shadowCascadeDistances, light" + _i2 + "_shadowCascadeCount);");
								if (_light.cascadeBlend > 0) {
									backend.append("cascadeIndex = ditherShadowCascadeIndex(cascadeIndex, light" + _i2 + "_shadowCascadeDistances, light" + _i2 + "_shadowCascadeCount, light" + _i2 + "_shadowCascadeBlend);");
								}
								backend.append("mat4 cascadeShadowMat = light" + _i2 + "_shadowMatrixPalette[cascadeIndex];");
								shadowMatrix = 'cascadeShadowMat';
							}
							backend.append("    dShadowCoord = getShadowSampleCoord" + _i2 + "(" + shadowMatrix + ", light" + _i2 + "_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);");
							if (_lightType === LIGHTTYPE_DIRECTIONAL) {
								backend.append("    fadeShadow(light" + _i2 + "_shadowCascadeDistances);");
							}
							var shadowCoordArgs = "SHADOWMAP_PASS(light" + _i2 + "_shadowMap), dShadowCoord, light" + _i2 + "_shadowParams";
							if (vsmShadows) {
								shadowCoordArgs = shadowCoordArgs + ", " + evsmExp + ", dLightDirW";
							} else if (pcssShadows) {
								var penumbraSizeArg = "vec2(light" + _i2 + "_shadowSearchArea)";
								if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
									penumbraSizeArg = "vec2(length(light" + _i2 + "_halfWidth), length(light" + _i2 + "_halfHeight)) * light" + _i2 + "_shadowSearchArea";
								}
								shadowCoordArgs = shadowCoordArgs + ", light" + _i2 + "_cameraParams, " + penumbraSizeArg + ", dLightDirW";
							}
							if (_lightType === LIGHTTYPE_OMNI) {
								shadowReadMode = "Point" + shadowReadMode;
								if (!pcssShadows) {
									shadowCoordArgs = shadowCoordArgs + ", dLightDirW";
								}
							} else if (_lightType === LIGHTTYPE_SPOT) {
								shadowReadMode = "Spot" + shadowReadMode;
							}
							backend.append("    float shadow" + _i2 + " = getShadow" + shadowReadMode + "(" + shadowCoordArgs + ");");
							backend.append("    dAtten *= mix(1.0, shadow" + _i2 + ", light" + _i2 + "_shadowIntensity);");
						}
					}
					if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
						if (options.useSpecular) {
							backend.append("    dDiffuseLight += ((dAttenD * dAtten) * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + ") * (1.0 - dLTCSpecFres);");
						} else {
							backend.append("    dDiffuseLight += (dAttenD * dAtten) * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + ";");
						}
					} else {
						if (hasAreaLights && options.useSpecular) {
							backend.append("    dDiffuseLight += (dAtten * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + ") * (1.0 - litArgs_specularity);");
						} else {
							backend.append("    dDiffuseLight += dAtten * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + ";");
						}
					}
					if (options.useSpecular) {
						backend.append('    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);');
					}
					if (_light.affectSpecularity) {
						if (_lightShape !== LIGHTSHAPE_PUNCTUAL) {
							if (options.useClearCoat) {
								backend.append("    ccSpecularLight += ccLTCSpecFres * get" + shapeString + "LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + ";");
							}
							if (options.useSpecular) {
								backend.append("    dSpecularLight += dLTCSpecFres * get" + shapeString + "LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + ";");
							}
						} else {
							var calcFresnel = false;
							if (_lightType === LIGHTTYPE_DIRECTIONAL && options.fresnelModel > 0) {
								calcFresnel = true;
							}
							if (options.useClearCoat) {
								backend.append("    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + (calcFresnel ? ' * getFresnelCC(dot(dViewDirW, dHalfDirW));' : ';'));
							}
							if (options.useSheen) {
								backend.append("    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3;' : ';'));
							}
							if (options.useSpecular) {
								backend.append("    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light" + _i2 + "_color" + (usesCookieNow ? ' * dAtten3' : '') + (calcFresnel ? " \n                                    * getFresnel(\n                                        dot(dViewDirW, dHalfDirW), \n                                        litArgs_gloss, \n                                        litArgs_specularity\n                                    #if defined(LIT_IRIDESCENCE)\n                                        , iridescenceFresnel, \n                                        litArgs_iridescence_intensity\n                                    #endif\n                                    );" : '* litArgs_specularity;'));
							}
						}
					}
					if (_lightType !== LIGHTTYPE_DIRECTIONAL) {
						backend.append('    }');
					}
				}
				if (options.clusteredLightingEnabled && this.lighting) {
					usesLinearFalloff = true;
					usesInvSquaredFalloff = true;
					hasPointLights = true;
					backend.append("    addClusteredLights(\n                                        litArgs_worldNormal, \n                                        dViewDirW, \n                                        dReflDirW,\n                                #if defined(LIT_CLEARCOAT)\n                                        ccReflDirW,\n                                #endif\n                                        litArgs_gloss, \n                                        litArgs_specularity, \n                                        dVertexNormalW, \n                                        dTBN, \n                                #if defined(LIT_IRIDESCENCE)\n                                        iridescenceFresnel,\n                                #endif\n                                        litArgs_clearcoat_worldNormal, \n                                        litArgs_clearcoat_gloss,\n                                        litArgs_sheen_gloss,\n                                        litArgs_iridescence_intensity\n                                    );");
				}
				if (hasAreaLights) {
					if (options.useClearCoat) {
						backend.append('    litArgs_clearcoat_specularity = 1.0;');
					}
					if (options.useSpecular) {
						backend.append('    litArgs_specularity = vec3(1);');
					}
				}
				if (options.useRefraction) {
					backend.append("    addRefraction(\n                        litArgs_worldNormal, \n                        dViewDirW, \n                        litArgs_thickness, \n                        litArgs_gloss, \n                        litArgs_specularity, \n                        litArgs_albedo, \n                        litArgs_transmission,\n                        litArgs_ior,\n                        litArgs_dispersion\n                    #if defined(LIT_IRIDESCENCE)\n                        , iridescenceFresnel, \n                        litArgs_iridescence_intensity\n                    #endif\n                    );");
				}
			}
			if (options.useAo) {
				if (options.occludeDirect) {
					backend.append('    occludeDiffuse(litArgs_ao);');
				}
				if (options.occludeSpecular === SPECOCC_AO || options.occludeSpecular === SPECOCC_GLOSSDEPENDENT) {
					backend.append('    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);');
				}
			}
			if (options.useSpecularityFactor) {
				backend.append('    dSpecularLight *= litArgs_specularityFactor;');
			}
			if (options.opacityFadesSpecular === false) {
				if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {
					backend.append('float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));');
					backend.append('#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif');
					backend.append('litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);');
				}
				backend.append('litArgs_opacity *= material_alphaFade;');
			}
			backend.append(chunks.endPS);
			if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
				backend.append(chunks.outputAlphaPS);
			} else if (options.blendType === BLEND_PREMULTIPLIED) {
				backend.append(chunks.outputAlphaPremulPS);
			} else {
				backend.append(chunks.outputAlphaOpaquePS);
			}
			if (options.useMsdf) {
				backend.append('    gl_FragColor = applyMsdf(gl_FragColor);');
			}
			backend.append(chunks.outputPS);
			backend.append(chunks.debugOutputPS);
			if (hasPointLights) {
				func.prepend(chunks.lightDirPointPS);
			}
			if (usesLinearFalloff) {
				func.prepend(chunks.falloffLinearPS);
			}
			if (usesInvSquaredFalloff) {
				func.prepend(chunks.falloffInvSquaredPS);
			}
			if (usesSpot) {
				func.prepend(chunks.spotPS);
			}
			if (usesCookie && !options.clusteredLightingEnabled) {
				func.prepend(chunks.cookiePS);
			}
			var structCode = '';
			var backendCode = "void evaluateBackend() {\n" + backend.code + "\n}";
			func.append(backendCode);
			code.append(chunks.debugProcessFrontendPS);
			code.append('    evaluateBackend();');
			code.append(ShaderGenerator.end());
			var mergedCode = decl.code + func.code + code.code;
			if (mergedCode.includes('dTBN')) structCode += 'mat3 dTBN;\n';
			if (mergedCode.includes('dVertexNormalW')) structCode += 'vec3 dVertexNormalW;\n';
			if (mergedCode.includes('dTangentW')) structCode += 'vec3 dTangentW;\n';
			if (mergedCode.includes('dBinormalW')) structCode += 'vec3 dBinormalW;\n';
			if (mergedCode.includes('dViewDirW')) structCode += 'vec3 dViewDirW;\n';
			if (mergedCode.includes('dReflDirW')) structCode += 'vec3 dReflDirW;\n';
			if (mergedCode.includes('dHalfDirW')) structCode += 'vec3 dHalfDirW;\n';
			if (mergedCode.includes('ccReflDirW')) structCode += 'vec3 ccReflDirW;\n';
			if (mergedCode.includes('dLightDirNormW')) structCode += 'vec3 dLightDirNormW;\n';
			if (mergedCode.includes('dLightDirW')) structCode += 'vec3 dLightDirW;\n';
			if (mergedCode.includes('dLightPosW')) structCode += 'vec3 dLightPosW;\n';
			if (mergedCode.includes('dShadowCoord')) structCode += 'vec3 dShadowCoord;\n';
			if (mergedCode.includes('dReflection')) structCode += 'vec4 dReflection;\n';
			if (mergedCode.includes('dDiffuseLight')) structCode += 'vec3 dDiffuseLight;\n';
			if (mergedCode.includes('dSpecularLight')) structCode += 'vec3 dSpecularLight;\n';
			if (mergedCode.includes('dAtten')) structCode += 'float dAtten;\n';
			if (mergedCode.includes('dAttenD')) structCode += 'float dAttenD;\n';
			if (mergedCode.includes('dAtten3')) structCode += 'vec3 dAtten3;\n';
			if (mergedCode.includes('dMsdf')) structCode += 'vec4 dMsdf;\n';
			if (mergedCode.includes('ccFresnel')) structCode += 'float ccFresnel;\n';
			if (mergedCode.includes('ccReflection')) structCode += 'vec3 ccReflection;\n';
			if (mergedCode.includes('ccSpecularLight')) structCode += 'vec3 ccSpecularLight;\n';
			if (mergedCode.includes('ccSpecularityNoFres')) structCode += 'float ccSpecularityNoFres;\n';
			if (mergedCode.includes('sSpecularLight')) structCode += 'vec3 sSpecularLight;\n';
			if (mergedCode.includes('sReflection')) structCode += 'vec3 sReflection;\n';
			var result = this._fsGetBeginCode() + this.varyings + this.varyingDefines + this._fsGetBaseCode() + structCode + this.frontendDecl + mergedCode;
			return result;
		};
		_proto.generateFragmentShader = function generateFragmentShader(frontendDecl, frontendCode, frontendFunc, lightingUv) {
			var _this$handleCompatibi;
			var options = this.options;
			this.frontendDecl = frontendDecl;
			this.frontendCode = frontendCode;
			this.frontendFunc = frontendFunc;
			this.lightingUv = lightingUv;
			if (options.pass === SHADER_PICK) {
				this.fshader = this._fsGetPickPassCode();
			} else if (options.pass === SHADER_DEPTH) {
				this.fshader = this._fsGetDepthPassCode();
			} else if (options.pass === SHADER_PREPASS) {
				this.fshader = this._fsGetPrePassCode();
			} else if (this.shadowPass) {
				this.fshader = this._fsGetShadowPassCode();
			} else if (options.customFragmentShader) {
				this.fshader = this._fsGetBeginCode() + options.customFragmentShader;
			} else {
				this.fshader = this._fsGetLitPassCode();
			}
			(_this$handleCompatibi = this.handleCompatibility) == null || _this$handleCompatibi.call(this);
		};
		_proto.getDefinition = function getDefinition(options) {
			var vIncludes = new Map();
			vIncludes.set('transformCore', this.chunks.transformCoreVS);
			vIncludes.set('transformInstancing', this.chunks.transformInstancingVS);
			vIncludes.set('skinTexVS', this.chunks.skinTexVS);
			vIncludes.set('skinBatchTexVS', this.chunks.skinBatchTexVS);
			var defines = new Map(options.defines);
			var definition = ShaderUtils.createDefinition(this.device, {
				name: 'LitShader',
				attributes: this.attributes,
				vertexCode: this.vshader,
				fragmentCode: this.fshader,
				vertexIncludes: vIncludes,
				fragmentDefines: defines,
				vertexDefines: defines
			});
			if (this.shaderPassInfo.isForward) {
				definition.tag = SHADERTAG_MATERIAL;
			}
			return definition;
		};
		return LitShader;
	}();

	var LitShaderOptions = function LitShaderOptions() {
		this.hasTangents = false;
		this.chunks = {};
		this.pass = 0;
		this.alphaTest = false;
		this.blendType = BLEND_NONE;
		this.separateAmbient = false;
		this.screenSpace = false;
		this.skin = false;
		this.batch = false;
		this.useInstancing = false;
		this.useMorphPosition = false;
		this.useMorphNormal = false;
		this.useMorphTextureBasedInt = false;
		this.nineSlicedMode = 0;
		this.clusteredLightingEnabled = true;
		this.clusteredLightingCookiesEnabled = false;
		this.clusteredLightingShadowsEnabled = false;
		this.clusteredLightingShadowType = 0;
		this.clusteredLightingAreaLightsEnabled = false;
		this.vertexColors = false;
		this.lightMapEnabled = false;
		this.dirLightMapEnabled = false;
		this.useHeights = false;
		this.useNormals = false;
		this.useClearCoatNormals = false;
		this.useAo = false;
		this.diffuseMapEnabled = false;
		this.customFragmentShader = null;
		this.pixelSnap = false;
		this.ambientSH = false;
		this.ssao = false;
		this.twoSidedLighting = false;
		this.occludeDirect = false;
		this.occludeSpecular = 0;
		this.occludeSpecularFloat = false;
		this.useMsdf = false;
		this.msdfTextAttribute = false;
		this.alphaToCoverage = false;
		this.opacityFadesSpecular = false;
		this.opacityDither = DITHER_NONE;
		this.opacityShadowDither = DITHER_NONE;
		this.cubeMapProjection = 0;
		this.useSpecular = false;
		this.useSpecularityFactor = false;
		this.enableGGXSpecular = false;
		this.fresnelModel = 0;
		this.useRefraction = false;
		this.useClearCoat = false;
		this.useSheen = false;
		this.useIridescence = false;
		this.useMetalness = false;
		this.useDynamicRefraction = false;
		this.dispersion = false;
		this.fog = FOG_NONE;
		this.gamma = GAMMA_NONE;
		this.toneMap = -1;
		this.reflectionSource = null;
		this.reflectionEncoding = null;
		this.reflectionCubemapEncoding = null;
		this.ambientSource = 'constant';
		this.ambientEncoding = null;
		this.skyboxIntensity = 1.0;
		this.useCubeMapRotation = false;
		this.lightMapWithoutAmbient = false;
		this.lights = [];
		this.noShadow = false;
		this.lightMaskDynamic = 0x0;
		this.userAttributes = {};
		this.linearDepth = false;
	};

	var StandardMaterialOptions = function () {
		function StandardMaterialOptions() {
			this.defines = new Map();
			this.forceUv1 = false;
			this.specularTint = false;
			this.metalnessTint = false;
			this.glossTint = false;
			this.emissiveEncoding = 'linear';
			this.lightMapEncoding = 'linear';
			this.packedNormal = false;
			this.glossInvert = false;
			this.sheenGlossInvert = false;
			this.clearCoatGlossInvert = false;
			this.useAO = false;
			this.litOptions = new LitShaderOptions();
		}
		return _createClass(StandardMaterialOptions, [{
			key: "pass",
			get: function get() {
				return this.litOptions.pass;
			}
		}]);
	}();

	var LitOptionsUtils = {
		generateKey: function generateKey(options) {
			return "lit" + Object.keys(options).sort().map(function (key) {
				if (key === 'chunks') {
					return LitOptionsUtils.generateChunksKey(options);
				} else if (key === 'lights') {
					return LitOptionsUtils.generateLightsKey(options);
				}
				return key + options[key];
			}).join('\n');
		},
		generateLightsKey: function generateLightsKey(options) {
			return "lights:" + options.lights.map(function (light) {
				return !options.clusteredLightingEnabled || light._type === LIGHTTYPE_DIRECTIONAL ? light.key + "," : '';
			}).join('');
		},
		generateChunksKey: function generateChunksKey(options) {
			var _options$chunks;
			return "chunks:\n" + Object.keys((_options$chunks = options.chunks) != null ? _options$chunks : {}).sort().map(function (key) {
				return key + options.chunks[key];
			}).join('');
		}
	};

	var _matTex2D = [];
	var buildPropertiesList = function buildPropertiesList(options) {
		return Object.keys(options).filter(function (key) {
			return key !== 'litOptions';
		}).sort();
	};
	var ShaderGeneratorStandard = function (_ShaderGenerator) {
		function ShaderGeneratorStandard() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _ShaderGenerator.call.apply(_ShaderGenerator, [this].concat(args)) || this;
			_this.optionsContext = new StandardMaterialOptions();
			_this.optionsContextMin = new StandardMaterialOptions();
			return _this;
		}
		_inheritsLoose(ShaderGeneratorStandard, _ShaderGenerator);
		var _proto = ShaderGeneratorStandard.prototype;
		_proto.generateKey = function generateKey(options) {
			var props;
			if (options === this.optionsContextMin) {
				if (!this.propsMin) this.propsMin = buildPropertiesList(options);
				props = this.propsMin;
			} else if (options === this.optionsContext) {
				if (!this.props) this.props = buildPropertiesList(options);
				props = this.props;
			} else {
				props = buildPropertiesList(options);
			}
			var definesHash = ShaderGenerator.definesHash(options.defines);
			var key = "standard:\n" + definesHash + "\n" + props.map(function (prop) {
				return prop + options[prop];
			}).join('\n') + LitOptionsUtils.generateKey(options.litOptions);
			return key;
		};
		_proto._getUvSourceExpression = function _getUvSourceExpression(transformPropName, uVPropName, options) {
			var transformId = options[transformPropName];
			var uvChannel = options[uVPropName];
			var isMainPass = options.litOptions.pass === SHADER_FORWARD;
			var expression;
			if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
				expression = 'nineSlicedUv';
			} else if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				expression = 'nineSlicedUv';
			} else {
				if (transformId === 0) {
					expression = "vUv" + uvChannel;
				} else {
					expression = "vUV" + uvChannel + "_" + transformId;
				}
				if (options.heightMap && transformPropName !== 'heightMapTransform') {
					expression += ' + dUvOffset';
				}
			}
			return expression;
		};
		_proto._addMapDef = function _addMapDef(name, enabled) {
			return enabled ? "#define " + name + "\n" : "#undef " + name + "\n";
		};
		_proto._addMapDefs = function _addMapDefs(_float, color, vertex, map, invert) {
			return this._addMapDef('MAPFLOAT', _float) + this._addMapDef('MAPCOLOR', color) + this._addMapDef('MAPVERTEX', vertex) + this._addMapDef('MAPTEXTURE', map) + this._addMapDef('MAPINVERT', invert);
		};
		_proto._addMap = function _addMap(propName, chunkName, options, chunks, mapping, encoding) {
			if (encoding === void 0) {
				encoding = null;
			}
			var mapPropName = propName + "Map";
			var uVPropName = mapPropName + "Uv";
			var identifierPropName = mapPropName + "Identifier";
			var transformPropName = mapPropName + "Transform";
			var channelPropName = mapPropName + "Channel";
			var vertexColorChannelPropName = propName + "VertexColorChannel";
			var tintPropName = propName + "Tint";
			var vertexColorPropName = propName + "VertexColor";
			var detailModePropName = propName + "Mode";
			var invertName = propName + "Invert";
			var tintOption = options[tintPropName];
			var vertexColorOption = options[vertexColorPropName];
			var textureOption = options[mapPropName];
			var textureIdentifier = options[identifierPropName];
			var detailModeOption = options[detailModePropName];
			var subCode = chunks[chunkName];
			if (textureOption) {
				var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);
				subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);
				if (mapping && subCode.search(/\$SAMPLER/g) !== -1) {
					var samplerName = "texture_" + mapPropName;
					var alias = mapping[textureIdentifier];
					if (alias) {
						samplerName = alias;
					} else {
						mapping[textureIdentifier] = samplerName;
					}
					subCode = subCode.replace(/\$SAMPLER/g, samplerName);
				}
				if (encoding) {
					if (options[channelPropName] === 'aaa') {
						subCode = subCode.replace(/\$DECODE/g, 'passThrough');
					} else {
						subCode = subCode.replace(/\$DECODE/g, ChunkUtils.decodeFunc(encoding));
					}
					if (subCode.indexOf('$texture2DSAMPLE')) {
						var decodeTable = {
							linear: 'texture2D',
							srgb: 'texture2DSRGB',
							rgbm: 'texture2DRGBM',
							rgbe: 'texture2DRGBE'
						};
						subCode = subCode.replace(/\$texture2DSAMPLE/g, decodeTable[encoding] || 'texture2D');
					}
				}
			}
			if (vertexColorOption) {
				subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
			}
			if (detailModeOption) {
				subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
			}
			var isFloatTint = !!(tintOption & 1);
			var isVecTint = !!(tintOption & 2);
			var invertOption = !!options[invertName];
			subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption, invertOption) + subCode;
			return subCode.replace(/\$/g, '');
		};
		_proto._correctChannel = function _correctChannel(p, chan, _matTex2D) {
			if (_matTex2D[p] > 0) {
				if (_matTex2D[p] < chan.length) {
					return chan.substring(0, _matTex2D[p]);
				} else if (_matTex2D[p] > chan.length) {
					var str = chan;
					var chr = str.charAt(str.length - 1);
					var addLen = _matTex2D[p] - str.length;
					for (var i = 0; i < addLen; i++) str += chr;
					return str;
				}
				return chan;
			}
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var shaderPassInfo = ShaderPass.get(device).getByIndex(options.litOptions.pass);
			var isForwardPass = shaderPassInfo.isForward;
			var litShader = new LitShader(device, options.litOptions);
			var useUv = [];
			var useUnmodifiedUv = [];
			var mapTransforms = [];
			var maxUvSets = 2;
			var textureMapping = {};
			for (var p in _matTex2D) {
				var mname = p + "Map";
				if (options[p + "VertexColor"]) {
					var cname = p + "VertexColorChannel";
					options[cname] = this._correctChannel(p, options[cname], _matTex2D);
				}
				if (options[mname]) {
					var _cname = mname + "Channel";
					var tname = mname + "Transform";
					var uname = mname + "Uv";
					options[uname] = Math.min(options[uname], maxUvSets - 1);
					options[_cname] = this._correctChannel(p, options[_cname], _matTex2D);
					var uvSet = options[uname];
					useUv[uvSet] = true;
					useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];
					if (options[tname]) {
						mapTransforms.push({
							name: p,
							id: options[tname],
							uv: options[uname]
						});
					}
				}
			}
			if (options.forceUv1) {
				useUv[1] = true;
				useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
			}
			litShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);
			options.litOptions.fresnelModel = options.litOptions.fresnelModel === 0 ? FRESNEL_SCHLICK : options.litOptions.fresnelModel;
			var decl = new ChunkBuilder();
			var code = new ChunkBuilder();
			var func = new ChunkBuilder();
			var args = new ChunkBuilder();
			var lightingUv = '';
			if (options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
				decl.append('const float textureBias = -1000.0;');
			} else {
				decl.append('uniform float textureBias;');
			}
			if (isForwardPass) {
				if (options.heightMap) {
					decl.append('vec2 dUvOffset;');
					code.append(this._addMap('height', 'parallaxPS', options, litShader.chunks, textureMapping));
					func.append('getParallax();');
				}
				if (options.litOptions.blendType !== BLEND_NONE || options.litOptions.alphaTest || options.litOptions.alphaToCoverage || options.litOptions.opacityDither !== DITHER_NONE) {
					decl.append('float dAlpha;');
					code.append(this._addMap('opacity', 'opacityPS', options, litShader.chunks, textureMapping));
					func.append('getOpacity();');
					args.append('litArgs_opacity = dAlpha;');
					if (options.litOptions.alphaTest) {
						code.append(litShader.chunks.alphaTestPS);
						func.append('alphaTest(dAlpha);');
					}
					var opacityDither = options.litOptions.opacityDither;
					if (opacityDither !== DITHER_NONE) {
						if (opacityDither === DITHER_BAYER8) {
							decl.append(litShader.chunks.bayerPS);
						}
						decl.append("#define DITHER_" + opacityDither.toUpperCase() + "\n");
						decl.append(litShader.chunks.opacityDitherPS);
						func.append('opacityDither(dAlpha, 0.0);');
					}
				} else {
					decl.append('float dAlpha = 1.0;');
				}
				if (litShader.needsNormal) {
					if (options.normalMap || options.clearCoatNormalMap) {
						code.append(options.packedNormal ? litShader.chunks.normalXYPS : litShader.chunks.normalXYZPS);
						if (!options.litOptions.hasTangents) {
							var baseName = options.normalMap ? 'normalMap' : 'clearCoatNormalMap';
							lightingUv = this._getUvSourceExpression(baseName + "Transform", baseName + "Uv", options);
						}
					}
					decl.append('vec3 dNormalW;');
					code.append(this._addMap('normalDetail', 'normalDetailMapPS', options, litShader.chunks, textureMapping));
					code.append(this._addMap('normal', 'normalMapPS', options, litShader.chunks, textureMapping));
					func.append('getNormal();');
					args.append('litArgs_worldNormal = dNormalW;');
				}
				if (litShader.needsSceneColor) {
					decl.append('uniform sampler2D uSceneColorMap;');
				}
				if (litShader.needsScreenSize) {
					decl.append('uniform vec4 uScreenSize;');
				}
				if (litShader.needsTransforms) {
					decl.append('uniform mat4 matrix_viewProjection;');
					decl.append('uniform mat4 matrix_model;');
				}
				if (options.diffuseDetail || options.aoDetail) {
					code.append(litShader.chunks.detailModesPS);
				}
				decl.append('vec3 dAlbedo;');
				if (options.diffuseDetail) {
					code.append(this._addMap('diffuseDetail', 'diffuseDetailMapPS', options, litShader.chunks, textureMapping, options.diffuseDetailEncoding));
				}
				code.append(this._addMap('diffuse', 'diffusePS', options, litShader.chunks, textureMapping, options.diffuseEncoding));
				func.append('getAlbedo();');
				args.append('litArgs_albedo = dAlbedo;');
				if (options.litOptions.useRefraction) {
					decl.append('float dTransmission;');
					code.append(this._addMap('refraction', 'transmissionPS', options, litShader.chunks, textureMapping));
					func.append('getRefraction();');
					args.append('litArgs_transmission = dTransmission;');
					decl.append('float dThickness;');
					code.append(this._addMap('thickness', 'thicknessPS', options, litShader.chunks, textureMapping));
					func.append('getThickness();');
					args.append('litArgs_thickness = dThickness;');
					if (options.litOptions.dispersion) {
						args.append('litArgs_dispersion = material_dispersion;');
					}
				}
				if (options.litOptions.useIridescence) {
					decl.append('float dIridescence;');
					code.append(this._addMap('iridescence', 'iridescencePS', options, litShader.chunks, textureMapping));
					func.append('getIridescence();');
					args.append('litArgs_iridescence_intensity = dIridescence;');
					decl.append('float dIridescenceThickness;');
					code.append(this._addMap('iridescenceThickness', 'iridescenceThicknessPS', options, litShader.chunks, textureMapping));
					func.append('getIridescenceThickness();');
					args.append('litArgs_iridescence_thickness = dIridescenceThickness;');
				}
				if (litShader.lighting && options.litOptions.useSpecular || litShader.reflections) {
					decl.append('vec3 dSpecularity;');
					decl.append('float dGlossiness;');
					if (options.litOptions.useSheen) {
						decl.append('vec3 sSpecularity;');
						code.append(this._addMap('sheen', 'sheenPS', options, litShader.chunks, textureMapping, options.sheenEncoding));
						func.append('getSheen();');
						args.append('litArgs_sheen_specularity = sSpecularity;');
						decl.append('float sGlossiness;');
						code.append(this._addMap('sheenGloss', 'sheenGlossPS', options, litShader.chunks, textureMapping));
						func.append('getSheenGlossiness();');
						args.append('litArgs_sheen_gloss = sGlossiness;');
					}
					if (options.litOptions.useMetalness) {
						decl.append('float dMetalness;');
						code.append(this._addMap('metalness', 'metalnessPS', options, litShader.chunks, textureMapping));
						func.append('getMetalness();');
						args.append('litArgs_metalness = dMetalness;');
						decl.append('float dIor;');
						code.append(this._addMap('ior', 'iorPS', options, litShader.chunks, textureMapping));
						func.append('getIor();');
						args.append('litArgs_ior = dIor;');
					}
					if (options.litOptions.useSpecularityFactor) {
						decl.append('float dSpecularityFactor;');
						code.append(this._addMap('specularityFactor', 'specularityFactorPS', options, litShader.chunks, textureMapping));
						func.append('getSpecularityFactor();');
						args.append('litArgs_specularityFactor = dSpecularityFactor;');
					}
					if (options.useSpecularColor) {
						code.append(this._addMap('specular', 'specularPS', options, litShader.chunks, textureMapping, options.specularEncoding));
					} else {
						code.append('void getSpecularity() { dSpecularity = vec3(1); }');
					}
					code.append(this._addMap('gloss', 'glossPS', options, litShader.chunks, textureMapping));
					func.append('getGlossiness();');
					func.append('getSpecularity();');
					args.append('litArgs_specularity = dSpecularity;');
					args.append('litArgs_gloss = dGlossiness;');
				} else {
					decl.append('vec3 dSpecularity = vec3(0.0);');
					decl.append('float dGlossiness = 0.0;');
				}
				if (options.aoDetail) {
					code.append(this._addMap('aoDetail', 'aoDetailMapPS', options, litShader.chunks, textureMapping));
				}
				if (options.aoMap || options.aoVertexColor || options.useAO) {
					decl.append('float dAo;');
					code.append(this._addMap('ao', 'aoPS', options, litShader.chunks, textureMapping));
					func.append('getAO();');
					args.append('litArgs_ao = dAo;');
				}
				decl.append('vec3 dEmission;');
				code.append(this._addMap('emissive', 'emissivePS', options, litShader.chunks, textureMapping, options.emissiveEncoding));
				func.append('getEmission();');
				args.append('litArgs_emission = dEmission;');
				if (options.litOptions.useClearCoat) {
					decl.append('float ccSpecularity;');
					decl.append('float ccGlossiness;');
					decl.append('vec3 ccNormalW;');
					code.append(this._addMap('clearCoat', 'clearCoatPS', options, litShader.chunks, textureMapping));
					code.append(this._addMap('clearCoatGloss', 'clearCoatGlossPS', options, litShader.chunks, textureMapping));
					code.append(this._addMap('clearCoatNormal', 'clearCoatNormalPS', options, litShader.chunks, textureMapping));
					func.append('getClearCoat();');
					func.append('getClearCoatGlossiness();');
					func.append('getClearCoatNormal();');
					args.append('litArgs_clearcoat_specularity = ccSpecularity;');
					args.append('litArgs_clearcoat_gloss = ccGlossiness;');
					args.append('litArgs_clearcoat_worldNormal = ccNormalW;');
				}
				if (options.lightMap || options.lightVertexColor) {
					var lightmapDir = options.dirLightMap && options.litOptions.useSpecular;
					var lightmapChunkPropName = lightmapDir ? 'lightmapDirPS' : 'lightmapSinglePS';
					decl.append('vec3 dLightmap;');
					if (lightmapDir) {
						decl.append('vec3 dLightmapDir;');
					}
					code.append(this._addMap('light', lightmapChunkPropName, options, litShader.chunks, textureMapping, options.lightMapEncoding));
					func.append('getLightMap();');
					args.append('litArgs_lightmap = dLightmap;');
					if (lightmapDir) {
						args.append('litArgs_lightmapDir = dLightmapDir;');
					}
				}
			} else {
				var opacityShadowDither = options.litOptions.opacityShadowDither;
				if (options.litOptions.alphaTest || opacityShadowDither) {
					decl.append('float dAlpha;');
					code.append(this._addMap('opacity', 'opacityPS', options, litShader.chunks, textureMapping));
					func.append('getOpacity();');
					args.append('litArgs_opacity = dAlpha;');
					if (options.litOptions.alphaTest) {
						code.append(litShader.chunks.alphaTestPS);
						func.append('alphaTest(dAlpha);');
					}
					if (opacityShadowDither !== DITHER_NONE) {
						if (opacityShadowDither === DITHER_BAYER8) {
							decl.append(litShader.chunks.bayerPS);
						}
						decl.append("#define DITHER_" + opacityShadowDither.toUpperCase() + "\n");
						decl.append(litShader.chunks.opacityDitherPS);
						func.append('opacityDither(dAlpha, 0.0);');
					}
				}
			}
			decl.append(litShader.chunks.litShaderArgsPS);
			code.append("void evaluateFrontend() { \n" + func.code + "\n" + args.code + "\n }\n");
			func.code = 'evaluateFrontend();';
			for (var texture in textureMapping) {
				decl.append("uniform sampler2D " + textureMapping[texture] + ";");
			}
			func.code = "\n" + func.code.split('\n').map(function (l) {
				return "    " + l;
			}).join('\n') + "\n\n";
			litShader.generateFragmentShader(decl.code, code.code, func.code, lightingUv);
			return litShader.getDefinition(options);
		};
		return ShaderGeneratorStandard;
	}(ShaderGenerator);
	var standard = new ShaderGeneratorStandard();

	var blendModes = [];
	blendModes[BLEND_SUBTRACTIVE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_REVERSE_SUBTRACT
	};
	blendModes[BLEND_NONE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ZERO,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_NORMAL] = {
		src: BLENDMODE_SRC_ALPHA,
		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		op: BLENDEQUATION_ADD,
		alphaSrc: BLENDMODE_ONE
	};
	blendModes[BLEND_PREMULTIPLIED] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_ADDITIVE] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_ADDITIVEALPHA] = {
		src: BLENDMODE_SRC_ALPHA,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_MULTIPLICATIVE2X] = {
		src: BLENDMODE_DST_COLOR,
		dst: BLENDMODE_SRC_COLOR,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_SCREEN] = {
		src: BLENDMODE_ONE_MINUS_DST_COLOR,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_MULTIPLICATIVE] = {
		src: BLENDMODE_DST_COLOR,
		dst: BLENDMODE_ZERO,
		op: BLENDEQUATION_ADD
	};
	blendModes[BLEND_MIN] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_MIN
	};
	blendModes[BLEND_MAX] = {
		src: BLENDMODE_ONE,
		dst: BLENDMODE_ONE,
		op: BLENDEQUATION_MAX
	};
	var id$1 = 0;
	var Material = function () {
		function Material() {
			this.meshInstances = [];
			this.name = 'Untitled';
			this.userId = '';
			this.id = id$1++;
			this.variants = new Map();
			this.defines = new Map();
			this._definesDirty = false;
			this.parameters = {};
			this.alphaTest = 0;
			this.alphaToCoverage = false;
			this._blendState = new BlendState();
			this._depthState = new DepthState();
			this.cull = CULLFACE_BACK;
			this.stencilFront = null;
			this.stencilBack = null;
			this._shaderVersion = 0;
			this._scene = null;
			this.dirty = true;
			if ((this instanceof Material ? this.constructor : void 0) === Material) ;
		}
		var _proto = Material.prototype;
		_proto._updateTransparency = function _updateTransparency() {
			var transparent = this.transparent;
			var meshInstances = this.meshInstances;
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].transparent = transparent;
			}
		};
		_proto.copy = function copy(source) {
			var _source$stencilFront,
				_this = this;
			this.name = source.name;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this._blendState.copy(source._blendState);
			this._depthState.copy(source._depthState);
			this.cull = source.cull;
			this.stencilFront = (_source$stencilFront = source.stencilFront) == null ? void 0 : _source$stencilFront.clone();
			if (source.stencilBack) {
				this.stencilBack = source.stencilFront === source.stencilBack ? this.stencilFront : source.stencilBack.clone();
			}
			this.clearParameters();
			for (var name in source.parameters) {
				if (source.parameters.hasOwnProperty(name)) {
					this._setParameterSimple(name, source.parameters[name].data);
				}
			}
			this.defines.clear();
			source.defines.forEach(function (value, key) {
				return _this.defines.set(key, value);
			});
			return this;
		};
		_proto.clone = function clone() {
			var clone = new this.constructor();
			return clone.copy(this);
		};
		_proto._updateMeshInstanceKeys = function _updateMeshInstanceKeys() {
			var meshInstances = this.meshInstances;
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].updateKey();
			}
		};
		_proto.updateUniforms = function updateUniforms(device, scene) {};
		_proto.getShaderVariant = function getShaderVariant(params) {};
		_proto.update = function update() {
			if (this._definesDirty) {
				this._definesDirty = false;
				this.clearVariants();
			}
			this.dirty = true;
		};
		_proto.clearParameters = function clearParameters() {
			this.parameters = {};
		};
		_proto.getParameters = function getParameters() {
			return this.parameters;
		};
		_proto.clearVariants = function clearVariants() {
			this.variants.clear();
			var meshInstances = this.meshInstances;
			var count = meshInstances.length;
			for (var i = 0; i < count; i++) {
				meshInstances[i].clearShaders();
			}
		};
		_proto.getParameter = function getParameter(name) {
			return this.parameters[name];
		};
		_proto._setParameterSimple = function _setParameterSimple(name, data) {
			var param = this.parameters[name];
			if (param) {
				param.data = data;
			} else {
				this.parameters[name] = {
					scopeId: null,
					data: data
				};
			}
		};
		_proto.setParameter = function setParameter(name, data) {
			if (data === undefined && typeof name === 'object') {
				var uniformObject = name;
				if (uniformObject.length) {
					for (var i = 0; i < uniformObject.length; i++) {
						this.setParameter(uniformObject[i]);
					}
					return;
				}
				name = uniformObject.name;
				data = uniformObject.value;
			}
			this._setParameterSimple(name, data);
		};
		_proto.deleteParameter = function deleteParameter(name) {
			if (this.parameters[name]) {
				delete this.parameters[name];
			}
		};
		_proto.setParameters = function setParameters(device, names) {
			var parameters = this.parameters;
			if (names === undefined) names = parameters;
			for (var paramName in names) {
				var parameter = parameters[paramName];
				if (parameter) {
					if (!parameter.scopeId) {
						parameter.scopeId = device.scope.resolve(paramName);
					}
					parameter.scopeId.setValue(parameter.data);
				}
			}
		};
		_proto.setDefine = function setDefine(name, value) {
			var modified = false;
			var defines = this.defines;
			if (value !== undefined && value !== false) {
				modified = !defines.has(name) || defines.get(name) !== value;
				defines.set(name, value);
			} else {
				modified = defines.has(name);
				defines.delete(name);
			}
			this._definesDirty || (this._definesDirty = modified);
		};
		_proto.getDefine = function getDefine(name) {
			return this.defines.has(name);
		};
		_proto.destroy = function destroy() {
			this.variants.clear();
			for (var i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];
				meshInstance.clearShaders();
				meshInstance._material = null;
				if (meshInstance.mesh) {
					var defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);
					if (this !== defaultMaterial) {
						meshInstance.material = defaultMaterial;
					}
				}
			}
			this.meshInstances.length = 0;
		};
		_proto.addMeshInstanceRef = function addMeshInstanceRef(meshInstance) {
			this.meshInstances.push(meshInstance);
		};
		_proto.removeMeshInstanceRef = function removeMeshInstanceRef(meshInstance) {
			var meshInstances = this.meshInstances;
			var i = meshInstances.indexOf(meshInstance);
			if (i !== -1) {
				meshInstances.splice(i, 1);
			}
		};
		return _createClass(Material, [{
			key: "depthBias",
			get: function get() {
				return this._depthState.depthBias;
			},
			set: function set(value) {
				this._depthState.depthBias = value;
			}
		}, {
			key: "slopeDepthBias",
			get: function get() {
				return this._depthState.depthBiasSlope;
			},
			set: function set(value) {
				this._depthState.depthBiasSlope = value;
			}
		}, {
			key: "redWrite",
			get: function get() {
				return this._blendState.redWrite;
			},
			set: function set(value) {
				this._blendState.redWrite = value;
			}
		}, {
			key: "greenWrite",
			get: function get() {
				return this._blendState.greenWrite;
			},
			set: function set(value) {
				this._blendState.greenWrite = value;
			}
		}, {
			key: "blueWrite",
			get: function get() {
				return this._blendState.blueWrite;
			},
			set: function set(value) {
				this._blendState.blueWrite = value;
			}
		}, {
			key: "alphaWrite",
			get: function get() {
				return this._blendState.alphaWrite;
			},
			set: function set(value) {
				this._blendState.alphaWrite = value;
			}
		}, {
			key: "transparent",
			get: function get() {
				return this._blendState.blend;
			}
		}, {
			key: "blendState",
			get: function get() {
				return this._blendState;
			},
			set: function set(value) {
				this._blendState.copy(value);
				this._updateTransparency();
			}
		}, {
			key: "blendType",
			get: function get() {
				if (!this.transparent) {
					return BLEND_NONE;
				}
				var _this$_blendState = this._blendState,
					colorOp = _this$_blendState.colorOp,
					colorSrcFactor = _this$_blendState.colorSrcFactor,
					colorDstFactor = _this$_blendState.colorDstFactor,
					alphaOp = _this$_blendState.alphaOp,
					alphaSrcFactor = _this$_blendState.alphaSrcFactor,
					alphaDstFactor = _this$_blendState.alphaDstFactor;
				for (var i = 0; i < blendModes.length; i++) {
					var blendMode = blendModes[i];
					if (blendMode.src === colorSrcFactor && blendMode.dst === colorDstFactor && blendMode.op === colorOp && blendMode.src === alphaSrcFactor && blendMode.dst === alphaDstFactor && blendMode.op === alphaOp) {
						return i;
					}
				}
				return BLEND_NORMAL;
			},
			set: function set(type) {
				var _blendMode$alphaOp, _blendMode$alphaSrc, _blendMode$alphaDst;
				var blendMode = blendModes[type];
				this._blendState.setColorBlend(blendMode.op, blendMode.src, blendMode.dst);
				this._blendState.setAlphaBlend((_blendMode$alphaOp = blendMode.alphaOp) != null ? _blendMode$alphaOp : blendMode.op, (_blendMode$alphaSrc = blendMode.alphaSrc) != null ? _blendMode$alphaSrc : blendMode.src, (_blendMode$alphaDst = blendMode.alphaDst) != null ? _blendMode$alphaDst : blendMode.dst);
				var blend = type !== BLEND_NONE;
				if (this._blendState.blend !== blend) {
					this._blendState.blend = blend;
					this._updateTransparency();
				}
				this._updateMeshInstanceKeys();
			}
		}, {
			key: "depthState",
			get: function get() {
				return this._depthState;
			},
			set: function set(value) {
				this._depthState.copy(value);
			}
		}, {
			key: "depthTest",
			get: function get() {
				return this._depthState.test;
			},
			set: function set(value) {
				this._depthState.test = value;
			}
		}, {
			key: "depthFunc",
			get: function get() {
				return this._depthState.func;
			},
			set: function set(value) {
				this._depthState.func = value;
			}
		}, {
			key: "depthWrite",
			get: function get() {
				return this._depthState.write;
			},
			set: function set(value) {
				this._depthState.write = value;
			}
		}]);
	}();

	var LitMaterialOptionsBuilder = function () {
		function LitMaterialOptionsBuilder() {}
		LitMaterialOptionsBuilder.update = function update(litOptions, material, scene, renderParams, objDefs, pass, sortedLights) {
			LitMaterialOptionsBuilder.updateSharedOptions(litOptions, material, scene, objDefs, pass);
			LitMaterialOptionsBuilder.updateMaterialOptions(litOptions, material);
			LitMaterialOptionsBuilder.updateEnvOptions(litOptions, material, scene, renderParams);
			LitMaterialOptionsBuilder.updateLightingOptions(litOptions, material, objDefs, sortedLights);
		};
		LitMaterialOptionsBuilder.updateSharedOptions = function updateSharedOptions(litOptions, material, scene, objDefs, pass) {
			litOptions.chunks = material.chunks;
			litOptions.pass = pass;
			litOptions.alphaTest = material.alphaTest > 0;
			litOptions.blendType = material.blendType;
			litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
			litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
			litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
			litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
			litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
			litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
			litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
			litOptions.nineSlicedMode = material.nineSlicedMode || SPRITE_RENDERMODE_SIMPLE;
			if (material.useLighting && scene.clusteredLightingEnabled) {
				litOptions.clusteredLightingEnabled = true;
				litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
				litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
				litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
				litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
			} else {
				litOptions.clusteredLightingEnabled = false;
				litOptions.clusteredLightingCookiesEnabled = false;
				litOptions.clusteredLightingShadowsEnabled = false;
				litOptions.clusteredLightingAreaLightsEnabled = false;
			}
		};
		LitMaterialOptionsBuilder.updateMaterialOptions = function updateMaterialOptions(litOptions, material) {
			litOptions.separateAmbient = false;
			litOptions.customFragmentShader = null;
			litOptions.pixelSnap = material.pixelSnap;
			litOptions.ambientSH = material.ambientSH;
			litOptions.twoSidedLighting = material.twoSidedLighting;
			litOptions.occludeDirect = material.occludeDirect;
			litOptions.occludeSpecular = material.occludeSpecular;
			litOptions.occludeSpecularFloat = material.occludeSpecularIntensity !== 1.0;
			litOptions.useMsdf = false;
			litOptions.msdfTextAttribute = false;
			litOptions.alphaToCoverage = material.alphaToCoverage;
			litOptions.opacityFadesSpecular = material.opacityFadesSpecular;
			litOptions.opacityDither = material.opacityDither;
			litOptions.cubeMapProjection = CUBEPROJ_NONE;
			litOptions.useSpecular = material.hasSpecular;
			litOptions.useSpecularityFactor = material.hasSpecularityFactor;
			litOptions.enableGGXSpecular = material.ggxSpecular;
			litOptions.fresnelModel = material.fresnelModel;
			litOptions.useRefraction = material.hasRefraction;
			litOptions.useClearCoat = material.hasClearCoat;
			litOptions.useSheen = material.hasSheen;
			litOptions.useIridescence = material.hasIrridescence;
			litOptions.useMetalness = material.hasMetalness;
			litOptions.useDynamicRefraction = material.dynamicRefraction;
			litOptions.dispersion = material.dispersion > 0;
			litOptions.vertexColors = false;
			litOptions.lightMapEnabled = material.hasLighting;
			litOptions.dirLightMapEnabled = material.dirLightMap;
			litOptions.useHeights = material.hasHeights;
			litOptions.useNormals = material.hasNormals;
			litOptions.useClearCoatNormals = material.hasClearCoatNormals;
			litOptions.useAo = material.hasAo;
			litOptions.diffuseMapEnabled = material.hasDiffuseMap;
		};
		LitMaterialOptionsBuilder.updateEnvOptions = function updateEnvOptions(litOptions, material, scene, renderParams) {
			litOptions.fog = material.useFog ? renderParams.fog : FOG_NONE;
			litOptions.gamma = renderParams.shaderOutputGamma;
			litOptions.toneMap = material.useTonemap ? renderParams.toneMapping : TONEMAP_NONE;
			if (material.useSkybox && scene.envAtlas && scene.skybox) {
				litOptions.reflectionSource = 'envAtlasHQ';
				litOptions.reflectionEncoding = scene.envAtlas.encoding;
				litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
			} else if (material.useSkybox && scene.envAtlas) {
				litOptions.reflectionSource = 'envAtlas';
				litOptions.reflectionEncoding = scene.envAtlas.encoding;
			} else if (material.useSkybox && scene.skybox) {
				litOptions.reflectionSource = 'cubeMap';
				litOptions.reflectionEncoding = scene.skybox.encoding;
			} else {
				litOptions.reflectionSource = null;
				litOptions.reflectionEncoding = null;
			}
			if (material.ambientSH) {
				litOptions.ambientSource = 'ambientSH';
				litOptions.ambientEncoding = null;
			} else if (litOptions.reflectionSource && scene.envAtlas) {
				litOptions.ambientSource = 'envAtlas';
				litOptions.ambientEncoding = scene.envAtlas.encoding;
			} else {
				litOptions.ambientSource = 'constant';
				litOptions.ambientEncoding = null;
			}
			var hasSkybox = !!litOptions.reflectionSource;
			litOptions.skyboxIntensity = hasSkybox;
			litOptions.useCubeMapRotation = hasSkybox && scene._skyboxRotationShaderInclude;
		};
		LitMaterialOptionsBuilder.updateLightingOptions = function updateLightingOptions(litOptions, material, objDefs, sortedLights) {
			litOptions.lightMapWithoutAmbient = false;
			if (material.useLighting) {
				var lightsFiltered = [];
				var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
				litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
				litOptions.lightMapWithoutAmbient = false;
				if (sortedLights) {
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
				}
				litOptions.lights = lightsFiltered;
			} else {
				litOptions.lights = [];
			}
			if (litOptions.lights.length === 0 || (objDefs & SHADERDEF_NOSHADOW) !== 0) {
				litOptions.noShadow = true;
			}
		};
		LitMaterialOptionsBuilder.collectLights = function collectLights(lType, lights, lightsFiltered, mask) {
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (light.enabled) {
					if (light.mask & mask) {
						lightsFiltered.push(light);
					}
				}
			}
		};
		return LitMaterialOptionsBuilder;
	}();

	var arraysEqual = function arraysEqual(a, b) {
		if (a.length !== b.length) {
			return false;
		}
		for (var i = 0; i < a.length; ++i) {
			if (a[i] !== b[i]) {
				return false;
			}
		}
		return true;
	};
	var notWhite = function notWhite(color) {
		return color.r !== 1 || color.g !== 1 || color.b !== 1;
	};
	var notBlack = function notBlack(color) {
		return color.r !== 0 || color.g !== 0 || color.b !== 0;
	};
	var StandardMaterialOptionsBuilder = function () {
		function StandardMaterialOptionsBuilder() {
			this._mapXForms = null;
		}
		var _proto = StandardMaterialOptionsBuilder.prototype;
		_proto.updateMinRef = function updateMinRef(options, scene, stdMat, objDefs, pass, sortedLights) {
			this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
			this._updateMinOptions(options, stdMat, pass);
			this._updateUVOptions(options, stdMat, objDefs, true);
		};
		_proto.updateRef = function updateRef(options, scene, cameraShaderParams, stdMat, objDefs, pass, sortedLights) {
			this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
			this._updateEnvOptions(options, stdMat, scene, cameraShaderParams);
			this._updateMaterialOptions(options, stdMat);
			options.litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
			this._updateLightOptions(options, scene, stdMat, objDefs, sortedLights);
			this._updateUVOptions(options, stdMat, objDefs, false, cameraShaderParams);
		};
		_proto._updateSharedOptions = function _updateSharedOptions(options, scene, stdMat, objDefs, pass) {
			options.forceUv1 = stdMat.forceUv1;
			if (stdMat.userAttributes) {
				options.litOptions.userAttributes = Object.fromEntries(stdMat.userAttributes.entries());
			}
			options.litOptions.chunks = stdMat.chunks || {};
			options.litOptions.pass = pass;
			options.litOptions.alphaTest = stdMat.alphaTest > 0;
			options.litOptions.blendType = stdMat.blendType;
			options.litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
			options.litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
			options.litOptions.batch = objDefs && (objDefs & SHADERDEF_BATCH) !== 0;
			options.litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
			options.litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
			options.litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
			options.litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
			options.litOptions.nineSlicedMode = stdMat.nineSlicedMode || 0;
			if (scene.clusteredLightingEnabled && stdMat.useLighting) {
				options.litOptions.clusteredLightingEnabled = true;
				options.litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
				options.litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
				options.litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
				options.litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
			} else {
				options.litOptions.clusteredLightingEnabled = false;
				options.litOptions.clusteredLightingCookiesEnabled = false;
				options.litOptions.clusteredLightingShadowsEnabled = false;
				options.litOptions.clusteredLightingAreaLightsEnabled = false;
			}
		};
		_proto._updateUVOptions = function _updateUVOptions(options, stdMat, objDefs, minimalOptions, cameraShaderParams) {
			var hasUv0 = false;
			var hasUv1 = false;
			var hasVcolor = false;
			if (objDefs) {
				hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
				hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
				hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
			}
			options.litOptions.vertexColors = false;
			this._mapXForms = [];
			var uniqueTextureMap = {};
			for (var p in _matTex2D) {
				this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap);
			}
			this._mapXForms = null;
			options.litOptions.ssao = cameraShaderParams == null ? void 0 : cameraShaderParams.ssaoEnabled;
			options.useAO = options.litOptions.ssao;
			options.litOptions.lightMapEnabled = options.lightMap;
			options.litOptions.dirLightMapEnabled = options.dirLightMap;
			options.litOptions.useHeights = options.heightMap;
			options.litOptions.useNormals = options.normalMap;
			options.litOptions.useClearCoatNormals = options.clearCoatNormalMap;
			options.litOptions.useAo = options.aoMap || options.aoVertexColor || options.litOptions.ssao;
			options.litOptions.diffuseMapEnabled = options.diffuseMap;
		};
		_proto._updateTexOptions = function _updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap) {
			var isOpacity = p === 'opacity';
			if (!minimalOptions || isOpacity) {
				var mname = p + "Map";
				var vname = p + "VertexColor";
				var vcname = p + "VertexColorChannel";
				var cname = mname + "Channel";
				var tname = mname + "Transform";
				var uname = mname + "Uv";
				var iname = mname + "Identifier";
				if (p !== 'light') {
					options[mname] = false;
					options[iname] = undefined;
					options[cname] = '';
					options[tname] = 0;
					options[uname] = 0;
				}
				options[vname] = false;
				options[vcname] = '';
				if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage && stdMat.opacityDither === DITHER_NONE) {
					return;
				}
				if (p !== 'height' && stdMat[vname]) {
					if (hasVcolor) {
						options[vname] = stdMat[vname];
						options[vcname] = stdMat[vcname];
						options.litOptions.vertexColors = true;
					}
				}
				if (stdMat[mname]) {
					var allow = true;
					if (stdMat[uname] === 0 && !hasUv0) allow = false;
					if (stdMat[uname] === 1 && !hasUv1) allow = false;
					if (allow) {
						var mapId = stdMat[mname].id;
						var identifier = uniqueTextureMap[mapId];
						if (identifier === undefined) {
							uniqueTextureMap[mapId] = p;
							identifier = p;
						}
						options[mname] = !!stdMat[mname];
						options[iname] = identifier;
						options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
						options[cname] = stdMat[cname];
						options[uname] = stdMat[uname];
					}
				}
			}
		};
		_proto._updateMinOptions = function _updateMinOptions(options, stdMat, pass) {
			var isPrepass = pass === SHADER_PREPASS;
			options.litOptions.opacityShadowDither = isPrepass ? stdMat.opacityDither : stdMat.opacityShadowDither;
			options.litOptions.linearDepth = isPrepass;
			options.litOptions.lights = [];
		};
		_proto._updateMaterialOptions = function _updateMaterialOptions(options, stdMat) {
			var _stdMat$diffuseMap, _stdMat$diffuseDetail, _stdMat$emissiveMap, _stdMat$lightMap;
			var useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 && stdMat.useMetalness || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
			var useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;
			var specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
			var specularityFactorTint = useSpecular && stdMat.useMetalnessSpecularColor && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);
			var isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;
			var equalish = function equalish(a, b) {
				return Math.abs(a - b) < 1e-4;
			};
			options.specularTint = specularTint ? 2 : 0;
			options.specularityFactorTint = specularityFactorTint ? 1 : 0;
			options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;
			options.glossTint = 1;
			options.diffuseEncoding = (_stdMat$diffuseMap = stdMat.diffuseMap) == null ? void 0 : _stdMat$diffuseMap.encoding;
			options.diffuseDetailEncoding = (_stdMat$diffuseDetail = stdMat.diffuseDetailMap) == null ? void 0 : _stdMat$diffuseDetail.encoding;
			options.emissiveEncoding = (_stdMat$emissiveMap = stdMat.emissiveMap) == null ? void 0 : _stdMat$emissiveMap.encoding;
			options.lightMapEncoding = (_stdMat$lightMap = stdMat.lightMap) == null ? void 0 : _stdMat$lightMap.encoding;
			options.packedNormal = isPackedNormalMap;
			options.refractionTint = equalish(stdMat.refraction, 1.0) ? 0 : 1;
			options.refractionIndexTint = equalish(stdMat.refractionIndex, 1.0 / 1.5) ? 0 : 1;
			options.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1.0 ? 1 : 0;
			options.specularEncoding = stdMat.specularEncoding || 'linear';
			options.sheenEncoding = stdMat.sheenEncoding || 'linear';
			options.aoMapUv = stdMat.aoUvSet;
			options.aoDetail = !!stdMat.aoMap;
			options.diffuseDetail = !!stdMat.diffuseMap;
			options.normalDetail = !!stdMat.normalMap;
			options.diffuseDetailMode = stdMat.diffuseDetailMode;
			options.aoDetailMode = stdMat.aoDetailMode;
			options.clearCoatTint = equalish(stdMat.clearCoat, 1.0) ? 0 : 1;
			options.clearCoatGloss = !!stdMat.clearCoatGloss;
			options.clearCoatGlossTint = stdMat.clearCoatGloss !== 1.0 ? 1 : 0;
			options.iorTint = equalish(stdMat.refractionIndex, 1.0 / 1.5) ? 0 : 1;
			options.iridescenceTint = stdMat.iridescence !== 1.0 ? 1 : 0;
			options.glossInvert = stdMat.glossInvert;
			options.sheenGlossInvert = stdMat.sheenGlossInvert;
			options.clearCoatGlossInvert = stdMat.clearCoatGlossInvert;
			options.useSpecularColor = useSpecularColor;
			options.litOptions.separateAmbient = false;
			options.litOptions.customFragmentShader = stdMat.customFragmentShader;
			options.litOptions.pixelSnap = stdMat.pixelSnap;
			options.litOptions.ambientSH = !!stdMat.ambientSH;
			options.litOptions.twoSidedLighting = stdMat.twoSidedLighting;
			options.litOptions.occludeSpecular = stdMat.occludeSpecular;
			options.litOptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
			options.litOptions.useMsdf = !!stdMat.msdfMap;
			options.litOptions.msdfTextAttribute = !!stdMat.msdfTextAttribute;
			options.litOptions.alphaToCoverage = stdMat.alphaToCoverage;
			options.litOptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;
			options.litOptions.opacityDither = stdMat.opacityDither;
			options.litOptions.cubeMapProjection = stdMat.cubeMapProjection;
			options.litOptions.occludeDirect = stdMat.occludeDirect;
			options.litOptions.useSpecular = useSpecular;
			options.litOptions.useSpecularityFactor = (specularityFactorTint || !!stdMat.specularityFactorMap) && stdMat.useMetalnessSpecularColor;
			options.litOptions.enableGGXSpecular = stdMat.enableGGXSpecular;
			options.litOptions.fresnelModel = stdMat.fresnelModel;
			options.litOptions.useRefraction = (stdMat.refraction || !!stdMat.refractionMap) && (stdMat.useDynamicRefraction || !!options.litOptions.reflectionSource);
			options.litOptions.useClearCoat = !!stdMat.clearCoat;
			options.litOptions.useSheen = stdMat.useSheen;
			options.litOptions.useIridescence = stdMat.useIridescence && stdMat.iridescence !== 0.0;
			options.litOptions.useMetalness = stdMat.useMetalness;
			options.litOptions.useDynamicRefraction = stdMat.useDynamicRefraction;
			options.litOptions.dispersion = stdMat.dispersion > 0;
		};
		_proto._updateEnvOptions = function _updateEnvOptions(options, stdMat, scene, cameraShaderParams) {
			options.litOptions.fog = stdMat.useFog ? cameraShaderParams.fog : FOG_NONE;
			options.litOptions.gamma = cameraShaderParams.shaderOutputGamma;
			options.litOptions.toneMap = stdMat.useTonemap ? cameraShaderParams.toneMapping : TONEMAP_NONE;
			var usingSceneEnv = false;
			if (stdMat.envAtlas && stdMat.cubeMap) {
				options.litOptions.reflectionSource = 'envAtlasHQ';
				options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
				options.litOptions.reflectionCubemapEncoding = stdMat.cubeMap.encoding;
			} else if (stdMat.envAtlas) {
				options.litOptions.reflectionSource = 'envAtlas';
				options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
			} else if (stdMat.cubeMap) {
				options.litOptions.reflectionSource = 'cubeMap';
				options.litOptions.reflectionEncoding = stdMat.cubeMap.encoding;
			} else if (stdMat.sphereMap) {
				options.litOptions.reflectionSource = 'sphereMap';
				options.litOptions.reflectionEncoding = stdMat.sphereMap.encoding;
			} else if (stdMat.useSkybox && scene.envAtlas && scene.skybox) {
				options.litOptions.reflectionSource = 'envAtlasHQ';
				options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
				options.litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
				usingSceneEnv = true;
			} else if (stdMat.useSkybox && scene.envAtlas) {
				options.litOptions.reflectionSource = 'envAtlas';
				options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
				usingSceneEnv = true;
			} else if (stdMat.useSkybox && scene.skybox) {
				options.litOptions.reflectionSource = 'cubeMap';
				options.litOptions.reflectionEncoding = scene.skybox.encoding;
				usingSceneEnv = true;
			} else {
				options.litOptions.reflectionSource = null;
				options.litOptions.reflectionEncoding = null;
			}
			if (stdMat.ambientSH) {
				options.litOptions.ambientSource = 'ambientSH';
				options.litOptions.ambientEncoding = null;
			} else {
				var envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);
				if (envAtlas && !stdMat.sphereMap) {
					options.litOptions.ambientSource = 'envAtlas';
					options.litOptions.ambientEncoding = envAtlas.encoding;
				} else {
					options.litOptions.ambientSource = 'constant';
					options.litOptions.ambientEncoding = null;
				}
			}
			options.litOptions.skyboxIntensity = usingSceneEnv;
			options.litOptions.useCubeMapRotation = usingSceneEnv && scene._skyboxRotationShaderInclude;
		};
		_proto._updateLightOptions = function _updateLightOptions(options, scene, stdMat, objDefs, sortedLights) {
			options.lightMap = false;
			options.lightMapChannel = '';
			options.lightMapUv = 0;
			options.lightMapTransform = 0;
			options.litOptions.lightMapWithoutAmbient = false;
			options.dirLightMap = false;
			if (objDefs) {
				options.litOptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;
				if ((objDefs & SHADERDEF_LM) !== 0) {
					options.lightMapEncoding = scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? 'rgbm' : 'linear';
					options.lightMap = true;
					options.lightMapChannel = 'rgb';
					options.lightMapUv = 1;
					options.lightMapTransform = 0;
					options.litOptions.lightMapWithoutAmbient = !stdMat.lightMap;
					if ((objDefs & SHADERDEF_DIRLM) !== 0) {
						options.dirLightMap = true;
					}
					if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
						options.litOptions.lightMapWithoutAmbient = false;
					}
				}
			}
			if (stdMat.useLighting) {
				var lightsFiltered = [];
				var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
				options.litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
				if (sortedLights) {
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
					LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
				}
				options.litOptions.lights = lightsFiltered;
			} else {
				options.litOptions.lights = [];
			}
			if (options.litOptions.lights.length === 0) {
				options.litOptions.noShadow = true;
			}
		};
		_proto._getMapTransformID = function _getMapTransformID(xform, uv) {
			if (!xform) return 0;
			var xforms = this._mapXForms[uv];
			if (!xforms) {
				xforms = [];
				this._mapXForms[uv] = xforms;
			}
			for (var i = 0; i < xforms.length; i++) {
				if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
					return i + 1;
				}
			}
			return xforms.push(xform);
		};
		return StandardMaterialOptionsBuilder;
	}();

	function _textureParameter(name, channel, vertexColor) {
		if (channel === void 0) {
			channel = true;
		}
		if (vertexColor === void 0) {
			vertexColor = true;
		}
		var result = {};
		result[name + "Map"] = 'texture';
		result[name + "MapTiling"] = 'vec2';
		result[name + "MapOffset"] = 'vec2';
		result[name + "MapRotation"] = 'number';
		result[name + "MapUv"] = 'number';
		if (channel) {
			result[name + "MapChannel"] = 'string';
			if (vertexColor) {
				result[name + "VertexColor"] = 'boolean';
				result[name + "VertexColorChannel"] = 'string';
			}
		}
		return result;
	}
	var standardMaterialParameterTypes = _extends({
		name: 'string',
		chunks: 'chunks',
		mappingFormat: 'string',
		_engine: 'boolean',
		ambient: 'rgb'
	}, _textureParameter('ao'), _textureParameter('aoDetail', true, false), {
		aoDetailMode: 'string',
		diffuse: 'rgb'
	}, _textureParameter('diffuse'), _textureParameter('diffuseDetail', true, false), {
		diffuseDetailMode: 'string',
		specular: 'rgb',
		specularTint: 'boolean'
	}, _textureParameter('specular'), {
		occludeSpecular: 'enum:occludeSpecular',
		specularityFactor: 'number',
		specularityFactorTint: 'boolean'
	}, _textureParameter('specularityFactor'), {
		useMetalness: 'boolean',
		metalness: 'number',
		enableGGXSpecular: 'boolean',
		anisotropy: 'number',
		metalnessTint: 'boolean'
	}, _textureParameter('metalness'), {
		useMetalnessSpecularColor: 'boolean',
		shininess: 'number',
		gloss: 'number',
		glossInvert: 'boolean'
	}, _textureParameter('gloss'), {
		clearCoat: 'number'
	}, _textureParameter('clearCoat'), {
		clearCoatGloss: 'number',
		clearCoatGlossInvert: 'boolean'
	}, _textureParameter('clearCoatGloss'), {
		clearCoatBumpiness: 'number'
	}, _textureParameter('clearCoatNormal', false), {
		useSheen: 'boolean',
		sheen: 'rgb'
	}, _textureParameter('sheen'), {
		sheenGloss: 'number',
		sheenGlossInvert: 'boolean'
	}, _textureParameter('sheenGloss'), {
		fresnelModel: 'number',
		emissive: 'rgb'
	}, _textureParameter('emissive'), {
		emissiveIntensity: 'number'
	}, _textureParameter('normal', false), {
		bumpiness: 'number'
	}, _textureParameter('normalDetail', false), {
		normalDetailMapBumpiness: 'number'
	}, _textureParameter('height', true, false), {
		heightMapFactor: 'number',
		alphaToCoverage: 'boolean',
		alphaTest: 'number',
		alphaFade: 'number',
		opacity: 'number'
	}, _textureParameter('opacity'), {
		opacityFadesSpecular: 'boolean',
		opacityDither: 'string',
		opacityShadowDither: 'string',
		reflectivity: 'number',
		refraction: 'number',
		refractionTint: 'boolean'
	}, _textureParameter('refraction'), {
		refractionIndex: 'number',
		dispersion: 'number',
		thickness: 'number',
		thicknessTint: 'boolean'
	}, _textureParameter('thickness'), {
		attenuation: 'rgb',
		attenuationDistance: 'number',
		useDynamicRefraction: 'boolean',
		sphereMap: 'texture',
		cubeMap: 'cubemap',
		cubeMapProjection: 'number',
		cubeMapProjectionBox: 'boundingbox',
		useIridescence: 'boolean',
		iridescence: 'number',
		iridescenceTint: 'boolean'
	}, _textureParameter('iridescence'), {
		iridescenceThicknessTint: 'boolean',
		iridescenceThicknessMin: 'number',
		iridescenceThicknessMax: 'number',
		iridescenceRefractionIndex: 'number'
	}, _textureParameter('iridescenceThickness'), _textureParameter('light'), {
		depthTest: 'boolean',
		depthFunc: 'enum:depthFunc',
		depthWrite: 'boolean',
		depthBias: 'number',
		slopeDepthBias: 'number',
		cull: 'enum:cull',
		blendType: 'enum:blendType',
		useFog: 'boolean',
		useLighting: 'boolean',
		useSkybox: 'boolean',
		useTonemap: 'boolean',
		envAtlas: 'texture',
		twoSidedLighting: 'boolean'
	});
	var standardMaterialTextureParameters = [];
	for (var key in standardMaterialParameterTypes) {
		var type = standardMaterialParameterTypes[key];
		if (type === 'texture') {
			standardMaterialTextureParameters.push(key);
		}
	}
	var standardMaterialCubemapParameters = [];
	for (var _key in standardMaterialParameterTypes) {
		var _type = standardMaterialParameterTypes[_key];
		if (_type === 'cubemap') {
			standardMaterialCubemapParameters.push(_key);
		}
	}
	var standardMaterialRemovedParameters = {
		aoMapVertexColor: 'boolean',
		diffuseMapTint: 'boolean',
		diffuseMapVertexColor: 'boolean',
		emissiveMapTint: 'boolean',
		emissiveMapVertexColor: 'boolean',
		glossMapVertexColor: 'boolean',
		metalnessMapVertexColor: 'boolean',
		opacityMapVertexColor: 'boolean',
		specularAntialias: 'boolean',
		specularMapTint: 'boolean',
		specularMapVertexColor: 'boolean',
		ambientTint: 'boolean',
		emissiveTint: 'boolean',
		diffuseTint: 'boolean',
		sheenTint: 'boolean',
		conserveEnergy: 'boolean',
		useGamma: 'boolean'
	};

	var _props = {};
	var _uniforms = {};
	var _params = new Set();
	var _tempColor$3 = new Color();
	var StandardMaterial = function (_Material) {
		function StandardMaterial() {
			var _this;
			_this = _Material.call(this) || this;
			_this.userAttributes = new Map();
			_this._dirtyShader = true;
			_this._assetReferences = {};
			_this._activeParams = new Set();
			_this._activeLightingParams = new Set();
			_this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
			_this.reset();
			return _this;
		}
		_inheritsLoose(StandardMaterial, _Material);
		var _proto = StandardMaterial.prototype;
		_proto.reset = function reset() {
			var _this2 = this;
			Object.keys(_props).forEach(function (name) {
				_this2["_" + name] = _props[name].value();
			});
			this._chunks = {};
			this._uniformCache = {};
		};
		_proto.copy = function copy(source) {
			var _this3 = this;
			_Material.prototype.copy.call(this, source);
			Object.keys(_props).forEach(function (k) {
				_this3[k] = source[k];
			});
			for (var p in source._chunks) {
				if (source._chunks.hasOwnProperty(p)) {
					this._chunks[p] = source._chunks[p];
				}
			}
			this.userAttributes = new Map(source.userAttributes);
			return this;
		};
		_proto.setAttribute = function setAttribute(name, semantic) {
			this.userAttributes.set(semantic, name);
		};
		_proto._setParameter = function _setParameter(name, value) {
			_params.add(name);
			this.setParameter(name, value);
		};
		_proto._setParameters = function _setParameters(parameters) {
			var _this4 = this;
			parameters.forEach(function (v) {
				_this4._setParameter(v.name, v.value);
			});
		};
		_proto._processParameters = function _processParameters(paramsName) {
			var _this5 = this;
			var prevParams = this[paramsName];
			prevParams.forEach(function (param) {
				if (!_params.has(param)) {
					delete _this5.parameters[param];
				}
			});
			this[paramsName] = _params;
			_params = prevParams;
			_params.clear();
		};
		_proto._updateMap = function _updateMap(p) {
			var mname = p + "Map";
			var map = this[mname];
			if (map) {
				this._setParameter("texture_" + mname, map);
				var tname = mname + "Transform";
				var uniform = this.getUniform(tname);
				if (uniform) {
					this._setParameters(uniform);
				}
			}
		};
		_proto._allocUniform = function _allocUniform(name, allocFunc) {
			var uniform = this._uniformCache[name];
			if (!uniform) {
				uniform = allocFunc();
				this._uniformCache[name] = uniform;
			}
			return uniform;
		};
		_proto.getUniform = function getUniform(name, device, scene) {
			return _uniforms[name](this, device, scene);
		};
		_proto.updateUniforms = function updateUniforms(device, scene) {
			var _this6 = this;
			var getUniform = function getUniform(name) {
				return _this6.getUniform(name, device, scene);
			};
			this._setParameter('material_ambient', getUniform('ambient'));
			this._setParameter('material_diffuse', getUniform('diffuse'));
			this._setParameter('material_aoIntensity', this.aoIntensity);
			if (this.useMetalness) {
				if (!this.metalnessMap || this.metalness < 1) {
					this._setParameter('material_metalness', this.metalness);
				}
				if (!this.specularMap || this.specularTint) {
					this._setParameter('material_specular', getUniform('specular'));
				}
				if (!this.specularityFactorMap || this.specularityFactorTint) {
					this._setParameter('material_specularityFactor', this.specularityFactor);
				}
				this._setParameter('material_sheen', getUniform('sheen'));
				this._setParameter('material_sheenGloss', this.sheenGloss);
				this._setParameter('material_refractionIndex', this.refractionIndex);
			} else {
				if (!this.specularMap || this.specularTint) {
					this._setParameter('material_specular', getUniform('specular'));
				}
			}
			if (this.enableGGXSpecular) {
				this._setParameter('material_anisotropy', this.anisotropy);
			}
			if (this.clearCoat > 0) {
				this._setParameter('material_clearCoat', this.clearCoat);
				this._setParameter('material_clearCoatGloss', this.clearCoatGloss);
				this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
			}
			this._setParameter('material_gloss', this.gloss);
			this._setParameter('material_emissive', getUniform('emissive'));
			this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
			if (this.refraction > 0) {
				this._setParameter('material_refraction', this.refraction);
			}
			if (this.dispersion > 0) {
				this._setParameter('material_dispersion', this.dispersion);
			}
			if (this.useDynamicRefraction) {
				this._setParameter('material_thickness', this.thickness);
				this._setParameter('material_attenuation', getUniform('attenuation'));
				this._setParameter('material_invAttenuationDistance', this.attenuationDistance === 0 ? 0 : 1.0 / this.attenuationDistance);
			}
			if (this.useIridescence) {
				this._setParameter('material_iridescence', this.iridescence);
				this._setParameter('material_iridescenceRefractionIndex', this.iridescenceRefractionIndex);
				this._setParameter('material_iridescenceThicknessMin', this.iridescenceThicknessMin);
				this._setParameter('material_iridescenceThicknessMax', this.iridescenceThicknessMax);
			}
			this._setParameter('material_opacity', this.opacity);
			if (this.opacityFadesSpecular === false) {
				this._setParameter('material_alphaFade', this.alphaFade);
			}
			if (this.occludeSpecular) {
				this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
			}
			if (this.cubeMapProjection === CUBEPROJ_BOX) {
				this._setParameter(getUniform('cubeMapProjectionBox'));
			}
			for (var p in _matTex2D) {
				this._updateMap(p);
			}
			if (this.ambientSH) {
				this._setParameter('ambientSH[0]', this.ambientSH);
			}
			if (this.normalMap) {
				this._setParameter('material_bumpiness', this.bumpiness);
			}
			if (this.normalMap && this.normalDetailMap) {
				this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
			}
			if (this.heightMap) {
				this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
			}
			if (this.envAtlas && this.cubeMap) {
				this._setParameter('texture_envAtlas', this.envAtlas);
				this._setParameter('texture_cubeMap', this.cubeMap);
			} else if (this.envAtlas) {
				this._setParameter('texture_envAtlas', this.envAtlas);
			} else if (this.cubeMap) {
				this._setParameter('texture_cubeMap', this.cubeMap);
			} else if (this.sphereMap) {
				this._setParameter('texture_sphereMap', this.sphereMap);
			}
			this._setParameter('material_reflectivity', this.reflectivity);
			this._processParameters('_activeParams');
			if (this._dirtyShader) {
				this.clearVariants();
			}
		};
		_proto.updateEnvUniforms = function updateEnvUniforms(device, scene) {
			var hasLocalEnvOverride = this.envAtlas || this.cubeMap || this.sphereMap;
			if (!hasLocalEnvOverride && this.useSkybox) {
				if (scene.envAtlas && scene.skybox) {
					this._setParameter('texture_envAtlas', scene.envAtlas);
					this._setParameter('texture_cubeMap', scene.skybox);
				} else if (scene.envAtlas) {
					this._setParameter('texture_envAtlas', scene.envAtlas);
				} else if (scene.skybox) {
					this._setParameter('texture_cubeMap', scene.skybox);
				}
			}
			this._processParameters('_activeLightingParams');
		};
		_proto.getShaderVariant = function getShaderVariant(params) {
			var device = params.device,
				scene = params.scene,
				pass = params.pass,
				objDefs = params.objDefs,
				sortedLights = params.sortedLights,
				cameraShaderParams = params.cameraShaderParams;
			this.updateEnvUniforms(device, scene);
			var shaderPassInfo = ShaderPass.get(device).getByIndex(pass);
			var minimalOptions = pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS || shaderPassInfo.isShadow;
			var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
			options.defines = getMaterialShaderDefines(this, cameraShaderParams);
			if (minimalOptions) {
				this.shaderOptBuilder.updateMinRef(options, scene, this, objDefs, pass, sortedLights);
			} else {
				this.shaderOptBuilder.updateRef(options, scene, cameraShaderParams, this, objDefs, pass, sortedLights);
			}
			if (this.onUpdateShader) {
				options = this.onUpdateShader(options);
			}
			var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
			var library = getProgramLibrary(device);
			library.register('standard', standard);
			var shader = library.getProgram('standard', options, processingOptions, this.userId);
			this._dirtyShader = false;
			return shader;
		};
		_proto.destroy = function destroy() {
			for (var asset in this._assetReferences) {
				this._assetReferences[asset]._unbind();
			}
			this._assetReferences = null;
			_Material.prototype.destroy.call(this);
		};
		return _createClass(StandardMaterial, [{
			key: "chunks",
			get: function get() {
				this._dirtyShader = true;
				return this._chunks;
			},
			set: function set(value) {
				this._dirtyShader = true;
				this._chunks = value;
			}
		}]);
	}(Material);
	StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
	StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;
	var defineUniform = function defineUniform(name, getUniformFunc) {
		_uniforms[name] = getUniformFunc;
	};
	var definePropInternal = function definePropInternal(name, constructorFunc, setterFunc, getterFunc) {
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: getterFunc || function () {
				return this["_" + name];
			},
			set: setterFunc
		});
		_props[name] = {
			value: constructorFunc
		};
	};
	var defineValueProp = function defineValueProp(prop) {
		var internalName = "_" + prop.name;
		var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
			return true;
		};
		var setterFunc = function setterFunc(value) {
			var oldValue = this[internalName];
			if (oldValue !== value) {
				this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
				this[internalName] = value;
			}
		};
		definePropInternal(prop.name, function () {
			return prop.defaultValue;
		}, setterFunc, prop.getterFunc);
	};
	var defineAggProp = function defineAggProp(prop) {
		var internalName = "_" + prop.name;
		var dirtyShaderFunc = prop.dirtyShaderFunc || function () {
			return true;
		};
		var setterFunc = function setterFunc(value) {
			var oldValue = this[internalName];
			if (!oldValue.equals(value)) {
				this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
				this[internalName] = oldValue.copy(value);
			}
		};
		definePropInternal(prop.name, function () {
			return prop.defaultValue.clone();
		}, setterFunc, prop.getterFunc);
	};
	var defineProp = function defineProp(prop) {
		return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
	};
	function _defineTex2D(name, channel, vertexColor, uv) {
		if (channel === void 0) {
			channel = 'rgb';
		}
		if (vertexColor === void 0) {
			vertexColor = true;
		}
		if (uv === void 0) {
			uv = 0;
		}
		_matTex2D[name] = channel.length || -1;
		defineProp({
			name: name + "Map",
			defaultValue: null,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.format !== newValue.format);
			}
		});
		defineProp({
			name: name + "MapTiling",
			defaultValue: new Vec2(1, 1)
		});
		defineProp({
			name: name + "MapOffset",
			defaultValue: new Vec2(0, 0)
		});
		defineProp({
			name: name + "MapRotation",
			defaultValue: 0
		});
		defineProp({
			name: name + "MapUv",
			defaultValue: uv
		});
		if (channel) {
			defineProp({
				name: name + "MapChannel",
				defaultValue: channel
			});
			if (vertexColor) {
				defineProp({
					name: name + "VertexColor",
					defaultValue: false
				});
				defineProp({
					name: name + "VertexColorChannel",
					defaultValue: channel
				});
			}
		}
		var mapTiling = name + "MapTiling";
		var mapOffset = name + "MapOffset";
		var mapRotation = name + "MapRotation";
		var mapTransform = name + "MapTransform";
		defineUniform(mapTransform, function (material, device, scene) {
			var tiling = material[mapTiling];
			var offset = material[mapOffset];
			var rotation = material[mapRotation];
			if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
				return null;
			}
			var uniform = material._allocUniform(mapTransform, function () {
				return [{
					name: "texture_" + mapTransform + "0",
					value: new Float32Array(3)
				}, {
					name: "texture_" + mapTransform + "1",
					value: new Float32Array(3)
				}];
			});
			var cr = Math.cos(rotation * math.DEG_TO_RAD);
			var sr = Math.sin(rotation * math.DEG_TO_RAD);
			var uniform0 = uniform[0].value;
			uniform0[0] = cr * tiling.x;
			uniform0[1] = -sr * tiling.y;
			uniform0[2] = offset.x;
			var uniform1 = uniform[1].value;
			uniform1[0] = sr * tiling.x;
			uniform1[1] = cr * tiling.y;
			uniform1[2] = 1.0 - tiling.y - offset.y;
			return uniform;
		});
	}
	function _defineColor(name, defaultValue) {
		defineProp({
			name: name,
			defaultValue: defaultValue,
			getterFunc: function getterFunc() {
				this._dirtyShader = true;
				return this["_" + name];
			}
		});
		defineUniform(name, function (material, device, scene) {
			var uniform = material._allocUniform(name, function () {
				return new Float32Array(3);
			});
			var color = material[name];
			_tempColor$3.linear(color);
			uniform[0] = _tempColor$3.r;
			uniform[1] = _tempColor$3.g;
			uniform[2] = _tempColor$3.b;
			return uniform;
		});
	}
	function _defineFloat(name, defaultValue, getUniformFunc) {
		defineProp({
			name: name,
			defaultValue: defaultValue,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
			}
		});
		defineUniform(name, getUniformFunc);
	}
	function _defineObject(name, getUniformFunc) {
		defineProp({
			name: name,
			defaultValue: null,
			dirtyShaderFunc: function dirtyShaderFunc(oldValue, newValue) {
				return !!oldValue === !!newValue;
			}
		});
		defineUniform(name, getUniformFunc);
	}
	function _defineFlag(name, defaultValue) {
		defineProp({
			name: name,
			defaultValue: defaultValue
		});
	}
	function _defineMaterialProps() {
		_defineColor('ambient', new Color(1, 1, 1));
		_defineColor('diffuse', new Color(1, 1, 1));
		_defineColor('specular', new Color(0, 0, 0));
		_defineColor('emissive', new Color(0, 0, 0));
		_defineColor('sheen', new Color(1, 1, 1));
		_defineColor('attenuation', new Color(1, 1, 1));
		_defineFloat('emissiveIntensity', 1);
		_defineFloat('specularityFactor', 1);
		_defineFloat('sheenGloss', 0.0);
		_defineFloat('gloss', 0.25);
		_defineFloat('aoIntensity', 1);
		_defineFloat('heightMapFactor', 1, function (material, device, scene) {
			return material.heightMapFactor * 0.025;
		});
		_defineFloat('opacity', 1);
		_defineFloat('alphaFade', 1);
		_defineFloat('alphaTest', 0);
		_defineFloat('bumpiness', 1);
		_defineFloat('normalDetailMapBumpiness', 1);
		_defineFloat('reflectivity', 1);
		_defineFloat('occludeSpecularIntensity', 1);
		_defineFloat('refraction', 0);
		_defineFloat('refractionIndex', 1.0 / 1.5);
		_defineFloat('dispersion', 0);
		_defineFloat('thickness', 0);
		_defineFloat('attenuationDistance', 0);
		_defineFloat('metalness', 1);
		_defineFloat('anisotropy', 0);
		_defineFloat('clearCoat', 0);
		_defineFloat('clearCoatGloss', 1);
		_defineFloat('clearCoatBumpiness', 1);
		_defineFloat('aoUvSet', 0, null);
		_defineFloat('iridescence', 0);
		_defineFloat('iridescenceRefractionIndex', 1.0 / 1.5);
		_defineFloat('iridescenceThicknessMin', 0);
		_defineFloat('iridescenceThicknessMax', 0);
		_defineObject('ambientSH');
		_defineObject('cubeMapProjectionBox', function (material, device, scene) {
			var uniform = material._allocUniform('cubeMapProjectionBox', function () {
				return [{
					name: 'envBoxMin',
					value: new Float32Array(3)
				}, {
					name: 'envBoxMax',
					value: new Float32Array(3)
				}];
			});
			var bboxMin = material.cubeMapProjectionBox.getMin();
			var minUniform = uniform[0].value;
			minUniform[0] = bboxMin.x;
			minUniform[1] = bboxMin.y;
			minUniform[2] = bboxMin.z;
			var bboxMax = material.cubeMapProjectionBox.getMax();
			var maxUniform = uniform[1].value;
			maxUniform[0] = bboxMax.x;
			maxUniform[1] = bboxMax.y;
			maxUniform[2] = bboxMax.z;
			return uniform;
		});
		_defineFlag('specularTint', false);
		_defineFlag('specularityFactorTint', false);
		_defineFlag('useMetalness', false);
		_defineFlag('useMetalnessSpecularColor', false);
		_defineFlag('useSheen', false);
		_defineFlag('enableGGXSpecular', false);
		_defineFlag('occludeDirect', false);
		_defineFlag('opacityFadesSpecular', true);
		_defineFlag('occludeSpecular', SPECOCC_AO);
		_defineFlag('fresnelModel', FRESNEL_SCHLICK);
		_defineFlag('useDynamicRefraction', false);
		_defineFlag('cubeMapProjection', CUBEPROJ_NONE);
		_defineFlag('customFragmentShader', null);
		_defineFlag('useFog', true);
		_defineFlag('useLighting', true);
		_defineFlag('useTonemap', true);
		_defineFlag('useSkybox', true);
		_defineFlag('forceUv1', false);
		_defineFlag('pixelSnap', false);
		_defineFlag('twoSidedLighting', false);
		_defineFlag('nineSlicedMode', undefined);
		_defineFlag('msdfTextAttribute', false);
		_defineFlag('useIridescence', false);
		_defineFlag('glossInvert', false);
		_defineFlag('sheenGlossInvert', false);
		_defineFlag('clearCoatGlossInvert', false);
		_defineFlag('opacityDither', DITHER_NONE);
		_defineFlag('opacityShadowDither', DITHER_NONE);
		_defineTex2D('diffuse');
		_defineTex2D('specular');
		_defineTex2D('emissive');
		_defineTex2D('thickness', 'g');
		_defineTex2D('specularityFactor', 'g');
		_defineTex2D('normal', '');
		_defineTex2D('metalness', 'g');
		_defineTex2D('gloss', 'g');
		_defineTex2D('opacity', 'a');
		_defineTex2D('refraction', 'g');
		_defineTex2D('height', 'g', false);
		_defineTex2D('ao', 'g');
		_defineTex2D('light', 'rgb', true, 1);
		_defineTex2D('msdf', '');
		_defineTex2D('diffuseDetail', 'rgb', false);
		_defineTex2D('normalDetail', '');
		_defineTex2D('aoDetail', 'g', false);
		_defineTex2D('clearCoat', 'g');
		_defineTex2D('clearCoatGloss', 'g');
		_defineTex2D('clearCoatNormal', '');
		_defineTex2D('sheen', 'rgb');
		_defineTex2D('sheenGloss', 'g');
		_defineTex2D('iridescence', 'g');
		_defineTex2D('iridescenceThickness', 'g');
		_defineFlag('diffuseDetailMode', DETAILMODE_MUL);
		_defineFlag('aoDetailMode', DETAILMODE_MUL);
		_defineObject('cubeMap');
		_defineObject('sphereMap');
		_defineObject('envAtlas');
		var getterFunc = function getterFunc() {
			return this._prefilteredCubemaps;
		};
		var setterFunc = function setterFunc(value) {
			var cubemaps = this._prefilteredCubemaps;
			value = value || [];
			var changed = false;
			var complete = true;
			for (var i = 0; i < 6; ++i) {
				var v = value[i] || null;
				if (cubemaps[i] !== v) {
					cubemaps[i] = v;
					changed = true;
				}
				complete = complete && !!cubemaps[i];
			}
			if (changed) {
				if (complete) {
					this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
						target: this.envAtlas
					});
				} else {
					if (this.envAtlas) {
						this.envAtlas.destroy();
						this.envAtlas = null;
					}
				}
				this._dirtyShader = true;
			}
		};
		var empty = [null, null, null, null, null, null];
		definePropInternal('prefilteredCubemaps', function () {
			return empty.slice();
		}, setterFunc, getterFunc);
	}
	_defineMaterialProps();

	var base64String = 'muPIHORMLNDCz4DxVR/ZvYfAUVEFR47KRIC4nwAAAAAP7WxlhD6Ci+2HCe7BF8jRAPZwdH2UPpI5PdLCJdkvG4UTaNDJ/0crAzne71GCrb4kbdMjjCEGzdX6fNxDMLJq5xkeoIVTdfiZkodEeArmZmp/FQzFjD4x8iOW7Dg64n+3mWqyEwLxXT8zoJXfbw8QJKDCaarUYyTlMzNFHbgUe9IQV7g4YOgtSKpIFZJ0qERm7u4PpmiF89ktHWCywaGmD6h+hfh2/Zd8KYlKqqo4Cem4T42bT/Z9FpCQF1hhSjfBzZ5XFn/y3jegWC6u86KuELRundQS/1Rp+XuKKGIgRv3CvP5y749yqLlFO495JOT3+f2CXgd71npU0/KjjpkZucbJ5m78IVyuSrSozc9jgBUhDrz0hFsyb7LFUH9//wJbBgLdNWJZObfKxrNt8TliLA9w9sXFv6g26iXpf6r/BqcAusj/QzGBZuoUGeEtw8BCXCZ3jUiw4hvM18ZVqlUD3C40LAFXW6FRjuAZGRNstb0/qVk4skwyT+MHrvRorI4rKHVMWZmKyAkzL/78u/9pMQuX14pZN50b2PHn6fRxeaCQLsfT4dpvIkWWFuFVENZIh+8xgR6lU+85W0PPdAu1j99kcCG40JBQa4JMyRzq6qriOBLtqF87vpCJan0WEduVr/mOYkS00urVA0mA6M3031+GmGmW48PaJDYOEIb3bIXWPaLoAOEinX1TN3+/vwhG6nqJu0TdHpedS7QsGZIoxH3nQYYjQP1jmbahlbNngw5ogsGk1y50XZyUmQBY+/JBJ3Unu4dApm+WmPwHPU9gLb+4mHh4BiY6M86pq+WeTyWdI3s0CXPEtHGXZ8zMZgUoyRomBi1VdazzuN+WOmQ9Pa0Z0tlNopUi8AJ4x2Xn4mmOKEbXLxlbVsWu8XhuDGYFOGCRVdSqDPXrHU5SDdUlti3k5///SBwzTMwK3L4a1H7w4lnpEas6////AfX8asyIBfeFXVJ3tgvxQ/blZuUKyIODIfr/UzdWNu7pciLBpdZRZ4pIfZ1R6szq+XNxkGG///8EZFpu7VHAhFWqHEOrB9unw+YQa5o8/9IR/V5/zq+986rJSyfgJKt2u9hxU1wzyQWPjJGvzG9+eWWxGFOHVKqI4jBQALwZZswesnvZ2UmmkEXdiRpz8B+oWE7PY70ZTMndisYSXg2TqoI+3y9BxbnY2Y4EfbdcRhAvG59NqDENNYbxKvK5HJfPG5M+Wi2AcpLVJrD6caiEOzgSoVNSgQK8fm2M3zGcF4xtClv/8Hs9oD7C3jitTATYNQxmKqKf1LhIxzf1bmfiNn7UKFmcJu4sLqVLwxGSue3taBEyknkw5hXTsUCvqmmL/f8n/w0giR7Hu/9EHvpkz3yuu64TioMkzdTJ30i0+hFnQqW1+v9mMwq+z9qGX0UFu9MomvVG2xod6vc12AAAAACq7sGa5qptFR0jF3nQt/D+7PibKYahaxP3hEixPbGi9nwNf2LAa7LkEZRKxzXeCD64Xpii5n+8Kpg8eHIv7AWXZltgMoGltmoJ0XGdOCL8WkzphvR9N2o3ARSZ42l5e5Pe4B58MCRlP3EKv+mcloknH+fto5BWsmEutW6KvjOVsznFCktkSczVk4aGvj9VXlRcLeDoKG8RkBgdcNG2bf8HUL4MT2DM+ar7NImJhKpxakX4Vk0CnP+/XNhl5UsP0lXgeZXPoDBMSW5An+DXlTCO5FQGwSPYwHLKYVIimEdAoVe49rQLaaNcye5LxU2/c5TijTgJtD5eQQIe1snxauj5jZsxJBUJdoP/zqpjqv8qBruoPsVsP8N44PCUW5Dd0DzqjSS/Dl5mI9cn1w2ndN/0KAEm1QAAAACwu6KM/083IBbH5bPa/9oHUwcU8I9v3j6/v18QYammrf+P6VL///8BrpuM3fOLCxaLNOFNF1zPbPYTP65ni6njft4eVcyrVXRQFrs52tr35StiSp55edVDCBC0H5rIfac6nzUwxQSt7y15QoKb+5zebEQUmVbrPjXuUa19Ey7sqXMiSUKHaw72PJKDdrutJoQr3u6lEYJ8K0MakWKj9zjTFi4X94TsKYco0GrLeB60M6D8M/80rhXUW8iMequg8y5F838WI0+gp3GBN5Kj/xIOxTWQuUaPV/LwvARr1VH93BFgGZR1MFW0Ua30GbYmdnAgo9VWy8SQtpDUgGE2r2zq2eTEMCL7sMKmE1hchVhuF/TCq9iXKEm86kzOf3Rp9ZnCxbpDUj+FKNxVyXe6pVZkRXv/m95SnB/EB8aME29N85MtAcDoXWlor8De2Q5Dg1tar+8wgiZufbMam81j//ASUohoR/zSh2KG4bvT6mkIPz6C5/98DC3LaWlaEZ1zA5JORZRu6J/a0GY285sEYzw71YqOT1ihAG0z5SDt1xNiDQWZdFpndArp6xWhqSDkRb4kSJEHb9liPvw7uLV/6i5MVf//A9Qjr8xkAEUh+KDI+zdtJ68d6MBOktg1iyp/SCq8O9f5pbamn1VVVQPRTWqNBvhQKa07s6P0lc9Luu/3gw4HeyOUfz8MxMwV4UQhua+t9cr4bz/nIB2wnDSK1K7I94M+s6C84htaX/CNlMQUSs2KJO+yaebfTbkNX5yWcqEJevo0vbKUiETuFXiL019A3E+lmsyZMwXrXLLiQAZ5t9+jI3JobhJTMiDH5ZOQ+8Jau5555NMjHSscP9qCVaa40doh+1a3Ukf6jqBmLddgh79/fwTfCyqiuldNkUoy+nUp+4nerwg0OjtGv2x485PJOJvUEokNhYIdWjpx7BWk0VZGWOp3jSFTJ2bnu6KCduZtG/UcBC9RZ3W/jMSfSMw4Etr/DoD/XYP2V5Ovw+YoM3F5g2dGLdvuG6ZkVGLE6Dk5Zr+sdSyGliJP1y2OFf/KFO0RWO+3gsGhesTnfZVpTd8/HwgO216gwaqo+vY3TljfJWowY+i0p0Os4SLn/1wLqDHMlszggmT/D8MRFzs+pLv6LNJSsNZ/r41mWi/rF6ZcKp/yzJdK0VU44hskq3RGpgO6mIpJDsf/mZkFrz0yYOMLbuaj/wp1v7JMFM5eqvBhmTd7U8frQAtHtys4zgpjZmzUhOVTfNNLifElGXADlqHGKrkBT/nYwX8ZRm3RjvyPvjKyEqEGKUpVnvOGx+NKPHiWM//ZDpDVGvvrjmk8RPF/wiYZD3+Us8YCXjrVOfjdd1UPAfjLp8jgSn4me7DPTpz1Ggy9XL80guFO7ECT10AvILKfD18Qx+KY/f8aRqu0oOO8hfKRFZa9PUJwCsp6VdZz6LFkm2b9Pl2LIifCwzRy7TpdG2uAtOxP2OemY26bJMa9ZGSLIRlMsgpDpnDJwd0oa5pQ13x1hrHf52HpulUWonGWsfXZbSQYKu9bnEN76ciQih0opN3deDVrbrxorfVlnCmL1R9zq3ePGWIv21c7pW8kEiFTM5JX8dAw867s/60cf79/BH+MDFCZBHlz1L+qGOJf/1txhhmrf3//As+RIJwevDb+fgNXVeHw67QptZegayhrEwr5Gy+EPo1RLaMtPbqOZYoVzXzwzjMFWZxyUG9YUIf6////AQWy84iAygLk9COtXt92+0mT/xg0zMzMBeLkb8y9SL2TDXgSX422hDgpGNLJyuPioA+YJ91G8znrpNqHkwYyscaJDEc9Vc+j4cXle3hvcd2JqDQH2lBZxDn6mUTs0b75raMvbs727codX01Anj8f3wir9P2xQaQ22v/TxCMglKDFoTjaP01XTLgxnTvPv02JgEUrW6UDgOnobFpLdvKdlypgIzPcq14fgXU5tvVW0FEs7VRlsG1IyA69fN4n+awHhT34cE+xUvdj86C8LgAsFheTjI9Ht9EyYAAAAAAVBVKRx2wLgUTI0/2QfyJo2riRw3JDqzEShmx/Lifo6mRkQVbS7X53t+EvKxcXogtdts31e9MRHdcHgsA8rt4/mt2unlzQ/wsU8Gu7+W6Oj7eD8EQdDp5XlCsVaS/AV/t5ZpPOHR3rGpyAJe9IPV+xMrBL1Oz/8MQhFs31h0N1cVnq371uqIJYHyafKH1jteAK3VpMXBcuC+yt0ZeKyRUY4QhdrJJ4tJ1wg3Hu6kDsbovxupTMkGdRrm8oZSoYPbJ+PwH/xotgTdkA1205vUEfnqkI04T/fnnd1fiZW5AwNcggd7fi4j5zasmcntZexIxqFZQMzMJpfndmI5jn17cgn5EV5t9XN0C///8Q9wlJpMGXdoiaMTG2sVyHQsn8mWRISCLNG777S0OuDRP2GlLcJ2UeOg7Fo8hTNPeJ//iTJhyqxhKRUntdXOihq2wfKfH///8B0GGrwT+fSOQRdctKxjjGCSS11d6BlQ9BDfE0J6Z25FaNTKGpFKNCMr2G/041KpWwBLVe1k08vncseQbKZdXi8x1t9XA45U/Wd43D9wAh3Tal0aiLVzGPusOZ1F+W3TWoqlX/A95+dNef11TsuGful+ctGssldk3fqpfqh+43XTxL42+leSHoF/dWHYGX6maqUEuLX7UB+r/6Llr4LKocbVIeu+hB9QTPfz9fCP8RyWmX4SmbhMFsNtCijV7lVcwejLKlvl0GfCndnWV7/39VBrtTRuUx92oke3GBgKkC5fdGK0YvNK+xenKaDmsHDjNFUM3NMz3ZiXXFuLgojosPVCDEl2W5BjX3Ms+j0GSqACHmh0+RPWyuNm/Qe8vFf9AW7N1uRaxWirrUytqEJnJ4/Flm8hSoiZ2NQBsS6w/yQlC4gCaFo8q4nyY6AFdo4hiwhBXzbNKKvZvktCjSCukRR/BbYVbNwZi2Yh3hGodEacLW8qijiWJODf0P2bhfaiPspPT4lYJBgi/KfcFwCfvyUIgkJOv///8CG/JEepRBLaMFE+2TgrqsJXOVOWHt6g/bFwVLLMVBsMR50dis/39/AlBX+/rMTJkUQrnlxpR2iu0Tp8tATkRYGmDIrcAiRP8PjoWIlb7/0ecTdSCE9Y58+a+n/FovJQTVF4F2jAxMZhTgrM/KVS5BQu6bVbkWY5HXnxRshks3urDdW4RkWp4M4TeLmFK5KF/uHkkiO5Kv96RioH984v/CSDBnG+BwlnU9B+o7Y+0X0Nob+0pLsStxjvPXMy2eCpzhOWV4XbObBHN4UE2sLQ/DIqXhOzxVf38GlTi6aG7EnePO7TRJm9yOfUUcqq1I2iQHrVDqn3TUNRi/lMw8KbMW/3/nqCz/Ef8PoW5Qxcz2yHR/f78EPB2Stbd+ZFmfNTUYILzsb9YNhpaHcaymYrBiNHmFE3Y4ccYJ25Prqm7zHobGHED8/93ZNlWro9vcKivGZs31UiK1k5zjUhexUgbqJb+fUTjxce/7Zly8a5KMC1fX5nfjPgibdvzbXV1jRT2asXvmSAusaLdq1TSIJ8fXINk5AtT34EWPAsfP9IFQqM5K11O6saoHJA==';
	var data = null;
	var initData = function initData() {
		if (!data) {
			var binaryString = atob(base64String);
			data = Uint8Array.from(binaryString, function (_char) {
				return _char.charCodeAt(0);
			});
		}
	};
	var blueNoiseData = function blueNoiseData() {
		initData();
		return data;
	};
	var BlueNoise = function () {
		function BlueNoise(seed) {
			if (seed === void 0) {
				seed = 0;
			}
			this.seed = 0;
			this.seed = seed * 4;
			initData();
		}
		var _proto = BlueNoise.prototype;
		_proto._next = function _next() {
			this.seed = (this.seed + 4) % data.length;
		};
		_proto.value = function value() {
			this._next();
			return data[this.seed] / 255;
		};
		_proto.vec4 = function vec4(dest) {
			if (dest === void 0) {
				dest = new Vec4();
			}
			this._next();
			return dest.set(data[this.seed], data[this.seed + 1], data[this.seed + 2], data[this.seed + 3]).mulScalar(1 / 255);
		};
		return BlueNoise;
	}();

	var lightCubeDir = [new Vec3(-1, 0, 0), new Vec3(1, 0, 0), new Vec3(0, -1, 0), new Vec3(0, 1, 0), new Vec3(0, 0, -1), new Vec3(0, 0, 1)];
	var LightCube = function () {
		function LightCube() {
			this.colors = new Float32Array(6 * 3);
		}
		var _proto = LightCube.prototype;
		_proto.update = function update(ambientLight, lights) {
			var colors = this.colors;
			var r = ambientLight.r,
				g = ambientLight.g,
				b = ambientLight.b;
			for (var j = 0; j < 6; j++) {
				colors[j * 3] = r;
				colors[j * 3 + 1] = g;
				colors[j * 3 + 2] = b;
			}
			for (var _j = 0; _j < lights.length; _j++) {
				var light = lights[_j];
				if (light._type === LIGHTTYPE_DIRECTIONAL) {
					for (var c = 0; c < 6; c++) {
						var weight = Math.max(lightCubeDir[c].dot(light._direction), 0) * light._intensity;
						var lightColor = light._color;
						colors[c * 3] += lightColor.r * weight;
						colors[c * 3 + 1] += lightColor.g * weight;
						colors[c * 3 + 2] += lightColor.b * weight;
					}
				}
			}
		};
		return LightCube;
	}();

	var createTexture = function createTexture(device, namePrefix, size, data) {
		var texture = new Texture(device, {
			name: "" + namePrefix + size,
			width: size,
			height: size,
			format: PIXELFORMAT_RGBA8,
			addressU: ADDRESS_REPEAT,
			addressV: ADDRESS_REPEAT,
			type: TEXTURETYPE_DEFAULT,
			magFilter: FILTER_NEAREST,
			minFilter: FILTER_NEAREST,
			anisotropy: 1,
			mipmaps: false
		});
		texture.lock().set(data);
		texture.unlock();
		return texture;
	};
	var deviceCacheBlueNoise = new DeviceCache();
	var getBlueNoiseTexture = function getBlueNoiseTexture(device) {
		return deviceCacheBlueNoise.get(device, function () {
			var data = blueNoiseData();
			var size = Math.sqrt(data.length / 4);
			return createTexture(device, 'BlueNoise', size, data);
		});
	};

	var ShadowMap = function () {
		function ShadowMap(texture, targets) {
			this.texture = texture;
			this.cached = false;
			this.renderTargets = targets;
		}
		var _proto = ShadowMap.prototype;
		_proto.destroy = function destroy() {
			if (this.texture) {
				this.texture.destroy();
				this.texture = null;
			}
			var targets = this.renderTargets;
			for (var i = 0; i < targets.length; i++) {
				targets[i].destroy();
			}
			this.renderTargets.length = 0;
		};
		ShadowMap.getShadowFiltering = function getShadowFiltering(device, shadowType) {
			if (shadowType === SHADOW_VSM_32F) {
				return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
			}
			return FILTER_LINEAR;
		};
		ShadowMap.create = function create(device, light) {
			var shadowMap = null;
			if (light._type === LIGHTTYPE_OMNI) {
				shadowMap = this.createCubemap(device, light._shadowResolution, light._shadowType);
			} else {
				shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
			}
			return shadowMap;
		};
		ShadowMap.createAtlas = function createAtlas(device, resolution, shadowType) {
			var shadowMap = this.create2dMap(device, resolution, shadowType);
			var targets = shadowMap.renderTargets;
			var rt = targets[0];
			for (var i = 0; i < 5; i++) {
				targets.push(rt);
			}
			return shadowMap;
		};
		ShadowMap.create2dMap = function create2dMap(device, size, shadowType) {
			var _pixelFormatInfo$get;
			var shadowInfo = shadowTypeInfo.get(shadowType);
			var filter = this.getShadowFiltering(device, shadowType);
			var formatName = (_pixelFormatInfo$get = pixelFormatInfo.get(shadowInfo.format)) == null ? void 0 : _pixelFormatInfo$get.name;
			var texture = new Texture(device, {
				format: shadowInfo == null ? void 0 : shadowInfo.format,
				width: size,
				height: size,
				mipmaps: false,
				minFilter: filter,
				magFilter: filter,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: "ShadowMap2D_" + formatName
			});
			var target = null;
			if (shadowInfo != null && shadowInfo.pcf) {
				texture.compareOnRead = true;
				texture.compareFunc = FUNC_LESS;
				target = new RenderTarget({
					depthBuffer: texture
				});
			} else {
				target = new RenderTarget({
					colorBuffer: texture,
					depth: true
				});
			}
			if (device.isWebGPU) {
				target.flipY = true;
			}
			return new ShadowMap(texture, [target]);
		};
		ShadowMap.createCubemap = function createCubemap(device, size, shadowType) {
			var _pixelFormatInfo$get2;
			var shadowInfo = shadowTypeInfo.get(shadowType);
			var formatName = (_pixelFormatInfo$get2 = pixelFormatInfo.get(shadowInfo.format)) == null ? void 0 : _pixelFormatInfo$get2.name;
			var isPcss = shadowType === SHADOW_PCSS_32F;
			var filter = isPcss ? FILTER_NEAREST : FILTER_LINEAR;
			var cubemap = new Texture(device, {
				format: shadowInfo == null ? void 0 : shadowInfo.format,
				width: size,
				height: size,
				cubemap: true,
				mipmaps: false,
				minFilter: filter,
				magFilter: filter,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: "ShadowMapCube_" + formatName
			});
			if (!isPcss) {
				cubemap.compareOnRead = true;
				cubemap.compareFunc = FUNC_LESS;
			}
			var targets = [];
			for (var i = 0; i < 6; i++) {
				if (isPcss) {
					targets.push(new RenderTarget({
						colorBuffer: cubemap,
						face: i,
						depth: true
					}));
				} else {
					targets.push(new RenderTarget({
						depthBuffer: cubemap,
						face: i
					}));
				}
			}
			return new ShadowMap(cubemap, targets);
		};
		return ShadowMap;
	}();

	var _tempArray = [];
	var _tempArray2 = [];
	var _viewport$3 = new Vec4();
	var _scissor = new Vec4();
	var Slot = function Slot(rect) {
		this.size = Math.floor(rect.w * 1024);
		this.used = false;
		this.lightId = -1;
		this.rect = rect;
	};
	var LightTextureAtlas = function () {
		function LightTextureAtlas(device) {
			this.device = device;
			this.version = 1;
			this.shadowAtlasResolution = 2048;
			this.shadowAtlas = null;
			this.shadowEdgePixels = 3;
			this.cookieAtlasResolution = 4;
			this.cookieAtlas = new Texture(this.device, {
				name: 'CookieAtlas',
				width: this.cookieAtlasResolution,
				height: this.cookieAtlasResolution,
				format: PIXELFORMAT_RGBA8,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			this.cookieRenderTarget = new RenderTarget({
				colorBuffer: this.cookieAtlas,
				depth: false,
				flipY: true
			});
			this.slots = [];
			this.atlasSplit = [];
			this.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];
			this.scissorVec = new Vec4();
			this.allocateShadowAtlas(1);
			this.allocateCookieAtlas(1);
			this.allocateUniforms();
		}
		var _proto = LightTextureAtlas.prototype;
		_proto.destroy = function destroy() {
			this.destroyShadowAtlas();
			this.destroyCookieAtlas();
		};
		_proto.destroyShadowAtlas = function destroyShadowAtlas() {
			var _this$shadowAtlas;
			(_this$shadowAtlas = this.shadowAtlas) == null || _this$shadowAtlas.destroy();
			this.shadowAtlas = null;
		};
		_proto.destroyCookieAtlas = function destroyCookieAtlas() {
			var _this$cookieAtlas, _this$cookieRenderTar;
			(_this$cookieAtlas = this.cookieAtlas) == null || _this$cookieAtlas.destroy();
			this.cookieAtlas = null;
			(_this$cookieRenderTar = this.cookieRenderTarget) == null || _this$cookieRenderTar.destroy();
			this.cookieRenderTarget = null;
		};
		_proto.allocateShadowAtlas = function allocateShadowAtlas(resolution, shadowType) {
			var _this$shadowAtlas2;
			if (shadowType === void 0) {
				shadowType = SHADOW_PCF3_32F;
			}
			var existingFormat = (_this$shadowAtlas2 = this.shadowAtlas) == null ? void 0 : _this$shadowAtlas2.texture.format;
			var requiredFormat = shadowTypeInfo.get(shadowType).format;
			if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution || existingFormat !== requiredFormat) {
				this.version++;
				this.destroyShadowAtlas();
				this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, shadowType);
				this.shadowAtlas.cached = true;
				var scissorOffset = 4 / this.shadowAtlasResolution;
				this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
			}
		};
		_proto.allocateCookieAtlas = function allocateCookieAtlas(resolution) {
			if (this.cookieAtlas.width !== resolution) {
				this.cookieRenderTarget.resize(resolution, resolution);
				this.version++;
			}
		};
		_proto.allocateUniforms = function allocateUniforms() {
			this._shadowAtlasTextureId = this.device.scope.resolve('shadowAtlasTexture');
			this._shadowAtlasParamsId = this.device.scope.resolve('shadowAtlasParams');
			this._shadowAtlasParams = new Float32Array(2);
			this._cookieAtlasTextureId = this.device.scope.resolve('cookieAtlasTexture');
		};
		_proto.updateUniforms = function updateUniforms() {
			var rt = this.shadowAtlas.renderTargets[0];
			var shadowBuffer = rt.depthBuffer;
			this._shadowAtlasTextureId.setValue(shadowBuffer);
			this._shadowAtlasParams[0] = this.shadowAtlasResolution;
			this._shadowAtlasParams[1] = this.shadowEdgePixels;
			this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);
			this._cookieAtlasTextureId.setValue(this.cookieAtlas);
		};
		_proto.subdivide = function subdivide(numLights, lightingParams) {
			var atlasSplit = lightingParams.atlasSplit;
			if (!atlasSplit) {
				var gridSize = Math.ceil(Math.sqrt(numLights));
				atlasSplit = _tempArray2;
				atlasSplit[0] = gridSize;
				atlasSplit.length = 1;
			}
			var arraysEqual = function arraysEqual(a, b) {
				return a.length === b.length && a.every(function (v, i) {
					return v === b[i];
				});
			};
			if (!arraysEqual(atlasSplit, this.atlasSplit)) {
				var _this$atlasSplit;
				this.version++;
				this.slots.length = 0;
				this.atlasSplit.length = 0;
				(_this$atlasSplit = this.atlasSplit).push.apply(_this$atlasSplit, atlasSplit);
				var splitCount = this.atlasSplit[0];
				if (splitCount > 1) {
					var invSize = 1 / splitCount;
					for (var i = 0; i < splitCount; i++) {
						for (var j = 0; j < splitCount; j++) {
							var rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
							var nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];
							if (nextLevelSplit > 1) {
								for (var x = 0; x < nextLevelSplit; x++) {
									for (var y = 0; y < nextLevelSplit; y++) {
										var invSizeNext = invSize / nextLevelSplit;
										var rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
										this.slots.push(new Slot(rectNext));
									}
								}
							} else {
								this.slots.push(new Slot(rect));
							}
						}
					}
				} else {
					this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
				}
				this.slots.sort(function (a, b) {
					return b.size - a.size;
				});
			}
		};
		_proto.collectLights = function collectLights(localLights, lightingParams) {
			var cookiesEnabled = lightingParams.cookiesEnabled;
			var shadowsEnabled = lightingParams.shadowsEnabled;
			var needsShadowAtlas = false;
			var needsCookieAtlas = false;
			var lights = _tempArray;
			lights.length = 0;
			var processLights = function processLights(list) {
				for (var i = 0; i < list.length; i++) {
					var light = list[i];
					if (light.visibleThisFrame) {
						var lightShadow = shadowsEnabled && light.castShadows;
						var lightCookie = cookiesEnabled && !!light.cookie;
						needsShadowAtlas || (needsShadowAtlas = lightShadow);
						needsCookieAtlas || (needsCookieAtlas = lightCookie);
						if (lightShadow || lightCookie) {
							lights.push(light);
						}
					}
				}
			};
			if (cookiesEnabled || shadowsEnabled) {
				processLights(localLights);
			}
			lights.sort(function (a, b) {
				return b.maxScreenSize - a.maxScreenSize;
			});
			if (needsShadowAtlas) {
				this.allocateShadowAtlas(this.shadowAtlasResolution, lightingParams.shadowType);
			}
			if (needsCookieAtlas) {
				this.allocateCookieAtlas(this.cookieAtlasResolution);
			}
			if (needsShadowAtlas || needsCookieAtlas) {
				this.subdivide(lights.length, lightingParams);
			}
			return lights;
		};
		_proto.setupSlot = function setupSlot(light, rect) {
			light.atlasViewport.copy(rect);
			var faceCount = light.numShadowFaces;
			for (var face = 0; face < faceCount; face++) {
				if (light.castShadows || light._cookie) {
					_viewport$3.copy(rect);
					_scissor.copy(rect);
					if (light._type === LIGHTTYPE_SPOT) {
						_viewport$3.add(this.scissorVec);
					}
					if (light._type === LIGHTTYPE_OMNI) {
						var smallSize = _viewport$3.z / 3;
						var offset = this.cubeSlotsOffsets[face];
						_viewport$3.x += smallSize * offset.x;
						_viewport$3.y += smallSize * offset.y;
						_viewport$3.z = smallSize;
						_viewport$3.w = smallSize;
						_scissor.copy(_viewport$3);
					}
					if (light.castShadows) {
						var lightRenderData = light.getRenderData(null, face);
						lightRenderData.shadowViewport.copy(_viewport$3);
						lightRenderData.shadowScissor.copy(_scissor);
					}
				}
			}
		};
		_proto.assignSlot = function assignSlot(light, slotIndex, slotReassigned) {
			light.atlasViewportAllocated = true;
			var slot = this.slots[slotIndex];
			slot.lightId = light.id;
			slot.used = true;
			if (slotReassigned) {
				light.atlasSlotUpdated = true;
				light.atlasVersion = this.version;
				light.atlasSlotIndex = slotIndex;
			}
		};
		_proto.update = function update(localLights, lightingParams) {
			this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
			this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
			var lights = this.collectLights(localLights, lightingParams);
			if (lights.length > 0) {
				var slots = this.slots;
				for (var i = 0; i < slots.length; i++) {
					slots[i].used = false;
				}
				var assignCount = Math.min(lights.length, slots.length);
				for (var _i = 0; _i < assignCount; _i++) {
					var light = lights[_i];
					if (light.castShadows) {
						light._shadowMap = this.shadowAtlas;
					}
					var previousSlot = slots[light.atlasSlotIndex];
					if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
						var _previousSlot = slots[light.atlasSlotIndex];
						if (_previousSlot.size === slots[_i].size && !_previousSlot.used) {
							this.assignSlot(light, light.atlasSlotIndex, false);
						}
					}
				}
				var usedCount = 0;
				for (var _i2 = 0; _i2 < assignCount; _i2++) {
					while (usedCount < slots.length && slots[usedCount].used) {
						usedCount++;
					}
					var _light = lights[_i2];
					if (!_light.atlasViewportAllocated) {
						this.assignSlot(_light, usedCount, true);
					}
					var slot = slots[_light.atlasSlotIndex];
					this.setupSlot(_light, slot.rect);
				}
			}
			this.updateUniforms();
		};
		return LightTextureAtlas;
	}();

	var ShadowMapCache = function () {
		function ShadowMapCache() {
			this.cache = new Map();
		}
		var _proto = ShadowMapCache.prototype;
		_proto.destroy = function destroy() {
			this.clear();
			this.cache = null;
		};
		_proto.clear = function clear() {
			this.cache.forEach(function (shadowMaps) {
				shadowMaps.forEach(function (shadowMap) {
					shadowMap.destroy();
				});
			});
			this.cache.clear();
		};
		_proto.getKey = function getKey(light) {
			var isCubeMap = light._type === LIGHTTYPE_OMNI;
			var shadowType = light._shadowType;
			var resolution = light._shadowResolution;
			return isCubeMap + "-" + shadowType + "-" + resolution;
		};
		_proto.get = function get(device, light) {
			var key = this.getKey(light);
			var shadowMaps = this.cache.get(key);
			if (shadowMaps && shadowMaps.length) {
				return shadowMaps.pop();
			}
			var shadowMap = ShadowMap.create(device, light);
			shadowMap.cached = true;
			return shadowMap;
		};
		_proto.add = function add(light, shadowMap) {
			var key = this.getKey(light);
			var shadowMaps = this.cache.get(key);
			if (shadowMaps) {
				shadowMaps.push(shadowMap);
			} else {
				this.cache.set(key, [shadowMap]);
			}
		};
		return ShadowMapCache;
	}();

	var RenderPassShadowLocalNonClustered = function (_RenderPass) {
		function RenderPassShadowLocalNonClustered(device, shadowRenderer, light, face, applyVsm) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.requiresCubemaps = false;
			_this.shadowRenderer = shadowRenderer;
			_this.light = light;
			_this.face = face;
			_this.applyVsm = applyVsm;
			_this.shadowCamera = shadowRenderer.prepareFace(light, null, face);
			shadowRenderer.setupRenderPass(_this, _this.shadowCamera, true);
			return _this;
		}
		_inheritsLoose(RenderPassShadowLocalNonClustered, _RenderPass);
		var _proto = RenderPassShadowLocalNonClustered.prototype;
		_proto.execute = function execute() {
			this.shadowRenderer.renderFace(this.light, null, this.face, false);
		};
		_proto.after = function after() {
			if (this.applyVsm) {
				this.shadowRenderer.renderVsm(this.light, this.shadowCamera);
			}
		};
		return RenderPassShadowLocalNonClustered;
	}(RenderPass);

	var ShadowRendererLocal = function () {
		function ShadowRendererLocal(renderer, shadowRenderer) {
			this.shadowLights = [];
			this.renderer = void 0;
			this.shadowRenderer = void 0;
			this.device = void 0;
			this.renderer = renderer;
			this.shadowRenderer = shadowRenderer;
			this.device = renderer.device;
		}
		var _proto = ShadowRendererLocal.prototype;
		_proto.cull = function cull(light, comp, casters) {
			if (casters === void 0) {
				casters = null;
			}
			var isClustered = this.renderer.scene.clusteredLightingEnabled;
			light.visibleThisFrame = true;
			if (!isClustered) {
				if (!light._shadowMap) {
					light._shadowMap = ShadowMap.create(this.device, light);
				}
			}
			var type = light._type;
			var faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;
			for (var face = 0; face < faceCount; face++) {
				var lightRenderData = light.getRenderData(null, face);
				var shadowCam = lightRenderData.shadowCamera;
				shadowCam.nearClip = light.attenuationEnd / 1000;
				shadowCam.farClip = light.attenuationEnd;
				var shadowCamNode = shadowCam._node;
				var lightNode = light._node;
				shadowCamNode.setPosition(lightNode.getPosition());
				if (type === LIGHTTYPE_SPOT) {
					shadowCam.fov = light._outerConeAngle * 2;
					shadowCamNode.setRotation(lightNode.getRotation());
					shadowCamNode.rotateLocal(-90, 0, 0);
				} else if (type === LIGHTTYPE_OMNI) {
					if (isClustered) {
						var tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
						var texelSize = 2 / tileSize;
						var filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
						shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
					} else {
						shadowCam.fov = 90;
					}
				}
				this.renderer.updateCameraFrustum(shadowCam);
				this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
			}
		};
		_proto.prepareLights = function prepareLights(shadowLights, lights) {
			var shadowCamera;
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (this.shadowRenderer.needsShadowRendering(light) && light.atlasViewportAllocated) {
					shadowLights.push(light);
					for (var face = 0; face < light.numShadowFaces; face++) {
						shadowCamera = this.shadowRenderer.prepareFace(light, null, face);
					}
				}
			}
			return shadowCamera;
		};
		_proto.buildNonClusteredRenderPasses = function buildNonClusteredRenderPasses(frameGraph, localLights) {
			for (var i = 0; i < localLights.length; i++) {
				var light = localLights[i];
				if (this.shadowRenderer.needsShadowRendering(light)) {
					var applyVsm = light._type === LIGHTTYPE_SPOT;
					var faceCount = light.numShadowFaces;
					for (var face = 0; face < faceCount; face++) {
						var renderPass = new RenderPassShadowLocalNonClustered(this.device, this.shadowRenderer, light, face, applyVsm);
						frameGraph.addRenderPass(renderPass);
					}
				}
			}
		};
		return ShadowRendererLocal;
	}();

	var RenderPassShadowDirectional = function (_RenderPass) {
		function RenderPassShadowDirectional(device, shadowRenderer, light, camera, allCascadesRendering) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.shadowRenderer = shadowRenderer;
			_this.light = light;
			_this.camera = camera;
			_this.allCascadesRendering = allCascadesRendering;
			return _this;
		}
		_inheritsLoose(RenderPassShadowDirectional, _RenderPass);
		var _proto = RenderPassShadowDirectional.prototype;
		_proto.execute = function execute() {
			var light = this.light,
				camera = this.camera,
				shadowRenderer = this.shadowRenderer,
				allCascadesRendering = this.allCascadesRendering;
			var faceCount = light.numShadowFaces;
			var shadowUpdateOverrides = light.shadowUpdateOverrides;
			for (var face = 0; face < faceCount; face++) {
				if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) !== SHADOWUPDATE_NONE) {
					shadowRenderer.renderFace(light, camera, face, !allCascadesRendering);
				}
				if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_THISFRAME) {
					shadowUpdateOverrides[face] = SHADOWUPDATE_NONE;
				}
			}
		};
		_proto.after = function after() {
			this.shadowRenderer.renderVsm(this.light, this.camera);
		};
		return RenderPassShadowDirectional;
	}(RenderPass);

	var visibleSceneAabb = new BoundingBox();
	var center = new Vec3();
	var shadowCamView$1 = new Mat4();
	var aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
	var _depthRange = {
		min: 0,
		max: 0
	};
	function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
		aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
		aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
		aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
		aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
		aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
		aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
		var minz = 9999999999;
		var maxz = -9999999999;
		for (var i = 0; i < 8; ++i) {
			cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
			var z = aabbPoints[i].z;
			if (z < minz) minz = z;
			if (z > maxz) maxz = z;
		}
		_depthRange.min = minz;
		_depthRange.max = maxz;
		return _depthRange;
	}
	var ShadowRendererDirectional = function () {
		function ShadowRendererDirectional(renderer, shadowRenderer) {
			this.renderer = void 0;
			this.shadowRenderer = void 0;
			this.device = void 0;
			this.renderer = renderer;
			this.shadowRenderer = shadowRenderer;
			this.device = renderer.device;
		}
		var _proto = ShadowRendererDirectional.prototype;
		_proto.cull = function cull(light, comp, camera, casters) {
			if (casters === void 0) {
				casters = null;
			}
			light.visibleThisFrame = true;
			if (!light._shadowMap) {
				light._shadowMap = ShadowMap.create(this.device, light);
			}
			var nearDist = camera._nearClip;
			this.generateSplitDistances(light, nearDist, Math.min(camera._farClip, light.shadowDistance));
			var shadowUpdateOverrides = light.shadowUpdateOverrides;
			for (var cascade = 0; cascade < light.numCascades; cascade++) {
				if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[cascade]) === SHADOWUPDATE_NONE) {
					break;
				}
				var lightRenderData = light.getRenderData(camera, cascade);
				var shadowCam = lightRenderData.shadowCamera;
				shadowCam.renderTarget = light._shadowMap.renderTargets[0];
				lightRenderData.shadowViewport.copy(light.cascades[cascade]);
				lightRenderData.shadowScissor.copy(light.cascades[cascade]);
				var shadowCamNode = shadowCam._node;
				var lightNode = light._node;
				shadowCamNode.setPosition(lightNode.getPosition());
				shadowCamNode.setRotation(lightNode.getRotation());
				shadowCamNode.rotateLocal(-90, 0, 0);
				var frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
				var frustumFarDist = light._shadowCascadeDistances[cascade];
				var frustumPoints = camera.getFrustumCorners(frustumNearDist, frustumFarDist);
				center.set(0, 0, 0);
				var cameraWorldMat = camera.node.getWorldTransform();
				for (var i = 0; i < 8; i++) {
					cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
					center.add(frustumPoints[i]);
				}
				center.mulScalar(1 / 8);
				var radius = 0;
				for (var _i = 0; _i < 8; _i++) {
					var dist = frustumPoints[_i].sub(center).length();
					if (dist > radius) {
						radius = dist;
					}
				}
				var right = shadowCamNode.right;
				var up = shadowCamNode.up;
				var lightDir = shadowCamNode.forward;
				var sizeRatio = 0.25 * light._shadowResolution / radius;
				var x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
				var y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
				var scaledUp = up.mulScalar(x);
				var scaledRight = right.mulScalar(y);
				var dot = center.dot(lightDir);
				var scaledDir = lightDir.mulScalar(dot);
				center.add2(scaledUp, scaledRight).add(scaledDir);
				shadowCamNode.setPosition(center);
				shadowCamNode.translateLocal(0, 0, 1000000);
				shadowCam.nearClip = 0.01;
				shadowCam.farClip = 2000000;
				shadowCam.orthoHeight = radius;
				this.renderer.updateCameraFrustum(shadowCam);
				this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
				var emptyAabb = true;
				var visibleCasters = lightRenderData.visibleCasters;
				for (var _i2 = 0; _i2 < visibleCasters.length; _i2++) {
					var meshInstance = visibleCasters[_i2];
					if (emptyAabb) {
						emptyAabb = false;
						visibleSceneAabb.copy(meshInstance.aabb);
					} else {
						visibleSceneAabb.add(meshInstance.aabb);
					}
				}
				shadowCamView$1.copy(shadowCamNode.getWorldTransform()).invert();
				var depthRange = getDepthRange(shadowCamView$1, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
				shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
				shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
				lightRenderData.projectionCompensation = radius;
			}
		};
		_proto.generateSplitDistances = function generateSplitDistances(light, nearDist, farDist) {
			light._shadowCascadeDistances.fill(farDist);
			for (var i = 1; i < light.numCascades; i++) {
				var fraction = i / light.numCascades;
				var linearDist = nearDist + (farDist - nearDist) * fraction;
				var logDist = nearDist * Math.pow(farDist / nearDist, fraction);
				var dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
				light._shadowCascadeDistances[i - 1] = dist;
			}
		};
		_proto.getLightRenderPass = function getLightRenderPass(light, camera) {
			var renderPass = null;
			if (this.shadowRenderer.needsShadowRendering(light)) {
				var faceCount = light.numShadowFaces;
				var shadowUpdateOverrides = light.shadowUpdateOverrides;
				var allCascadesRendering = true;
				var shadowCamera;
				for (var face = 0; face < faceCount; face++) {
					if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_NONE) {
						allCascadesRendering = false;
					}
					shadowCamera = this.shadowRenderer.prepareFace(light, camera, face);
				}
				renderPass = new RenderPassShadowDirectional(this.device, this.shadowRenderer, light, camera, allCascadesRendering);
				this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, allCascadesRendering);
			}
			return renderPass;
		};
		return ShadowRendererDirectional;
	}();

	var tempSet$1 = new Set();
	var shadowCamView = new Mat4();
	var shadowCamViewProj = new Mat4();
	var pixelOffset = new Float32Array(2);
	var blurScissorRect = new Vec4(1, 1, 0, 0);
	var viewportMatrix = new Mat4();
	function gauss(x, sigma) {
		return Math.exp(-(x * x) / (2.0 * sigma * sigma));
	}
	function gaussWeights(kernelSize) {
		var sigma = (kernelSize - 1) / (2 * 3);
		var halfWidth = (kernelSize - 1) * 0.5;
		var values = new Array(kernelSize);
		var sum = 0.0;
		for (var i = 0; i < kernelSize; ++i) {
			values[i] = gauss(i - halfWidth, sigma);
			sum += values[i];
		}
		for (var _i = 0; _i < kernelSize; ++_i) {
			values[_i] /= sum;
		}
		return values;
	}
	var ShadowRenderer = function () {
		function ShadowRenderer(renderer, lightTextureAtlas) {
			this.shadowPassCache = [];
			this.device = renderer.device;
			this.renderer = renderer;
			this.lightTextureAtlas = lightTextureAtlas;
			var scope = this.device.scope;
			this.sourceId = scope.resolve('source');
			this.pixelOffsetId = scope.resolve('pixelOffset');
			this.weightId = scope.resolve('weight[0]');
			this.blurVsmShaderCode = [shaderChunks.blurVSMPS, "#define GAUSS\n" + shaderChunks.blurVSMPS];
			this.blurVsmShader = [{}, {}];
			this.blurVsmWeights = {};
			this.shadowMapLightRadiusId = scope.resolve('light_radius');
			this.viewUniformFormat = null;
			this.viewBindGroupFormat = null;
			this.blendStateWrite = new BlendState();
			this.blendStateNoWrite = new BlendState();
			this.blendStateNoWrite.setColorWrite(false, false, false, false);
		}
		ShadowRenderer.createShadowCamera = function createShadowCamera(shadowType, type, face) {
			var _shadowInfo$vsm, _shadowInfo$pcf;
			var shadowCam = LightCamera.create('ShadowCamera', type, face);
			var shadowInfo = shadowTypeInfo.get(shadowType);
			var isVsm = (_shadowInfo$vsm = shadowInfo == null ? void 0 : shadowInfo.vsm) != null ? _shadowInfo$vsm : false;
			var isPcf = (_shadowInfo$pcf = shadowInfo == null ? void 0 : shadowInfo.pcf) != null ? _shadowInfo$pcf : false;
			if (isVsm) {
				shadowCam.clearColor = new Color(0, 0, 0, 0);
			} else {
				shadowCam.clearColor = new Color(1, 1, 1, 1);
			}
			shadowCam.clearDepthBuffer = true;
			shadowCam.clearStencilBuffer = false;
			shadowCam.clearColorBuffer = !isPcf;
			return shadowCam;
		};
		var _proto = ShadowRenderer.prototype;
		_proto._cullShadowCastersInternal = function _cullShadowCastersInternal(meshInstances, visible, camera) {
			var numInstances = meshInstances.length;
			for (var i = 0; i < numInstances; i++) {
				var meshInstance = meshInstances[i];
				if (meshInstance.castShadow) {
					if (!meshInstance.cull || meshInstance._isVisible(camera)) {
						meshInstance.visibleThisFrame = true;
						visible.push(meshInstance);
					}
				}
			}
		};
		_proto.cullShadowCasters = function cullShadowCasters(comp, light, visible, camera, casters) {
			visible.length = 0;
			if (casters) {
				this._cullShadowCastersInternal(casters, visible, camera);
			} else {
				var layers = comp.layerList;
				var len = layers.length;
				for (var i = 0; i < len; i++) {
					var layer = layers[i];
					if (layer._lightsSet.has(light)) {
						if (!tempSet$1.has(layer)) {
							tempSet$1.add(layer);
							this._cullShadowCastersInternal(layer.shadowCasters, visible, camera);
						}
					}
				}
				tempSet$1.clear();
			}
			visible.sort(this.renderer.sortCompareDepth);
		};
		_proto.setupRenderState = function setupRenderState(device, light) {
			var isClustered = this.renderer.scene.clusteredLightingEnabled;
			var useShadowSampler = isClustered ? light._isPcf : light._isPcf && light._type !== LIGHTTYPE_OMNI;
			device.setBlendState(useShadowSampler ? this.blendStateNoWrite : this.blendStateWrite);
			device.setDepthState(light.shadowDepthState);
			device.setStencilState(null, null);
		};
		_proto.dispatchUniforms = function dispatchUniforms(light, shadowCam, lightRenderData, face) {
			var shadowCamNode = shadowCam._node;
			if (light._type !== LIGHTTYPE_DIRECTIONAL) {
				this.renderer.dispatchViewPos(shadowCamNode.getPosition());
				this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
			}
			shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
			shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
			var rectViewport = lightRenderData.shadowViewport;
			shadowCam.rect = rectViewport;
			shadowCam.scissorRect = lightRenderData.shadowScissor;
			viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
			lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);
			if (light._type === LIGHTTYPE_DIRECTIONAL) {
				light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
			}
		};
		_proto.getShadowPass = function getShadowPass(light) {
			var _this$shadowPassCache;
			var lightType = light._type;
			var shadowType = light._shadowType;
			var shadowPassInfo = (_this$shadowPassCache = this.shadowPassCache[lightType]) == null ? void 0 : _this$shadowPassCache[shadowType];
			if (!shadowPassInfo) {
				var shadowPassName = "ShadowPass_" + lightType + "_" + shadowType;
				shadowPassInfo = ShaderPass.get(this.device).allocate(shadowPassName, {
					isShadow: true,
					lightType: lightType,
					shadowType: shadowType
				});
				if (!this.shadowPassCache[lightType]) {
					this.shadowPassCache[lightType] = [];
				}
				this.shadowPassCache[lightType][shadowType] = shadowPassInfo;
			}
			return shadowPassInfo.index;
		};
		_proto.submitCasters = function submitCasters(visibleCasters, light, camera) {
			var device = this.device;
			var renderer = this.renderer;
			var scene = renderer.scene;
			var passFlags = 1 << SHADER_SHADOW;
			var shadowPass = this.getShadowPass(light);
			var cameraShaderParams = camera.shaderParams;
			var count = visibleCasters.length;
			for (var i = 0; i < count; i++) {
				var meshInstance = visibleCasters[i];
				var mesh = meshInstance.mesh;
				meshInstance.ensureMaterial(device);
				var material = meshInstance.material;
				renderer.setBaseConstants(device, material);
				renderer.setSkinning(device, meshInstance);
				if (material.dirty) {
					material.updateUniforms(device, scene);
					material.dirty = false;
				}
				if (material.chunks) {
					renderer.setupCullMode(true, 1, meshInstance);
					material.setParameters(device);
					meshInstance.setParameters(device, passFlags);
				}
				var shaderInstance = meshInstance.getShaderInstance(shadowPass, 0, scene, cameraShaderParams, this.viewUniformFormat, this.viewBindGroupFormat);
				var shadowShader = shaderInstance.shader;
				meshInstance._key[SORTKEY_DEPTH] = shadowShader.id;
				device.setShader(shadowShader);
				renderer.setVertexBuffers(device, mesh);
				renderer.setMorphing(device, meshInstance.morphInstance);
				this.renderer.setupMeshUniformBuffers(shaderInstance, meshInstance);
				var style = meshInstance.renderStyle;
				device.setIndexBuffer(mesh.indexBuffer[style]);
				renderer.drawInstance(device, meshInstance, mesh, style);
				renderer._shadowDrawCalls++;
			}
		};
		_proto.needsShadowRendering = function needsShadowRendering(light) {
			var needs = light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame;
			if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
				light.shadowUpdateMode = SHADOWUPDATE_NONE;
			}
			if (needs) {
				this.renderer._shadowMapUpdates += light.numShadowFaces;
			}
			return needs;
		};
		_proto.getLightRenderData = function getLightRenderData(light, camera, face) {
			return light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
		};
		_proto.setupRenderPass = function setupRenderPass(renderPass, shadowCamera, clearRenderTarget) {
			var rt = shadowCamera.renderTarget;
			renderPass.init(rt);
			renderPass.depthStencilOps.clearDepthValue = 1;
			renderPass.depthStencilOps.clearDepth = clearRenderTarget;
			if (rt.depthBuffer) {
				renderPass.depthStencilOps.storeDepth = true;
			} else {
				renderPass.colorOps.clearValue.copy(shadowCamera.clearColor);
				renderPass.colorOps.clear = clearRenderTarget;
				renderPass.depthStencilOps.storeDepth = false;
			}
			renderPass.requiresCubemaps = false;
		};
		_proto.prepareFace = function prepareFace(light, camera, face) {
			var type = light._type;
			var lightRenderData = this.getLightRenderData(light, camera, face);
			var shadowCam = lightRenderData.shadowCamera;
			var renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
			shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
			return shadowCam;
		};
		_proto.renderFace = function renderFace(light, camera, face, clear, insideRenderPass) {
			if (insideRenderPass === void 0) {
				insideRenderPass = true;
			}
			var device = this.device;
			var lightRenderData = this.getLightRenderData(light, camera, face);
			var shadowCam = lightRenderData.shadowCamera;
			this.dispatchUniforms(light, shadowCam, lightRenderData, face);
			var rt = shadowCam.renderTarget;
			var renderer = this.renderer;
			renderer.setCameraUniforms(shadowCam, rt);
			if (device.supportsUniformBuffers) {
				renderer.setupViewUniformBuffers(lightRenderData.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1);
			}
			if (insideRenderPass) {
				renderer.setupViewport(shadowCam, rt);
				if (clear) {
					renderer.clear(shadowCam);
				}
			} else {
				renderer.clearView(shadowCam, rt, true, false);
			}
			this.setupRenderState(device, light);
			this.submitCasters(lightRenderData.visibleCasters, light, shadowCam);
		};
		_proto.render = function render(light, camera, insideRenderPass) {
			if (insideRenderPass === void 0) {
				insideRenderPass = true;
			}
			if (this.needsShadowRendering(light)) {
				var faceCount = light.numShadowFaces;
				for (var face = 0; face < faceCount; face++) {
					this.prepareFace(light, camera, face);
					this.renderFace(light, camera, face, true, insideRenderPass);
				}
				this.renderVsm(light, camera);
			}
		};
		_proto.renderVsm = function renderVsm(light, camera) {
			if (light._isVsm && light._vsmBlurSize > 1) {
				var isClustered = this.renderer.scene.clusteredLightingEnabled;
				if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
					this.applyVsmBlur(light, camera);
				}
			}
		};
		_proto.getVsmBlurShader = function getVsmBlurShader(blurMode, filterSize) {
			var cache = this.blurVsmShader;
			var blurShader = cache[blurMode][filterSize];
			if (!blurShader) {
				this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
				var blurVS = shaderChunks.fullscreenQuadVS;
				var blurFS = "#define SAMPLES " + filterSize + "\n";
				blurFS += this.blurVsmShaderCode[blurMode];
				var blurShaderName = "blurVsm" + blurMode + filterSize;
				blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
				cache[blurMode][filterSize] = blurShader;
			}
			return blurShader;
		};
		_proto.applyVsmBlur = function applyVsmBlur(light, camera) {
			var device = this.device;
			device.setBlendState(BlendState.NOBLEND);
			var lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
			var shadowCam = lightRenderData.shadowCamera;
			var origShadowMap = shadowCam.renderTarget;
			var tempShadowMap = this.renderer.shadowMapCache.get(device, light);
			var tempRt = tempShadowMap.renderTargets[0];
			var blurMode = light.vsmBlurMode;
			var filterSize = light._vsmBlurSize;
			var blurShader = this.getVsmBlurShader(blurMode, filterSize);
			blurScissorRect.z = light._shadowResolution - 2;
			blurScissorRect.w = blurScissorRect.z;
			this.sourceId.setValue(origShadowMap.colorBuffer);
			pixelOffset[0] = 1 / light._shadowResolution;
			pixelOffset[1] = 0;
			this.pixelOffsetId.setValue(pixelOffset);
			if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
			drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
			this.sourceId.setValue(tempRt.colorBuffer);
			pixelOffset[1] = pixelOffset[0];
			pixelOffset[0] = 0;
			this.pixelOffsetId.setValue(pixelOffset);
			drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
			this.renderer.shadowMapCache.add(light, tempShadowMap);
		};
		_proto.initViewBindGroupFormat = function initViewBindGroupFormat() {
			if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
				this.viewUniformFormat = new UniformBufferFormat(this.device, [new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4)]);
				this.viewBindGroupFormat = new BindGroupFormat(this.device, [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)]);
			}
		};
		_proto.frameUpdate = function frameUpdate() {
			this.initViewBindGroupFormat();
		};
		return ShadowRenderer;
	}();

	var tempClusterArray = [];
	var WorldClustersAllocator = function () {
		function WorldClustersAllocator(graphicsDevice) {
			this._empty = null;
			this._allocated = [];
			this._clusters = new Map();
			this.device = graphicsDevice;
		}
		var _proto = WorldClustersAllocator.prototype;
		_proto.destroy = function destroy() {
			if (this._empty) {
				this._empty.destroy();
				this._empty = null;
			}
			this._allocated.forEach(function (cluster) {
				cluster.destroy();
			});
			this._allocated.length = 0;
		};
		_proto.assign = function assign(renderPasses) {
			var empty = this.empty;
			tempClusterArray.push.apply(tempClusterArray, this._allocated);
			this._allocated.length = 0;
			this._clusters.clear();
			var passCount = renderPasses.length;
			for (var p = 0; p < passCount; p++) {
				var renderPass = renderPasses[p];
				var renderActions = renderPass.renderActions;
				if (renderActions) {
					var count = renderActions.length;
					for (var i = 0; i < count; i++) {
						var ra = renderActions[i];
						ra.lightClusters = null;
						var layer = ra.layer;
						if (layer.hasClusteredLights && layer.meshInstances.length) {
							var hash = layer.getLightIdHash();
							var existingRenderAction = this._clusters.get(hash);
							var clusters = existingRenderAction == null ? void 0 : existingRenderAction.lightClusters;
							if (!clusters) {
								var _tempClusterArray$pop;
								clusters = (_tempClusterArray$pop = tempClusterArray.pop()) != null ? _tempClusterArray$pop : new WorldClusters(this.device);
								this._allocated.push(clusters);
								this._clusters.set(hash, ra);
							}
							ra.lightClusters = clusters;
						}
						if (!ra.lightClusters) {
							ra.lightClusters = empty;
						}
					}
				}
			}
			tempClusterArray.forEach(function (item) {
				return item.destroy();
			});
			tempClusterArray.length = 0;
		};
		_proto.update = function update(renderPasses, lighting) {
			this.assign(renderPasses);
			this._clusters.forEach(function (renderAction) {
				var layer = renderAction.layer;
				var cluster = renderAction.lightClusters;
				cluster.update(layer.clusteredLightsSet, lighting);
			});
		};
		return _createClass(WorldClustersAllocator, [{
			key: "count",
			get: function get() {
				return this._allocated.length;
			}
		}, {
			key: "empty",
			get: function get() {
				if (!this._empty) {
					var empty = new WorldClusters(this.device);
					empty.name = 'ClusterEmpty';
					empty.update([]);
					this._empty = empty;
				}
				return this._empty;
			}
		}]);
	}();

	var textureBlitVertexShader$1 = "\n\tattribute vec2 vertex_position;\n\tvarying vec2 uv0;\n\tvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t#ifndef WEBGPU\n\t\t\tuv0.y = 1.0 - uv0.y;\n\t\t#endif\n\t}";
	var textureBlitFragmentShader$1 = "\n\tvarying vec2 uv0;\n\tuniform sampler2D blitTexture;\n\tvoid main(void) {\n\t\tgl_FragColor = texture2D(blitTexture, uv0);\n\t}";
	var textureCubeBlitFragmentShader = "\n\tvarying vec2 uv0;\n\tuniform samplerCube blitTexture;\n\tuniform mat4 invViewProj;\n\tvoid main(void) {\n\t\tvec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n\t\tvec4 worldPos = invViewProj * projPos;\n\t\tgl_FragColor = textureCube(blitTexture, worldPos.xyz);\n\t}";
	var _viewport$2 = new Vec4();
	var _invViewProjMatrices = [];
	var RenderPassCookieRenderer = function (_RenderPass) {
		function RenderPassCookieRenderer(device, cubeSlotsOffsets) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this._quadRenderer2D = null;
			_this._quadRendererCube = null;
			_this._filteredLights = [];
			_this._cubeSlotsOffsets = cubeSlotsOffsets;
			_this.requiresCubemaps = false;
			_this.blitTextureId = device.scope.resolve('blitTexture');
			_this.invViewProjId = device.scope.resolve('invViewProj');
			return _this;
		}
		_inheritsLoose(RenderPassCookieRenderer, _RenderPass);
		var _proto = RenderPassCookieRenderer.prototype;
		_proto.destroy = function destroy() {
			var _this$_quadRenderer2D, _this$_quadRendererCu;
			(_this$_quadRenderer2D = this._quadRenderer2D) == null || _this$_quadRenderer2D.destroy();
			this._quadRenderer2D = null;
			(_this$_quadRendererCu = this._quadRendererCube) == null || _this$_quadRendererCu.destroy();
			this._quadRendererCube = null;
		};
		RenderPassCookieRenderer.create = function create(renderTarget, cubeSlotsOffsets) {
			var renderPass = new RenderPassCookieRenderer(renderTarget.device, cubeSlotsOffsets);
			renderPass.init(renderTarget);
			renderPass.colorOps.clear = false;
			renderPass.depthStencilOps.clearDepth = false;
			return renderPass;
		};
		_proto.update = function update(lights) {
			var filteredLights = this._filteredLights;
			this.filter(lights, filteredLights);
			this.executeEnabled = filteredLights.length > 0;
		};
		_proto.filter = function filter(lights, filteredLights) {
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (light._type === LIGHTTYPE_DIRECTIONAL) {
					continue;
				}
				if (!light.atlasViewportAllocated) {
					continue;
				}
				if (!light.atlasSlotUpdated) {
					continue;
				}
				if (light.enabled && light.cookie && light.visibleThisFrame) {
					filteredLights.push(light);
				}
			}
		};
		_proto.initInvViewProjMatrices = function initInvViewProjMatrices() {
			if (!_invViewProjMatrices.length) {
				for (var face = 0; face < 6; face++) {
					var camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
					var projMat = camera.projectionMatrix;
					var viewMat = camera.node.getLocalTransform().clone().invert();
					_invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
				}
			}
		};
		_proto.execute = function execute() {
			var device = this.device;
			device.setBlendState(BlendState.NOBLEND);
			device.setCullMode(CULLFACE_NONE);
			device.setDepthState(DepthState.NODEPTH);
			device.setStencilState();
			var renderTargetWidth = this.renderTarget.colorBuffer.width;
			var cubeSlotsOffsets = this._cubeSlotsOffsets;
			var filteredLights = this._filteredLights;
			for (var i = 0; i < filteredLights.length; i++) {
				var light = filteredLights[i];
				var faceCount = light.numShadowFaces;
				var quad = faceCount > 1 ? this.quadRendererCube : this.quadRenderer2D;
				if (faceCount > 1) {
					this.initInvViewProjMatrices();
				}
				this.blitTextureId.setValue(light.cookie);
				for (var face = 0; face < faceCount; face++) {
					_viewport$2.copy(light.atlasViewport);
					if (faceCount > 1) {
						var smallSize = _viewport$2.z / 3;
						var offset = cubeSlotsOffsets[face];
						_viewport$2.x += smallSize * offset.x;
						_viewport$2.y += smallSize * offset.y;
						_viewport$2.z = smallSize;
						_viewport$2.w = smallSize;
						this.invViewProjId.setValue(_invViewProjMatrices[face].data);
					}
					_viewport$2.mulScalar(renderTargetWidth);
					quad.render(_viewport$2);
				}
			}
			filteredLights.length = 0;
		};
		return _createClass(RenderPassCookieRenderer, [{
			key: "quadRenderer2D",
			get: function get() {
				if (!this._quadRenderer2D) {
					var shader = createShaderFromCode(this.device, textureBlitVertexShader$1, textureBlitFragmentShader$1, 'cookieRenderer2d');
					this._quadRenderer2D = new QuadRender(shader);
				}
				return this._quadRenderer2D;
			}
		}, {
			key: "quadRendererCube",
			get: function get() {
				if (!this._quadRendererCube) {
					var shader = createShaderFromCode(this.device, textureBlitVertexShader$1, textureCubeBlitFragmentShader, 'cookieRendererCube');
					this._quadRendererCube = new QuadRender(shader);
				}
				return this._quadRendererCube;
			}
		}]);
	}(RenderPass);

	var RenderPassShadowLocalClustered = function (_RenderPass) {
		function RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.requiresCubemaps = false;
			_this.shadowRenderer = shadowRenderer;
			_this.shadowRendererLocal = shadowRendererLocal;
			return _this;
		}
		_inheritsLoose(RenderPassShadowLocalClustered, _RenderPass);
		var _proto = RenderPassShadowLocalClustered.prototype;
		_proto.update = function update(localLights) {
			var shadowLights = this.shadowRendererLocal.shadowLights;
			var shadowCamera = this.shadowRendererLocal.prepareLights(shadowLights, localLights);
			var count = shadowLights.length;
			this.enabled = count > 0;
			if (count) {
				this.shadowRenderer.setupRenderPass(this, shadowCamera, false);
			}
		};
		_proto.execute = function execute() {
			var shadowLights = this.shadowRendererLocal.shadowLights;
			var count = shadowLights.length;
			for (var i = 0; i < count; i++) {
				var light = shadowLights[i];
				for (var face = 0; face < light.numShadowFaces; face++) {
					this.shadowRenderer.renderFace(light, null, face, true);
				}
			}
			shadowLights.length = 0;
		};
		return RenderPassShadowLocalClustered;
	}(RenderPass);

	var RenderPassUpdateClustered = function (_RenderPass) {
		function RenderPassUpdateClustered(device, renderer, shadowRenderer, shadowRendererLocal, lightTextureAtlas) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.renderer = renderer;
			_this.frameGraph = null;
			_this.cookiesRenderPass = RenderPassCookieRenderer.create(lightTextureAtlas.cookieRenderTarget, lightTextureAtlas.cubeSlotsOffsets);
			_this.beforePasses.push(_this.cookiesRenderPass);
			_this.shadowRenderPass = new RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal);
			_this.beforePasses.push(_this.shadowRenderPass);
			return _this;
		}
		_inheritsLoose(RenderPassUpdateClustered, _RenderPass);
		var _proto = RenderPassUpdateClustered.prototype;
		_proto.update = function update(frameGraph, shadowsEnabled, cookiesEnabled, lights, localLights) {
			this.frameGraph = frameGraph;
			this.cookiesRenderPass.enabled = cookiesEnabled;
			if (cookiesEnabled) {
				this.cookiesRenderPass.update(lights);
			}
			this.shadowRenderPass.enabled = shadowsEnabled;
			if (shadowsEnabled) {
				this.shadowRenderPass.update(localLights);
			}
		};
		_proto.destroy = function destroy() {
			this.cookiesRenderPass.destroy();
			this.cookiesRenderPass = null;
		};
		_proto.execute = function execute() {
			var renderer = this.renderer;
			var scene = renderer.scene;
			renderer.worldClustersAllocator.update(this.frameGraph.renderPasses, scene.lighting);
		};
		return RenderPassUpdateClustered;
	}(RenderPass);

	var _skinUpdateIndex = 0;
	var viewProjMat = new Mat4();
	var viewInvMat = new Mat4();
	var viewMat = new Mat4();
	var viewMat3 = new Mat3();
	var tempSphere$1 = new BoundingSphere();
	var _flipYMat = new Mat4().setScale(1, -1, 1);
	var _tempLightSet = new Set();
	var _tempLayerSet = new Set();
	var _dynamicBindGroup = new DynamicBindGroup();
	var _fixProjRangeMat = new Mat4().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1]);
	var _haltonSequence = [new Vec2(0.5, 0.333333), new Vec2(0.25, 0.666667), new Vec2(0.75, 0.111111), new Vec2(0.125, 0.444444), new Vec2(0.625, 0.777778), new Vec2(0.375, 0.222222), new Vec2(0.875, 0.555556), new Vec2(0.0625, 0.888889), new Vec2(0.5625, 0.037037), new Vec2(0.3125, 0.370370), new Vec2(0.8125, 0.703704), new Vec2(0.1875, 0.148148), new Vec2(0.6875, 0.481481), new Vec2(0.4375, 0.814815), new Vec2(0.9375, 0.259259), new Vec2(0.03125, 0.592593)];
	var _tempProjMat0 = new Mat4();
	var _tempProjMat1 = new Mat4();
	var _tempProjMat2 = new Mat4();
	var _tempProjMat3 = new Mat4();
	var _tempProjMat4 = new Mat4();
	var _tempProjMat5 = new Mat4();
	var _tempSet = new Set();
	var _tempMeshInstances = [];
	var _tempMeshInstancesSkinned = [];
	var Renderer = function () {
		function Renderer(graphicsDevice) {
			this.clustersDebugRendered = false;
			this.processingMeshInstances = new Set();
			this.worldClustersAllocator = void 0;
			this.lights = [];
			this.localLights = [];
			this.cameraDirShadowLights = new Map();
			this.dirLightShadows = new Map();
			this.blueNoise = new BlueNoise(123);
			this.device = graphicsDevice;
			this.scene = null;
			this.worldClustersAllocator = new WorldClustersAllocator(graphicsDevice);
			this.lightTextureAtlas = new LightTextureAtlas(graphicsDevice);
			this.shadowMapCache = new ShadowMapCache();
			this.shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
			this._shadowRendererLocal = new ShadowRendererLocal(this, this.shadowRenderer);
			this._shadowRendererDirectional = new ShadowRendererDirectional(this, this.shadowRenderer);
			this._renderPassUpdateClustered = new RenderPassUpdateClustered(this.device, this, this.shadowRenderer, this._shadowRendererLocal, this.lightTextureAtlas);
			this.viewUniformFormat = null;
			this.viewBindGroupFormat = null;
			this._skinTime = 0;
			this._morphTime = 0;
			this._cullTime = 0;
			this._shadowMapTime = 0;
			this._lightClustersTime = 0;
			this._layerCompositionUpdateTime = 0;
			this._shadowDrawCalls = 0;
			this._skinDrawCalls = 0;
			this._instancedDrawCalls = 0;
			this._shadowMapUpdates = 0;
			this._numDrawCallsCulled = 0;
			this._camerasRendered = 0;
			this._lightClusters = 0;
			var scope = graphicsDevice.scope;
			this.boneTextureId = scope.resolve('texture_poseMap');
			this.boneTextureSizeId = scope.resolve('texture_poseMapSize');
			this.modelMatrixId = scope.resolve('matrix_model');
			this.normalMatrixId = scope.resolve('matrix_normal');
			this.viewInvId = scope.resolve('matrix_viewInverse');
			this.viewPos = new Float32Array(3);
			this.viewPosId = scope.resolve('view_position');
			this.projId = scope.resolve('matrix_projection');
			this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
			this.viewId = scope.resolve('matrix_view');
			this.viewId3 = scope.resolve('matrix_view3');
			this.viewProjId = scope.resolve('matrix_viewProjection');
			this.flipYId = scope.resolve('projectionFlipY');
			this.tbnBasis = scope.resolve('tbnBasis');
			this.nearClipId = scope.resolve('camera_near');
			this.farClipId = scope.resolve('camera_far');
			this.cameraParams = new Float32Array(4);
			this.cameraParamsId = scope.resolve('camera_params');
			this.viewIndexId = scope.resolve('view_index');
			this.blueNoiseJitterVersion = 0;
			this.blueNoiseJitterVec = new Vec4();
			this.blueNoiseJitterData = new Float32Array(4);
			this.blueNoiseJitterId = scope.resolve('blueNoiseJitter');
			this.blueNoiseTextureId = scope.resolve('blueNoiseTex32');
			this.alphaTestId = scope.resolve('alpha_ref');
			this.opacityMapId = scope.resolve('texture_opacityMap');
			this.exposureId = scope.resolve('exposure');
			this.twoSidedLightingNegScaleFactorId = scope.resolve('twoSidedLightingNegScaleFactor');
			this.twoSidedLightingNegScaleFactorId.setValue(0);
			this.morphPositionTex = scope.resolve('morphPositionTex');
			this.morphNormalTex = scope.resolve('morphNormalTex');
			this.morphTexParams = scope.resolve('morph_tex_params');
			this.lightCube = new LightCube();
			this.constantLightCube = scope.resolve('lightCube[0]');
		}
		var _proto = Renderer.prototype;
		_proto.destroy = function destroy() {
			this.shadowRenderer = null;
			this._shadowRendererLocal = null;
			this._shadowRendererDirectional = null;
			this.shadowMapCache.destroy();
			this.shadowMapCache = null;
			this._renderPassUpdateClustered.destroy();
			this._renderPassUpdateClustered = null;
			this.lightTextureAtlas.destroy();
			this.lightTextureAtlas = null;
		};
		_proto.sortCompare = function sortCompare(drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				} else if (drawCallA.zdist2 && drawCallB.zdist2) {
					return drawCallA.zdist2 - drawCallB.zdist2;
				}
			}
			return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
		};
		_proto.sortCompareMesh = function sortCompareMesh(drawCallA, drawCallB) {
			if (drawCallA.layer === drawCallB.layer) {
				if (drawCallA.drawOrder && drawCallB.drawOrder) {
					return drawCallA.drawOrder - drawCallB.drawOrder;
				} else if (drawCallA.zdist && drawCallB.zdist) {
					return drawCallB.zdist - drawCallA.zdist;
				}
			}
			var keyA = drawCallA._key[SORTKEY_FORWARD];
			var keyB = drawCallB._key[SORTKEY_FORWARD];
			if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}
			return keyB - keyA;
		};
		_proto.sortCompareDepth = function sortCompareDepth(drawCallA, drawCallB) {
			var keyA = drawCallA._key[SORTKEY_DEPTH];
			var keyB = drawCallB._key[SORTKEY_DEPTH];
			if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
				return drawCallB.mesh.id - drawCallA.mesh.id;
			}
			return keyB - keyA;
		};
		_proto.setupViewport = function setupViewport(camera, renderTarget) {
			var device = this.device;
			var pixelWidth = renderTarget ? renderTarget.width : device.width;
			var pixelHeight = renderTarget ? renderTarget.height : device.height;
			var rect = camera.rect;
			var x = Math.floor(rect.x * pixelWidth);
			var y = Math.floor(rect.y * pixelHeight);
			var w = Math.floor(rect.z * pixelWidth);
			var h = Math.floor(rect.w * pixelHeight);
			device.setViewport(x, y, w, h);
			if (camera._scissorRectClear) {
				var scissorRect = camera.scissorRect;
				x = Math.floor(scissorRect.x * pixelWidth);
				y = Math.floor(scissorRect.y * pixelHeight);
				w = Math.floor(scissorRect.z * pixelWidth);
				h = Math.floor(scissorRect.w * pixelHeight);
			}
			device.setScissor(x, y, w, h);
		};
		_proto.setCameraUniforms = function setCameraUniforms(camera, target) {
			var flipY = target == null ? void 0 : target.flipY;
			var viewCount = 1;
			if (camera.xr && camera.xr.session) {
				var _camera$_node;
				var transform = ((_camera$_node = camera._node) == null || (_camera$_node = _camera$_node.parent) == null ? void 0 : _camera$_node.getWorldTransform()) || null;
				var views = camera.xr.views;
				viewCount = views.list.length;
				for (var v = 0; v < viewCount; v++) {
					var view = views.list[v];
					view.updateTransforms(transform);
					camera.frustum.setFromMat4(view.projViewOffMat);
				}
			} else {
				var projMat = camera.projectionMatrix;
				if (camera.calculateProjection) {
					camera.calculateProjection(projMat, VIEW_CENTER);
				}
				var projMatSkybox = camera.getProjectionMatrixSkybox();
				if (flipY) {
					projMat = _tempProjMat0.mul2(_flipYMat, projMat);
					projMatSkybox = _tempProjMat1.mul2(_flipYMat, projMatSkybox);
				}
				if (this.device.isWebGPU) {
					projMat = _tempProjMat2.mul2(_fixProjRangeMat, projMat);
					projMatSkybox = _tempProjMat3.mul2(_fixProjRangeMat, projMatSkybox);
				}
				var jitter = camera.jitter;
				var jitterX = 0;
				var jitterY = 0;
				if (jitter > 0) {
					var targetWidth = target ? target.width : this.device.width;
					var targetHeight = target ? target.height : this.device.height;
					var offset = _haltonSequence[this.device.renderVersion % _haltonSequence.length];
					jitterX = jitter * (offset.x * 2 - 1) / targetWidth;
					jitterY = jitter * (offset.y * 2 - 1) / targetHeight;
					projMat = _tempProjMat4.copy(projMat);
					projMat.data[8] = jitterX;
					projMat.data[9] = jitterY;
					projMatSkybox = _tempProjMat5.copy(projMatSkybox);
					projMatSkybox.data[8] = jitterX;
					projMatSkybox.data[9] = jitterY;
					if (this.blueNoiseJitterVersion !== this.device.renderVersion) {
						this.blueNoiseJitterVersion = this.device.renderVersion;
						this.blueNoise.vec4(this.blueNoiseJitterVec);
					}
				}
				var jitterVec = jitter > 0 ? this.blueNoiseJitterVec : Vec4.ZERO;
				this.blueNoiseJitterData[0] = jitterVec.x;
				this.blueNoiseJitterData[1] = jitterVec.y;
				this.blueNoiseJitterData[2] = jitterVec.z;
				this.blueNoiseJitterData[3] = jitterVec.w;
				this.blueNoiseJitterId.setValue(this.blueNoiseJitterData);
				this.projId.setValue(projMat.data);
				this.projSkyboxId.setValue(projMatSkybox.data);
				if (camera.calculateTransform) {
					camera.calculateTransform(viewInvMat, VIEW_CENTER);
				} else {
					var pos = camera._node.getPosition();
					var rot = camera._node.getRotation();
					viewInvMat.setTRS(pos, rot, Vec3.ONE);
				}
				this.viewInvId.setValue(viewInvMat.data);
				viewMat.copy(viewInvMat).invert();
				this.viewId.setValue(viewMat.data);
				viewMat3.setFromMat4(viewMat);
				this.viewId3.setValue(viewMat3.data);
				viewProjMat.mul2(projMat, viewMat);
				this.viewProjId.setValue(viewProjMat.data);
				camera._storeShaderMatrices(viewProjMat, jitterX, jitterY, this.device.renderVersion);
				this.flipYId.setValue(flipY ? -1 : 1);
				this.dispatchViewPos(camera._node.getPosition());
				camera.frustum.setFromMat4(viewProjMat);
			}
			this.tbnBasis.setValue(flipY ? -1 : 1);
			var n = camera._nearClip;
			var f = camera._farClip;
			this.nearClipId.setValue(n);
			this.farClipId.setValue(f);
			this.cameraParams[0] = 1 / f;
			this.cameraParams[1] = f;
			this.cameraParams[2] = n;
			this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
			this.cameraParamsId.setValue(this.cameraParams);
			this.exposureId.setValue(this.scene.physicalUnits ? camera.getExposure() : this.scene.exposure);
			return viewCount;
		};
		_proto.clear = function clear(camera, clearColor, clearDepth, clearStencil) {
			var flags = ((clearColor != null ? clearColor : camera._clearColorBuffer) ? CLEARFLAG_COLOR : 0) | ((clearDepth != null ? clearDepth : camera._clearDepthBuffer) ? CLEARFLAG_DEPTH : 0) | ((clearStencil != null ? clearStencil : camera._clearStencilBuffer) ? CLEARFLAG_STENCIL : 0);
			if (flags) {
				var device = this.device;
				device.clear({
					color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
					depth: camera._clearDepth,
					stencil: camera._clearStencil,
					flags: flags
				});
			}
		};
		_proto.setCamera = function setCamera(camera, target, clear, renderAction) {
			this.setCameraUniforms(camera, target);
			this.clearView(camera, target, clear, false);
		};
		_proto.clearView = function clearView(camera, target, clear, forceWrite) {
			var device = this.device;
			device.setRenderTarget(target);
			device.updateBegin();
			if (forceWrite) {
				device.setColorWrite(true, true, true, true);
				device.setDepthWrite(true);
			}
			this.setupViewport(camera, target);
			if (clear) {
				var options = camera._clearOptions;
				device.clear(options ? options : {
					color: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],
					depth: camera._clearDepth,
					flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
					stencil: camera._clearStencil
				});
			}
		};
		_proto.setupCullMode = function setupCullMode(cullFaces, flipFactor, drawCall) {
			var material = drawCall.material;
			var mode = CULLFACE_NONE;
			if (cullFaces) {
				var flipFaces = 1;
				if (material.cull === CULLFACE_FRONT || material.cull === CULLFACE_BACK) {
					flipFaces = flipFactor * drawCall.flipFacesFactor * drawCall.node.worldScaleSign;
				}
				if (flipFaces < 0) {
					mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
				} else {
					mode = material.cull;
				}
			}
			this.device.setCullMode(mode);
			if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
				this.twoSidedLightingNegScaleFactorId.setValue(drawCall.node.worldScaleSign);
			}
		};
		_proto.updateCameraFrustum = function updateCameraFrustum(camera) {
			if (camera.xr && camera.xr.views.list.length) {
				var view = camera.xr.views.list[0];
				viewProjMat.mul2(view.projMat, view.viewOffMat);
				camera.frustum.setFromMat4(viewProjMat);
				return;
			}
			var projMat = camera.projectionMatrix;
			if (camera.calculateProjection) {
				camera.calculateProjection(projMat, VIEW_CENTER);
			}
			if (camera.calculateTransform) {
				camera.calculateTransform(viewInvMat, VIEW_CENTER);
			} else {
				var pos = camera._node.getPosition();
				var rot = camera._node.getRotation();
				viewInvMat.setTRS(pos, rot, Vec3.ONE);
				this.viewInvId.setValue(viewInvMat.data);
			}
			viewMat.copy(viewInvMat).invert();
			viewProjMat.mul2(projMat, viewMat);
			camera.frustum.setFromMat4(viewProjMat);
		};
		_proto.setBaseConstants = function setBaseConstants(device, material) {
			device.setCullMode(material.cull);
			if (material.opacityMap) {
				this.opacityMapId.setValue(material.opacityMap);
			}
			if (material.opacityMap || material.alphaTest > 0) {
				this.alphaTestId.setValue(material.alphaTest);
			}
		};
		_proto.updateCpuSkinMatrices = function updateCpuSkinMatrices(drawCalls) {
			_skinUpdateIndex++;
			var drawCallsCount = drawCalls.length;
			if (drawCallsCount === 0) return;
			for (var i = 0; i < drawCallsCount; i++) {
				var si = drawCalls[i].skinInstance;
				if (si) {
					si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
					si._dirty = true;
				}
			}
		};
		_proto.updateGpuSkinMatrices = function updateGpuSkinMatrices(drawCalls) {
			for (var _iterator = _createForOfIteratorHelperLoose(drawCalls), _step; !(_step = _iterator()).done;) {
				var drawCall = _step.value;
				var skin = drawCall.skinInstance;
				if (skin && skin._dirty) {
					skin.updateMatrixPalette(drawCall.node, _skinUpdateIndex);
					skin._dirty = false;
				}
			}
		};
		_proto.updateMorphing = function updateMorphing(drawCalls) {
			for (var _iterator2 = _createForOfIteratorHelperLoose(drawCalls), _step2; !(_step2 = _iterator2()).done;) {
				var drawCall = _step2.value;
				var morphInst = drawCall.morphInstance;
				if (morphInst && morphInst._dirty) {
					morphInst.update();
				}
			}
		};
		_proto.updateGSplats = function updateGSplats(drawCalls) {
			for (var _iterator3 = _createForOfIteratorHelperLoose(drawCalls), _step3; !(_step3 = _iterator3()).done;) {
				var _drawCall$gsplatInsta;
				var drawCall = _step3.value;
				(_drawCall$gsplatInsta = drawCall.gsplatInstance) == null || _drawCall$gsplatInsta.update();
			}
		};
		_proto.gpuUpdate = function gpuUpdate(drawCalls) {
			this.updateGpuSkinMatrices(drawCalls);
			this.updateMorphing(drawCalls);
			this.updateGSplats(drawCalls);
		};
		_proto.setVertexBuffers = function setVertexBuffers(device, mesh) {
			device.setVertexBuffer(mesh.vertexBuffer);
		};
		_proto.setMorphing = function setMorphing(device, morphInstance) {
			if (morphInstance) {
				morphInstance.prepareRendering(device);
				device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
				this.morphPositionTex.setValue(morphInstance.texturePositions);
				this.morphNormalTex.setValue(morphInstance.textureNormals);
				this.morphTexParams.setValue(morphInstance._textureParams);
			}
		};
		_proto.setSkinning = function setSkinning(device, meshInstance) {
			var skinInstance = meshInstance.skinInstance;
			if (skinInstance) {
				this._skinDrawCalls++;
				var boneTexture = skinInstance.boneTexture;
				this.boneTextureId.setValue(boneTexture);
				this.boneTextureSizeId.setValue(skinInstance.boneTextureSize);
			}
		};
		_proto.dispatchViewPos = function dispatchViewPos(position) {
			var vp = this.viewPos;
			vp[0] = position.x;
			vp[1] = position.y;
			vp[2] = position.z;
			this.viewPosId.setValue(vp);
		};
		_proto.initViewBindGroupFormat = function initViewBindGroupFormat(isClustered) {
			if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
				var uniforms = [new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4), new UniformFormat('cubeMapRotationMatrix', UNIFORMTYPE_MAT3), new UniformFormat('view_position', UNIFORMTYPE_VEC3), new UniformFormat('skyboxIntensity', UNIFORMTYPE_FLOAT), new UniformFormat('exposure', UNIFORMTYPE_FLOAT), new UniformFormat('textureBias', UNIFORMTYPE_FLOAT)];
				if (isClustered) {
					uniforms.push.apply(uniforms, [new UniformFormat('clusterCellsCountByBoundsSize', UNIFORMTYPE_VEC3), new UniformFormat('clusterTextureSize', UNIFORMTYPE_VEC3), new UniformFormat('clusterBoundsMin', UNIFORMTYPE_VEC3), new UniformFormat('clusterBoundsDelta', UNIFORMTYPE_VEC3), new UniformFormat('clusterCellsDot', UNIFORMTYPE_VEC3), new UniformFormat('clusterCellsMax', UNIFORMTYPE_VEC3), new UniformFormat('clusterCompressionLimit0', UNIFORMTYPE_VEC2), new UniformFormat('shadowAtlasParams', UNIFORMTYPE_VEC2), new UniformFormat('clusterMaxCells', UNIFORMTYPE_INT), new UniformFormat('clusterSkip', UNIFORMTYPE_FLOAT)]);
				}
				this.viewUniformFormat = new UniformBufferFormat(this.device, uniforms);
				var formats = [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT), new BindTextureFormat('lightsTextureFloat', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat('lightsTexture8', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat('shadowAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_DEPTH), new BindTextureFormat('cookieAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat('areaLightsLutTex1', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat('areaLightsLutTex2', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT)];
				if (isClustered) {
					formats.push.apply(formats, [new BindTextureFormat('clusterWorldTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT)]);
				}
				this.viewBindGroupFormat = new BindGroupFormat(this.device, formats);
			}
		};
		_proto.setupViewUniformBuffers = function setupViewUniformBuffers(viewBindGroups, viewUniformFormat, viewBindGroupFormat, viewCount) {
			var device = this.device;
			while (viewBindGroups.length < viewCount) {
				var ub = new UniformBuffer(device, viewUniformFormat, false);
				var bg = new BindGroup(device, viewBindGroupFormat, ub);
				viewBindGroups.push(bg);
			}
			var viewBindGroup = viewBindGroups[0];
			viewBindGroup.defaultUniformBuffer.update();
			viewBindGroup.update();
			device.setBindGroup(BINDGROUP_VIEW, viewBindGroup);
		};
		_proto.setupMeshUniformBuffers = function setupMeshUniformBuffers(shaderInstance, meshInstance) {
			var device = this.device;
			if (device.supportsUniformBuffers) {
				this.modelMatrixId.setValue(meshInstance.node.worldTransform.data);
				this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
				var meshBindGroup = shaderInstance.getBindGroup(device);
				meshBindGroup.update();
				device.setBindGroup(BINDGROUP_MESH, meshBindGroup);
				var meshUniformBuffer = shaderInstance.getUniformBuffer(device);
				meshUniformBuffer.update(_dynamicBindGroup);
				device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup.bindGroup, _dynamicBindGroup.offsets);
			}
		};
		_proto.drawInstance = function drawInstance(device, meshInstance, mesh, style, normal) {
			var modelMatrix = meshInstance.node.worldTransform;
			this.modelMatrixId.setValue(modelMatrix.data);
			if (normal) {
				this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
			}
			var instancingData = meshInstance.instancingData;
			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.setVertexBuffer(instancingData.vertexBuffer);
					device.draw(mesh.primitive[style], instancingData.count);
				} else {
					device.clearVertexBuffer();
				}
			} else {
				device.draw(mesh.primitive[style]);
			}
		};
		_proto.drawInstance2 = function drawInstance2(device, meshInstance, mesh, style) {
			var instancingData = meshInstance.instancingData;
			if (instancingData) {
				if (instancingData.count > 0) {
					this._instancedDrawCalls++;
					device.draw(mesh.primitive[style], instancingData.count, true);
				} else {
					device.clearVertexBuffer();
				}
			} else {
				device.draw(mesh.primitive[style], undefined, true);
			}
		};
		_proto.cull = function cull(camera, drawCalls, culledInstances) {
			var opaque = culledInstances.opaque;
			opaque.length = 0;
			var transparent = culledInstances.transparent;
			transparent.length = 0;
			var doCull = camera.frustumCulling;
			var count = drawCalls.length;
			for (var i = 0; i < count; i++) {
				var drawCall = drawCalls[i];
				if (drawCall.visible) {
					var visible = !doCull || !drawCall.cull || drawCall._isVisible(camera);
					if (visible) {
						drawCall.visibleThisFrame = true;
						var bucket = drawCall.transparent ? transparent : opaque;
						bucket.push(drawCall);
						if (drawCall.skinInstance || drawCall.morphInstance || drawCall.gsplatInstance) {
							this.processingMeshInstances.add(drawCall);
							if (drawCall.gsplatInstance) {
								drawCall.gsplatInstance.cameras.push(camera);
							}
						}
					}
				}
			}
		};
		_proto.collectLights = function collectLights(comp) {
			this.lights.length = 0;
			this.localLights.length = 0;
			var stats = this.scene._stats;
			var count = comp.layerList.length;
			for (var i = 0; i < count; i++) {
				var layer = comp.layerList[i];
				if (!_tempLayerSet.has(layer)) {
					_tempLayerSet.add(layer);
					var lights = layer._lights;
					for (var j = 0; j < lights.length; j++) {
						var light = lights[j];
						if (!_tempLightSet.has(light)) {
							_tempLightSet.add(light);
							this.lights.push(light);
							if (light._type !== LIGHTTYPE_DIRECTIONAL) {
								this.localLights.push(light);
							}
						}
					}
				}
			}
			stats.lights = this.lights.length;
			_tempLightSet.clear();
			_tempLayerSet.clear();
		};
		_proto.cullLights = function cullLights(camera, lights) {
			var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
			var physicalUnits = this.scene.physicalUnits;
			for (var i = 0; i < lights.length; i++) {
				var light = lights[i];
				if (light.enabled) {
					if (light._type !== LIGHTTYPE_DIRECTIONAL) {
						light.getBoundingSphere(tempSphere$1);
						if (camera.frustum.containsSphere(tempSphere$1)) {
							light.visibleThisFrame = true;
							light.usePhysicalUnits = physicalUnits;
							var screenSize = camera.getScreenSize(tempSphere$1);
							light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
						} else {
							if (!clusteredLightingEnabled) {
								if (light.castShadows && !light.shadowMap) {
									light.visibleThisFrame = true;
								}
							}
						}
					} else {
						light.usePhysicalUnits = this.scene.physicalUnits;
					}
				}
			}
		};
		_proto.cullShadowmaps = function cullShadowmaps(comp) {
			var isClustered = this.scene.clusteredLightingEnabled;
			for (var i = 0; i < this.localLights.length; i++) {
				var light = this.localLights[i];
				if (light._type !== LIGHTTYPE_DIRECTIONAL) {
					if (isClustered) {
						if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
							light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
						}
					} else {
						if (light.shadowUpdateMode === SHADOWUPDATE_NONE && light.castShadows) {
							if (!light.getRenderData(null, 0).shadowCamera.renderTarget) {
								light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
							}
						}
					}
					if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
						this._shadowRendererLocal.cull(light, comp);
					}
				}
			}
			this.cameraDirShadowLights.clear();
			var cameras = comp.cameras;
			for (var _i = 0; _i < cameras.length; _i++) {
				var cameraComponent = cameras[_i];
				if (cameraComponent.enabled) {
					var camera = cameraComponent.camera;
					var lightList = void 0;
					var cameraLayers = camera.layers;
					for (var l = 0; l < cameraLayers.length; l++) {
						var cameraLayer = comp.getLayerById(cameraLayers[l]);
						if (cameraLayer) {
							var layerDirLights = cameraLayer.splitLights[LIGHTTYPE_DIRECTIONAL];
							for (var j = 0; j < layerDirLights.length; j++) {
								var _light = layerDirLights[j];
								if (_light.castShadows && !_tempSet.has(_light)) {
									var _lightList;
									_tempSet.add(_light);
									lightList = (_lightList = lightList) != null ? _lightList : [];
									lightList.push(_light);
									this._shadowRendererDirectional.cull(_light, comp, camera);
								}
							}
						}
					}
					if (lightList) {
						this.cameraDirShadowLights.set(camera, lightList);
					}
					_tempSet.clear();
				}
			}
		};
		_proto.cullComposition = function cullComposition(comp) {
			var scene = this.scene;
			this.processingMeshInstances.clear();
			var numCameras = comp.cameras.length;
			this._camerasRendered += numCameras;
			for (var i = 0; i < numCameras; i++) {
				var camera = comp.cameras[i];
				scene == null || scene.fire(EVENT_PRECULL, camera);
				var renderTarget = camera.renderTarget;
				camera.frameUpdate(renderTarget);
				this.updateCameraFrustum(camera.camera);
				var layerIds = camera.layers;
				for (var j = 0; j < layerIds.length; j++) {
					var layer = comp.getLayerById(layerIds[j]);
					if (layer && layer.enabled) {
						this.cullLights(camera.camera, layer._lights);
						var culledInstances = layer.getCulledInstances(camera.camera);
						this.cull(camera.camera, layer.meshInstances, culledInstances);
					}
				}
				scene == null || scene.fire(EVENT_POSTCULL, camera);
			}
			if (scene.clusteredLightingEnabled) {
				this.updateLightTextureAtlas();
			}
			this.cullShadowmaps(comp);
		};
		_proto.updateShaders = function updateShaders(drawCalls, onlyLitShaders) {
			var count = drawCalls.length;
			for (var i = 0; i < count; i++) {
				var mat = drawCalls[i].material;
				if (mat) {
					if (!_tempSet.has(mat)) {
						_tempSet.add(mat);
						if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
							if (onlyLitShaders) {
								if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) {
									continue;
								}
							}
							mat.clearVariants();
						}
					}
				}
			}
			_tempSet.clear();
		};
		_proto.updateFrameUniforms = function updateFrameUniforms() {
			this.blueNoiseTextureId.setValue(getBlueNoiseTexture(this.device));
		};
		_proto.beginFrame = function beginFrame(comp) {
			var scene = this.scene;
			var updateShaders = scene.updateShaders;
			var layers = comp.layerList;
			var layerCount = layers.length;
			for (var i = 0; i < layerCount; i++) {
				var layer = layers[i];
				var meshInstances = layer.meshInstances;
				var count = meshInstances.length;
				for (var j = 0; j < count; j++) {
					var meshInst = meshInstances[j];
					meshInst.visibleThisFrame = false;
					if (updateShaders) {
						_tempMeshInstances.push(meshInst);
					}
					if (meshInst.skinInstance) {
						_tempMeshInstancesSkinned.push(meshInst);
					}
				}
			}
			if (updateShaders) {
				var onlyLitShaders = !scene.updateShaders;
				this.updateShaders(_tempMeshInstances, onlyLitShaders);
				scene.updateShaders = false;
				scene._shaderVersion++;
			}
			this.updateFrameUniforms();
			this.updateCpuSkinMatrices(_tempMeshInstancesSkinned);
			_tempMeshInstances.length = 0;
			_tempMeshInstancesSkinned.length = 0;
			var lights = this.lights;
			var lightCount = lights.length;
			for (var _i2 = 0; _i2 < lightCount; _i2++) {
				lights[_i2].beginFrame();
			}
		};
		_proto.updateLightTextureAtlas = function updateLightTextureAtlas() {
			this.lightTextureAtlas.update(this.localLights, this.scene.lighting);
		};
		_proto.updateLayerComposition = function updateLayerComposition(comp) {
			var len = comp.layerList.length;
			var scene = this.scene;
			var shaderVersion = scene._shaderVersion;
			for (var i = 0; i < len; i++) {
				var layer = comp.layerList[i];
				layer._shaderVersion = shaderVersion;
			}
			comp._update();
		};
		_proto.frameUpdate = function frameUpdate() {
			this.clustersDebugRendered = false;
			this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled);
			this.dirLightShadows.clear();
		};
		return Renderer;
	}();

	var RenderAction = function () {
		function RenderAction() {
			this.layer = null;
			this.transparent = false;
			this.camera = null;
			this.renderTarget = null;
			this.lightClusters = null;
			this.clearColor = false;
			this.clearDepth = false;
			this.clearStencil = false;
			this.triggerPostprocess = false;
			this.firstCameraUse = false;
			this.lastCameraUse = false;
			this.viewBindGroups = [];
			this.useCameraPasses = false;
		}
		var _proto = RenderAction.prototype;
		_proto.destroy = function destroy() {
			this.viewBindGroups.forEach(function (bg) {
				bg.defaultUniformBuffer.destroy();
				bg.destroy();
			});
			this.viewBindGroups.length = 0;
		};
		_proto.setupClears = function setupClears(camera, layer) {
			this.clearColor = (camera == null ? void 0 : camera.clearColorBuffer) || layer.clearColorBuffer;
			this.clearDepth = (camera == null ? void 0 : camera.clearDepthBuffer) || layer.clearDepthBuffer;
			this.clearStencil = (camera == null ? void 0 : camera.clearStencilBuffer) || layer.clearStencilBuffer;
		};
		return RenderAction;
	}();

	var RenderPassForward = function (_RenderPass) {
		function RenderPassForward(device, layerComposition, scene, renderer) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.layerComposition = void 0;
			_this.scene = void 0;
			_this.renderer = void 0;
			_this.renderActions = [];
			_this.noDepthClear = false;
			_this.layerComposition = layerComposition;
			_this.scene = scene;
			_this.renderer = renderer;
			return _this;
		}
		_inheritsLoose(RenderPassForward, _RenderPass);
		var _proto = RenderPassForward.prototype;
		_proto.addRenderAction = function addRenderAction(renderAction) {
			this.renderActions.push(renderAction);
		};
		_proto.addLayer = function addLayer(cameraComponent, layer, transparent, autoClears) {
			if (autoClears === void 0) {
				autoClears = true;
			}
			var ra = new RenderAction();
			ra.renderTarget = this.renderTarget;
			ra.camera = cameraComponent;
			ra.layer = layer;
			ra.transparent = transparent;
			if (autoClears) {
				var firstRa = this.renderActions.length === 0;
				ra.setupClears(firstRa ? cameraComponent : undefined, layer);
			}
			this.addRenderAction(ra);
		};
		_proto.addLayers = function addLayers(composition, cameraComponent, startIndex, firstLayerClears, lastLayerId, lastLayerIsTransparent) {
			if (lastLayerIsTransparent === void 0) {
				lastLayerIsTransparent = true;
			}
			var layerList = composition.layerList,
				subLayerList = composition.subLayerList;
			var clearRenderTarget = firstLayerClears;
			var index = startIndex;
			while (index < layerList.length) {
				var layer = layerList[index];
				var isTransparent = subLayerList[index];
				var renderedByCamera = cameraComponent.camera.layersSet.has(layer.id);
				if (renderedByCamera) {
					this.addLayer(cameraComponent, layer, isTransparent, clearRenderTarget);
					clearRenderTarget = false;
				}
				index++;
				if (layer.id === lastLayerId && isTransparent === lastLayerIsTransparent) {
					break;
				}
			}
			return index;
		};
		_proto.updateDirectionalShadows = function updateDirectionalShadows() {
			var renderer = this.renderer,
				renderActions = this.renderActions;
			for (var i = 0; i < renderActions.length; i++) {
				var renderAction = renderActions[i];
				var cameraComp = renderAction.camera;
				var camera = cameraComp.camera;
				var shadowDirLights = this.renderer.cameraDirShadowLights.get(camera);
				if (shadowDirLights) {
					for (var l = 0; l < shadowDirLights.length; l++) {
						var light = shadowDirLights[l];
						if (renderer.dirLightShadows.get(light) !== camera) {
							renderer.dirLightShadows.set(light, camera);
							var shadowPass = renderer._shadowRendererDirectional.getLightRenderPass(light, camera);
							if (shadowPass) {
								this.beforePasses.push(shadowPass);
							}
						}
					}
				}
			}
		};
		_proto.updateClears = function updateClears() {
			var renderAction = this.renderActions[0];
			if (renderAction) {
				var cameraComponent = renderAction.camera;
				var camera = cameraComponent.camera;
				var fullSizeClearRect = camera.fullSizeClearRect;
				this.setClearColor(fullSizeClearRect && renderAction.clearColor ? camera.clearColor : undefined);
				this.setClearDepth(fullSizeClearRect && renderAction.clearDepth && !this.noDepthClear ? camera.clearDepth : undefined);
				this.setClearStencil(fullSizeClearRect && renderAction.clearStencil ? camera.clearStencil : undefined);
			}
		};
		_proto.frameUpdate = function frameUpdate() {
			_RenderPass.prototype.frameUpdate.call(this);
			this.updateDirectionalShadows();
			this.updateClears();
		};
		_proto.before = function before() {
			var renderActions = this.renderActions;
			for (var i = 0; i < renderActions.length; i++) {
				var ra = renderActions[i];
				if (ra.firstCameraUse) {
					this.scene.fire(EVENT_PRERENDER, ra.camera);
				}
			}
		};
		_proto.execute = function execute() {
			var layerComposition = this.layerComposition,
				renderActions = this.renderActions;
			for (var i = 0; i < renderActions.length; i++) {
				var ra = renderActions[i];
				var layer = ra.layer;
				if (layerComposition.isEnabled(layer, ra.transparent)) {
					this.renderRenderAction(ra, i === 0);
				}
			}
		};
		_proto.after = function after() {
			for (var i = 0; i < this.renderActions.length; i++) {
				var ra = this.renderActions[i];
				if (ra.lastCameraUse) {
					this.scene.fire(EVENT_POSTRENDER, ra.camera);
				}
			}
			this.beforePasses.length = 0;
		};
		_proto.renderRenderAction = function renderRenderAction(renderAction, firstRenderAction) {
			var renderer = this.renderer,
				scene = this.scene;
			var device = renderer.device;
			var layer = renderAction.layer,
				transparent = renderAction.transparent,
				camera = renderAction.camera;
			if (camera) {
				var _camera$camera$shader, _camera$camera$shader2, _renderAction$renderT;
				scene.fire(EVENT_PRERENDER_LAYER, camera, layer, transparent);
				var options = {
					lightClusters: renderAction.lightClusters
				};
				var shaderPass = (_camera$camera$shader = (_camera$camera$shader2 = camera.camera.shaderPassInfo) == null ? void 0 : _camera$camera$shader2.index) != null ? _camera$camera$shader : SHADER_FORWARD;
				if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
					options.clearColor = renderAction.clearColor;
					options.clearDepth = renderAction.clearDepth;
					options.clearStencil = renderAction.clearStencil;
				}
				var renderTarget = (_renderAction$renderT = renderAction.renderTarget) != null ? _renderAction$renderT : device.backBuffer;
				renderer.renderForwardLayer(camera.camera, renderTarget, layer, transparent, shaderPass, renderAction.viewBindGroups, options);
				device.setBlendState(BlendState.NOBLEND);
				device.setStencilState(null, null);
				device.setAlphaToCoverage(false);
				scene.fire(EVENT_POSTRENDER_LAYER, camera, layer, transparent);
			}
		};
		return _createClass(RenderPassForward, [{
			key: "rendersAnything",
			get: function get() {
				return this.renderActions.length > 0;
			}
		}]);
	}(RenderPass);

	var RenderPassPostprocessing = function (_RenderPass) {
		function RenderPassPostprocessing(device, renderer, renderAction) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.renderer = renderer;
			_this.renderAction = renderAction;
			_this.requiresCubemaps = false;
			return _this;
		}
		_inheritsLoose(RenderPassPostprocessing, _RenderPass);
		var _proto = RenderPassPostprocessing.prototype;
		_proto.execute = function execute() {
			var renderAction = this.renderAction;
			var camera = renderAction.camera;
			camera.onPostprocessing();
		};
		return RenderPassPostprocessing;
	}(RenderPass);

	var _noLights = [[], [], []];
	var tmpColor$1 = new Color();
	var _drawCallList = {
		drawCalls: [],
		shaderInstances: [],
		isNewMaterial: [],
		lightMaskChanged: [],
		clear: function clear() {
			this.drawCalls.length = 0;
			this.shaderInstances.length = 0;
			this.isNewMaterial.length = 0;
			this.lightMaskChanged.length = 0;
		}
	};
	function vogelDiskPrecalculationSamples(numSamples) {
		var samples = [];
		for (var i = 0; i < numSamples; ++i) {
			var r = Math.sqrt(i + 0.5) / Math.sqrt(numSamples);
			samples.push(r);
		}
		return samples;
	}
	function vogelSpherePrecalculationSamples(numSamples) {
		var samples = [];
		for (var i = 0; i < numSamples; i++) {
			var weight = i / numSamples;
			var radius = Math.sqrt(weight * weight);
			samples.push(radius);
		}
		return samples;
	}
	var ForwardRenderer = function (_Renderer) {
		function ForwardRenderer(graphicsDevice) {
			var _this;
			_this = _Renderer.call(this, graphicsDevice) || this;
			var device = _this.device;
			_this._forwardDrawCalls = 0;
			_this._materialSwitches = 0;
			_this._depthMapTime = 0;
			_this._forwardTime = 0;
			_this._sortTime = 0;
			var scope = device.scope;
			_this.fogColorId = scope.resolve('fog_color');
			_this.fogStartId = scope.resolve('fog_start');
			_this.fogEndId = scope.resolve('fog_end');
			_this.fogDensityId = scope.resolve('fog_density');
			_this.ambientId = scope.resolve('light_globalAmbient');
			_this.skyboxIntensityId = scope.resolve('skyboxIntensity');
			_this.cubeMapRotationMatrixId = scope.resolve('cubeMapRotationMatrix');
			_this.pcssDiskSamplesId = scope.resolve('pcssDiskSamples[0]');
			_this.pcssSphereSamplesId = scope.resolve('pcssSphereSamples[0]');
			_this.lightColorId = [];
			_this.lightDir = [];
			_this.lightDirId = [];
			_this.lightShadowMapId = [];
			_this.lightShadowMatrixId = [];
			_this.lightShadowParamsId = [];
			_this.lightShadowIntensity = [];
			_this.lightRadiusId = [];
			_this.lightPos = [];
			_this.lightPosId = [];
			_this.lightWidth = [];
			_this.lightWidthId = [];
			_this.lightHeight = [];
			_this.lightHeightId = [];
			_this.lightInAngleId = [];
			_this.lightOutAngleId = [];
			_this.lightCookieId = [];
			_this.lightCookieIntId = [];
			_this.lightCookieMatrixId = [];
			_this.lightCookieOffsetId = [];
			_this.lightShadowSearchAreaId = [];
			_this.lightCameraParamsId = [];
			_this.shadowMatrixPaletteId = [];
			_this.shadowCascadeDistancesId = [];
			_this.shadowCascadeCountId = [];
			_this.shadowCascadeBlendId = [];
			_this.screenSizeId = scope.resolve('uScreenSize');
			_this._screenSize = new Float32Array(4);
			_this.fogColor = new Float32Array(3);
			_this.ambientColor = new Float32Array(3);
			_this.pcssDiskSamples = vogelDiskPrecalculationSamples(16);
			_this.pcssSphereSamples = vogelSpherePrecalculationSamples(16);
			return _this;
		}
		_inheritsLoose(ForwardRenderer, _Renderer);
		var _proto = ForwardRenderer.prototype;
		_proto.destroy = function destroy() {
			_Renderer.prototype.destroy.call(this);
		};
		_proto.dispatchGlobalLights = function dispatchGlobalLights(scene) {
			var ambientUniform = this.ambientColor;
			tmpColor$1.linear(scene.ambientLight);
			ambientUniform[0] = tmpColor$1.r;
			ambientUniform[1] = tmpColor$1.g;
			ambientUniform[2] = tmpColor$1.b;
			if (scene.physicalUnits) {
				for (var i = 0; i < 3; i++) {
					ambientUniform[i] *= scene.ambientLuminance;
				}
			}
			this.ambientId.setValue(ambientUniform);
			this.skyboxIntensityId.setValue(scene.physicalUnits ? scene.skyboxLuminance : scene.skyboxIntensity);
			this.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);
		};
		_proto._resolveLight = function _resolveLight(scope, i) {
			var light = "light" + i;
			this.lightColorId[i] = scope.resolve(light + "_color");
			this.lightDir[i] = new Float32Array(3);
			this.lightDirId[i] = scope.resolve(light + "_direction");
			this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
			this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
			this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
			this.lightShadowIntensity[i] = scope.resolve(light + "_shadowIntensity");
			this.lightShadowSearchAreaId[i] = scope.resolve(light + "_shadowSearchArea");
			this.lightRadiusId[i] = scope.resolve(light + "_radius");
			this.lightPos[i] = new Float32Array(3);
			this.lightPosId[i] = scope.resolve(light + "_position");
			this.lightWidth[i] = new Float32Array(3);
			this.lightWidthId[i] = scope.resolve(light + "_halfWidth");
			this.lightHeight[i] = new Float32Array(3);
			this.lightHeightId[i] = scope.resolve(light + "_halfHeight");
			this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
			this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
			this.lightCookieId[i] = scope.resolve(light + "_cookie");
			this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
			this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
			this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
			this.lightCameraParamsId[i] = scope.resolve(light + "_cameraParams");
			this.shadowMatrixPaletteId[i] = scope.resolve(light + "_shadowMatrixPalette[0]");
			this.shadowCascadeDistancesId[i] = scope.resolve(light + "_shadowCascadeDistances");
			this.shadowCascadeCountId[i] = scope.resolve(light + "_shadowCascadeCount");
			this.shadowCascadeBlendId[i] = scope.resolve(light + "_shadowCascadeBlend");
		};
		_proto.setLTCDirectionalLight = function setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
			this.lightPos[cnt][0] = campos.x - dir.x * far;
			this.lightPos[cnt][1] = campos.y - dir.y * far;
			this.lightPos[cnt][2] = campos.z - dir.z * far;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
			this.lightWidth[cnt][0] = hWidth.x * far;
			this.lightWidth[cnt][1] = hWidth.y * far;
			this.lightWidth[cnt][2] = hWidth.z * far;
			this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
			var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
			this.lightHeight[cnt][0] = hHeight.x * far;
			this.lightHeight[cnt][1] = hHeight.y * far;
			this.lightHeight[cnt][2] = hHeight.z * far;
			this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		};
		_proto.dispatchDirectLights = function dispatchDirectLights(dirs, mask, camera) {
			var cnt = 0;
			var scope = this.device.scope;
			for (var i = 0; i < dirs.length; i++) {
				if (!(dirs[i].mask & mask)) continue;
				var directional = dirs[i];
				var wtm = directional._node.getWorldTransform();
				if (!this.lightColorId[cnt]) {
					this._resolveLight(scope, cnt);
				}
				this.lightColorId[cnt].setValue(directional._colorLinear);
				wtm.getY(directional._direction).mulScalar(-1);
				directional._direction.normalize();
				this.lightDir[cnt][0] = directional._direction.x;
				this.lightDir[cnt][1] = directional._direction.y;
				this.lightDir[cnt][2] = directional._direction.z;
				this.lightDirId[cnt].setValue(this.lightDir[cnt]);
				if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
					this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
				}
				if (directional.castShadows) {
					var lightRenderData = directional.getRenderData(camera, 0);
					var biases = directional._getUniformBiasValues(lightRenderData);
					this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
					this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
					this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
					this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
					this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
					this.shadowCascadeBlendId[cnt].setValue(1 - directional.cascadeBlend);
					this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);
					var shadowRT = lightRenderData.shadowCamera.renderTarget;
					if (shadowRT) {
						this.lightShadowSearchAreaId[cnt].setValue(directional.penumbraSize / lightRenderData.shadowCamera.renderTarget.width * lightRenderData.projectionCompensation);
					}
					var cameraParams = directional._shadowCameraParams;
					cameraParams.length = 4;
					cameraParams[0] = 3.0;
					cameraParams[1] = lightRenderData.shadowCamera._farClip;
					cameraParams[2] = lightRenderData.shadowCamera._nearClip;
					cameraParams[3] = 1;
					this.lightCameraParamsId[cnt].setValue(cameraParams);
					var params = directional._shadowRenderParams;
					params.length = 4;
					params[0] = directional._shadowResolution;
					params[1] = biases.normalBias;
					params[2] = biases.bias;
					params[3] = 0;
					this.lightShadowParamsId[cnt].setValue(params);
				}
				cnt++;
			}
			return cnt;
		};
		_proto.setLTCPositionalLight = function setLTCPositionalLight(wtm, cnt) {
			var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
			this.lightWidth[cnt][0] = hWidth.x;
			this.lightWidth[cnt][1] = hWidth.y;
			this.lightWidth[cnt][2] = hWidth.z;
			this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
			var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
			this.lightHeight[cnt][0] = hHeight.x;
			this.lightHeight[cnt][1] = hHeight.y;
			this.lightHeight[cnt][2] = hHeight.z;
			this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
		};
		_proto.dispatchOmniLight = function dispatchOmniLight(scope, omni, cnt) {
			var wtm = omni._node.getWorldTransform();
			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}
			this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
			this.lightColorId[cnt].setValue(omni._colorLinear);
			wtm.getTranslation(omni._position);
			this.lightPos[cnt][0] = omni._position.x;
			this.lightPos[cnt][1] = omni._position.y;
			this.lightPos[cnt][2] = omni._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCPositionalLight(wtm, cnt);
			}
			if (omni.castShadows) {
				var lightRenderData = omni.getRenderData(null, 0);
				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
				var biases = omni._getUniformBiasValues(lightRenderData);
				var params = omni._shadowRenderParams;
				params.length = 4;
				params[0] = omni._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				params[3] = 1.0 / omni.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
				this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);
				var pixelsPerMeter = omni.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
				this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter);
				var cameraParams = omni._shadowCameraParams;
				cameraParams.length = 4;
				cameraParams[0] = 0;
				cameraParams[1] = lightRenderData.shadowCamera._farClip;
				cameraParams[2] = lightRenderData.shadowCamera._nearClip;
				cameraParams[3] = 0;
				this.lightCameraParamsId[cnt].setValue(cameraParams);
			}
			if (omni._cookie) {
				this.lightCookieId[cnt].setValue(omni._cookie);
				this.lightShadowMatrixId[cnt].setValue(wtm.data);
				this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
			}
		};
		_proto.dispatchSpotLight = function dispatchSpotLight(scope, spot, cnt) {
			var wtm = spot._node.getWorldTransform();
			if (!this.lightColorId[cnt]) {
				this._resolveLight(scope, cnt);
			}
			this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
			this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
			this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
			this.lightColorId[cnt].setValue(spot._colorLinear);
			wtm.getTranslation(spot._position);
			this.lightPos[cnt][0] = spot._position.x;
			this.lightPos[cnt][1] = spot._position.y;
			this.lightPos[cnt][2] = spot._position.z;
			this.lightPosId[cnt].setValue(this.lightPos[cnt]);
			if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
				this.setLTCPositionalLight(wtm, cnt);
			}
			wtm.getY(spot._direction).mulScalar(-1);
			spot._direction.normalize();
			this.lightDir[cnt][0] = spot._direction.x;
			this.lightDir[cnt][1] = spot._direction.y;
			this.lightDir[cnt][2] = spot._direction.z;
			this.lightDirId[cnt].setValue(this.lightDir[cnt]);
			if (spot.castShadows) {
				var lightRenderData = spot.getRenderData(null, 0);
				this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
				this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
				var biases = spot._getUniformBiasValues(lightRenderData);
				var params = spot._shadowRenderParams;
				params.length = 4;
				params[0] = spot._shadowResolution;
				params[1] = biases.normalBias;
				params[2] = biases.bias;
				params[3] = 1.0 / spot.attenuationEnd;
				this.lightShadowParamsId[cnt].setValue(params);
				this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);
				var pixelsPerMeter = spot.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
				var fov = lightRenderData.shadowCamera._fov * Math.PI / 180.0;
				var fovRatio = 1.0 / Math.tan(fov / 2.0);
				this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * fovRatio);
				var cameraParams = spot._shadowCameraParams;
				cameraParams.length = 4;
				cameraParams[0] = 0;
				cameraParams[1] = lightRenderData.shadowCamera._farClip;
				cameraParams[2] = lightRenderData.shadowCamera._nearClip;
				cameraParams[3] = 0;
				this.lightCameraParamsId[cnt].setValue(cameraParams);
			}
			if (spot._cookie) {
				if (!spot.castShadows) {
					var cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
					this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
				}
				this.lightCookieId[cnt].setValue(spot._cookie);
				this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
				if (spot._cookieTransform) {
					spot._cookieTransformUniform[0] = spot._cookieTransform.x;
					spot._cookieTransformUniform[1] = spot._cookieTransform.y;
					spot._cookieTransformUniform[2] = spot._cookieTransform.z;
					spot._cookieTransformUniform[3] = spot._cookieTransform.w;
					this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
					spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
					spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
					this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
				}
			}
		};
		_proto.dispatchLocalLights = function dispatchLocalLights(sortedLights, mask, usedDirLights) {
			var cnt = usedDirLights;
			var scope = this.device.scope;
			var omnis = sortedLights[LIGHTTYPE_OMNI];
			var numOmnis = omnis.length;
			for (var i = 0; i < numOmnis; i++) {
				var omni = omnis[i];
				if (!(omni.mask & mask)) continue;
				this.dispatchOmniLight(scope, omni, cnt);
				cnt++;
			}
			var spts = sortedLights[LIGHTTYPE_SPOT];
			var numSpts = spts.length;
			for (var _i = 0; _i < numSpts; _i++) {
				var spot = spts[_i];
				if (!(spot.mask & mask)) continue;
				this.dispatchSpotLight(scope, spot, cnt);
				cnt++;
			}
		};
		_proto.renderForwardPrepareMaterials = function renderForwardPrepareMaterials(camera, renderTarget, drawCalls, sortedLights, layer, pass) {
			var _camera$fog, _renderTarget$isColor, _layer$getLightHash;
			var fogParams = (_camera$fog = camera.fog) != null ? _camera$fog : this.scene.fog;
			var shaderParams = camera.shaderParams;
			shaderParams.fog = fogParams.type;
			shaderParams.srgbRenderTarget = (_renderTarget$isColor = renderTarget == null ? void 0 : renderTarget.isColorBufferSrgb(0)) != null ? _renderTarget$isColor : false;
			var addCall = function addCall(drawCall, shaderInstance, isNewMaterial, lightMaskChanged) {
				_drawCallList.drawCalls.push(drawCall);
				_drawCallList.shaderInstances.push(shaderInstance);
				_drawCallList.isNewMaterial.push(isNewMaterial);
				_drawCallList.lightMaskChanged.push(lightMaskChanged);
			};
			_drawCallList.clear();
			var device = this.device;
			var scene = this.scene;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			var lightHash = (_layer$getLightHash = layer == null ? void 0 : layer.getLightHash(clusteredLightingEnabled)) != null ? _layer$getLightHash : 0;
			var prevMaterial = null,
				prevObjDefs,
				prevLightMask;
			var drawCallsCount = drawCalls.length;
			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];
				drawCall.ensureMaterial(device);
				var material = drawCall.material;
				var objDefs = drawCall._shaderDefs;
				var lightMask = drawCall.mask;
				if (material && material === prevMaterial && objDefs !== prevObjDefs) {
					prevMaterial = null;
				}
				if (material !== prevMaterial) {
					this._materialSwitches++;
					material._scene = scene;
					if (material.dirty) {
						material.updateUniforms(device, scene);
						material.dirty = false;
					}
				}
				var shaderInstance = drawCall.getShaderInstance(pass, lightHash, scene, shaderParams, this.viewUniformFormat, this.viewBindGroupFormat, sortedLights);
				addCall(drawCall, shaderInstance, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
				prevMaterial = material;
				prevObjDefs = objDefs;
				prevLightMask = lightMask;
			}
			return _drawCallList;
		};
		_proto.renderForwardInternal = function renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {
			var device = this.device;
			var scene = this.scene;
			var passFlag = 1 << pass;
			var flipFactor = flipFaces ? -1 : 1;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			var preparedCallsCount = preparedCalls.drawCalls.length;
			for (var i = 0; i < preparedCallsCount; i++) {
				var _drawCall$stencilFron, _drawCall$stencilBack;
				var drawCall = preparedCalls.drawCalls[i];
				var newMaterial = preparedCalls.isNewMaterial[i];
				var lightMaskChanged = preparedCalls.lightMaskChanged[i];
				var shaderInstance = preparedCalls.shaderInstances[i];
				var material = drawCall.material;
				var lightMask = drawCall.mask;
				if (newMaterial) {
					var asyncCompile = false;
					device.setShader(shaderInstance.shader, asyncCompile);
					material.setParameters(device);
					if (lightMaskChanged) {
						var usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], lightMask, camera);
						if (!clusteredLightingEnabled) {
							this.dispatchLocalLights(sortedLights, lightMask, usedDirLights);
						}
					}
					this.alphaTestId.setValue(material.alphaTest);
					device.setBlendState(material.blendState);
					device.setDepthState(material.depthState);
					device.setAlphaToCoverage(material.alphaToCoverage);
				}
				this.setupCullMode(camera._cullFaces, flipFactor, drawCall);
				var stencilFront = (_drawCall$stencilFron = drawCall.stencilFront) != null ? _drawCall$stencilFron : material.stencilFront;
				var stencilBack = (_drawCall$stencilBack = drawCall.stencilBack) != null ? _drawCall$stencilBack : material.stencilBack;
				device.setStencilState(stencilFront, stencilBack);
				drawCall.setParameters(device, passFlag);
				device.scope.resolve('meshInstanceId').setValue(drawCall.id);
				var mesh = drawCall.mesh;
				this.setVertexBuffers(device, mesh);
				this.setMorphing(device, drawCall.morphInstance);
				this.setSkinning(device, drawCall);
				this.setupMeshUniformBuffers(shaderInstance, drawCall);
				var style = drawCall.renderStyle;
				device.setIndexBuffer(mesh.indexBuffer[style]);
				drawCallback == null || drawCallback(drawCall, i);
				if (camera.xr && camera.xr.session && camera.xr.views.list.length) {
					var views = camera.xr.views;
					for (var v = 0; v < views.list.length; v++) {
						var view = views.list[v];
						device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
						this.projId.setValue(view.projMat.data);
						this.projSkyboxId.setValue(view.projMat.data);
						this.viewId.setValue(view.viewOffMat.data);
						this.viewInvId.setValue(view.viewInvOffMat.data);
						this.viewId3.setValue(view.viewMat3.data);
						this.viewProjId.setValue(view.projViewOffMat.data);
						this.viewPosId.setValue(view.positionData);
						this.viewIndexId.setValue(v);
						if (v === 0) {
							this.drawInstance(device, drawCall, mesh, style, true);
						} else {
							this.drawInstance2(device, drawCall, mesh, style);
						}
						this._forwardDrawCalls++;
					}
				} else {
					this.drawInstance(device, drawCall, mesh, style, true);
					this._forwardDrawCalls++;
				}
				if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
					material.setParameters(device, drawCall.parameters);
				}
			}
		};
		_proto.renderForward = function renderForward(camera, renderTarget, allDrawCalls, sortedLights, pass, drawCallback, layer, flipFaces) {
			var preparedCalls = this.renderForwardPrepareMaterials(camera, renderTarget, allDrawCalls, sortedLights, layer, pass);
			this.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);
			_drawCallList.clear();
		};
		_proto.renderForwardLayer = function renderForwardLayer(camera, renderTarget, layer, transparent, shaderPass, viewBindGroups, options) {
			var _camera$fog2, _options$clearColor, _options$clearDepth, _options$clearStencil;
			if (options === void 0) {
				options = {};
			}
			var scene = this.scene,
				device = this.device;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			this.setupViewport(camera, renderTarget);
			var visible, splitLights;
			if (layer) {
				layer.sortVisible(camera, transparent);
				var culledInstances = layer.getCulledInstances(camera);
				visible = transparent ? culledInstances.transparent : culledInstances.opaque;
				scene.immediate.onPreRenderLayer(layer, visible, transparent);
				if (layer.requiresLightCube) {
					this.lightCube.update(scene.ambientLight, layer._lights);
					this.constantLightCube.setValue(this.lightCube.colors);
				}
				splitLights = layer.splitLights;
			} else {
				var _options$splitLights;
				visible = options.meshInstances;
				splitLights = (_options$splitLights = options.splitLights) != null ? _options$splitLights : _noLights;
			}
			if (clusteredLightingEnabled) {
				var _options$lightCluster;
				var lightClusters = (_options$lightCluster = options.lightClusters) != null ? _options$lightCluster : this.worldClustersAllocator.empty;
				lightClusters.activate();
				if (layer) {
					if (!this.clustersDebugRendered && scene.lighting.debugLayer === layer.id) {
						this.clustersDebugRendered = true;
					}
				}
			}
			scene._activeCamera = camera;
			var fogParams = (_camera$fog2 = camera.fog) != null ? _camera$fog2 : this.scene.fog;
			this.setFogConstants(fogParams);
			var viewCount = this.setCameraUniforms(camera, renderTarget);
			if (device.supportsUniformBuffers) {
				this.setupViewUniformBuffers(viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, viewCount);
			}
			var clearColor = (_options$clearColor = options.clearColor) != null ? _options$clearColor : false;
			var clearDepth = (_options$clearDepth = options.clearDepth) != null ? _options$clearDepth : false;
			var clearStencil = (_options$clearStencil = options.clearStencil) != null ? _options$clearStencil : false;
			if (clearColor || clearDepth || clearStencil) {
				this.clear(camera, clearColor, clearDepth, clearStencil);
			}
			var flipFaces = !!(camera._flipFaces ^ (renderTarget == null ? void 0 : renderTarget.flipY));
			var forwardDrawCalls = this._forwardDrawCalls;
			this.renderForward(camera, renderTarget, visible, splitLights, shaderPass, null, layer, flipFaces);
			if (layer) {
				layer._forwardDrawCalls += this._forwardDrawCalls - forwardDrawCalls;
			}
		};
		_proto.setFogConstants = function setFogConstants(fogParams) {
			if (fogParams.type !== FOG_NONE) {
				tmpColor$1.linear(fogParams.color);
				var fogUniform = this.fogColor;
				fogUniform[0] = tmpColor$1.r;
				fogUniform[1] = tmpColor$1.g;
				fogUniform[2] = tmpColor$1.b;
				this.fogColorId.setValue(fogUniform);
				if (fogParams.type === FOG_LINEAR) {
					this.fogStartId.setValue(fogParams.start);
					this.fogEndId.setValue(fogParams.end);
				} else {
					this.fogDensityId.setValue(fogParams.density);
				}
			}
		};
		_proto.setSceneConstants = function setSceneConstants() {
			var scene = this.scene;
			this.dispatchGlobalLights(scene);
			var device = this.device;
			this._screenSize[0] = device.width;
			this._screenSize[1] = device.height;
			this._screenSize[2] = 1 / device.width;
			this._screenSize[3] = 1 / device.height;
			this.screenSizeId.setValue(this._screenSize);
			this.pcssDiskSamplesId.setValue(this.pcssDiskSamples);
			this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);
		};
		_proto.buildFrameGraph = function buildFrameGraph(frameGraph, layerComposition) {
			var scene = this.scene;
			frameGraph.reset();
			if (scene.clusteredLightingEnabled) {
				var _scene$lighting = scene.lighting,
					shadowsEnabled = _scene$lighting.shadowsEnabled,
					cookiesEnabled = _scene$lighting.cookiesEnabled;
				this._renderPassUpdateClustered.update(frameGraph, shadowsEnabled, cookiesEnabled, this.lights, this.localLights);
				frameGraph.addRenderPass(this._renderPassUpdateClustered);
			} else {
				this._shadowRendererLocal.buildNonClusteredRenderPasses(frameGraph, this.localLights);
			}
			var startIndex = 0;
			var newStart = true;
			var renderTarget = null;
			var renderActions = layerComposition._renderActions;
			for (var i = startIndex; i < renderActions.length; i++) {
				var renderAction = renderActions[i];
				var layer = renderAction.layer,
					camera = renderAction.camera;
				if (renderAction.useCameraPasses) {
					camera.camera.renderPasses.forEach(function (renderPass) {
						frameGraph.addRenderPass(renderPass);
					});
				} else {
					var isDepthLayer = layer.id === LAYERID_DEPTH;
					var isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
					if (newStart) {
						newStart = false;
						startIndex = i;
						renderTarget = renderAction.renderTarget;
					}
					var nextRenderAction = renderActions[i + 1];
					var isNextLayerDepth = nextRenderAction ? !nextRenderAction.useCameraPasses && nextRenderAction.layer.id === LAYERID_DEPTH : false;
					var isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
					var nextNeedDirShadows = nextRenderAction ? nextRenderAction.firstCameraUse && this.cameraDirShadowLights.has(nextRenderAction.camera.camera) : false;
					if (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextNeedDirShadows || isNextLayerGrabPass || isGrabPass) {
						var isDepthOnly = isDepthLayer && startIndex === i;
						if (!isDepthOnly) {
							this.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i);
						}
						if (isDepthLayer) {
							if (camera.renderSceneColorMap) {
								var colorGrabPass = camera.camera.renderPassColorGrab;
								colorGrabPass.source = camera.renderTarget;
								frameGraph.addRenderPass(colorGrabPass);
							}
							if (camera.renderSceneDepthMap) {
								frameGraph.addRenderPass(camera.camera.renderPassDepthGrab);
							}
						}
						if (renderAction.triggerPostprocess && camera != null && camera.onPostprocessing) {
							var renderPass = new RenderPassPostprocessing(this.device, this, renderAction);
							frameGraph.addRenderPass(renderPass);
						}
						newStart = true;
					}
				}
			}
		};
		_proto.addMainRenderPass = function addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex) {
			var renderPass = new RenderPassForward(this.device, layerComposition, this.scene, this);
			renderPass.init(renderTarget);
			var renderActions = layerComposition._renderActions;
			for (var i = startIndex; i <= endIndex; i++) {
				renderPass.addRenderAction(renderActions[i]);
			}
			frameGraph.addRenderPass(renderPass);
		};
		_proto.update = function update(comp) {
			this.frameUpdate();
			this.shadowRenderer.frameUpdate();
			this.scene._updateSkyMesh();
			this.updateLayerComposition(comp);
			this.collectLights(comp);
			this.beginFrame(comp);
			this.setSceneConstants();
			this.cullComposition(comp);
			this.gpuUpdate(this.processingMeshInstances);
		};
		return ForwardRenderer;
	}(Renderer);

	var layerCounter = 0;
	var lightKeys = [];
	var _tempMaterials = new Set();
	function sortManual(drawCallA, drawCallB) {
		return drawCallA.drawOrder - drawCallB.drawOrder;
	}
	function sortMaterialMesh(drawCallA, drawCallB) {
		var keyA = drawCallA._key[SORTKEY_FORWARD];
		var keyB = drawCallB._key[SORTKEY_FORWARD];
		if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
			return drawCallB.mesh.id - drawCallA.mesh.id;
		}
		return keyB - keyA;
	}
	function sortBackToFront(drawCallA, drawCallB) {
		return drawCallB.zdist - drawCallA.zdist;
	}
	function sortFrontToBack(drawCallA, drawCallB) {
		return drawCallA.zdist - drawCallB.zdist;
	}
	var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];
	var CulledInstances = function CulledInstances() {
		this.opaque = [];
		this.transparent = [];
	};
	var Layer = function () {
		function Layer(options) {
			var _options$enabled, _options$opaqueSortMo, _options$transparentS;
			if (options === void 0) {
				options = {};
			}
			this.meshInstances = [];
			this.meshInstancesSet = new Set();
			this.shadowCasters = [];
			this.shadowCastersSet = new Set();
			this._visibleInstances = new WeakMap();
			this._lights = [];
			this._lightsSet = new Set();
			this._clusteredLightsSet = new Set();
			this._splitLights = [[], [], []];
			this._splitLightsDirty = true;
			this.requiresLightCube = false;
			this.cameras = [];
			this.camerasSet = new Set();
			this._dirtyComposition = false;
			if (options.id !== undefined) {
				this.id = options.id;
				layerCounter = Math.max(this.id + 1, layerCounter);
			} else {
				this.id = layerCounter++;
			}
			this.name = options.name;
			this._enabled = (_options$enabled = options.enabled) != null ? _options$enabled : true;
			this._refCounter = this._enabled ? 1 : 0;
			this.opaqueSortMode = (_options$opaqueSortMo = options.opaqueSortMode) != null ? _options$opaqueSortMo : SORTMODE_MATERIALMESH;
			this.transparentSortMode = (_options$transparentS = options.transparentSortMode) != null ? _options$transparentS : SORTMODE_BACK2FRONT;
			if (options.renderTarget) {
				this.renderTarget = options.renderTarget;
			}
			this._clearColorBuffer = !!options.clearColorBuffer;
			this._clearDepthBuffer = !!options.clearDepthBuffer;
			this._clearStencilBuffer = !!options.clearStencilBuffer;
			this.onEnable = options.onEnable;
			this.onDisable = options.onDisable;
			if (this._enabled && this.onEnable) {
				this.onEnable();
			}
			this.customSortCallback = null;
			this.customCalculateSortValues = null;
			this._lightHash = 0;
			this._lightHashDirty = false;
			this._lightIdHash = 0;
			this._lightIdHashDirty = false;
			this._shaderVersion = -1;
		}
		var _proto = Layer.prototype;
		_proto.incrementCounter = function incrementCounter() {
			if (this._refCounter === 0) {
				this._enabled = true;
				if (this.onEnable) this.onEnable();
			}
			this._refCounter++;
		};
		_proto.decrementCounter = function decrementCounter() {
			if (this._refCounter === 1) {
				this._enabled = false;
				if (this.onDisable) this.onDisable();
			} else if (this._refCounter === 0) {
				return;
			}
			this._refCounter--;
		};
		_proto.addMeshInstances = function addMeshInstances(meshInstances, skipShadowCasters) {
			var destMeshInstances = this.meshInstances;
			var destMeshInstancesSet = this.meshInstancesSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (!destMeshInstancesSet.has(mi)) {
					destMeshInstances.push(mi);
					destMeshInstancesSet.add(mi);
					_tempMaterials.add(mi.material);
				}
			}
			if (!skipShadowCasters) {
				this.addShadowCasters(meshInstances);
			}
			if (_tempMaterials.size > 0) {
				var sceneShaderVer = this._shaderVersion;
				_tempMaterials.forEach(function (mat) {
					if (sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
						if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
							mat.clearVariants();
						}
						mat._shaderVersion = sceneShaderVer;
					}
				});
				_tempMaterials.clear();
			}
		};
		_proto.removeMeshInstances = function removeMeshInstances(meshInstances, skipShadowCasters) {
			var destMeshInstances = this.meshInstances;
			var destMeshInstancesSet = this.meshInstancesSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (destMeshInstancesSet.has(mi)) {
					destMeshInstancesSet.delete(mi);
					var j = destMeshInstances.indexOf(mi);
					if (j >= 0) {
						destMeshInstances.splice(j, 1);
					}
				}
			}
			if (!skipShadowCasters) {
				this.removeShadowCasters(meshInstances);
			}
		};
		_proto.addShadowCasters = function addShadowCasters(meshInstances) {
			var shadowCasters = this.shadowCasters;
			var shadowCastersSet = this.shadowCastersSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (mi.castShadow && !shadowCastersSet.has(mi)) {
					shadowCastersSet.add(mi);
					shadowCasters.push(mi);
				}
			}
		};
		_proto.removeShadowCasters = function removeShadowCasters(meshInstances) {
			var shadowCasters = this.shadowCasters;
			var shadowCastersSet = this.shadowCastersSet;
			for (var i = 0; i < meshInstances.length; i++) {
				var mi = meshInstances[i];
				if (shadowCastersSet.has(mi)) {
					shadowCastersSet.delete(mi);
					var j = shadowCasters.indexOf(mi);
					if (j >= 0) {
						shadowCasters.splice(j, 1);
					}
				}
			}
		};
		_proto.clearMeshInstances = function clearMeshInstances(skipShadowCasters) {
			if (skipShadowCasters === void 0) {
				skipShadowCasters = false;
			}
			this.meshInstances.length = 0;
			this.meshInstancesSet.clear();
			if (!skipShadowCasters) {
				this.shadowCasters.length = 0;
				this.shadowCastersSet.clear();
			}
		};
		_proto.markLightsDirty = function markLightsDirty() {
			this._lightHashDirty = true;
			this._lightIdHashDirty = true;
			this._splitLightsDirty = true;
		};
		_proto.hasLight = function hasLight(light) {
			return this._lightsSet.has(light);
		};
		_proto.addLight = function addLight(light) {
			var l = light.light;
			if (!this._lightsSet.has(l)) {
				this._lightsSet.add(l);
				this._lights.push(l);
				this.markLightsDirty();
			}
			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.add(l);
			}
		};
		_proto.removeLight = function removeLight(light) {
			var l = light.light;
			if (this._lightsSet.has(l)) {
				this._lightsSet.delete(l);
				this._lights.splice(this._lights.indexOf(l), 1);
				this.markLightsDirty();
			}
			if (l.type !== LIGHTTYPE_DIRECTIONAL) {
				this._clusteredLightsSet.delete(l);
			}
		};
		_proto.clearLights = function clearLights() {
			var _this = this;
			this._lightsSet.forEach(function (light) {
				return light.removeLayer(_this);
			});
			this._lightsSet.clear();
			this._clusteredLightsSet.clear();
			this._lights.length = 0;
			this.markLightsDirty();
		};
		_proto.evaluateLightHash = function evaluateLightHash(localLights, directionalLights, useIds) {
			var hash = 0;
			var lights = this._lights;
			for (var i = 0; i < lights.length; i++) {
				var isLocalLight = lights[i].type !== LIGHTTYPE_DIRECTIONAL;
				if (localLights && isLocalLight || directionalLights && !isLocalLight) {
					lightKeys.push(useIds ? lights[i].id : lights[i].key);
				}
			}
			if (lightKeys.length > 0) {
				lightKeys.sort();
				hash = hash32Fnv1a(lightKeys);
				lightKeys.length = 0;
			}
			return hash;
		};
		_proto.getLightHash = function getLightHash(isClustered) {
			if (this._lightHashDirty) {
				this._lightHashDirty = false;
				this._lightHash = this.evaluateLightHash(!isClustered, true, false);
			}
			return this._lightHash;
		};
		_proto.getLightIdHash = function getLightIdHash() {
			if (this._lightIdHashDirty) {
				this._lightIdHashDirty = false;
				this._lightIdHash = this.evaluateLightHash(true, false, true);
			}
			return this._lightIdHash;
		};
		_proto.addCamera = function addCamera(camera) {
			if (!this.camerasSet.has(camera.camera)) {
				this.camerasSet.add(camera.camera);
				this.cameras.push(camera);
				this._dirtyComposition = true;
			}
		};
		_proto.removeCamera = function removeCamera(camera) {
			if (this.camerasSet.has(camera.camera)) {
				this.camerasSet.delete(camera.camera);
				var index = this.cameras.indexOf(camera);
				this.cameras.splice(index, 1);
				this._dirtyComposition = true;
			}
		};
		_proto.clearCameras = function clearCameras() {
			this.cameras.length = 0;
			this.camerasSet.clear();
			this._dirtyComposition = true;
		};
		_proto._calculateSortDistances = function _calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {
			for (var i = 0; i < drawCallsCount; i++) {
				var drawCall = drawCalls[i];
				if (drawCall.layer <= LAYER_FX) continue;
				if (drawCall.calculateSortDistance) {
					drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
					continue;
				}
				var meshPos = drawCall.aabb.center;
				var tempx = meshPos.x - camPos.x;
				var tempy = meshPos.y - camPos.y;
				var tempz = meshPos.z - camPos.z;
				drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
			}
		};
		_proto.getCulledInstances = function getCulledInstances(camera) {
			var instances = this._visibleInstances.get(camera);
			if (!instances) {
				instances = new CulledInstances();
				this._visibleInstances.set(camera, instances);
			}
			return instances;
		};
		_proto.sortVisible = function sortVisible(camera, transparent) {
			var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
			if (sortMode === SORTMODE_NONE) {
				return;
			}
			var culledInstances = this.getCulledInstances(camera);
			var instances = transparent ? culledInstances.transparent : culledInstances.opaque;
			var cameraNode = camera.node;
			if (sortMode === SORTMODE_CUSTOM) {
				var sortPos = cameraNode.getPosition();
				var sortDir = cameraNode.forward;
				if (this.customCalculateSortValues) {
					this.customCalculateSortValues(instances, instances.length, sortPos, sortDir);
				}
				if (this.customSortCallback) {
					instances.sort(this.customSortCallback);
				}
			} else {
				if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
					var _sortPos = cameraNode.getPosition();
					var _sortDir = cameraNode.forward;
					this._calculateSortDistances(instances, instances.length, _sortPos, _sortDir);
				}
				instances.sort(sortCallbacks[sortMode]);
			}
		};
		return _createClass(Layer, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(val) {
				if (val !== this._enabled) {
					this._dirtyComposition = true;
					this._enabled = val;
					if (val) {
						this.incrementCounter();
						if (this.onEnable) this.onEnable();
					} else {
						this.decrementCounter();
						if (this.onDisable) this.onDisable();
					}
				}
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._clearColorBuffer;
			},
			set: function set(val) {
				this._clearColorBuffer = val;
				this._dirtyComposition = true;
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._clearDepthBuffer;
			},
			set: function set(val) {
				this._clearDepthBuffer = val;
				this._dirtyComposition = true;
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._clearStencilBuffer;
			},
			set: function set(val) {
				this._clearStencilBuffer = val;
				this._dirtyComposition = true;
			}
		}, {
			key: "hasClusteredLights",
			get: function get() {
				return this._clusteredLightsSet.size > 0;
			}
		}, {
			key: "clusteredLightsSet",
			get: function get() {
				return this._clusteredLightsSet;
			}
		}, {
			key: "splitLights",
			get: function get() {
				if (this._splitLightsDirty) {
					this._splitLightsDirty = false;
					var splitLights = this._splitLights;
					for (var i = 0; i < splitLights.length; i++) {
						splitLights[i].length = 0;
					}
					var lights = this._lights;
					for (var _i = 0; _i < lights.length; _i++) {
						var light = lights[_i];
						if (light.enabled) {
							splitLights[light._type].push(light);
						}
					}
					for (var _i2 = 0; _i2 < splitLights.length; _i2++) {
						splitLights[_i2].sort(function (a, b) {
							return a.key - b.key;
						});
					}
				}
				return this._splitLights;
			}
		}]);
	}();

	var cmpPriority = function cmpPriority(a, b) {
		return a.priority - b.priority;
	};
	var sortPriority = function sortPriority(arr) {
		return arr.sort(cmpPriority);
	};

	var LayerComposition = function (_EventHandler) {
		function LayerComposition(name) {
			var _this;
			if (name === void 0) {
				name = 'Untitled';
			}
			_this = _EventHandler.call(this) || this;
			_this.layerList = [];
			_this.layerIdMap = new Map();
			_this.layerNameMap = new Map();
			_this.layerOpaqueIndexMap = new Map();
			_this.layerTransparentIndexMap = new Map();
			_this.subLayerList = [];
			_this.subLayerEnabled = [];
			_this.cameras = [];
			_this._renderActions = [];
			_this._dirty = false;
			_this.name = name;
			_this._opaqueOrder = {};
			_this._transparentOrder = {};
			return _this;
		}
		_inheritsLoose(LayerComposition, _EventHandler);
		var _proto = LayerComposition.prototype;
		_proto.destroy = function destroy() {
			this.destroyRenderActions();
		};
		_proto.destroyRenderActions = function destroyRenderActions() {
			this._renderActions.forEach(function (ra) {
				return ra.destroy();
			});
			this._renderActions.length = 0;
		};
		_proto._update = function _update() {
			var len = this.layerList.length;
			if (!this._dirty) {
				for (var i = 0; i < len; i++) {
					if (this.layerList[i]._dirtyComposition) {
						this._dirty = true;
						break;
					}
				}
			}
			if (this._dirty) {
				this._dirty = false;
				this.cameras.length = 0;
				for (var _i = 0; _i < len; _i++) {
					var layer = this.layerList[_i];
					layer._dirtyComposition = false;
					for (var j = 0; j < layer.cameras.length; j++) {
						var camera = layer.cameras[j];
						var index = this.cameras.indexOf(camera);
						if (index < 0) {
							this.cameras.push(camera);
						}
					}
				}
				if (this.cameras.length > 1) {
					sortPriority(this.cameras);
				}
				var cameraLayers = [];
				var renderActionCount = 0;
				this.destroyRenderActions();
				for (var _i2 = 0; _i2 < this.cameras.length; _i2++) {
					var _camera = this.cameras[_i2];
					cameraLayers.length = 0;
					if (_camera.camera.renderPasses.length > 0) {
						this.addDummyRenderAction(renderActionCount, _camera);
						renderActionCount++;
						continue;
					}
					var cameraFirstRenderAction = true;
					var cameraFirstRenderActionIndex = renderActionCount;
					var lastRenderAction = null;
					var postProcessMarked = false;
					for (var _j = 0; _j < len; _j++) {
						var _layer = this.layerList[_j];
						var isLayerEnabled = _layer.enabled && this.subLayerEnabled[_j];
						if (isLayerEnabled) {
							if (_layer.cameras.length > 0) {
								if (_camera.layers.indexOf(_layer.id) >= 0) {
									cameraLayers.push(_layer);
									if (!postProcessMarked && _layer.id === _camera.disablePostEffectsLayer) {
										postProcessMarked = true;
										if (lastRenderAction) {
											lastRenderAction.triggerPostprocess = true;
										}
									}
									var isTransparent = this.subLayerList[_j];
									lastRenderAction = this.addRenderAction(renderActionCount, _layer, isTransparent, _camera, cameraFirstRenderAction, postProcessMarked);
									renderActionCount++;
									cameraFirstRenderAction = false;
								}
							}
						}
					}
					if (cameraFirstRenderActionIndex < renderActionCount) {
						lastRenderAction.lastCameraUse = true;
					}
					if (!postProcessMarked && lastRenderAction) {
						lastRenderAction.triggerPostprocess = true;
					}
					if (_camera.renderTarget && _camera.postEffectsEnabled) {
						this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, _camera);
					}
				}
				this._logRenderActions();
			}
		};
		_proto.getNextRenderAction = function getNextRenderAction(renderActionIndex) {
			var renderAction = new RenderAction();
			this._renderActions.push(renderAction);
			return renderAction;
		};
		_proto.addDummyRenderAction = function addDummyRenderAction(renderActionIndex, camera) {
			var renderAction = this.getNextRenderAction(renderActionIndex);
			renderAction.camera = camera;
			renderAction.useCameraPasses = true;
		};
		_proto.addRenderAction = function addRenderAction(renderActionIndex, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked) {
			var rt = layer.id !== LAYERID_DEPTH ? camera.renderTarget : null;
			var used = false;
			var renderActions = this._renderActions;
			for (var i = renderActionIndex - 1; i >= 0; i--) {
				if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
					used = true;
					break;
				}
			}
			if (postProcessMarked && camera.postEffectsEnabled) {
				rt = null;
			}
			var renderAction = this.getNextRenderAction(renderActionIndex);
			renderAction.triggerPostprocess = false;
			renderAction.layer = layer;
			renderAction.transparent = isTransparent;
			renderAction.camera = camera;
			renderAction.renderTarget = rt;
			renderAction.firstCameraUse = cameraFirstRenderAction;
			renderAction.lastCameraUse = false;
			var needsCameraClear = cameraFirstRenderAction || !used;
			var needsLayerClear = layer.clearColorBuffer || layer.clearDepthBuffer || layer.clearStencilBuffer;
			if (needsCameraClear || needsLayerClear) {
				renderAction.setupClears(needsCameraClear ? camera : undefined, layer);
			}
			return renderAction;
		};
		_proto.propagateRenderTarget = function propagateRenderTarget(startIndex, fromCamera) {
			for (var a = startIndex; a >= 0; a--) {
				var ra = this._renderActions[a];
				var layer = ra.layer;
				if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
					break;
				}
				if (layer.id === LAYERID_DEPTH) {
					continue;
				}
				if (ra.useCameraPasses) {
					break;
				}
				var thisCamera = ra == null ? void 0 : ra.camera.camera;
				if (thisCamera) {
					if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
						break;
					}
				}
				ra.renderTarget = fromCamera.renderTarget;
			}
		};
		_proto._logRenderActions = function _logRenderActions() {};
		_proto._isLayerAdded = function _isLayerAdded(layer) {
			var found = this.layerIdMap.get(layer.id) === layer;
			return found;
		};
		_proto._isSublayerAdded = function _isSublayerAdded(layer, transparent) {
			var map = transparent ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
			if (map.get(layer) !== undefined) {
				return true;
			}
			return false;
		};
		_proto.push = function push(layer) {
			if (this._isLayerAdded(layer)) return;
			this.layerList.push(layer);
			this.layerList.push(layer);
			this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
			this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
			this.subLayerEnabled.push(true);
			this.subLayerEnabled.push(true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.insert = function insert(layer, index) {
			if (this._isLayerAdded(layer)) return;
			this.layerList.splice(index, 0, layer, layer);
			this.subLayerList.splice(index, 0, false, true);
			var count = this.layerList.length;
			this._updateOpaqueOrder(index, count - 1);
			this._updateTransparentOrder(index, count - 1);
			this.subLayerEnabled.splice(index, 0, true, true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.remove = function remove(layer) {
			var id = this.layerList.indexOf(layer);
			delete this._opaqueOrder[id];
			delete this._transparentOrder[id];
			while (id >= 0) {
				this.layerList.splice(id, 1);
				this.subLayerList.splice(id, 1);
				this.subLayerEnabled.splice(id, 1);
				id = this.layerList.indexOf(layer);
				this._dirty = true;
				this.fire('remove', layer);
			}
			var count = this.layerList.length;
			this._updateOpaqueOrder(0, count - 1);
			this._updateTransparentOrder(0, count - 1);
			this._updateLayerMaps();
		};
		_proto.pushOpaque = function pushOpaque(layer) {
			if (this._isSublayerAdded(layer, false)) return;
			this.layerList.push(layer);
			this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
			this.subLayerEnabled.push(true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.insertOpaque = function insertOpaque(layer, index) {
			if (this._isSublayerAdded(layer, false)) return;
			this.layerList.splice(index, 0, layer);
			this.subLayerList.splice(index, 0, false);
			var count = this.subLayerList.length;
			this._updateOpaqueOrder(index, count - 1);
			this.subLayerEnabled.splice(index, 0, true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.removeOpaque = function removeOpaque(layer) {
			for (var i = 0, len = this.layerList.length; i < len; i++) {
				if (this.layerList[i] === layer && !this.subLayerList[i]) {
					this.layerList.splice(i, 1);
					this.subLayerList.splice(i, 1);
					len--;
					this._updateOpaqueOrder(i, len - 1);
					this.subLayerEnabled.splice(i, 1);
					this._dirty = true;
					if (this.layerList.indexOf(layer) < 0) {
						this.fire('remove', layer);
					}
					break;
				}
			}
			this._updateLayerMaps();
		};
		_proto.pushTransparent = function pushTransparent(layer) {
			if (this._isSublayerAdded(layer, true)) return;
			this.layerList.push(layer);
			this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
			this.subLayerEnabled.push(true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.insertTransparent = function insertTransparent(layer, index) {
			if (this._isSublayerAdded(layer, true)) return;
			this.layerList.splice(index, 0, layer);
			this.subLayerList.splice(index, 0, true);
			var count = this.subLayerList.length;
			this._updateTransparentOrder(index, count - 1);
			this.subLayerEnabled.splice(index, 0, true);
			this._updateLayerMaps();
			this._dirty = true;
			this.fire('add', layer);
		};
		_proto.removeTransparent = function removeTransparent(layer) {
			for (var i = 0, len = this.layerList.length; i < len; i++) {
				if (this.layerList[i] === layer && this.subLayerList[i]) {
					this.layerList.splice(i, 1);
					this.subLayerList.splice(i, 1);
					len--;
					this._updateTransparentOrder(i, len - 1);
					this.subLayerEnabled.splice(i, 1);
					this._dirty = true;
					if (this.layerList.indexOf(layer) < 0) {
						this.fire('remove', layer);
					}
					break;
				}
			}
			this._updateLayerMaps();
		};
		_proto.getOpaqueIndex = function getOpaqueIndex(layer) {
			var _this$layerOpaqueInde;
			return (_this$layerOpaqueInde = this.layerOpaqueIndexMap.get(layer)) != null ? _this$layerOpaqueInde : -1;
		};
		_proto.getTransparentIndex = function getTransparentIndex(layer) {
			var _this$layerTransparen;
			return (_this$layerTransparen = this.layerTransparentIndexMap.get(layer)) != null ? _this$layerTransparen : -1;
		};
		_proto.isEnabled = function isEnabled(layer, transparent) {
			if (layer.enabled) {
				var index = transparent ? this.getTransparentIndex(layer) : this.getOpaqueIndex(layer);
				if (index >= 0) {
					return this.subLayerEnabled[index];
				}
			}
			return false;
		};
		_proto._updateLayerMaps = function _updateLayerMaps() {
			this.layerIdMap.clear();
			this.layerNameMap.clear();
			this.layerOpaqueIndexMap.clear();
			this.layerTransparentIndexMap.clear();
			for (var i = 0; i < this.layerList.length; i++) {
				var layer = this.layerList[i];
				this.layerIdMap.set(layer.id, layer);
				this.layerNameMap.set(layer.name, layer);
				var subLayerIndexMap = this.subLayerList[i] ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
				subLayerIndexMap.set(layer, i);
			}
		};
		_proto.getLayerById = function getLayerById(id) {
			var _this$layerIdMap$get;
			return (_this$layerIdMap$get = this.layerIdMap.get(id)) != null ? _this$layerIdMap$get : null;
		};
		_proto.getLayerByName = function getLayerByName(name) {
			var _this$layerNameMap$ge;
			return (_this$layerNameMap$ge = this.layerNameMap.get(name)) != null ? _this$layerNameMap$ge : null;
		};
		_proto._updateOpaqueOrder = function _updateOpaqueOrder(startIndex, endIndex) {
			for (var i = startIndex; i <= endIndex; i++) {
				if (this.subLayerList[i] === false) {
					this._opaqueOrder[this.layerList[i].id] = i;
				}
			}
		};
		_proto._updateTransparentOrder = function _updateTransparentOrder(startIndex, endIndex) {
			for (var i = startIndex; i <= endIndex; i++) {
				if (this.subLayerList[i] === true) {
					this._transparentOrder[this.layerList[i].id] = i;
				}
			}
		};
		_proto._sortLayersDescending = function _sortLayersDescending(layersA, layersB, order) {
			var topLayerA = -1;
			var topLayerB = -1;
			for (var i = 0, len = layersA.length; i < len; i++) {
				var id = layersA[i];
				if (order.hasOwnProperty(id)) {
					topLayerA = Math.max(topLayerA, order[id]);
				}
			}
			for (var _i3 = 0, _len = layersB.length; _i3 < _len; _i3++) {
				var _id = layersB[_i3];
				if (order.hasOwnProperty(_id)) {
					topLayerB = Math.max(topLayerB, order[_id]);
				}
			}
			if (topLayerA === -1 && topLayerB !== -1) {
				return 1;
			} else if (topLayerB === -1 && topLayerA !== -1) {
				return -1;
			}
			return topLayerB - topLayerA;
		};
		_proto.sortTransparentLayers = function sortTransparentLayers(layersA, layersB) {
			return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
		};
		_proto.sortOpaqueLayers = function sortOpaqueLayers(layersA, layersB) {
			return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
		};
		return LayerComposition;
	}(EventHandler);

	var tmpVec = new Vec3();
	var tmpBiases = {
		bias: 0,
		normalBias: 0
	};
	var tmpColor = new Color();
	var chanId = {
		r: 0,
		g: 1,
		b: 2,
		a: 3
	};
	var lightTypes = {
		'directional': LIGHTTYPE_DIRECTIONAL,
		'omni': LIGHTTYPE_OMNI,
		'point': LIGHTTYPE_OMNI,
		'spot': LIGHTTYPE_SPOT
	};
	var directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];
	var id = 0;
	var LightRenderData = function () {
		function LightRenderData(camera, face, light) {
			this.light = light;
			this.camera = camera;
			this.shadowCamera = ShadowRenderer.createShadowCamera(light._shadowType, light._type, face);
			this.shadowMatrix = new Mat4();
			this.shadowViewport = new Vec4(0, 0, 1, 1);
			this.shadowScissor = new Vec4(0, 0, 1, 1);
			this.projectionCompensation = 0;
			this.face = face;
			this.visibleCasters = [];
			this.viewBindGroups = [];
		}
		var _proto = LightRenderData.prototype;
		_proto.destroy = function destroy() {
			this.viewBindGroups.forEach(function (bg) {
				bg.defaultUniformBuffer.destroy();
				bg.destroy();
			});
			this.viewBindGroups.length = 0;
		};
		return _createClass(LightRenderData, [{
			key: "shadowBuffer",
			get: function get() {
				var rt = this.shadowCamera.renderTarget;
				if (rt) {
					return this.light._isPcf ? rt.depthBuffer : rt.colorBuffer;
				}
				return null;
			}
		}]);
	}();
	var Light = function () {
		function Light(graphicsDevice, clusteredLighting) {
			this.layers = new Set();
			this.clusteredLighting = void 0;
			this.shadowDepthState = DepthState.DEFAULT.clone();
			this.device = graphicsDevice;
			this.clusteredLighting = clusteredLighting;
			this.id = id++;
			this._type = LIGHTTYPE_DIRECTIONAL;
			this._color = new Color(0.8, 0.8, 0.8);
			this._intensity = 1;
			this._affectSpecularity = true;
			this._luminance = 0;
			this._castShadows = false;
			this._enabled = false;
			this._mask = MASK_AFFECT_DYNAMIC;
			this.isStatic = false;
			this.key = 0;
			this.bakeDir = true;
			this.bakeNumSamples = 1;
			this.bakeArea = 0;
			this.attenuationStart = 10;
			this.attenuationEnd = 10;
			this._falloffMode = LIGHTFALLOFF_LINEAR;
			this._shadowType = SHADOW_PCF3_32F;
			this._vsmBlurSize = 11;
			this.vsmBlurMode = BLUR_GAUSSIAN;
			this.vsmBias = 0.01 * 0.25;
			this._cookie = null;
			this.cookieIntensity = 1;
			this._cookieFalloff = true;
			this._cookieChannel = 'rgb';
			this._cookieTransform = null;
			this._cookieTransformUniform = new Float32Array(4);
			this._cookieOffset = null;
			this._cookieOffsetUniform = new Float32Array(2);
			this._cookieTransformSet = false;
			this._cookieOffsetSet = false;
			this._innerConeAngle = 40;
			this._outerConeAngle = 45;
			this.cascades = null;
			this._shadowMatrixPalette = null;
			this._shadowCascadeDistances = null;
			this.numCascades = 1;
			this._cascadeBlend = 0;
			this.cascadeDistribution = 0.5;
			this._shape = LIGHTSHAPE_PUNCTUAL;
			this._colorLinear = new Float32Array(3);
			this._updateLinearColor();
			this._position = new Vec3(0, 0, 0);
			this._direction = new Vec3(0, 0, 0);
			this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
			this._updateOuterAngle(this._outerConeAngle);
			this._usePhysicalUnits = undefined;
			this._shadowMap = null;
			this._shadowRenderParams = [];
			this._shadowCameraParams = [];
			this.shadowDistance = 40;
			this._shadowResolution = 1024;
			this._shadowBias = -0.0005;
			this.shadowIntensity = 1.0;
			this._normalOffsetBias = 0.0;
			this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
			this.shadowUpdateOverrides = null;
			this._penumbraSize = 1.0;
			this._isVsm = false;
			this._isPcf = true;
			this._cookieMatrix = null;
			this._atlasViewport = null;
			this.atlasViewportAllocated = false;
			this.atlasVersion = 0;
			this.atlasSlotIndex = 0;
			this.atlasSlotUpdated = false;
			this._node = null;
			this._renderData = [];
			this.visibleThisFrame = false;
			this.maxScreenSize = 0;
			this._updateShadowBias();
		}
		var _proto2 = Light.prototype;
		_proto2.destroy = function destroy() {
			this._destroyShadowMap();
			this.releaseRenderData();
			this._renderData = null;
		};
		_proto2.releaseRenderData = function releaseRenderData() {
			if (this._renderData) {
				for (var i = 0; i < this._renderData.length; i++) {
					this._renderData[i].destroy();
				}
				this._renderData.length = 0;
			}
		};
		_proto2.addLayer = function addLayer(layer) {
			this.layers.add(layer);
		};
		_proto2.removeLayer = function removeLayer(layer) {
			this.layers.delete(layer);
		};
		_proto2._updateOuterAngle = function _updateOuterAngle(angle) {
			var radAngle = angle * Math.PI / 180;
			this._outerConeAngleCos = Math.cos(radAngle);
			this._outerConeAngleSin = Math.sin(radAngle);
		};
		_proto2.beginFrame = function beginFrame() {
			this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
			this.maxScreenSize = 0;
			this.atlasViewportAllocated = false;
			this.atlasSlotUpdated = false;
		};
		_proto2._destroyShadowMap = function _destroyShadowMap() {
			this.releaseRenderData();
			if (this._shadowMap) {
				if (!this._shadowMap.cached) {
					this._shadowMap.destroy();
				}
				this._shadowMap = null;
			}
			if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
				this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
			}
			if (this.shadowUpdateOverrides) {
				for (var i = 0; i < this.shadowUpdateOverrides.length; i++) {
					if (this.shadowUpdateOverrides[i] === SHADOWUPDATE_NONE) {
						this.shadowUpdateOverrides[i] = SHADOWUPDATE_THISFRAME;
					}
				}
			}
		};
		_proto2.getRenderData = function getRenderData(camera, face) {
			for (var i = 0; i < this._renderData.length; i++) {
				var current = this._renderData[i];
				if (current.camera === camera && current.face === face) {
					return current;
				}
			}
			var rd = new LightRenderData(camera, face, this);
			this._renderData.push(rd);
			return rd;
		};
		_proto2.clone = function clone() {
			var clone = new Light(this.device, this.clusteredLighting);
			clone.type = this._type;
			clone.setColor(this._color);
			clone.intensity = this._intensity;
			clone.affectSpecularity = this._affectSpecularity;
			clone.luminance = this._luminance;
			clone.castShadows = this.castShadows;
			clone._enabled = this._enabled;
			clone.attenuationStart = this.attenuationStart;
			clone.attenuationEnd = this.attenuationEnd;
			clone.falloffMode = this._falloffMode;
			clone.shadowType = this._shadowType;
			clone.vsmBlurSize = this._vsmBlurSize;
			clone.vsmBlurMode = this.vsmBlurMode;
			clone.vsmBias = this.vsmBias;
			clone.penumbraSize = this.penumbraSize;
			clone.shadowUpdateMode = this.shadowUpdateMode;
			clone.mask = this.mask;
			if (this.shadowUpdateOverrides) {
				clone.shadowUpdateOverrides = this.shadowUpdateOverrides.slice();
			}
			clone.innerConeAngle = this._innerConeAngle;
			clone.outerConeAngle = this._outerConeAngle;
			clone.numCascades = this.numCascades;
			clone.cascadeDistribution = this.cascadeDistribution;
			clone.cascadeBlend = this._cascadeBlend;
			clone.shape = this._shape;
			clone.shadowDepthState.copy(this.shadowDepthState);
			clone.shadowBias = this.shadowBias;
			clone.normalOffsetBias = this._normalOffsetBias;
			clone.shadowResolution = this._shadowResolution;
			clone.shadowDistance = this.shadowDistance;
			clone.shadowIntensity = this.shadowIntensity;
			return clone;
		};
		Light.getLightUnitConversion = function getLightUnitConversion(type, outerAngle, innerAngle) {
			if (outerAngle === void 0) {
				outerAngle = Math.PI / 4;
			}
			if (innerAngle === void 0) {
				innerAngle = 0;
			}
			switch (type) {
				case LIGHTTYPE_SPOT:
					{
						var falloffEnd = Math.cos(outerAngle);
						var falloffStart = Math.cos(innerAngle);
						return 2 * Math.PI * (1 - falloffStart + (falloffStart - falloffEnd) / 2.0);
					}
				case LIGHTTYPE_OMNI:
					return 4 * Math.PI;
				case LIGHTTYPE_DIRECTIONAL:
					return 1;
			}
		};
		_proto2._getUniformBiasValues = function _getUniformBiasValues(lightRenderData) {
			var farClip = lightRenderData.shadowCamera._farClip;
			switch (this._type) {
				case LIGHTTYPE_OMNI:
					tmpBiases.bias = this.shadowBias;
					tmpBiases.normalBias = this._normalOffsetBias;
					break;
				case LIGHTTYPE_SPOT:
					if (this._isVsm) {
						tmpBiases.bias = -0.00001 * 20;
					} else {
						tmpBiases.bias = this.shadowBias * 20;
					}
					tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
					break;
				case LIGHTTYPE_DIRECTIONAL:
					if (this._isVsm) {
						tmpBiases.bias = -0.00001 * 20;
					} else {
						tmpBiases.bias = this.shadowBias / farClip * 100;
					}
					tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
					break;
			}
			return tmpBiases;
		};
		_proto2.getColor = function getColor() {
			return this._color;
		};
		_proto2.getBoundingSphere = function getBoundingSphere(sphere) {
			if (this._type === LIGHTTYPE_SPOT) {
				var size = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var cosAngle = this._outerConeAngleCos;
				var node = this._node;
				tmpVec.copy(node.up);
				if (angle > 45) {
					sphere.radius = size * this._outerConeAngleSin;
					tmpVec.mulScalar(-size * cosAngle);
				} else {
					sphere.radius = size / (2 * cosAngle);
					tmpVec.mulScalar(-sphere.radius);
				}
				sphere.center.add2(node.getPosition(), tmpVec);
			} else if (this._type === LIGHTTYPE_OMNI) {
				sphere.center = this._node.getPosition();
				sphere.radius = this.attenuationEnd;
			}
		};
		_proto2.getBoundingBox = function getBoundingBox(box) {
			if (this._type === LIGHTTYPE_SPOT) {
				var range = this.attenuationEnd;
				var angle = this._outerConeAngle;
				var node = this._node;
				var scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
				box.center.set(0, -range * 0.5, 0);
				box.halfExtents.set(scl, range * 0.5, scl);
				box.setFromTransformedAabb(box, node.getWorldTransform(), true);
			} else if (this._type === LIGHTTYPE_OMNI) {
				box.center.copy(this._node.getPosition());
				box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
			}
		};
		_proto2._updateShadowBias = function _updateShadowBias() {
			if (this._type === LIGHTTYPE_OMNI && !this.clusteredLighting) {
				this.shadowDepthState.depthBias = 0;
				this.shadowDepthState.depthBiasSlope = 0;
			} else {
				var bias = this.shadowBias * -1000.0;
				this.shadowDepthState.depthBias = bias;
				this.shadowDepthState.depthBiasSlope = bias;
			}
		};
		_proto2._updateLinearColor = function _updateLinearColor() {
			var intensity = this._intensity;
			if (this._usePhysicalUnits) {
				intensity = this._luminance / Light.getLightUnitConversion(this._type, this._outerConeAngle * math.DEG_TO_RAD, this._innerConeAngle * math.DEG_TO_RAD);
			}
			var color = this._color;
			var colorLinear = this._colorLinear;
			if (intensity >= 1) {
				tmpColor.linear(color).mulScalar(intensity);
			} else {
				tmpColor.copy(color).mulScalar(intensity).linear();
			}
			colorLinear[0] = tmpColor.r;
			colorLinear[1] = tmpColor.g;
			colorLinear[2] = tmpColor.b;
		};
		_proto2.setColor = function setColor() {
			if (arguments.length === 1) {
				this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
			} else if (arguments.length === 3) {
				this._color.set(arguments[0], arguments[1], arguments[2]);
			}
			this._updateLinearColor();
		};
		_proto2.layersDirty = function layersDirty() {
			var _this = this;
			this.layers.forEach(function (layer) {
				if (layer.hasLight(_this)) {
					layer.markLightsDirty();
				}
			});
		};
		_proto2.updateKey = function updateKey() {
			var key = this._type << 29 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | (this.numCascades > 0 ? 1 : 0) << 9 | (this._cascadeBlend > 0 ? 1 : 0) << 8 | (this.affectSpecularity ? 1 : 0) << 7 | this.mask << 6 | (this._castShadows ? 1 : 0) << 3;
			if (this._cookieChannel.length === 3) {
				key |= chanId[this._cookieChannel.charAt(1)] << 16;
				key |= chanId[this._cookieChannel.charAt(2)] << 14;
			}
			if (key !== this.key) {
				this.layersDirty();
			}
			this.key = key;
		};
		return _createClass(Light, [{
			key: "shadowBias",
			get: function get() {
				return this._shadowBias;
			},
			set: function set(value) {
				if (this._shadowBias !== value) {
					this._shadowBias = value;
					this._updateShadowBias();
				}
			}
		}, {
			key: "numCascades",
			get: function get() {
				return this.cascades.length;
			},
			set: function set(value) {
				if (!this.cascades || this.numCascades !== value) {
					this.cascades = directionalCascades[value - 1];
					this._shadowMatrixPalette = new Float32Array(4 * 16);
					this._shadowCascadeDistances = new Float32Array(4);
					this._destroyShadowMap();
					this.updateKey();
				}
			}
		}, {
			key: "cascadeBlend",
			get: function get() {
				return this._cascadeBlend;
			},
			set: function set(value) {
				if (this._cascadeBlend !== value) {
					this._cascadeBlend = value;
					this.updateKey();
				}
			}
		}, {
			key: "shadowMap",
			get: function get() {
				return this._shadowMap;
			},
			set: function set(shadowMap) {
				if (this._shadowMap !== shadowMap) {
					this._destroyShadowMap();
					this._shadowMap = shadowMap;
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._mask !== value) {
					this._mask = value;
					this.updateKey();
				}
			}
		}, {
			key: "numShadowFaces",
			get: function get() {
				var type = this._type;
				if (type === LIGHTTYPE_DIRECTIONAL) {
					return this.numCascades;
				} else if (type === LIGHTTYPE_OMNI) {
					return 6;
				}
				return 1;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) {
					return;
				}
				this._type = value;
				this._destroyShadowMap();
				this._updateShadowBias();
				this.updateKey();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowUpdateOverrides = null;
				this.shadowType = stype;
			}
		}, {
			key: "shape",
			get: function get() {
				return this._shape;
			},
			set: function set(value) {
				if (this._shape === value) {
					return;
				}
				this._shape = value;
				this._destroyShadowMap();
				this.updateKey();
				var stype = this._shadowType;
				this._shadowType = null;
				this.shadowType = stype;
			}
		}, {
			key: "usePhysicalUnits",
			get: function get() {
				return this._usePhysicalUnits;
			},
			set: function set(value) {
				if (this._usePhysicalUnits !== value) {
					this._usePhysicalUnits = value;
					this._updateLinearColor();
				}
			}
		}, {
			key: "shadowType",
			get: function get() {
				return this._shadowType;
			},
			set: function set(value) {
				var _shadowInfo$vsm, _shadowInfo$pcf;
				if (this._shadowType === value) {
					return;
				}
				var device = this.device;
				if (this._type === LIGHTTYPE_OMNI && value !== SHADOW_PCF1_32F && value !== SHADOW_PCF3_32F && value !== SHADOW_PCF1_16F && value !== SHADOW_PCF3_16F && value !== SHADOW_PCSS_32F) {
					value = SHADOW_PCF3_32F;
				}
				if (value === SHADOW_VSM_32F && (!device.textureFloatRenderable || !device.textureFloatFilterable)) {
					value = SHADOW_VSM_16F;
				}
				if (value === SHADOW_VSM_16F && !device.textureHalfFloatRenderable) {
					value = SHADOW_PCF3_32F;
				}
				var shadowInfo = shadowTypeInfo.get(value);
				this._isVsm = (_shadowInfo$vsm = shadowInfo == null ? void 0 : shadowInfo.vsm) != null ? _shadowInfo$vsm : false;
				this._isPcf = (_shadowInfo$pcf = shadowInfo == null ? void 0 : shadowInfo.pcf) != null ? _shadowInfo$pcf : false;
				this._shadowType = value;
				this._destroyShadowMap();
				this.updateKey();
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				if (this._enabled !== value) {
					this._enabled = value;
					this.layersDirty();
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows && this._mask !== MASK_BAKE && this._mask !== 0;
			},
			set: function set(value) {
				if (this._castShadows !== value) {
					this._castShadows = value;
					this._destroyShadowMap();
					this.layersDirty();
					this.updateKey();
				}
			}
		}, {
			key: "bakeShadows",
			get: function get() {
				return this._castShadows && this._mask === MASK_BAKE;
			}
		}, {
			key: "shadowResolution",
			get: function get() {
				return this._shadowResolution;
			},
			set: function set(value) {
				if (this._shadowResolution !== value) {
					if (this._type === LIGHTTYPE_OMNI) {
						value = Math.min(value, this.device.maxCubeMapSize);
					} else {
						value = Math.min(value, this.device.maxTextureSize);
					}
					this._shadowResolution = value;
					this._destroyShadowMap();
				}
			}
		}, {
			key: "vsmBlurSize",
			get: function get() {
				return this._vsmBlurSize;
			},
			set: function set(value) {
				if (this._vsmBlurSize === value) {
					return;
				}
				if (value % 2 === 0) value++;
				this._vsmBlurSize = value;
			}
		}, {
			key: "normalOffsetBias",
			get: function get() {
				return this._normalOffsetBias;
			},
			set: function set(value) {
				if (this._normalOffsetBias !== value) {
					var dirty = !this._normalOffsetBias && value || this._normalOffsetBias && !value;
					this._normalOffsetBias = value;
					if (dirty) {
						this.updateKey();
					}
				}
			}
		}, {
			key: "falloffMode",
			get: function get() {
				return this._falloffMode;
			},
			set: function set(value) {
				if (this._falloffMode === value) {
					return;
				}
				this._falloffMode = value;
				this.updateKey();
			}
		}, {
			key: "innerConeAngle",
			get: function get() {
				return this._innerConeAngle;
			},
			set: function set(value) {
				if (this._innerConeAngle === value) {
					return;
				}
				this._innerConeAngle = value;
				this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
				if (this._usePhysicalUnits) {
					this._updateLinearColor();
				}
			}
		}, {
			key: "outerConeAngle",
			get: function get() {
				return this._outerConeAngle;
			},
			set: function set(value) {
				if (this._outerConeAngle === value) {
					return;
				}
				this._outerConeAngle = value;
				this._updateOuterAngle(value);
				if (this._usePhysicalUnits) {
					this._updateLinearColor();
				}
			}
		}, {
			key: "penumbraSize",
			get: function get() {
				return this._penumbraSize;
			},
			set: function set(value) {
				this._penumbraSize = value;
			}
		}, {
			key: "intensity",
			get: function get() {
				return this._intensity;
			},
			set: function set(value) {
				if (this._intensity !== value) {
					this._intensity = value;
					this._updateLinearColor();
				}
			}
		}, {
			key: "affectSpecularity",
			get: function get() {
				return this._affectSpecularity;
			},
			set: function set(value) {
				if (this._type === LIGHTTYPE_DIRECTIONAL) {
					this._affectSpecularity = value;
					this.updateKey();
				}
			}
		}, {
			key: "luminance",
			get: function get() {
				return this._luminance;
			},
			set: function set(value) {
				if (this._luminance !== value) {
					this._luminance = value;
					this._updateLinearColor();
				}
			}
		}, {
			key: "cookieMatrix",
			get: function get() {
				if (!this._cookieMatrix) {
					this._cookieMatrix = new Mat4();
				}
				return this._cookieMatrix;
			}
		}, {
			key: "atlasViewport",
			get: function get() {
				if (!this._atlasViewport) {
					this._atlasViewport = new Vec4(0, 0, 1, 1);
				}
				return this._atlasViewport;
			}
		}, {
			key: "cookie",
			get: function get() {
				return this._cookie;
			},
			set: function set(value) {
				if (this._cookie === value) {
					return;
				}
				this._cookie = value;
				this.updateKey();
			}
		}, {
			key: "cookieFalloff",
			get: function get() {
				return this._cookieFalloff;
			},
			set: function set(value) {
				if (this._cookieFalloff === value) {
					return;
				}
				this._cookieFalloff = value;
				this.updateKey();
			}
		}, {
			key: "cookieChannel",
			get: function get() {
				return this._cookieChannel;
			},
			set: function set(value) {
				if (this._cookieChannel === value) {
					return;
				}
				if (value.length < 3) {
					var chr = value.charAt(value.length - 1);
					var addLen = 3 - value.length;
					for (var i = 0; i < addLen; i++) {
						value += chr;
					}
				}
				this._cookieChannel = value;
				this.updateKey();
			}
		}, {
			key: "cookieTransform",
			get: function get() {
				return this._cookieTransform;
			},
			set: function set(value) {
				if (this._cookieTransform === value) {
					return;
				}
				this._cookieTransform = value;
				this._cookieTransformSet = !!value;
				if (value && !this._cookieOffset) {
					this.cookieOffset = new Vec2();
					this._cookieOffsetSet = false;
				}
				this.updateKey();
			}
		}, {
			key: "cookieOffset",
			get: function get() {
				return this._cookieOffset;
			},
			set: function set(value) {
				if (this._cookieOffset === value) {
					return;
				}
				var xformNew = !!(this._cookieTransformSet || value);
				if (xformNew && !value && this._cookieOffset) {
					this._cookieOffset.set(0, 0);
				} else {
					this._cookieOffset = value;
				}
				this._cookieOffsetSet = !!value;
				if (value && !this._cookieTransform) {
					this.cookieTransform = new Vec4(1, 1, 0, 0);
					this._cookieTransformSet = false;
				}
				this.updateKey();
			}
		}]);
	}();

	var LightingParams = function () {
		function LightingParams(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {
			this._areaLightsEnabled = false;
			this._cells = new Vec3(10, 3, 10);
			this._maxLightsPerCell = 255;
			this._shadowsEnabled = true;
			this._shadowType = SHADOW_PCF3_32F;
			this._shadowAtlasResolution = 2048;
			this._cookiesEnabled = false;
			this._cookieAtlasResolution = 2048;
			this.debugLayer = void 0;
			this.atlasSplit = null;
			this._supportsAreaLights = supportsAreaLights;
			this._maxTextureSize = maxTextureSize;
			this._dirtyLightsFnc = dirtyLightsFnc;
		}
		var _proto = LightingParams.prototype;
		_proto.applySettings = function applySettings(render) {
			var _render$lightingShado, _render$lightingCooki, _render$lightingAreaL, _render$lightingShado2, _render$lightingCooki2, _render$lightingMaxLi, _render$lightingShado3;
			this.shadowsEnabled = (_render$lightingShado = render.lightingShadowsEnabled) != null ? _render$lightingShado : this.shadowsEnabled;
			this.cookiesEnabled = (_render$lightingCooki = render.lightingCookiesEnabled) != null ? _render$lightingCooki : this.cookiesEnabled;
			this.areaLightsEnabled = (_render$lightingAreaL = render.lightingAreaLightsEnabled) != null ? _render$lightingAreaL : this.areaLightsEnabled;
			this.shadowAtlasResolution = (_render$lightingShado2 = render.lightingShadowAtlasResolution) != null ? _render$lightingShado2 : this.shadowAtlasResolution;
			this.cookieAtlasResolution = (_render$lightingCooki2 = render.lightingCookieAtlasResolution) != null ? _render$lightingCooki2 : this.cookieAtlasResolution;
			this.maxLightsPerCell = (_render$lightingMaxLi = render.lightingMaxLightsPerCell) != null ? _render$lightingMaxLi : this.maxLightsPerCell;
			this.shadowType = (_render$lightingShado3 = render.lightingShadowType) != null ? _render$lightingShado3 : this.shadowType;
			if (render.lightingCells) {
				this.cell = new Vec3(render.lightingCells);
			}
		};
		return _createClass(LightingParams, [{
			key: "cells",
			get: function get() {
				return this._cells;
			},
			set: function set(value) {
				this._cells.copy(value);
			}
		}, {
			key: "maxLightsPerCell",
			get: function get() {
				return this._maxLightsPerCell;
			},
			set: function set(value) {
				this._maxLightsPerCell = math.clamp(value, 1, 255);
			}
		}, {
			key: "cookieAtlasResolution",
			get: function get() {
				return this._cookieAtlasResolution;
			},
			set: function set(value) {
				this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
			}
		}, {
			key: "shadowAtlasResolution",
			get: function get() {
				return this._shadowAtlasResolution;
			},
			set: function set(value) {
				this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
			}
		}, {
			key: "shadowType",
			get: function get() {
				return this._shadowType;
			},
			set: function set(value) {
				if (this._shadowType !== value) {
					this._shadowType = value;
					this._dirtyLightsFnc();
				}
			}
		}, {
			key: "cookiesEnabled",
			get: function get() {
				return this._cookiesEnabled;
			},
			set: function set(value) {
				if (this._cookiesEnabled !== value) {
					this._cookiesEnabled = value;
					this._dirtyLightsFnc();
				}
			}
		}, {
			key: "areaLightsEnabled",
			get: function get() {
				return this._areaLightsEnabled;
			},
			set: function set(value) {
				if (this._supportsAreaLights) {
					if (this._areaLightsEnabled !== value) {
						this._areaLightsEnabled = value;
						this._dirtyLightsFnc();
					}
				}
			}
		}, {
			key: "shadowsEnabled",
			get: function get() {
				return this._shadowsEnabled;
			},
			set: function set(value) {
				if (this._shadowsEnabled !== value) {
					this._shadowsEnabled = value;
					this._dirtyLightsFnc();
				}
			}
		}]);
	}();

	var textureMorphVertexShader = "\n\tattribute vec2 vertex_position;\n\tvarying vec2 uv0;\n\tvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t}\n\t";
	var blendStateAdditive = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
	var MorphInstance = function () {
		function MorphInstance(morph) {
			var _this = this;
			this.shaderCache = [];
			this.morph = morph;
			morph.incRefCount();
			this.device = morph.device;
			this._weights = [];
			this._weightMap = new Map();
			for (var v = 0; v < morph._targets.length; v++) {
				var target = morph._targets[v];
				if (target.name) {
					this._weightMap.set(target.name, v);
				}
				this.setWeight(v, target.defaultWeight);
			}
			this._activeTargets = [];
			this.maxSubmitCount = this.device.maxTextures;
			this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
			var createRT = function createRT(name, textureVar) {
				_this[textureVar] = morph._createTexture(name, morph._renderTextureFormat);
				return new RenderTarget({
					colorBuffer: _this[textureVar],
					depth: false
				});
			};
			if (morph.morphPositions) {
				this.rtPositions = createRT('MorphRTPos', 'texturePositions');
			}
			if (morph.morphNormals) {
				this.rtNormals = createRT('MorphRTNrm', 'textureNormals');
			}
			this._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight]);
			var halfSize = morph.aabb.halfExtents;
			this._aabbSize = new Float32Array([halfSize.x * 4, halfSize.y * 4, halfSize.z * 4]);
			var min = morph.aabb.getMin();
			this._aabbMin = new Float32Array([min.x * 2, min.y * 2, min.z * 2]);
			this._aabbNrmSize = new Float32Array([2, 2, 2]);
			this._aabbNrmMin = new Float32Array([-1, -1, -1]);
			this.aabbSizeId = this.device.scope.resolve('aabbSize');
			this.aabbMinId = this.device.scope.resolve('aabbMin');
			for (var i = 0; i < this.maxSubmitCount; i++) {
				this["morphBlendTex" + i] = this.device.scope.resolve("morphBlendTex" + i);
			}
			this.morphFactor = this.device.scope.resolve('morphFactor[0]');
			this.zeroTextures = false;
		}
		var _proto = MorphInstance.prototype;
		_proto.destroy = function destroy() {
			this.shader = null;
			var morph = this.morph;
			if (morph) {
				this.morph = null;
				morph.decRefCount();
				if (morph.refCount < 1) {
					morph.destroy();
				}
			}
			if (this.rtPositions) {
				this.rtPositions.destroy();
				this.rtPositions = null;
			}
			if (this.texturePositions) {
				this.texturePositions.destroy();
				this.texturePositions = null;
			}
			if (this.rtNormals) {
				this.rtNormals.destroy();
				this.rtNormals = null;
			}
			if (this.textureNormals) {
				this.textureNormals.destroy();
				this.textureNormals = null;
			}
		};
		_proto.clone = function clone() {
			return new MorphInstance(this.morph);
		};
		_proto._getWeightIndex = function _getWeightIndex(key) {
			if (typeof key === 'string') {
				var index = this._weightMap.get(key);
				return index;
			}
			return key;
		};
		_proto.getWeight = function getWeight(key) {
			var index = this._getWeightIndex(key);
			return this._weights[index];
		};
		_proto.setWeight = function setWeight(key, weight) {
			var index = this._getWeightIndex(key);
			this._weights[index] = weight;
			this._dirty = true;
		};
		_proto._getFragmentShader = function _getFragmentShader(numTextures) {
			var textureDecl = '';
			var addingCode = '';
			for (var i = 0; i < numTextures; i++) {
				textureDecl += "uniform highp sampler2D morphBlendTex" + i + ";";
				addingCode += "color.xyz += morphFactor[" + i + "] * texture2D(morphBlendTex" + i + ", uv0).xyz;";
			}
			return "\n\n            varying vec2 uv0;\n            " + (this.morph.intRenderFormat ? '#define MORPH_INT' : '') + "\n            " + (numTextures > 0 ? "uniform highp float morphFactor[" + numTextures + "];" : '') + "\n            " + textureDecl + "\n\n            #ifdef MORPH_INT\n                uniform vec3 aabbSize;\n                uniform vec3 aabbMin;\n            #endif\n\n            void main (void) {\n                highp vec4 color = vec4(0, 0, 0, 1);\n\n                " + addingCode + "\n\n                #ifdef MORPH_INT\n                    color.xyz = (color.xyz - aabbMin) / aabbSize * 65535.0;\n                    gl_FragColor = uvec4(color);\n                #else\n                    gl_FragColor = color;\n                #endif\n            }\n        ";
		};
		_proto._getShader = function _getShader(count) {
			var shader = this.shaderCache[count];
			if (!shader) {
				var fs = this._getFragmentShader(count);
				var outputType = this.morph.intRenderFormat ? 'uvec4' : 'vec4';
				shader = createShaderFromCode(this.device, textureMorphVertexShader, fs, "textureMorph" + count, undefined, {
					fragmentOutputTypes: [outputType]
				});
				this.shaderCache[count] = shader;
			}
			return shader;
		};
		_proto._updateTextureRenderTarget = function _updateTextureRenderTarget(renderTarget, srcTextureName, isPos) {
			var _this2 = this;
			var device = this.device;
			var submitBatch = function submitBatch(usedCount, blending) {
				_this2.morphFactor.setValue(_this2._shaderMorphWeights);
				device.setBlendState(blending ? blendStateAdditive : BlendState.NOBLEND);
				var shader = _this2._getShader(usedCount);
				drawQuadWithShader(device, renderTarget, shader);
			};
			this.setAabbUniforms(isPos);
			var usedCount = 0;
			var blending = false;
			var count = this._activeTargets.length;
			for (var i = 0; i < count; i++) {
				var activeTarget = this._activeTargets[i];
				var tex = activeTarget.target[srcTextureName];
				if (tex) {
					this["morphBlendTex" + usedCount].setValue(tex);
					this._shaderMorphWeights[usedCount] = activeTarget.weight;
					usedCount++;
					if (usedCount >= this.maxSubmitCount) {
						submitBatch(usedCount, blending);
						usedCount = 0;
						blending = true;
					}
				}
			}
			if (usedCount > 0 || count === 0 && !this.zeroTextures) {
				submitBatch(usedCount, blending);
			}
		};
		_proto._updateTextureMorph = function _updateTextureMorph() {
			this.device;
			if (this._activeTargets.length > 0 || !this.zeroTextures) {
				if (this.rtPositions) {
					this._updateTextureRenderTarget(this.rtPositions, 'texturePositions', true);
				}
				if (this.rtNormals) {
					this._updateTextureRenderTarget(this.rtNormals, 'textureNormals', false);
				}
				this.zeroTextures = this._activeTargets.length === 0;
			}
		};
		_proto.setAabbUniforms = function setAabbUniforms(isPos) {
			if (isPos === void 0) {
				isPos = true;
			}
			this.aabbSizeId.setValue(isPos ? this._aabbSize : this._aabbNrmSize);
			this.aabbMinId.setValue(isPos ? this._aabbMin : this._aabbNrmMin);
		};
		_proto.prepareRendering = function prepareRendering(device) {
			this.setAabbUniforms();
		};
		_proto.update = function update() {
			this._dirty = false;
			var targets = this.morph._targets;
			var activeCount = 0;
			var epsilon = 0.00001;
			for (var i = 0; i < targets.length; i++) {
				var absWeight = Math.abs(this.getWeight(i));
				if (absWeight > epsilon) {
					if (this._activeTargets.length <= activeCount) {
						this._activeTargets[activeCount] = {};
					}
					var activeTarget = this._activeTargets[activeCount++];
					activeTarget.absWeight = absWeight;
					activeTarget.weight = this.getWeight(i);
					activeTarget.target = targets[i];
				}
			}
			this._activeTargets.length = activeCount;
			if (this.morph.intRenderFormat) {
				if (this._activeTargets.length > this.maxSubmitCount) {
					this._activeTargets.sort(function (l, r) {
						return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
					});
					this._activeTargets.length = this.maxSubmitCount;
				}
			}
			this._updateTextureMorph();
		};
		return MorphInstance;
	}();

	var Model = function () {
		function Model() {
			this.graph = null;
			this.meshInstances = [];
			this.skinInstances = [];
			this.morphInstances = [];
			this.cameras = [];
			this.lights = [];
			this._shadersVersion = 0;
			this._immutable = false;
		}
		var _proto = Model.prototype;
		_proto.getGraph = function getGraph() {
			return this.graph;
		};
		_proto.setGraph = function setGraph(graph) {
			this.graph = graph;
		};
		_proto.getCameras = function getCameras() {
			return this.cameras;
		};
		_proto.setCameras = function setCameras(cameras) {
			this.cameras = cameras;
		};
		_proto.getLights = function getLights() {
			return this.lights;
		};
		_proto.setLights = function setLights(lights) {
			this.lights = lights;
		};
		_proto.getMaterials = function getMaterials() {
			var materials = [];
			for (var i = 0; i < this.meshInstances.length; i++) {
				var meshInstance = this.meshInstances[i];
				if (materials.indexOf(meshInstance.material) === -1) {
					materials.push(meshInstance.material);
				}
			}
			return materials;
		};
		_proto.clone = function clone() {
			var srcNodes = [];
			var cloneNodes = [];
			var _duplicate2 = function _duplicate(node) {
				var newNode = node.clone();
				srcNodes.push(node);
				cloneNodes.push(newNode);
				for (var idx = 0; idx < node._children.length; idx++) {
					newNode.addChild(_duplicate2(node._children[idx]));
				}
				return newNode;
			};
			var cloneGraph = _duplicate2(this.graph);
			var cloneMeshInstances = [];
			var cloneSkinInstances = [];
			var cloneMorphInstances = [];
			for (var i = 0; i < this.skinInstances.length; i++) {
				var skin = this.skinInstances[i].skin;
				var cloneSkinInstance = new SkinInstance(skin);
				var bones = [];
				for (var j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = cloneGraph.findByName(boneName);
					bones.push(bone);
				}
				cloneSkinInstance.bones = bones;
				cloneSkinInstances.push(cloneSkinInstance);
			}
			for (var _i = 0; _i < this.morphInstances.length; _i++) {
				var morph = this.morphInstances[_i].morph;
				var cloneMorphInstance = new MorphInstance(morph);
				cloneMorphInstances.push(cloneMorphInstance);
			}
			for (var _i2 = 0; _i2 < this.meshInstances.length; _i2++) {
				var meshInstance = this.meshInstances[_i2];
				var nodeIndex = srcNodes.indexOf(meshInstance.node);
				var cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);
				if (meshInstance.skinInstance) {
					var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
					cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
				}
				if (meshInstance.morphInstance) {
					var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
					cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
				}
				cloneMeshInstances.push(cloneMeshInstance);
			}
			var clone = new Model();
			clone.graph = cloneGraph;
			clone.meshInstances = cloneMeshInstances;
			clone.skinInstances = cloneSkinInstances;
			clone.morphInstances = cloneMorphInstances;
			clone.getGraph().syncHierarchy();
			return clone;
		};
		_proto.destroy = function destroy() {
			var meshInstances = this.meshInstances;
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].destroy();
			}
			this.meshInstances.length = 0;
		};
		_proto.generateWireframe = function generateWireframe() {
			MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
		};
		return Model;
	}();

	var Morph = function (_RefCountedObject) {
		function Morph(targets, graphicsDevice, _temp) {
			var _this$_renderTextureF;
			var _this;
			var _ref = _temp === void 0 ? {} : _temp,
				_ref$preferHighPrecis = _ref.preferHighPrecision,
				preferHighPrecision = _ref$preferHighPrecis === void 0 ? false : _ref$preferHighPrecis;
			_this = _RefCountedObject.call(this) || this;
			_this._aabb = void 0;
			_this.preferHighPrecision = void 0;
			_this.device = graphicsDevice;
			_this.preferHighPrecision = preferHighPrecision;
			_this._targets = targets.slice();
			var device = _this.device;
			var renderableHalf = device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;
			var renderableFloat = device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;
			_this._renderTextureFormat = _this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;
			_this._renderTextureFormat = (_this$_renderTextureF = _this._renderTextureFormat) != null ? _this$_renderTextureF : PIXELFORMAT_RGBA16U;
			_this.intRenderFormat = isIntegerPixelFormat(_this._renderTextureFormat);
			_this._textureFormat = _this.preferHighPrecision ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;
			_this._init();
			_this._updateMorphFlags();
			return _this;
		}
		_inheritsLoose(Morph, _RefCountedObject);
		var _proto = Morph.prototype;
		_proto._init = function _init() {
			this._initTextureBased();
			for (var i = 0; i < this._targets.length; i++) {
				this._targets[i]._postInit();
			}
		};
		_proto._findSparseSet = function _findSparseSet(deltaArrays, ids, usedDataIndices) {
			var freeIndex = 1;
			var dataCount = deltaArrays[0].length;
			for (var v = 0; v < dataCount; v += 3) {
				var vertexUsed = false;
				for (var i = 0; i < deltaArrays.length; i++) {
					var data = deltaArrays[i];
					if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
						vertexUsed = true;
						break;
					}
				}
				if (vertexUsed) {
					ids.push(freeIndex);
					usedDataIndices.push(v / 3);
					freeIndex++;
				} else {
					ids.push(0);
				}
			}
			return freeIndex;
		};
		_proto._initTextureBased = function _initTextureBased() {
			var deltaArrays = [],
				deltaInfos = [];
			for (var i = 0; i < this._targets.length; i++) {
				var target = this._targets[i];
				if (target.options.deltaPositions) {
					deltaArrays.push(target.options.deltaPositions);
					deltaInfos.push({
						target: target,
						name: 'texturePositions'
					});
				}
				if (target.options.deltaNormals) {
					deltaArrays.push(target.options.deltaNormals);
					deltaInfos.push({
						target: target,
						name: 'textureNormals'
					});
				}
			}
			var ids = [],
				usedDataIndices = [];
			var freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices);
			var maxTextureSize = this.device.maxTextureSize;
			var morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
			morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
			var morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);
			if (morphTextureHeight > maxTextureSize) {
				return false;
			}
			this.morphTextureWidth = morphTextureWidth;
			this.morphTextureHeight = morphTextureHeight;
			var halfFloat = false;
			var numComponents = 3;
			var float2Half = FloatPacking.float2Half;
			if (this._textureFormat === PIXELFORMAT_RGBA16F) {
				halfFloat = true;
				numComponents = 4;
			}
			var textures = [];
			for (var _i = 0; _i < deltaArrays.length; _i++) {
				textures.push(this._createTexture('MorphTarget', this._textureFormat));
			}
			for (var _i2 = 0; _i2 < deltaArrays.length; _i2++) {
				var data = deltaArrays[_i2];
				var texture = textures[_i2];
				var textureData = texture.lock();
				if (halfFloat) {
					for (var v = 0; v < usedDataIndices.length; v++) {
						var index = usedDataIndices[v] * 3;
						var dstIndex = v * numComponents + numComponents;
						textureData[dstIndex] = float2Half(data[index]);
						textureData[dstIndex + 1] = float2Half(data[index + 1]);
						textureData[dstIndex + 2] = float2Half(data[index + 2]);
					}
				} else {
					for (var _v = 0; _v < usedDataIndices.length; _v++) {
						var _index = usedDataIndices[_v] * 3;
						var _dstIndex = _v * numComponents + numComponents;
						textureData[_dstIndex] = data[_index];
						textureData[_dstIndex + 1] = data[_index + 1];
						textureData[_dstIndex + 2] = data[_index + 2];
					}
				}
				texture.unlock();
				var _target = deltaInfos[_i2].target;
				_target._setTexture(deltaInfos[_i2].name, texture);
			}
			var formatDesc = [{
				semantic: SEMANTIC_ATTR15,
				components: 1,
				type: TYPE_UINT32,
				asInt: true
			}];
			this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids.length), ids.length, {
				data: new Uint32Array(ids)
			});
			return true;
		};
		_proto.destroy = function destroy() {
			var _this$vertexBufferIds;
			(_this$vertexBufferIds = this.vertexBufferIds) == null || _this$vertexBufferIds.destroy();
			this.vertexBufferIds = null;
			for (var i = 0; i < this._targets.length; i++) {
				this._targets[i].destroy();
			}
			this._targets.length = 0;
		};
		_proto._updateMorphFlags = function _updateMorphFlags() {
			this._morphPositions = false;
			this._morphNormals = false;
			for (var i = 0; i < this._targets.length; i++) {
				var target = this._targets[i];
				if (target.morphPositions) {
					this._morphPositions = true;
				}
				if (target.morphNormals) {
					this._morphNormals = true;
				}
			}
		};
		_proto._createTexture = function _createTexture(name, format) {
			return new Texture(this.device, {
				width: this.morphTextureWidth,
				height: this.morphTextureHeight,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: name
			});
		};
		return _createClass(Morph, [{
			key: "aabb",
			get: function get() {
				if (!this._aabb) {
					var min = new Vec3();
					var max = new Vec3();
					for (var i = 0; i < this._targets.length; i++) {
						var targetAabb = this._targets[i].aabb;
						min.min(targetAabb.getMin());
						max.max(targetAabb.getMax());
					}
					this._aabb = new BoundingBox();
					this._aabb.setMinMax(min, max);
				}
				return this._aabb;
			}
		}, {
			key: "morphPositions",
			get: function get() {
				return this._morphPositions;
			}
		}, {
			key: "morphNormals",
			get: function get() {
				return this._morphNormals;
			}
		}, {
			key: "targets",
			get: function get() {
				return this._targets;
			}
		}]);
	}(RefCountedObject);

	var MorphTarget = function () {
		function MorphTarget(options) {
			this.used = false;
			this.options = options;
			this._name = options.name;
			this._defaultWeight = options.defaultWeight || 0;
			this._aabb = options.aabb;
			this.deltaPositions = options.deltaPositions;
		}
		var _proto = MorphTarget.prototype;
		_proto.destroy = function destroy() {
			var _this$texturePosition, _this$textureNormals;
			(_this$texturePosition = this.texturePositions) == null || _this$texturePosition.destroy();
			this.texturePositions = null;
			(_this$textureNormals = this.textureNormals) == null || _this$textureNormals.destroy();
			this.textureNormals = null;
		};
		_proto.clone = function clone() {
			return new MorphTarget(this.options);
		};
		_proto._postInit = function _postInit() {
			if (!this.options.preserveData) {
				this.options = null;
			}
			this.used = true;
		};
		_proto._setTexture = function _setTexture(name, texture) {
			this[name] = texture;
		};
		return _createClass(MorphTarget, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "defaultWeight",
			get: function get() {
				return this._defaultWeight;
			}
		}, {
			key: "aabb",
			get: function get() {
				if (!this._aabb) {
					this._aabb = new BoundingBox();
					if (this.deltaPositions) {
						this._aabb.compute(this.deltaPositions);
					}
				}
				return this._aabb;
			}
		}, {
			key: "morphPositions",
			get: function get() {
				return !!this.texturePositions;
			}
		}, {
			key: "morphNormals",
			get: function get() {
				return !!this.textureNormals;
			}
		}]);
	}();

	var nonUniformScale;
	var uniformScale = 1;
	var particleTexChannels$1 = 4;
	var rotMat = new Mat4();
	var rotMatInv = new Mat4();
	var randomPosTformed = new Vec3();
	var randomPos = new Vec3();
	var rndFactor3Vec = new Vec3();
	var particlePosPrev = new Vec3();
	var velocityVec = new Vec3();
	var localVelocityVec = new Vec3();
	var velocityVec2 = new Vec3();
	var localVelocityVec2 = new Vec3();
	var radialVelocityVec = new Vec3();
	var particlePos = new Vec3();
	var particleFinalPos = new Vec3();
	var moveDirVec = new Vec3();
	var tmpVec3$1 = new Vec3();
	function frac(f) {
		return f - Math.floor(f);
	}
	function saturate$1(x) {
		return Math.max(Math.min(x, 1), 0);
	}
	function glMod(x, y) {
		return x - y * Math.floor(x / y);
	}
	function encodeFloatRGBA(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		var encZ = frac(65025.0 * v);
		var encW = frac(160581375.0 * v);
		encX -= encY / 255.0;
		encY -= encZ / 255.0;
		encZ -= encW / 255.0;
		encW -= encW / 255.0;
		return [encX, encY, encZ, encW];
	}
	function encodeFloatRG(v) {
		var encX = frac(v);
		var encY = frac(255.0 * v);
		encX -= encY / 255.0;
		encY -= encY / 255.0;
		return [encX, encY];
	}
	var ParticleCPUUpdater = function () {
		function ParticleCPUUpdater(emitter) {
			this._emitter = emitter;
		}
		var _proto = ParticleCPUUpdater.prototype;
		_proto.calcSpawnPosition = function calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
			var emitter = this._emitter;
			var rX = Math.random();
			var rY = Math.random();
			var rZ = Math.random();
			var rW = Math.random();
			if (emitter.useCpu) {
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
			}
			randomPos.x = rX - 0.5;
			randomPos.y = rY - 0.5;
			randomPos.z = rZ - 0.5;
			if (emitter.emitterShape === EMITTERSHAPE_BOX) {
				var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
				var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
				var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
				var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
				randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
				randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
				randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
				if (!emitter.localSpace) {
					randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));
				} else {
					randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
				}
			} else {
				randomPos.normalize();
				var spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
				var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
				if (!emitter.localSpace) {
					randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));
				} else {
					randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
				}
			}
			var particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
			var startSpawnTime = -particleRate * i;
			if (emitter.pack8) {
				var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
				var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
				var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
				var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
				packA = packA % (Math.PI * 2) / (Math.PI * 2);
				var rg0 = encodeFloatRG(packX);
				particleTex[i * particleTexChannels$1] = rg0[0];
				particleTex[i * particleTexChannels$1 + 1] = rg0[1];
				var ba0 = encodeFloatRG(packY);
				particleTex[i * particleTexChannels$1 + 2] = ba0[0];
				particleTex[i * particleTexChannels$1 + 3] = ba0[1];
				var rg1 = encodeFloatRG(packZ);
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
				var ba1 = encodeFloatRG(packA);
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
				var a2 = 1.0;
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
				var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
				var maxPosLife = emitter.lifetime + 1.0;
				startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
				var rgba3 = encodeFloatRGBA(startSpawnTime);
				particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
				particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
				particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
			} else {
				particleTex[i * particleTexChannels$1] = randomPosTformed.x;
				particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
				particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
				particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
				particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
			}
		};
		_proto.update = function update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
			var a, b, c;
			var emitter = this._emitter;
			if (emitter.meshInstance.node) {
				var fullMat = emitter.meshInstance.node.worldTransform;
				for (var j = 0; j < 12; j++) {
					rotMat.data[j] = fullMat.data[j];
				}
				rotMatInv.copy(rotMat);
				rotMatInv.invert();
				nonUniformScale = emitter.meshInstance.node.localScale;
				uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
			}
			emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
			var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
			var vertSize = !emitter.useMesh ? 15 : 17;
			var cf, cc;
			var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
			var precision1 = emitter.precision - 1;
			for (var i = 0; i < emitter.numParticles; i++) {
				var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
				var rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				rndFactor3Vec.x = rndFactor;
				rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
				var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
				var particleLifetime = emitter.lifetime;
				var life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
				var nlife = saturate$1(life / particleLifetime);
				var scale = 0;
				var alphaDiv = 0;
				var angle = 0;
				var respawn = life - delta <= 0.0 || life >= particleLifetime;
				if (respawn) {
					this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
				}
				var particleEnabled = life > 0.0 && life < particleLifetime;
				if (particleEnabled) {
					c = nlife * precision1;
					cf = Math.floor(c);
					cc = Math.ceil(c);
					c %= 1;
					a = emitter.qRotSpeed[cf];
					b = emitter.qRotSpeed[cc];
					rotSpeed = a + (b - a) * c;
					a = emitter.qRotSpeed2[cf];
					b = emitter.qRotSpeed2[cc];
					rotSpeed2 = a + (b - a) * c;
					a = emitter.qScale[cf];
					b = emitter.qScale[cc];
					scale = a + (b - a) * c;
					a = emitter.qScale2[cf];
					b = emitter.qScale2[cc];
					scale2 = a + (b - a) * c;
					a = emitter.qAlpha[cf];
					b = emitter.qAlpha[cc];
					alpha = a + (b - a) * c;
					a = emitter.qAlpha2[cf];
					b = emitter.qAlpha2[cc];
					alpha2 = a + (b - a) * c;
					a = emitter.qRadialSpeed[cf];
					b = emitter.qRadialSpeed[cc];
					radialSpeed = a + (b - a) * c;
					a = emitter.qRadialSpeed2[cf];
					b = emitter.qRadialSpeed2[cc];
					radialSpeed2 = a + (b - a) * c;
					radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
					particlePosPrev.x = particleTex[id * particleTexChannels$1];
					particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
					particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
					if (!emitter.localSpace) {
						radialVelocityVec.copy(particlePosPrev).sub(emitterPos);
					} else {
						radialVelocityVec.copy(particlePosPrev);
					}
					radialVelocityVec.normalize().mulScalar(radialSpeed);
					cf *= 3;
					cc *= 3;
					a = emitter.qLocalVelocity[cf];
					b = emitter.qLocalVelocity[cc];
					localVelocityVec.x = a + (b - a) * c;
					a = emitter.qLocalVelocity[cf + 1];
					b = emitter.qLocalVelocity[cc + 1];
					localVelocityVec.y = a + (b - a) * c;
					a = emitter.qLocalVelocity[cf + 2];
					b = emitter.qLocalVelocity[cc + 2];
					localVelocityVec.z = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf];
					b = emitter.qLocalVelocity2[cc];
					localVelocityVec2.x = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf + 1];
					b = emitter.qLocalVelocity2[cc + 1];
					localVelocityVec2.y = a + (b - a) * c;
					a = emitter.qLocalVelocity2[cf + 2];
					b = emitter.qLocalVelocity2[cc + 2];
					localVelocityVec2.z = a + (b - a) * c;
					a = emitter.qVelocity[cf];
					b = emitter.qVelocity[cc];
					velocityVec.x = a + (b - a) * c;
					a = emitter.qVelocity[cf + 1];
					b = emitter.qVelocity[cc + 1];
					velocityVec.y = a + (b - a) * c;
					a = emitter.qVelocity[cf + 2];
					b = emitter.qVelocity[cc + 2];
					velocityVec.z = a + (b - a) * c;
					a = emitter.qVelocity2[cf];
					b = emitter.qVelocity2[cc];
					velocityVec2.x = a + (b - a) * c;
					a = emitter.qVelocity2[cf + 1];
					b = emitter.qVelocity2[cc + 1];
					velocityVec2.y = a + (b - a) * c;
					a = emitter.qVelocity2[cf + 2];
					b = emitter.qVelocity2[cc + 2];
					velocityVec2.z = a + (b - a) * c;
					localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
					localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
					localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;
					if (emitter.initialVelocity > 0) {
						if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
							randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
							localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
						} else {
							localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
						}
					}
					velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
					velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
					velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
					rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
					scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
					alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);
					if (emitter.meshInstance.node) {
						if (!emitter.localSpace) {
							rotMat.transformPoint(localVelocityVec, localVelocityVec);
						} else {
							localVelocityVec.x /= nonUniformScale.x;
							localVelocityVec.y /= nonUniformScale.y;
							localVelocityVec.z /= nonUniformScale.z;
						}
					}
					if (!emitter.localSpace) {
						localVelocityVec.add(velocityVec.mul(nonUniformScale));
						localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
					} else {
						rotMatInv.transformPoint(velocityVec, velocityVec);
						localVelocityVec.add(velocityVec).add(radialVelocityVec);
					}
					moveDirVec.copy(localVelocityVec);
					particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
					particleFinalPos.copy(particlePos);
					particleTex[id * particleTexChannels$1] = particleFinalPos.x;
					particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
					particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
					particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;
					if (emitter.wrap && emitter.wrapBounds) {
						if (!emitter.localSpace) {
							particleFinalPos.sub(emitterPos);
						}
						particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
						particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
						particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
						if (!emitter.localSpace) {
							particleFinalPos.add(emitterPos);
						}
					}
					if (emitter.sort > 0) {
						if (emitter.sort === 1) {
							tmpVec3$1.copy(particleFinalPos).sub(posCam);
							emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
						} else if (emitter.sort === 2) {
							emitter.particleDistance[id] = life;
						} else if (emitter.sort === 3) {
							emitter.particleDistance[id] = -life;
						}
					}
				}
				if (isOnStop) {
					if (life < 0) {
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
					}
				} else {
					if (life >= particleLifetime) {
						life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
					}
					if (life < 0 && emitter.loop) {
						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
					}
				}
				if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) {
					particleEnabled = false;
				}
				particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;
				for (var v = 0; v < emitter.numParticleVerts; v++) {
					var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
					var quadX = emitter.vbCPU[vbOffset];
					var quadY = emitter.vbCPU[vbOffset + 1];
					var quadZ = emitter.vbCPU[vbOffset + 2];
					if (!particleEnabled) {
						quadX = quadY = quadZ = 0;
					}
					var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
					data[w] = particleFinalPos.x;
					data[w + 1] = particleFinalPos.y;
					data[w + 2] = particleFinalPos.z;
					data[w + 3] = nlife;
					data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
					data[w + 5] = scale;
					data[w + 6] = alphaDiv;
					data[w + 7] = moveDirVec.x;
					data[w + 8] = quadX;
					data[w + 9] = quadY;
					data[w + 10] = quadZ;
					data[w + 11] = moveDirVec.y;
					data[w + 12] = id;
					data[w + 13] = moveDirVec.z;
					data[w + 14] = emitter.vbCPU[vbOffset + 3];
					if (emitter.useMesh) {
						data[w + 15] = emitter.vbCPU[vbOffset + 4];
						data[w + 16] = emitter.vbCPU[vbOffset + 5];
					}
				}
			}
			if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
				var vbStride = emitter.useMesh ? 6 : 4;
				var particleDistance = emitter.particleDistance;
				for (var _i = 0; _i < emitter.numParticles; _i++) {
					vbToSort[_i][0] = _i;
					vbToSort[_i][1] = particleDistance[Math.floor(emitter.vbCPU[_i * emitter.numParticleVerts * vbStride + 3])];
				}
				emitter.vbOld.set(emitter.vbCPU);
				vbToSort.sort(function (p1, p2) {
					return p1[1] - p2[1];
				});
				for (var _i2 = 0; _i2 < emitter.numParticles; _i2++) {
					var src = vbToSort[_i2][0] * emitter.numParticleVerts * vbStride;
					var dest = _i2 * emitter.numParticleVerts * vbStride;
					for (var _j = 0; _j < emitter.numParticleVerts * vbStride; _j++) {
						emitter.vbCPU[dest + _j] = emitter.vbOld[src + _j];
					}
				}
			}
		};
		return ParticleCPUUpdater;
	}();

	var spawnMatrix3 = new Mat3();
	var emitterMatrix3 = new Mat3();
	var emitterMatrix3Inv = new Mat3();
	var ParticleGPUUpdater = function () {
		function ParticleGPUUpdater(emitter, gd) {
			this._emitter = emitter;
			this.frameRandomUniform = new Float32Array(3);
			this.emitterPosUniform = new Float32Array(3);
			this.emitterScaleUniform = new Float32Array([1, 1, 1]);
			this.worldBoundsMulUniform = new Float32Array(3);
			this.worldBoundsAddUniform = new Float32Array(3);
			this.inBoundsSizeUniform = new Float32Array(3);
			this.inBoundsCenterUniform = new Float32Array(3);
			this.constantParticleTexIN = gd.scope.resolve('particleTexIN');
			this.constantParticleTexOUT = gd.scope.resolve('particleTexOUT');
			this.constantEmitterPos = gd.scope.resolve('emitterPos');
			this.constantEmitterScale = gd.scope.resolve('emitterScale');
			this.constantSpawnBounds = gd.scope.resolve('spawnBounds');
			this.constantSpawnPosInnerRatio = gd.scope.resolve('spawnPosInnerRatio');
			this.constantSpawnBoundsSphere = gd.scope.resolve('spawnBoundsSphere');
			this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve('spawnBoundsSphereInnerRatio');
			this.constantInitialVelocity = gd.scope.resolve('initialVelocity');
			this.constantFrameRandom = gd.scope.resolve('frameRandom');
			this.constantDelta = gd.scope.resolve('delta');
			this.constantRate = gd.scope.resolve('rate');
			this.constantRateDiv = gd.scope.resolve('rateDiv');
			this.constantLifetime = gd.scope.resolve('lifetime');
			this.constantGraphSampleSize = gd.scope.resolve('graphSampleSize');
			this.constantGraphNumSamples = gd.scope.resolve('graphNumSamples');
			this.constantInternalTex0 = gd.scope.resolve('internalTex0');
			this.constantInternalTex1 = gd.scope.resolve('internalTex1');
			this.constantInternalTex2 = gd.scope.resolve('internalTex2');
			this.constantInternalTex3 = gd.scope.resolve('internalTex3');
			this.constantEmitterMatrix = gd.scope.resolve('emitterMatrix');
			this.constantEmitterMatrixInv = gd.scope.resolve('emitterMatrixInv');
			this.constantNumParticles = gd.scope.resolve('numParticles');
			this.constantNumParticlesPot = gd.scope.resolve('numParticlesPot');
			this.constantLocalVelocityDivMult = gd.scope.resolve('localVelocityDivMult');
			this.constantVelocityDivMult = gd.scope.resolve('velocityDivMult');
			this.constantRotSpeedDivMult = gd.scope.resolve('rotSpeedDivMult');
			this.constantSeed = gd.scope.resolve('seed');
			this.constantStartAngle = gd.scope.resolve('startAngle');
			this.constantStartAngle2 = gd.scope.resolve('startAngle2');
			this.constantOutBoundsMul = gd.scope.resolve('outBoundsMul');
			this.constantOutBoundsAdd = gd.scope.resolve('outBoundsAdd');
			this.constantInBoundsSize = gd.scope.resolve('inBoundsSize');
			this.constantInBoundsCenter = gd.scope.resolve('inBoundsCenter');
			this.constantMaxVel = gd.scope.resolve('maxVel');
			this.constantFaceTangent = gd.scope.resolve('faceTangent');
			this.constantFaceBinorm = gd.scope.resolve('faceBinorm');
		}
		var _proto = ParticleGPUUpdater.prototype;
		_proto._setInputBounds = function _setInputBounds() {
			this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
			this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
			this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
			this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
			this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
			this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
			this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
			this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
		};
		_proto.randomize = function randomize() {
			this.frameRandomUniform[0] = Math.random();
			this.frameRandomUniform[1] = Math.random();
			this.frameRandomUniform[2] = Math.random();
		};
		_proto.update = function update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
			var emitter = this._emitter;
			device.setBlendState(BlendState.NOBLEND);
			device.setDepthState(DepthState.NODEPTH);
			device.setCullMode(CULLFACE_NONE);
			this.randomize();
			this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
			this.constantGraphNumSamples.setValue(emitter.precision);
			this.constantNumParticles.setValue(emitter.numParticles);
			this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
			this.constantInternalTex0.setValue(emitter.internalTex0);
			this.constantInternalTex1.setValue(emitter.internalTex1);
			this.constantInternalTex2.setValue(emitter.internalTex2);
			this.constantInternalTex3.setValue(emitter.internalTex3);
			var node = emitter.meshInstance.node;
			var emitterScale = node === null ? Vec3.ONE : node.localScale;
			if (emitter.pack8) {
				this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
				this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
				this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
				this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
				this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
				this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
				this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
				this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
				this._setInputBounds();
				var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
				maxVel = Math.max(maxVel, 1);
				this.constantMaxVel.setValue(maxVel);
			}
			var emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
			var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();
			if (emitter.emitterShape === EMITTERSHAPE_BOX) {
				spawnMatrix3.setFromMat4(spawnMatrix);
				this.constantSpawnBounds.setValue(spawnMatrix3.data);
				this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
			} else {
				this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
				this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
			}
			this.constantInitialVelocity.setValue(emitter.initialVelocity);
			emitterMatrix3.setFromMat4(emitterMatrix);
			emitterMatrix3Inv.invertMat4(emitterMatrix);
			this.emitterPosUniform[0] = emitterPos.x;
			this.emitterPosUniform[1] = emitterPos.y;
			this.emitterPosUniform[2] = emitterPos.z;
			this.constantEmitterPos.setValue(this.emitterPosUniform);
			this.constantFrameRandom.setValue(this.frameRandomUniform);
			this.constantDelta.setValue(delta);
			this.constantRate.setValue(emitter.rate);
			this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
			this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
			this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
			this.constantSeed.setValue(emitter.seed);
			this.constantLifetime.setValue(emitter.lifetime);
			this.emitterScaleUniform[0] = emitterScale.x;
			this.emitterScaleUniform[1] = emitterScale.y;
			this.emitterScaleUniform[2] = emitterScale.z;
			this.constantEmitterScale.setValue(this.emitterScaleUniform);
			this.constantEmitterMatrix.setValue(emitterMatrix3.data);
			this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
			this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
			this.constantVelocityDivMult.setValue(emitter.velocityUMax);
			this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
			var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
			texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
			var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
			this.constantParticleTexIN.setValue(texIN);
			drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
			emitter.material.setParameter('particleTexOUT', texIN);
			emitter.material.setParameter('particleTexIN', texOUT);
			emitter.beenReset = false;
			emitter.swapTex = !emitter.swapTex;
			emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
			emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
			if (emitter.pack8) {
				this._setInputBounds();
			}
		};
		return ParticleGPUUpdater;
	}();

	var ShaderGeneratorParticle = function (_ShaderGenerator) {
		function ShaderGeneratorParticle() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		_inheritsLoose(ShaderGeneratorParticle, _ShaderGenerator);
		var _proto = ShaderGeneratorParticle.prototype;
		_proto.generateKey = function generateKey(options) {
			var definesHash = ShaderGenerator.definesHash(options.defines);
			var key = "particle_" + definesHash + "_";
			for (var prop in options) {
				if (options.hasOwnProperty(prop)) {
					key += options[prop];
				}
			}
			return key;
		};
		_proto._animTex = function _animTex(options) {
			var vshader = '';
			vshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;
			vshader += shaderChunks.particleAnimTexVS;
			return vshader;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var executionDefine = "#define PARTICLE_" + (options.useCpu ? 'CPU' : 'GPU') + "\n";
			var fshader = "#define PARTICLE\n" + executionDefine;
			var vshader = "#define VERTEXSHADER\n" + executionDefine;
			if (options.mesh) vshader += '#define USE_MESH\n';
			if (options.localSpace) vshader += '#define LOCAL_SPACE\n';
			if (options.screenSpace) vshader += '#define SCREEN_SPACE\n';
			if (options.animTex) vshader += '\nuniform vec2 animTexTilesParams;\n';
			if (options.animTex) vshader += '\nuniform vec4 animTexParams;\n';
			if (options.animTex) vshader += '\nuniform vec2 animTexIndexParams;\n';
			if (options.normal === 2) vshader += '\nvarying mat3 ParticleMat;\n';
			if (options.normal === 1) vshader += '\nvarying vec3 Normal;\n';
			if (options.soft) vshader += '\nvarying float vDepth;\n';
			var faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;
			if (!options.useCpu) {
				vshader += shaderChunks.particle_initVS;
				vshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particleVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.wrap) vshader += shaderChunks.particle_wrapVS;
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			} else {
				if (options.soft > 0) vshader += shaderChunks.screenDepthPS;
				vshader += shaderChunks.particle_cpuVS;
				if (options.localSpace) vshader += shaderChunks.particle_localShiftVS;
				if (options.animTex) vshader += this._animTex(options);
				if (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;
				vshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;
				if (options.normal === 1) vshader += shaderChunks.particle_normalVS;
				if (options.normal === 2) vshader += shaderChunks.particle_TBNVS;
				if (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;
				vshader += shaderChunks.particle_cpu_endVS;
				if (options.soft > 0) vshader += shaderChunks.particle_softVS;
			}
			vshader += '}\n';
			if (options.normal > 0) {
				if (options.normal === 1) {
					fshader += '\nvarying vec3 Normal;\n';
				} else if (options.normal === 2) {
					fshader += '\nvarying mat3 ParticleMat;\n';
				}
				fshader += '\nuniform vec3 lightCube[6];\n';
			}
			if (options.soft) fshader += '\nvarying float vDepth;\n';
			fshader += shaderChunks.decodePS;
			fshader += ShaderGenerator.gammaCode(options.gamma);
			fshader += '#include "tonemappingPS"\n';
			fshader += ShaderGenerator.fogCode(options.fog);
			if (options.normal === 2) fshader += '\nuniform sampler2D normalMap;\n';
			if (options.soft > 0) fshader += shaderChunks.screenDepthPS;
			fshader += shaderChunks.particlePS;
			if (options.soft > 0) fshader += shaderChunks.particle_softPS;
			if (options.normal === 1) fshader += '\nvec3 normal = Normal;\n';
			if (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;
			if (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;
			if (options.normal > 0) fshader += shaderChunks.particle_lightingPS;
			if (options.blend === BLEND_NORMAL) {
				fshader += shaderChunks.particle_blendNormalPS;
			} else if (options.blend === BLEND_ADDITIVE) {
				fshader += shaderChunks.particle_blendAddPS;
			} else if (options.blend === BLEND_MULTIPLICATIVE) {
				fshader += shaderChunks.particle_blendMultiplyPS;
			}
			fshader += shaderChunks.particle_endPS;
			var includes = new Map(Object.entries(_extends({}, shaderChunks, options.chunks)));
			var fragmentDefines = new Map(options.defines);
			fragmentDefines.set('TONEMAP', tonemapNames[options.toneMap]);
			return ShaderUtils.createDefinition(device, {
				name: 'ParticleShader',
				vertexCode: vshader,
				fragmentCode: fshader,
				fragmentDefines: fragmentDefines,
				fragmentIncludes: includes,
				vertexDefines: options.defines
			});
		};
		return ShaderGeneratorParticle;
	}(ShaderGenerator);
	var particle = new ShaderGeneratorParticle();

	var ParticleMaterial = function (_Material) {
		function ParticleMaterial(emitter) {
			var _this;
			_this = _Material.call(this) || this;
			_this.emitter = null;
			_this.emitter = emitter;
			return _this;
		}
		_inheritsLoose(ParticleMaterial, _Material);
		var _proto = ParticleMaterial.prototype;
		_proto.getShaderVariant = function getShaderVariant(params) {
			var _cameraShaderParams$s, _cameraShaderParams$t;
			var device = params.device,
				scene = params.scene,
				cameraShaderParams = params.cameraShaderParams;
			var emitter = this.emitter;
			var options = {
				defines: getMaterialShaderDefines(this, cameraShaderParams),
				pass: SHADER_FORWARD,
				useCpu: this.emitter.useCpu,
				normal: emitter.lighting ? emitter.normalMap !== null ? 2 : 1 : 0,
				halflambert: this.emitter.halfLambert,
				stretch: this.emitter.stretch,
				alignToMotion: this.emitter.alignToMotion,
				soft: this.emitter.depthSoftening,
				mesh: this.emitter.useMesh,
				gamma: (_cameraShaderParams$s = cameraShaderParams == null ? void 0 : cameraShaderParams.shaderOutputGamma) != null ? _cameraShaderParams$s : GAMMA_NONE,
				toneMap: (_cameraShaderParams$t = cameraShaderParams == null ? void 0 : cameraShaderParams.toneMapping) != null ? _cameraShaderParams$t : TONEMAP_LINEAR,
				fog: scene && !this.emitter.noFog ? scene.fog.type : 'none',
				wrap: this.emitter.wrap && this.emitter.wrapBounds,
				localSpace: this.emitter.localSpace,
				screenSpace: emitter.inTools ? false : this.emitter.screenSpace,
				blend: this.blendType,
				animTex: this.emitter._isAnimated(),
				animTexLoop: this.emitter.animLoop,
				pack8: this.emitter.pack8,
				customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
			};
			var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
			var library = getProgramLibrary(device);
			library.register('particle', particle);
			return library.getProgram('particle', options, processingOptions, this.userId);
		};
		return ParticleMaterial;
	}(Material);

	var particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
	function _createTexture(device, width, height, pixelData, format, mult8Bit, filter) {
		if (format === void 0) {
			format = PIXELFORMAT_RGBA32F;
		}
		var mipFilter = FILTER_NEAREST;
		if (filter && (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8)) {
			mipFilter = FILTER_LINEAR;
		}
		var texture = new Texture(device, {
			width: width,
			height: height,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: mipFilter,
			magFilter: mipFilter,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE,
			name: 'ParticleSystemTexture'
		});
		var pixels = texture.lock();
		if (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8) {
			var temp = new Uint8Array(pixelData.length);
			for (var i = 0; i < pixelData.length; i++) {
				temp[i] = pixelData[i] * mult8Bit * 255;
			}
			pixelData = temp;
		}
		pixels.set(pixelData);
		texture.unlock();
		return texture;
	}
	function saturate(x) {
		return Math.max(Math.min(x, 1), 0);
	}
	var default0Curve = new Curve([0, 0, 1, 0]);
	var default1Curve = new Curve([0, 1, 1, 1]);
	var default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
	var default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
	var particleTexHeight = 2;
	var particleTexChannels = 4;
	var extentsInnerRatioUniform = new Float32Array(3);
	var spawnMatrix = new Mat4();
	var tmpVec3 = new Vec3();
	var bMin = new Vec3();
	var bMax = new Vec3();
	var setPropertyTarget;
	var setPropertyOptions;
	function setProperty(pName, defaultVal) {
		if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
			setPropertyTarget[pName] = setPropertyOptions[pName];
		} else {
			setPropertyTarget[pName] = defaultVal;
		}
	}
	function pack3NFloats(a, b, c) {
		var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
		return packed / (1 << 24);
	}
	function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
		var num = qXYZ.length / 3;
		var colors = new Array(num * 4);
		for (var i = 0; i < num; i++) {
			colors[i * 4] = qXYZ[i * 3];
			colors[i * 4 + 1] = qXYZ[i * 3 + 1];
			colors[i * 4 + 2] = qXYZ[i * 3 + 2];
			colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
		}
		return colors;
	}
	function packTextureRGBA(qRGB, qA) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qRGB[i * 3];
			colors[i * 4 + 1] = qRGB[i * 3 + 1];
			colors[i * 4 + 2] = qRGB[i * 3 + 2];
			colors[i * 4 + 3] = qA[i];
		}
		return colors;
	}
	function packTexture5Floats(qA, qB, qC, qD, qE) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
		}
		return colors;
	}
	function packTexture2Floats(qA, qB) {
		var colors = new Array(qA.length * 4);
		for (var i = 0; i < qA.length; i++) {
			colors[i * 4] = qA[i];
			colors[i * 4 + 1] = qB[i];
			colors[i * 4 + 2] = 0;
			colors[i * 4 + 3] = 0;
		}
		return colors;
	}
	function calcEndTime(emitter) {
		var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
		return Date.now() + interval * 1000;
	}
	function subGraph(A, B) {
		var r = new Float32Array(A.length);
		for (var i = 0; i < A.length; i++) {
			r[i] = A[i] - B[i];
		}
		return r;
	}
	function maxUnsignedGraphValue(A, outUMax) {
		var chans = outUMax.length;
		var values = A.length / chans;
		for (var i = 0; i < values; i++) {
			for (var j = 0; j < chans; j++) {
				var a = Math.abs(A[i * chans + j]);
				outUMax[j] = Math.max(outUMax[j], a);
			}
		}
	}
	function normalizeGraph(A, uMax) {
		var chans = uMax.length;
		var values = A.length / chans;
		for (var i = 0; i < values; i++) {
			for (var j = 0; j < chans; j++) {
				A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
				A[i * chans + j] *= 0.5;
				A[i * chans + j] += 0.5;
			}
		}
	}
	function divGraphFrom2Curves(curve1, curve2, outUMax) {
		var sub = subGraph(curve2, curve1);
		maxUnsignedGraphValue(sub, outUMax);
		normalizeGraph(sub, outUMax);
		return sub;
	}
	var particleEmitterDeviceCache = new DeviceCache();
	var ParticleEmitter = function () {
		function ParticleEmitter(graphicsDevice, options) {
			this.material = null;
			this.internalTex0 = null;
			this.internalTex1 = null;
			this.internalTex2 = null;
			this.colorParam = null;
			this.graphicsDevice = graphicsDevice;
			var gd = graphicsDevice;
			var precision = 32;
			this.precision = precision;
			this._addTimeTime = 0;
			setPropertyTarget = this;
			setPropertyOptions = options;
			setProperty('numParticles', 1);
			if (this.numParticles > graphicsDevice.maxTextureSize) {
				this.numParticles = graphicsDevice.maxTextureSize;
			}
			setProperty('rate', 1);
			setProperty('rate2', this.rate);
			setProperty('lifetime', 50);
			setProperty('emitterExtents', new Vec3(0, 0, 0));
			setProperty('emitterExtentsInner', new Vec3(0, 0, 0));
			setProperty('emitterRadius', 0);
			setProperty('emitterRadiusInner', 0);
			setProperty('emitterShape', EMITTERSHAPE_BOX);
			setProperty('initialVelocity', 1);
			setProperty('wrap', false);
			setProperty('localSpace', false);
			setProperty('screenSpace', false);
			setProperty('wrapBounds', null);
			setProperty('colorMap', this.defaultParamTexture);
			setProperty('normalMap', null);
			setProperty('loop', true);
			setProperty('preWarm', false);
			setProperty('sort', PARTICLESORT_NONE);
			setProperty('mode', PARTICLEMODE_GPU);
			setProperty('scene', null);
			setProperty('lighting', false);
			setProperty('halfLambert', false);
			setProperty('intensity', 1.0);
			setProperty('stretch', 0.0);
			setProperty('alignToMotion', false);
			setProperty('depthSoftening', 0);
			setProperty('mesh', null);
			setProperty('particleNormal', new Vec3(0, 1, 0));
			setProperty('orientation', PARTICLEORIENTATION_SCREEN);
			setProperty('depthWrite', false);
			setProperty('noFog', false);
			setProperty('blendType', BLEND_NORMAL);
			setProperty('node', null);
			setProperty('startAngle', 0);
			setProperty('startAngle2', this.startAngle);
			setProperty('animTilesX', 1);
			setProperty('animTilesY', 1);
			setProperty('animStartFrame', 0);
			setProperty('animNumFrames', 1);
			setProperty('animNumAnimations', 1);
			setProperty('animIndex', 0);
			setProperty('randomizeAnimIndex', false);
			setProperty('animSpeed', 1);
			setProperty('animLoop', true);
			this._gpuUpdater = new ParticleGPUUpdater(this, gd);
			this._cpuUpdater = new ParticleCPUUpdater(this);
			this.emitterPosUniform = new Float32Array(3);
			this.wrapBoundsUniform = new Float32Array(3);
			this.emitterScaleUniform = new Float32Array([1, 1, 1]);
			setProperty('colorGraph', default1Curve3);
			setProperty('colorGraph2', this.colorGraph);
			setProperty('scaleGraph', default1Curve);
			setProperty('scaleGraph2', this.scaleGraph);
			setProperty('alphaGraph', default1Curve);
			setProperty('alphaGraph2', this.alphaGraph);
			setProperty('localVelocityGraph', default0Curve3);
			setProperty('localVelocityGraph2', this.localVelocityGraph);
			setProperty('velocityGraph', default0Curve3);
			setProperty('velocityGraph2', this.velocityGraph);
			setProperty('rotationSpeedGraph', default0Curve);
			setProperty('rotationSpeedGraph2', this.rotationSpeedGraph);
			setProperty('radialSpeedGraph', default0Curve);
			setProperty('radialSpeedGraph2', this.radialSpeedGraph);
			this.animTilesParams = new Float32Array(2);
			this.animParams = new Float32Array(4);
			this.animIndexParams = new Float32Array(2);
			this.vbToSort = null;
			this.vbOld = null;
			this.particleDistance = null;
			this.camera = null;
			this.swapTex = false;
			this.useMesh = true;
			this.useCpu = !graphicsDevice.supportsGpuParticles;
			this.pack8 = true;
			this.localBounds = new BoundingBox();
			this.worldBoundsNoTrail = new BoundingBox();
			this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
			this.worldBounds = new BoundingBox();
			this.worldBoundsSize = new Vec3();
			this.prevWorldBoundsSize = new Vec3();
			this.prevWorldBoundsCenter = new Vec3();
			this.prevEmitterExtents = this.emitterExtents;
			this.prevEmitterRadius = this.emitterRadius;
			this.worldBoundsMul = new Vec3();
			this.worldBoundsAdd = new Vec3();
			this.timeToSwitchBounds = 0;
			this.shaderParticleUpdateRespawn = null;
			this.shaderParticleUpdateNoRespawn = null;
			this.shaderParticleUpdateOnStop = null;
			this.numParticleVerts = 0;
			this.numParticleIndices = 0;
			this.material = null;
			this.meshInstance = null;
			this.drawOrder = 0;
			this.seed = Math.random();
			this.fixedTimeStep = 1.0 / 60;
			this.maxSubSteps = 10;
			this.simTime = 0;
			this.simTimeTotal = 0;
			this.beenReset = false;
			this._layer = null;
			this.rebuild();
		}
		var _proto = ParticleEmitter.prototype;
		_proto.onChangeCamera = function onChangeCamera() {
			this.resetMaterial();
		};
		_proto.calculateBoundsMad = function calculateBoundsMad() {
			this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
			this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
			this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
			this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
			this.worldBoundsAdd.x += 0.5;
			this.worldBoundsAdd.y += 0.5;
			this.worldBoundsAdd.z += 0.5;
		};
		_proto.calculateWorldBounds = function calculateWorldBounds() {
			if (!this.node) return;
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			if (!this.useCpu) {
				var recalculateLocalBounds = false;
				if (this.emitterShape === EMITTERSHAPE_BOX) {
					recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
				} else {
					recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
				}
				if (recalculateLocalBounds) {
					this.calculateLocalBounds();
				}
			}
			var nodeWT = this.node.getWorldTransform();
			if (this.localSpace) {
				this.worldBoundsNoTrail.copy(this.localBounds);
			} else {
				this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
			}
			this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
			var now = this.simTimeTotal;
			if (now >= this.timeToSwitchBounds) {
				this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
				this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
				this.timeToSwitchBounds = now + this.lifetime;
			}
			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
				this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
				this.meshInstance.mesh.aabb.copy(this.worldBounds);
			}
			this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
			if (this.pack8) this.calculateBoundsMad();
		};
		_proto.resetWorldBounds = function resetWorldBounds() {
			if (!this.node) return;
			this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
			this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
			this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
			this.worldBounds.copy(this.worldBoundsTrail[0]);
			this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
			this.prevWorldBoundsSize.copy(this.worldBoundsSize);
			this.prevWorldBoundsCenter.copy(this.worldBounds.center);
			this.simTimeTotal = 0;
			this.timeToSwitchBounds = 0;
		};
		_proto.calculateLocalBounds = function calculateLocalBounds() {
			var minx = Number.MAX_VALUE;
			var miny = Number.MAX_VALUE;
			var minz = Number.MAX_VALUE;
			var maxx = -Number.MAX_VALUE;
			var maxy = -Number.MAX_VALUE;
			var maxz = -Number.MAX_VALUE;
			var maxR = 0;
			var maxScale = 0;
			var stepWeight = this.lifetime / this.precision;
			var wVels = [this.qVelocity, this.qVelocity2];
			var lVels = [this.qLocalVelocity, this.qLocalVelocity2];
			var accumX = [0, 0];
			var accumY = [0, 0];
			var accumZ = [0, 0];
			var accumR = [0, 0];
			var accumW = [0, 0];
			var x, y, z;
			for (var i = 0; i < this.precision + 1; i++) {
				var index = Math.min(i, this.precision - 1);
				for (var j = 0; j < 2; j++) {
					x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
					y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
					z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
					minx = Math.min(x, minx);
					miny = Math.min(y, miny);
					minz = Math.min(z, minz);
					maxx = Math.max(x, maxx);
					maxy = Math.max(y, maxy);
					maxz = Math.max(z, maxz);
					accumX[j] = x;
					accumY[j] = y;
					accumZ[j] = z;
				}
				for (var _j = 0; _j < 2; _j++) {
					accumW[_j] += stepWeight * Math.sqrt(wVels[_j][index * 3 + 0] * wVels[_j][index * 3 + 0] + wVels[_j][index * 3 + 1] * wVels[_j][index * 3 + 1] + wVels[_j][index * 3 + 2] * wVels[_j][index * 3 + 2]);
				}
				accumR[0] += this.qRadialSpeed[index] * stepWeight;
				accumR[1] += this.qRadialSpeed2[index] * stepWeight;
				maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
				maxScale = Math.max(maxScale, this.qScale[index]);
			}
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				x = this.emitterExtents.x * 0.5;
				y = this.emitterExtents.y * 0.5;
				z = this.emitterExtents.z * 0.5;
			} else {
				x = this.emitterRadius;
				y = this.emitterRadius;
				z = this.emitterRadius;
			}
			var w = Math.max(accumW[0], accumW[1]);
			bMin.x = minx - maxScale - x - maxR - w;
			bMin.y = miny - maxScale - y - maxR - w;
			bMin.z = minz - maxScale - z - maxR - w;
			bMax.x = maxx + maxScale + x + maxR + w;
			bMax.y = maxy + maxScale + y + maxR + w;
			bMax.z = maxz + maxScale + z + maxR + w;
			this.localBounds.setMinMax(bMin, bMax);
		};
		_proto.rebuild = function rebuild() {
			var gd = this.graphicsDevice;
			if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
			this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
			this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles;
			this._destroyResources();
			this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
			particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
			this.useMesh = !!this.mesh;
			this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
			this.rebuildGraphs();
			this.calculateLocalBounds();
			this.resetWorldBounds();
			if (this.node) {
				this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
				this.worldBoundsTrail[0].copy(this.worldBounds);
				this.worldBoundsTrail[1].copy(this.worldBounds);
				this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
				if (this.pack8) this.calculateBoundsMad();
			}
			this.vbToSort = new Array(this.numParticles);
			for (var iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];
			this.particleDistance = new Float32Array(this.numParticles);
			this._gpuUpdater.randomize();
			this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
			var emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				if (this.node === null || this.localSpace) {
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
				}
				extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
			}
			for (var i = 0; i < this.numParticles; i++) {
				this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);
				if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
			}
			this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
			for (var _i = 0; _i < this.particleTexStart.length; _i++) {
				this.particleTexStart[_i] = this.particleTex[_i];
			}
			if (!this.useCpu) {
				if (this.pack8) {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_RGBA8, 1, false);
				} else {
					this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
					this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
				}
				this.rtParticleTexIN = new RenderTarget({
					colorBuffer: this.particleTexIN,
					depth: false
				});
				this.rtParticleTexOUT = new RenderTarget({
					colorBuffer: this.particleTexOUT,
					depth: false
				});
				this.swapTex = false;
			}
			var shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;
			var shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;
			var shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;
			var params = "Shape:" + this.emitterShape + "-Pack:" + this.pack8 + "-Local:" + this.localSpace;
			this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, "ParticleUpdateRespawn-" + params);
			this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, "ParticleUpdateNoRespawn-" + params);
			this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, "ParticleUpdateStop-" + params);
			this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
			this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
			this._allocate(this.numParticles);
			var mesh = new Mesh(gd);
			mesh.vertexBuffer = this.vertexBuffer;
			mesh.indexBuffer[0] = this.indexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
			mesh.primitive[0].indexed = true;
			this.material = this._createMaterial();
			this.resetMaterial();
			var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
			this.meshInstance = new MeshInstance(mesh, this.material, this.node);
			this.meshInstance.pick = false;
			this.meshInstance.updateKey();
			this.meshInstance.cull = true;
			if (this.localSpace) {
				this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
			} else {
				this.meshInstance.aabb.copy(this.worldBounds);
			}
			this.meshInstance._updateAabb = false;
			this.meshInstance.visible = wasVisible;
			this._setMaterialTextures();
			this.resetTime();
			this.addTime(0, false);
			if (this.preWarm) this.prewarm(this.lifetime);
		};
		_proto._isAnimated = function _isAnimated() {
			return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
		};
		_proto.rebuildGraphs = function rebuildGraphs() {
			var precision = this.precision;
			var gd = this.graphicsDevice;
			this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
			this.qVelocity = this.velocityGraph.quantize(precision);
			this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
			this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
			this.qScale = this.scaleGraph.quantize(precision);
			this.qAlpha = this.alphaGraph.quantize(precision);
			this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
			this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
			this.qVelocity2 = this.velocityGraph2.quantize(precision);
			this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
			this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
			this.qScale2 = this.scaleGraph2.quantize(precision);
			this.qAlpha2 = this.alphaGraph2.quantize(precision);
			this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);
			for (var i = 0; i < precision; i++) {
				this.qRotSpeed[i] *= math.DEG_TO_RAD;
				this.qRotSpeed2[i] *= math.DEG_TO_RAD;
			}
			this.localVelocityUMax = new Float32Array(3);
			this.velocityUMax = new Float32Array(3);
			this.colorUMax = new Float32Array(3);
			this.rotSpeedUMax = [0];
			this.scaleUMax = [0];
			this.alphaUMax = [0];
			this.radialSpeedUMax = [0];
			this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
			this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
			this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
			this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
			this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
			this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
			this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
			if (this.pack8) {
				var umax = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity, umax);
				var umax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qVelocity2, umax2);
				var lumax = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity, lumax);
				var lumax2 = [0, 0, 0];
				maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
				var rumax = [0];
				maxUnsignedGraphValue(this.qRadialSpeed, rumax);
				var rumax2 = [0];
				maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
				var maxVel = Math.max(umax[0], umax2[0]);
				maxVel = Math.max(maxVel, umax[1]);
				maxVel = Math.max(maxVel, umax2[1]);
				maxVel = Math.max(maxVel, umax[2]);
				maxVel = Math.max(maxVel, umax2[2]);
				var lmaxVel = Math.max(lumax[0], lumax2[0]);
				lmaxVel = Math.max(lmaxVel, lumax[1]);
				lmaxVel = Math.max(lmaxVel, lumax2[1]);
				lmaxVel = Math.max(lmaxVel, lumax[2]);
				lmaxVel = Math.max(lmaxVel, lumax2[2]);
				var maxRad = Math.max(rumax[0], rumax2[0]);
				this.maxVel = maxVel + lmaxVel + maxRad;
			}
			if (!this.useCpu) {
				this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
				this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
				this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
				this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
			}
			this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_SRGBA8, 1.0, true);
		};
		_proto._setMaterialTextures = function _setMaterialTextures() {
			if (this.colorMap) {
				this.material.setParameter('colorMap', this.colorMap);
				if (this.lighting && this.normalMap) {
					this.material.setParameter('normalMap', this.normalMap);
				}
			}
		};
		_proto._createMaterial = function _createMaterial() {
			var material = new ParticleMaterial(this);
			material.name = "EmitterMaterial:" + this.node.name;
			material.cull = CULLFACE_NONE;
			material.alphaWrite = false;
			material.blendType = this.blendType;
			material.depthWrite = this.depthWrite;
			return material;
		};
		_proto.resetMaterial = function resetMaterial() {
			var material = this.material;
			material.setParameter('stretch', this.stretch);
			if (this._isAnimated()) {
				material.setParameter('animTexTilesParams', this.animTilesParams);
				material.setParameter('animTexParams', this.animParams);
				material.setParameter('animTexIndexParams', this.animIndexParams);
			}
			material.setParameter('colorMult', this.intensity);
			if (!this.useCpu) {
				material.setParameter('internalTex0', this.internalTex0);
				material.setParameter('internalTex1', this.internalTex1);
				material.setParameter('internalTex2', this.internalTex2);
				material.setParameter('internalTex3', this.internalTex3);
			}
			material.setParameter('colorParam', this.colorParam);
			material.setParameter('numParticles', this.numParticles);
			material.setParameter('numParticlesPot', this.numParticlesPot);
			material.setParameter('lifetime', this.lifetime);
			material.setParameter('rate', this.rate);
			material.setParameter('rateDiv', this.rate2 - this.rate);
			material.setParameter('seed', this.seed);
			material.setParameter('scaleDivMult', this.scaleUMax[0]);
			material.setParameter('alphaDivMult', this.alphaUMax[0]);
			material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
			material.setParameter('graphNumSamples', this.precision);
			material.setParameter('graphSampleSize', 1.0 / this.precision);
			material.setParameter('emitterScale', new Float32Array([1, 1, 1]));
			if (this.pack8) {
				this._gpuUpdater._setInputBounds();
				material.setParameter('inBoundsSize', this._gpuUpdater.inBoundsSizeUniform);
				material.setParameter('inBoundsCenter', this._gpuUpdater.inBoundsCenterUniform);
				material.setParameter('maxVel', this.maxVel);
			}
			if (this.wrap && this.wrapBounds) {
				this.wrapBoundsUniform[0] = this.wrapBounds.x;
				this.wrapBoundsUniform[1] = this.wrapBounds.y;
				this.wrapBoundsUniform[2] = this.wrapBounds.z;
				material.setParameter('wrapBounds', this.wrapBoundsUniform);
			}
			this._setMaterialTextures();
			if (this.depthSoftening > 0) {
				material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
			}
			if (this.stretch > 0.0) material.cull = CULLFACE_NONE;
			this._compParticleFaceParams();
		};
		_proto._compParticleFaceParams = function _compParticleFaceParams() {
			var tangent, binormal;
			if (this.orientation === PARTICLEORIENTATION_SCREEN) {
				tangent = new Float32Array([1, 0, 0]);
				binormal = new Float32Array([0, 0, 1]);
			} else {
				var n;
				if (this.orientation === PARTICLEORIENTATION_WORLD) {
					n = this.particleNormal.normalize();
				} else {
					var emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
					n = emitterMat.transformVector(this.particleNormal).normalize();
				}
				var t = new Vec3(1, 0, 0);
				if (Math.abs(t.dot(n)) === 1) {
					t.set(0, 0, 1);
				}
				var b = new Vec3().cross(n, t).normalize();
				t.cross(b, n).normalize();
				tangent = new Float32Array([t.x, t.y, t.z]);
				binormal = new Float32Array([b.x, b.y, b.z]);
			}
			this.material.setParameter('faceTangent', tangent);
			this.material.setParameter('faceBinorm', binormal);
		};
		_proto._allocate = function _allocate(numParticles) {
			var psysVertCount = numParticles * this.numParticleVerts;
			var psysIndexCount = numParticles * this.numParticleIndices;
			if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
				var elements = [];
				if (!this.useCpu) {
					elements.push({
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					});
					if (this.useMesh) {
						elements.push({
							semantic: SEMANTIC_ATTR1,
							components: 2,
							type: TYPE_FLOAT32
						});
					}
				} else {
					elements.push({
						semantic: SEMANTIC_ATTR0,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR1,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR2,
						components: 4,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR3,
						components: 1,
						type: TYPE_FLOAT32
					}, {
						semantic: SEMANTIC_ATTR4,
						components: this.useMesh ? 4 : 2,
						type: TYPE_FLOAT32
					});
				}
				var vertexFormat = new VertexFormat(this.graphicsDevice, elements);
				this.vertexBuffer = new VertexBuffer(this.graphicsDevice, vertexFormat, psysVertCount, {
					usage: BUFFER_DYNAMIC
				});
				this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT32, psysIndexCount);
				var data = new Float32Array(this.vertexBuffer.lock());
				var meshData, stride, texCoordOffset;
				if (this.useMesh) {
					meshData = new Float32Array(this.mesh.vertexBuffer.lock());
					stride = meshData.length / this.mesh.vertexBuffer.numVertices;
					for (var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
						if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
							texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
							break;
						}
					}
				}
				for (var i = 0; i < psysVertCount; i++) {
					var id = Math.floor(i / this.numParticleVerts);
					if (!this.useMesh) {
						var vertID = i % 4;
						data[i * 4] = particleVerts[vertID][0];
						data[i * 4 + 1] = particleVerts[vertID][1];
						data[i * 4 + 2] = 0;
						data[i * 4 + 3] = id;
					} else {
						var vert = i % this.numParticleVerts;
						data[i * 6] = meshData[vert * stride];
						data[i * 6 + 1] = meshData[vert * stride + 1];
						data[i * 6 + 2] = meshData[vert * stride + 2];
						data[i * 6 + 3] = id;
						data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
						data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
					}
				}
				if (this.useCpu) {
					this.vbCPU = new Float32Array(data);
					this.vbOld = new Float32Array(this.vbCPU.length);
				}
				this.vertexBuffer.unlock();
				if (this.useMesh) {
					this.mesh.vertexBuffer.unlock();
				}
				var dst = 0;
				var indices = new Uint32Array(this.indexBuffer.lock());
				if (this.useMesh) {
					var ib = this.mesh.indexBuffer[0];
					meshData = new typedArrayIndexFormats[ib.format](ib.lock());
				}
				for (var _i2 = 0; _i2 < numParticles; _i2++) {
					if (!this.useMesh) {
						var baseIndex = _i2 * 4;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 1;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex;
						indices[dst++] = baseIndex + 2;
						indices[dst++] = baseIndex + 3;
					} else {
						for (var j = 0; j < this.numParticleIndices; j++) {
							indices[_i2 * this.numParticleIndices + j] = meshData[j] + _i2 * this.numParticleVerts;
						}
					}
				}
				this.indexBuffer.unlock();
				if (this.useMesh) this.mesh.indexBuffer[0].unlock();
			}
		};
		_proto.reset = function reset() {
			this.beenReset = true;
			this.seed = Math.random();
			this.material.setParameter('seed', this.seed);
			if (this.useCpu) {
				for (var i = 0; i < this.particleTexStart.length; i++) {
					this.particleTex[i] = this.particleTexStart[i];
				}
			} else {
				this._setMaterialTextures();
			}
			this.resetWorldBounds();
			this.resetTime();
			var origLoop = this.loop;
			this.loop = true;
			this.addTime(0, false);
			this.loop = origLoop;
			if (this.preWarm) {
				this.prewarm(this.lifetime);
			}
		};
		_proto.prewarm = function prewarm(time) {
			var lifetimeFraction = time / this.lifetime;
			var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
			var stepDelta = time / iterations;
			for (var i = 0; i < iterations; i++) {
				this.addTime(stepDelta, false);
			}
		};
		_proto.resetTime = function resetTime() {
			this.endTime = calcEndTime(this);
		};
		_proto.finishFrame = function finishFrame() {
			if (this.useCpu) this.vertexBuffer.unlock();
		};
		_proto.addTime = function addTime(delta, isOnStop) {
			var device = this.graphicsDevice;
			this.simTimeTotal += delta;
			this.calculateWorldBounds();
			if (this._isAnimated()) {
				var tilesParams = this.animTilesParams;
				tilesParams[0] = 1.0 / this.animTilesX;
				tilesParams[1] = 1.0 / this.animTilesY;
				var params = this.animParams;
				params[0] = this.animStartFrame;
				params[1] = this.animNumFrames * this.animSpeed;
				params[2] = this.animNumFrames - 1;
				params[3] = this.animNumAnimations - 1;
				var animIndexParams = this.animIndexParams;
				animIndexParams[0] = this.animIndex;
				animIndexParams[1] = this.randomizeAnimIndex;
			}
			if (this.scene) {
				if (this.camera !== this.scene._activeCamera) {
					this.camera = this.scene._activeCamera;
					this.onChangeCamera();
				}
			}
			if (this.emitterShape === EMITTERSHAPE_BOX) {
				extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
				extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
				extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
				if (this.meshInstance.node === null) {
					spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
				} else {
					spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
				}
			}
			var emitterPos;
			var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
			this.emitterScaleUniform[0] = emitterScale.x;
			this.emitterScaleUniform[1] = emitterScale.y;
			this.emitterScaleUniform[2] = emitterScale.z;
			this.material.setParameter('emitterScale', this.emitterScaleUniform);
			if (this.localSpace && this.meshInstance.node) {
				emitterPos = this.meshInstance.node.getPosition();
				this.emitterPosUniform[0] = emitterPos.x;
				this.emitterPosUniform[1] = emitterPos.y;
				this.emitterPosUniform[2] = emitterPos.z;
				this.material.setParameter('emitterPos', this.emitterPosUniform);
			}
			this._compParticleFaceParams();
			if (!this.useCpu) {
				this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
			} else {
				var data = new Float32Array(this.vertexBuffer.lock());
				this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
			}
			if (!this.loop) {
				if (Date.now() > this.endTime) {
					if (this.onFinished) this.onFinished();
					this.meshInstance.visible = false;
				}
			}
			if (this.meshInstance) {
				this.meshInstance.drawOrder = this.drawOrder;
			}
		};
		_proto._destroyResources = function _destroyResources() {
			var _this$particleTexIN, _this$particleTexOUT, _this$rtParticleTexIN, _this$rtParticleTexOU, _this$internalTex, _this$internalTex2, _this$internalTex3, _this$internalTex4, _this$colorParam, _this$vertexBuffer, _this$indexBuffer, _this$material;
			(_this$particleTexIN = this.particleTexIN) == null || _this$particleTexIN.destroy();
			this.particleTexIN = null;
			(_this$particleTexOUT = this.particleTexOUT) == null || _this$particleTexOUT.destroy();
			this.particleTexOUT = null;
			if (this.particleTexStart && this.particleTexStart.destroy) {
				this.particleTexStart.destroy();
				this.particleTexStart = null;
			}
			(_this$rtParticleTexIN = this.rtParticleTexIN) == null || _this$rtParticleTexIN.destroy();
			this.rtParticleTexIN = null;
			(_this$rtParticleTexOU = this.rtParticleTexOUT) == null || _this$rtParticleTexOU.destroy();
			this.rtParticleTexOUT = null;
			(_this$internalTex = this.internalTex0) == null || _this$internalTex.destroy();
			this.internalTex0 = null;
			(_this$internalTex2 = this.internalTex1) == null || _this$internalTex2.destroy();
			this.internalTex1 = null;
			(_this$internalTex3 = this.internalTex2) == null || _this$internalTex3.destroy();
			this.internalTex2 = null;
			(_this$internalTex4 = this.internalTex3) == null || _this$internalTex4.destroy();
			this.internalTex3 = null;
			(_this$colorParam = this.colorParam) == null || _this$colorParam.destroy();
			this.colorParam = null;
			(_this$vertexBuffer = this.vertexBuffer) == null || _this$vertexBuffer.destroy();
			this.vertexBuffer = undefined;
			(_this$indexBuffer = this.indexBuffer) == null || _this$indexBuffer.destroy();
			this.indexBuffer = undefined;
			(_this$material = this.material) == null || _this$material.destroy();
			this.material = null;
		};
		_proto.destroy = function destroy() {
			this.camera = null;
			this._destroyResources();
		};
		return _createClass(ParticleEmitter, [{
			key: "defaultParamTexture",
			get: function get() {
				var _this = this;
				return particleEmitterDeviceCache.get(this.graphicsDevice, function () {
					var resolution = 16;
					var centerPoint = resolution * 0.5 + 0.5;
					var dtex = new Float32Array(resolution * resolution * 4);
					for (var y = 0; y < resolution; y++) {
						for (var x = 0; x < resolution; x++) {
							var xgrad = x + 1 - centerPoint;
							var ygrad = y + 1 - centerPoint;
							var c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
							var p = y * resolution + x;
							dtex[p * 4] = 1;
							dtex[p * 4 + 1] = 1;
							dtex[p * 4 + 2] = 1;
							dtex[p * 4 + 3] = c;
						}
					}
					var texture = _createTexture(_this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_SRGBA8, 1.0, true);
					texture.minFilter = FILTER_LINEAR;
					texture.magFilter = FILTER_LINEAR;
					return texture;
				});
			}
		}]);
	}();

	var vShader = "\n    #include \"shaderPassDefines\"\n    #include \"userCode\"\n";
	var fShader = "\n    #include \"shaderPassDefines\"\n    #include \"decodePS\"\n    #include \"gamma\"\n    #include \"tonemappingPS\"\n    #include \"fog\"\n    #include \"userCode\"\n";
	var ShaderGeneratorShader = function (_ShaderGenerator) {
		function ShaderGeneratorShader() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		_inheritsLoose(ShaderGeneratorShader, _ShaderGenerator);
		var _proto = ShaderGeneratorShader.prototype;
		_proto.generateKey = function generateKey(options) {
			var desc = options.shaderDesc;
			var vsHash = desc.vertexCode ? hashCode(desc.vertexCode) : 0;
			var fsHash = desc.fragmentCode ? hashCode(desc.fragmentCode) : 0;
			var definesHash = ShaderGenerator.definesHash(options.defines);
			var key = desc.uniqueName + "_" + vsHash + "_" + fsHash + "_" + definesHash;
			key += "_" + options.pass;
			key += "_" + options.gamma;
			key += "_" + options.toneMapping;
			key += "_" + options.fog;
			if (options.skin) key += '_skin';
			if (options.useInstancing) key += '_inst';
			if (options.useMorphPosition) key += '_morphp';
			if (options.useMorphNormal) key += '_morphn';
			if (options.useMorphTextureBasedInt) key += '_morphi';
			return key;
		};
		_proto.createAttributesDefinition = function createAttributesDefinition(definitionOptions, options) {
			var srcAttributes = options.shaderDesc.attributes;
			var attributes = srcAttributes ? _extends({}, srcAttributes) : undefined;
			if (options.skin) {
				attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
				attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
			}
			if (options.useMorphPosition || options.useMorphNormal) {
				attributes.morph_vertex_id = SEMANTIC_ATTR15;
			}
			definitionOptions.attributes = attributes;
		};
		_proto.createVertexDefinition = function createVertexDefinition(definitionOptions, options, shaderPassInfo) {
			var desc = options.shaderDesc;
			if (definitionOptions.shaderLanguage === SHADERLANGUAGE_WGSL) {
				definitionOptions.vertexCode = desc.vertexCode;
			} else {
				var includes = new Map();
				var defines = new Map(options.defines);
				includes.set('shaderPassDefines', shaderPassInfo.shaderDefines);
				includes.set('userCode', desc.vertexCode);
				includes.set('transformCore', shaderChunks.transformCoreVS);
				includes.set('transformInstancing', '');
				includes.set('normalCore', shaderChunks.normalCoreVS);
				includes.set('skinCode', shaderChunks.skinTexVS);
				includes.set('skinTexVS', shaderChunks.skinTexVS);
				if (options.skin) defines.set('SKIN', true);
				if (options.useInstancing) defines.set('INSTANCING', true);
				if (options.useMorphPosition || options.useMorphNormal) {
					defines.set('MORPHING', true);
					if (options.useMorphTextureBasedInt) defines.set('MORPHING_INT', true);
					if (options.useMorphPosition) defines.set('MORPHING_POSITION', true);
					if (options.useMorphNormal) defines.set('MORPHING_NORMAL', true);
				}
				definitionOptions.vertexCode = vShader;
				definitionOptions.vertexIncludes = includes;
				definitionOptions.vertexDefines = defines;
			}
		};
		_proto.createFragmentDefinition = function createFragmentDefinition(definitionOptions, options, shaderPassInfo) {
			var desc = options.shaderDesc;
			if (definitionOptions.shaderLanguage === SHADERLANGUAGE_WGSL) {
				definitionOptions.fragmentCode = desc.fragmentCode;
			} else {
				var includes = new Map(Object.entries(_extends({}, shaderChunks, options.chunks)));
				includes.set('shaderPassDefines', shaderPassInfo.shaderDefines);
				includes.set('gamma', ShaderGenerator.gammaCode(options.gamma));
				includes.set('fog', ShaderGenerator.fogCode(options.fog));
				includes.set('userCode', desc.fragmentCode);
				var defines = new Map(options.defines);
				defines.set('TONEMAP', tonemapNames[options.toneMapping]);
				definitionOptions.fragmentCode = fShader;
				definitionOptions.fragmentIncludes = includes;
				definitionOptions.fragmentDefines = defines;
			}
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var shaderPassInfo = ShaderPass.get(device).getByIndex(options.pass);
			var desc = options.shaderDesc;
			var definitionOptions = {
				name: "ShaderMaterial-" + desc.uniqueName,
				shaderLanguage: desc.shaderLanguage,
				fragmentOutputTypes: desc.fragmentOutputTypes,
				meshUniformBufferFormat: desc.meshUniformBufferFormat,
				meshBindGroupFormat: desc.meshBindGroupFormat
			};
			this.createAttributesDefinition(definitionOptions, options);
			this.createVertexDefinition(definitionOptions, options, shaderPassInfo);
			this.createFragmentDefinition(definitionOptions, options, shaderPassInfo);
			return ShaderUtils.createDefinition(device, definitionOptions);
		};
		return ShaderGeneratorShader;
	}(ShaderGenerator);
	var shaderGeneratorShader = new ShaderGeneratorShader();

	var ShaderMaterial = function (_Material) {
		function ShaderMaterial(shaderDesc) {
			var _this;
			_this = _Material.call(this) || this;
			_this._shaderDesc = void 0;
			_this.shaderDesc = shaderDesc;
			return _this;
		}
		_inheritsLoose(ShaderMaterial, _Material);
		var _proto = ShaderMaterial.prototype;
		_proto.copy = function copy(source) {
			_Material.prototype.copy.call(this, source);
			this.shaderDesc = source.shaderDesc;
			return this;
		};
		_proto.getShaderVariant = function getShaderVariant(params) {
			var objDefs = params.objDefs,
				cameraShaderParams = params.cameraShaderParams;
			var options = {
				defines: getMaterialShaderDefines(this, cameraShaderParams),
				skin: (objDefs & SHADERDEF_SKIN) !== 0,
				useInstancing: (objDefs & SHADERDEF_INSTANCING) !== 0,
				useMorphPosition: (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
				useMorphNormal: (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
				useMorphTextureBasedInt: (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0,
				pass: params.pass,
				gamma: params.cameraShaderParams.shaderOutputGamma,
				toneMapping: params.cameraShaderParams.toneMapping,
				fog: params.cameraShaderParams.fog,
				shaderDesc: this.shaderDesc
			};
			var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
			var library = getProgramLibrary(params.device);
			library.register('shader-material', shaderGeneratorShader);
			return library.getProgram('shader-material', options, processingOptions, this.userId);
		};
		return _createClass(ShaderMaterial, [{
			key: "shaderDesc",
			get: function get() {
				return this._shaderDesc;
			},
			set: function set(value) {
				this._shaderDesc = value ? _extends({}, value) : undefined;
				this.clearVariants();
			}
		}]);
	}(Material);

	var ShaderGeneratorSkybox = function (_ShaderGenerator) {
		function ShaderGeneratorSkybox() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		_inheritsLoose(ShaderGeneratorSkybox, _ShaderGenerator);
		var _proto = ShaderGeneratorSkybox.prototype;
		_proto.generateKey = function generateKey(options) {
			var definesHash = ShaderGenerator.definesHash(options.defines);
			var sharedKey = "skybox-" + options.type + "-" + options.encoding + "-" + options.gamma + "-" + options.toneMapping + "-" + options.skymesh + "_" + definesHash;
			return sharedKey + (options.type === 'cubemap' ? "-" + options.mip : '');
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var defines = new Map();
			defines.set('TONEMAP', tonemapNames[options.toneMapping]);
			defines.set('SKYBOX_DECODE_FNC', ChunkUtils.decodeFunc(options.encoding));
			if (options.skymesh !== SKYTYPE_INFINITE) defines.set('SKYMESH', '');
			if (options.type === 'cubemap') {
				defines.set('SKY_CUBEMAP', '');
			}
			var includes = new Map(Object.entries(_extends({}, shaderChunks, options.chunks)));
			includes.set('decodePS', shaderChunks.decodePS);
			includes.set('gamma', ShaderGenerator.gammaCode(options.gamma));
			includes.set('envMultiplyPS', shaderChunks.envMultiplyPS);
			if (options.type !== 'cubemap') {
				includes.set('sphericalPS', shaderChunks.sphericalPS);
				includes.set('envAtlasPS', shaderChunks.envAtlasPS);
			}
			return ShaderUtils.createDefinition(device, {
				name: 'SkyboxShader',
				attributes: {
					aPosition: SEMANTIC_POSITION
				},
				vertexCode: shaderChunks.skyboxVS,
				vertexDefines: defines,
				fragmentCode: shaderChunks.skyboxPS,
				fragmentDefines: defines,
				fragmentIncludes: includes
			});
		};
		return ShaderGeneratorSkybox;
	}(ShaderGenerator);
	var skybox = new ShaderGeneratorSkybox();

	var calculateNormals = function calculateNormals(positions, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var p1 = new Vec3();
		var p2 = new Vec3();
		var p3 = new Vec3();
		var p1p2 = new Vec3();
		var p1p3 = new Vec3();
		var faceNormal = new Vec3();
		var normals = [];
		for (var i = 0; i < positions.length; i++) {
			normals[i] = 0;
		}
		for (var _i = 0; _i < triangleCount; _i++) {
			var i1 = indices[_i * 3];
			var i2 = indices[_i * 3 + 1];
			var i3 = indices[_i * 3 + 2];
			p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			p1p2.sub2(p2, p1);
			p1p3.sub2(p3, p1);
			faceNormal.cross(p1p2, p1p3).normalize();
			normals[i1 * 3] += faceNormal.x;
			normals[i1 * 3 + 1] += faceNormal.y;
			normals[i1 * 3 + 2] += faceNormal.z;
			normals[i2 * 3] += faceNormal.x;
			normals[i2 * 3 + 1] += faceNormal.y;
			normals[i2 * 3 + 2] += faceNormal.z;
			normals[i3 * 3] += faceNormal.x;
			normals[i3 * 3 + 1] += faceNormal.y;
			normals[i3 * 3 + 2] += faceNormal.z;
		}
		for (var _i2 = 0; _i2 < vertexCount; _i2++) {
			var nx = normals[_i2 * 3];
			var ny = normals[_i2 * 3 + 1];
			var nz = normals[_i2 * 3 + 2];
			var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
			normals[_i2 * 3] *= invLen;
			normals[_i2 * 3 + 1] *= invLen;
			normals[_i2 * 3 + 2] *= invLen;
		}
		return normals;
	};
	var calculateTangents = function calculateTangents(positions, normals, uvs, indices) {
		var triangleCount = indices.length / 3;
		var vertexCount = positions.length / 3;
		var v1 = new Vec3();
		var v2 = new Vec3();
		var v3 = new Vec3();
		var w1 = new Vec2();
		var w2 = new Vec2();
		var w3 = new Vec2();
		var sdir = new Vec3();
		var tdir = new Vec3();
		var tan1 = new Float32Array(vertexCount * 3);
		var tan2 = new Float32Array(vertexCount * 3);
		var tangents = [];
		for (var i = 0; i < triangleCount; i++) {
			var i1 = indices[i * 3];
			var i2 = indices[i * 3 + 1];
			var i3 = indices[i * 3 + 2];
			v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
			v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
			v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
			w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
			w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
			w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
			var x1 = v2.x - v1.x;
			var x2 = v3.x - v1.x;
			var y1 = v2.y - v1.y;
			var y2 = v3.y - v1.y;
			var z1 = v2.z - v1.z;
			var z2 = v3.z - v1.z;
			var s1 = w2.x - w1.x;
			var s2 = w3.x - w1.x;
			var _t = w2.y - w1.y;
			var _t2 = w3.y - w1.y;
			var area = s1 * _t2 - s2 * _t;
			if (area === 0) {
				sdir.set(0, 1, 0);
				tdir.set(1, 0, 0);
			} else {
				var r = 1 / area;
				sdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);
				tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
			}
			tan1[i1 * 3 + 0] += sdir.x;
			tan1[i1 * 3 + 1] += sdir.y;
			tan1[i1 * 3 + 2] += sdir.z;
			tan1[i2 * 3 + 0] += sdir.x;
			tan1[i2 * 3 + 1] += sdir.y;
			tan1[i2 * 3 + 2] += sdir.z;
			tan1[i3 * 3 + 0] += sdir.x;
			tan1[i3 * 3 + 1] += sdir.y;
			tan1[i3 * 3 + 2] += sdir.z;
			tan2[i1 * 3 + 0] += tdir.x;
			tan2[i1 * 3 + 1] += tdir.y;
			tan2[i1 * 3 + 2] += tdir.z;
			tan2[i2 * 3 + 0] += tdir.x;
			tan2[i2 * 3 + 1] += tdir.y;
			tan2[i2 * 3 + 2] += tdir.z;
			tan2[i3 * 3 + 0] += tdir.x;
			tan2[i3 * 3 + 1] += tdir.y;
			tan2[i3 * 3 + 2] += tdir.z;
		}
		var t1 = new Vec3();
		var t2 = new Vec3();
		var n = new Vec3();
		var temp = new Vec3();
		for (var _i3 = 0; _i3 < vertexCount; _i3++) {
			n.set(normals[_i3 * 3], normals[_i3 * 3 + 1], normals[_i3 * 3 + 2]);
			t1.set(tan1[_i3 * 3], tan1[_i3 * 3 + 1], tan1[_i3 * 3 + 2]);
			t2.set(tan2[_i3 * 3], tan2[_i3 * 3 + 1], tan2[_i3 * 3 + 2]);
			var ndott = n.dot(t1);
			temp.copy(n).mulScalar(ndott);
			temp.sub2(t1, temp).normalize();
			tangents[_i3 * 4] = temp.x;
			tangents[_i3 * 4 + 1] = temp.y;
			tangents[_i3 * 4 + 2] = temp.z;
			temp.cross(n, t1);
			tangents[_i3 * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;
		}
		return tangents;
	};

	var Geometry = function () {
		function Geometry() {
			this.positions = void 0;
			this.normals = void 0;
			this.colors = void 0;
			this.uvs = void 0;
			this.uvs1 = void 0;
			this.blendIndices = void 0;
			this.blendWeights = void 0;
			this.tangents = void 0;
			this.indices = void 0;
		}
		var _proto = Geometry.prototype;
		_proto.calculateNormals = function calculateNormals$1() {
			this.normals = calculateNormals(this.positions, this.indices);
		};
		_proto.calculateTangents = function calculateTangents$1() {
			this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
		};
		return Geometry;
	}();

	var primitiveUv1Padding$1 = 4.0 / 64;
	var primitiveUv1PaddingScale$1 = 1.0 - primitiveUv1Padding$1 * 2;
	var BoxGeometry = function (_Geometry) {
		function BoxGeometry(opts) {
			var _opts$halfExtents, _opts$widthSegments, _opts$lengthSegments, _opts$heightSegments, _opts$yOffset;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			_this = _Geometry.call(this) || this;
			var he = (_opts$halfExtents = opts.halfExtents) != null ? _opts$halfExtents : new Vec3(0.5, 0.5, 0.5);
			var ws = (_opts$widthSegments = opts.widthSegments) != null ? _opts$widthSegments : 1;
			var ls = (_opts$lengthSegments = opts.lengthSegments) != null ? _opts$lengthSegments : 1;
			var hs = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 1;
			var yOffset = (_opts$yOffset = opts.yOffset) != null ? _opts$yOffset : 0;
			var minY = -he.y + yOffset;
			var maxY = he.y + yOffset;
			var corners = [new Vec3(-he.x, minY, he.z), new Vec3(he.x, minY, he.z), new Vec3(he.x, maxY, he.z), new Vec3(-he.x, maxY, he.z), new Vec3(he.x, minY, -he.z), new Vec3(-he.x, minY, -he.z), new Vec3(-he.x, maxY, -he.z), new Vec3(he.x, maxY, -he.z)];
			var faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
			var faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
			var sides = {
				FRONT: 0,
				BACK: 1,
				TOP: 2,
				BOTTOM: 3,
				RIGHT: 4,
				LEFT: 5
			};
			var positions = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var vcounter = 0;
			var generateFace = function generateFace(side, uSegments, vSegments) {
				var temp1 = new Vec3();
				var temp2 = new Vec3();
				var temp3 = new Vec3();
				var r = new Vec3();
				for (var i = 0; i <= uSegments; i++) {
					for (var j = 0; j <= vSegments; j++) {
						temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
						temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
						temp3.sub2(temp2, corners[faceAxes[side][0]]);
						r.add2(temp1, temp3);
						var u = i / uSegments;
						var v = j / vSegments;
						positions.push(r.x, r.y, r.z);
						normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
						uvs.push(u, 1 - v);
						u = u * primitiveUv1PaddingScale$1 + primitiveUv1Padding$1;
						v = v * primitiveUv1PaddingScale$1 + primitiveUv1Padding$1;
						u /= 3;
						v /= 3;
						u += side % 3 / 3;
						v += Math.floor(side / 3) / 3;
						if (i < uSegments && j < vSegments) {
							indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
							indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
						}
						vcounter++;
					}
				}
			};
			generateFace(sides.FRONT, ws, hs);
			generateFace(sides.BACK, ws, hs);
			generateFace(sides.TOP, ws, ls);
			generateFace(sides.BOTTOM, ws, ls);
			generateFace(sides.RIGHT, ls, hs);
			generateFace(sides.LEFT, ls, hs);
			_this.positions = positions;
			_this.normals = normals;
			_this.uvs = uvs;
			_this.uvs1 = uvs;
			_this.indices = indices;
			if (opts.calculateTangents) {
				_this.tangents = calculateTangents(positions, normals, uvs, indices);
			}
			return _this;
		}
		_inheritsLoose(BoxGeometry, _Geometry);
		return BoxGeometry;
	}(Geometry);

	var SphereGeometry = function (_Geometry) {
		function SphereGeometry(opts) {
			var _opts$radius, _opts$latitudeBands, _opts$longitudeBands;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			_this = _Geometry.call(this) || this;
			var radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.5;
			var latitudeBands = (_opts$latitudeBands = opts.latitudeBands) != null ? _opts$latitudeBands : 16;
			var longitudeBands = (_opts$longitudeBands = opts.longitudeBands) != null ? _opts$longitudeBands : 16;
			var positions = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			for (var lat = 0; lat <= latitudeBands; lat++) {
				var theta = lat * Math.PI / latitudeBands;
				var sinTheta = Math.sin(theta);
				var cosTheta = Math.cos(theta);
				for (var lon = 0; lon <= longitudeBands; lon++) {
					var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
					var sinPhi = Math.sin(phi);
					var cosPhi = Math.cos(phi);
					var x = cosPhi * sinTheta;
					var y = cosTheta;
					var z = sinPhi * sinTheta;
					var u = 1 - lon / longitudeBands;
					var v = 1 - lat / latitudeBands;
					positions.push(x * radius, y * radius, z * radius);
					normals.push(x, y, z);
					uvs.push(u, 1 - v);
				}
			}
			for (var _lat = 0; _lat < latitudeBands; ++_lat) {
				for (var _lon = 0; _lon < longitudeBands; ++_lon) {
					var first = _lat * (longitudeBands + 1) + _lon;
					var second = first + longitudeBands + 1;
					indices.push(first + 1, second, first);
					indices.push(first + 1, second + 1, second);
				}
			}
			_this.positions = positions;
			_this.normals = normals;
			_this.uvs = uvs;
			_this.uvs1 = uvs;
			_this.indices = indices;
			if (opts.calculateTangents) {
				_this.tangents = calculateTangents(positions, normals, uvs, indices);
			}
			return _this;
		}
		_inheritsLoose(SphereGeometry, _Geometry);
		return SphereGeometry;
	}(Geometry);

	var DomeGeometry = function (_SphereGeometry) {
		function DomeGeometry(opts) {
			var _opts$latitudeBands, _opts$longitudeBands;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			var radius = 0.5;
			var latitudeBands = (_opts$latitudeBands = opts.latitudeBands) != null ? _opts$latitudeBands : 16;
			var longitudeBands = (_opts$longitudeBands = opts.longitudeBands) != null ? _opts$longitudeBands : 16;
			_this = _SphereGeometry.call(this, {
				radius: radius,
				latitudeBands: latitudeBands,
				longitudeBands: longitudeBands
			}) || this;
			var bottomLimit = 0.1;
			var curvatureRadius = 0.95;
			var curvatureRadiusSq = curvatureRadius * curvatureRadius;
			var positions = _this.positions;
			for (var i = 0; i < positions.length; i += 3) {
				var x = positions[i] / radius;
				var y = positions[i + 1] / radius;
				var z = positions[i + 2] / radius;
				if (y < 0) {
					y *= 0.3;
					if (x * x + z * z < curvatureRadiusSq) {
						y = -bottomLimit;
					}
				}
				y += bottomLimit;
				y *= radius;
				positions[i + 1] = y;
			}
			return _this;
		}
		_inheritsLoose(DomeGeometry, _SphereGeometry);
		return DomeGeometry;
	}(SphereGeometry);

	var SkyGeometry = function () {
		function SkyGeometry() {}
		SkyGeometry.create = function create(device, type) {
			switch (type) {
				case SKYTYPE_BOX:
					return SkyGeometry.box(device);
				case SKYTYPE_DOME:
					return SkyGeometry.dome(device);
			}
			return SkyGeometry.infinite(device);
		};
		SkyGeometry.infinite = function infinite(device) {
			return Mesh.fromGeometry(device, new BoxGeometry(device));
		};
		SkyGeometry.box = function box(device) {
			return Mesh.fromGeometry(device, new BoxGeometry({
				yOffset: 0.5
			}));
		};
		SkyGeometry.dome = function dome(device) {
			var geom = new DomeGeometry({
				latitudeBands: 50,
				longitudeBands: 50
			});
			geom.normals = undefined;
			geom.uvs = undefined;
			return Mesh.fromGeometry(device, geom);
		};
		return SkyGeometry;
	}();

	var SkyMesh = function () {
		function SkyMesh(device, scene, node, texture, type) {
			this.meshInstance = null;
			var material = new ShaderMaterial();
			material.name = 'SkyMaterial';
			material.getShaderVariant = function (params) {
				var scene = params.scene,
					cameraShaderParams = params.cameraShaderParams;
				var options = {
					defines: getMaterialShaderDefines(this, cameraShaderParams),
					pass: params.pass,
					encoding: texture.encoding,
					gamma: cameraShaderParams.shaderOutputGamma,
					toneMapping: cameraShaderParams.toneMapping,
					skymesh: type
				};
				if (texture.cubemap) {
					options.type = 'cubemap';
					options.mip = scene.skyboxMip;
				} else {
					options.type = 'envAtlas';
				}
				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat);
				var library = getProgramLibrary(device);
				library.register('skybox', skybox);
				return library.getProgram('skybox', options, processingOptions);
			};
			material.setParameter('skyboxHighlightMultiplier', scene.skyboxHighlightMultiplier);
			if (texture.cubemap) {
				material.setParameter('texture_cubeMap', texture);
			} else {
				material.setParameter('texture_envAtlas', texture);
				material.setParameter('mipLevel', scene.skyboxMip);
			}
			material.cull = CULLFACE_FRONT;
			material.depthWrite = false;
			var skyLayer = scene.layers.getLayerById(LAYERID_SKYBOX);
			if (skyLayer) {
				var mesh = SkyGeometry.create(device, type);
				var meshInstance = new MeshInstance(mesh, material, node);
				this.meshInstance = meshInstance;
				meshInstance.cull = false;
				meshInstance.pick = false;
				skyLayer.addMeshInstances([meshInstance]);
				this.skyLayer = skyLayer;
			}
		}
		var _proto = SkyMesh.prototype;
		_proto.destroy = function destroy() {
			if (this.meshInstance) {
				if (this.skyLayer) {
					this.skyLayer.removeMeshInstances([this.meshInstance]);
				}
				this.meshInstance.destroy();
				this.meshInstance = null;
			}
		};
		return SkyMesh;
	}();

	var Sky = function () {
		function Sky(scene) {
			this._type = SKYTYPE_INFINITE;
			this._center = new Vec3(0, 1, 0);
			this.skyMesh = null;
			this.node = new GraphNode('SkyMeshNode');
			this.device = scene.device;
			this.scene = scene;
			this.center = new Vec3(0, 1, 0);
			this.centerArray = new Float32Array(3);
			this.projectedSkydomeCenterId = this.device.scope.resolve('projectedSkydomeCenter');
		}
		var _proto = Sky.prototype;
		_proto.applySettings = function applySettings(render) {
			var _render$skyType, _render$skyMeshPositi, _render$skyMeshRotati, _render$skyMeshScale;
			this.type = (_render$skyType = render.skyType) != null ? _render$skyType : SKYTYPE_INFINITE;
			this.node.setLocalPosition(new Vec3((_render$skyMeshPositi = render.skyMeshPosition) != null ? _render$skyMeshPositi : [0, 0, 0]));
			this.node.setLocalEulerAngles(new Vec3((_render$skyMeshRotati = render.skyMeshRotation) != null ? _render$skyMeshRotati : [0, 0, 0]));
			this.node.setLocalScale(new Vec3((_render$skyMeshScale = render.skyMeshScale) != null ? _render$skyMeshScale : [1, 1, 1]));
			if (render.skyCenter) {
				this._center = new Vec3(render.skyCenter);
			}
		};
		_proto.updateSkyMesh = function updateSkyMesh() {
			var texture = this.scene._getSkyboxTex();
			if (texture) {
				this.resetSkyMesh();
				this.skyMesh = new SkyMesh(this.device, this.scene, this.node, texture, this.type);
				this.scene.fire('set:skybox', texture);
			}
		};
		_proto.resetSkyMesh = function resetSkyMesh() {
			var _this$skyMesh;
			(_this$skyMesh = this.skyMesh) == null || _this$skyMesh.destroy();
			this.skyMesh = null;
		};
		_proto.update = function update() {
			if (this.type !== SKYTYPE_INFINITE) {
				var center = this.center,
					centerArray = this.centerArray;
				var temp = new Vec3();
				this.node.getWorldTransform().transformPoint(center, temp);
				centerArray[0] = temp.x;
				centerArray[1] = temp.y;
				centerArray[2] = temp.z;
				this.projectedSkydomeCenterId.setValue(centerArray);
			}
		};
		return _createClass(Sky, [{
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type !== value) {
					this._type = value;
					this.scene.updateShaders = true;
					this.updateSkyMesh();
				}
			}
		}, {
			key: "center",
			get: function get() {
				return this._center;
			},
			set: function set(value) {
				this._center.copy(value);
			}
		}]);
	}();

	var identityGraphNode = new GraphNode();
	identityGraphNode.worldTransform = Mat4.IDENTITY;
	identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
	var ImmediateBatch = function () {
		function ImmediateBatch(device, material, layer) {
			this.material = material;
			this.layer = layer;
			this.positions = [];
			this.colors = [];
			this.mesh = new Mesh(device);
			this.meshInstance = null;
		}
		var _proto = ImmediateBatch.prototype;
		_proto.addLines = function addLines(positions, color) {
			var destPos = this.positions;
			var count = positions.length;
			for (var i = 0; i < count; i++) {
				var pos = positions[i];
				destPos.push(pos.x, pos.y, pos.z);
			}
			var destCol = this.colors;
			if (color.length) {
				for (var _i = 0; _i < count; _i++) {
					var col = color[_i];
					destCol.push(col.r, col.g, col.b, col.a);
				}
			} else {
				for (var _i2 = 0; _i2 < count; _i2++) {
					destCol.push(color.r, color.g, color.b, color.a);
				}
			}
		};
		_proto.addLinesArrays = function addLinesArrays(positions, color) {
			var destPos = this.positions;
			for (var i = 0; i < positions.length; i += 3) {
				destPos.push(positions[i], positions[i + 1], positions[i + 2]);
			}
			var destCol = this.colors;
			if (color.length) {
				for (var _i3 = 0; _i3 < color.length; _i3 += 4) {
					destCol.push(color[_i3], color[_i3 + 1], color[_i3 + 2], color[_i3 + 3]);
				}
			} else {
				var count = positions.length / 3;
				for (var _i4 = 0; _i4 < count; _i4++) {
					destCol.push(color.r, color.g, color.b, color.a);
				}
			}
		};
		_proto.onPreRender = function onPreRender(visibleList, transparent) {
			if (this.positions.length > 0 && this.material.transparent === transparent) {
				this.mesh.setPositions(this.positions);
				this.mesh.setColors(this.colors);
				this.mesh.update(PRIMITIVE_LINES, false);
				if (!this.meshInstance) {
					this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
				}
				visibleList.push(this.meshInstance);
			}
		};
		_proto.clear = function clear() {
			this.positions.length = 0;
			this.colors.length = 0;
		};
		return ImmediateBatch;
	}();

	var ImmediateBatches = function () {
		function ImmediateBatches(device) {
			this.device = device;
			this.map = new Map();
		}
		var _proto = ImmediateBatches.prototype;
		_proto.getBatch = function getBatch(material, layer) {
			var batch = this.map.get(material);
			if (!batch) {
				batch = new ImmediateBatch(this.device, material, layer);
				this.map.set(material, batch);
			}
			return batch;
		};
		_proto.onPreRender = function onPreRender(visibleList, transparent) {
			this.map.forEach(function (batch) {
				batch.onPreRender(visibleList, transparent);
			});
		};
		_proto.clear = function clear() {
			this.map.forEach(function (batch) {
				return batch.clear();
			});
		};
		return ImmediateBatches;
	}();

	var tempPoints = [];
	var vec = new Vec3();
	var lineShaderDesc = {
		uniqueName: 'ImmediateLine',
		vertexCode: "\n\t\tattribute vec3 vertex_position;\n\t\tattribute vec4 vertex_color;\n\t\tuniform mat4 matrix_model;\n\t\tuniform mat4 matrix_viewProjection;\n\t\tvarying vec4 color;\n\t\tvoid main(void) {\n\t\t\tcolor = vertex_color;\n\t\t\tgl_Position = matrix_viewProjection * matrix_model * vec4(vertex_position, 1);\n\t\t}\n\t",
		fragmentCode: "\n\t\tvarying vec4 color;\n\t\tvoid main(void) {\n\t\t\tgl_FragColor = vec4(gammaCorrectOutput(decodeGamma(color.rgb)), color.a);\n\t\t}\n\t",
		attributes: {
			vertex_position: SEMANTIC_POSITION,
			vertex_color: SEMANTIC_COLOR
		}
	};
	var Immediate = function () {
		function Immediate(device) {
			this.shaderDescs = new Map();
			this.device = device;
			this.quadMesh = null;
			this.textureShader = null;
			this.depthTextureShader = null;
			this.cubeLocalPos = null;
			this.cubeWorldPos = null;
			this.batchesMap = new Map();
			this.allBatches = new Set();
			this.updatedLayers = new Set();
			this._materialDepth = null;
			this._materialNoDepth = null;
			this.layerMeshInstances = new Map();
		}
		var _proto = Immediate.prototype;
		_proto.createMaterial = function createMaterial(depthTest) {
			var material = new ShaderMaterial(lineShaderDesc);
			material.blendType = BLEND_NORMAL;
			material.depthTest = depthTest;
			material.update();
			return material;
		};
		_proto.getBatch = function getBatch(layer, depthTest) {
			var batches = this.batchesMap.get(layer);
			if (!batches) {
				batches = new ImmediateBatches(this.device);
				this.batchesMap.set(layer, batches);
			}
			this.allBatches.add(batches);
			var material = depthTest ? this.materialDepth : this.materialNoDepth;
			return batches.getBatch(material, layer);
		};
		_proto.getShaderDesc = function getShaderDesc(id, fragment) {
			if (!this.shaderDescs.has(id)) {
				var vertex = "\n\t\t\t\tattribute vec2 vertex_position;\n\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\tvarying vec2 uv0;\n\t\t\t\tvoid main(void) {\n\t\t\t\t\tgl_Position = matrix_model * vec4(vertex_position, 0, 1);\n\t\t\t\t\tuv0 = vertex_position.xy + 0.5;\n\t\t\t\t}\n\t\t\t";
				this.shaderDescs.set(id, {
					uniqueName: "DebugShader:" + id,
					vertexCode: vertex,
					fragmentCode: fragment,
					attributes: {
						vertex_position: SEMANTIC_POSITION
					}
				});
			}
			return this.shaderDescs.get(id);
		};
		_proto.getTextureShaderDesc = function getTextureShaderDesc(encoding) {
			var decodeFunc = ChunkUtils.decodeFunc(encoding);
			return this.getShaderDesc("textureShader-" + encoding, "\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform sampler2D colorMap;\n\t\t\tvoid main (void) {\n\t\t\t\tvec3 linearColor = " + decodeFunc + "(texture2D(colorMap, uv0));\n\t\t\t\tgl_FragColor = vec4(gammaCorrectOutput(linearColor), 1);\n\t\t\t}\n\t\t");
		};
		_proto.getUnfilterableTextureShaderDesc = function getUnfilterableTextureShaderDesc() {
			return this.getShaderDesc('textureShaderUnfilterable', "\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform highp sampler2D colorMap;\n\t\t\tvoid main (void) {\n\t\t\t\tivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));\n\t\t\t\tgl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);\n\t\t\t}\n\t\t");
		};
		_proto.getDepthTextureShaderDesc = function getDepthTextureShaderDesc() {
			return this.getShaderDesc('depthTextureShader', "\n\t\t\t" + shaderChunks.screenDepthPS + "\n\t\t\tvarying vec2 uv0;\n\t\t\tvoid main() {\n\t\t\t\tfloat depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;\n\t\t\t\tgl_FragColor = vec4(gammaCorrectOutput(vec3(depth)), 1.0);\n\t\t\t}\n\t\t");
		};
		_proto.getQuadMesh = function getQuadMesh() {
			if (!this.quadMesh) {
				this.quadMesh = new Mesh(this.device);
				this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);
				this.quadMesh.update(PRIMITIVE_TRISTRIP);
			}
			return this.quadMesh;
		};
		_proto.drawMesh = function drawMesh(material, matrix, mesh, meshInstance, layer) {
			if (!meshInstance) {
				var graphNode = this.getGraphNode(matrix);
				meshInstance = new MeshInstance(mesh, material, graphNode);
			}
			var layerMeshInstances = this.layerMeshInstances.get(layer);
			if (!layerMeshInstances) {
				layerMeshInstances = [];
				this.layerMeshInstances.set(layer, layerMeshInstances);
			}
			layerMeshInstances.push(meshInstance);
		};
		_proto.drawWireAlignedBox = function drawWireAlignedBox(min, max, color, depthTest, layer, mat) {
			if (mat) {
				var mulPoint = function mulPoint(x, y, z) {
					vec.set(x, y, z);
					mat.transformPoint(vec, vec);
					tempPoints.push(vec.x, vec.y, vec.z);
				};
				mulPoint(min.x, min.y, min.z);
				mulPoint(min.x, max.y, min.z);
				mulPoint(min.x, max.y, min.z);
				mulPoint(max.x, max.y, min.z);
				mulPoint(max.x, max.y, min.z);
				mulPoint(max.x, min.y, min.z);
				mulPoint(max.x, min.y, min.z);
				mulPoint(min.x, min.y, min.z);
				mulPoint(min.x, min.y, max.z);
				mulPoint(min.x, max.y, max.z);
				mulPoint(min.x, max.y, max.z);
				mulPoint(max.x, max.y, max.z);
				mulPoint(max.x, max.y, max.z);
				mulPoint(max.x, min.y, max.z);
				mulPoint(max.x, min.y, max.z);
				mulPoint(min.x, min.y, max.z);
				mulPoint(min.x, min.y, min.z);
				mulPoint(min.x, min.y, max.z);
				mulPoint(min.x, max.y, min.z);
				mulPoint(min.x, max.y, max.z);
				mulPoint(max.x, max.y, min.z);
				mulPoint(max.x, max.y, max.z);
				mulPoint(max.x, min.y, min.z);
				mulPoint(max.x, min.y, max.z);
			} else {
				tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
			}
			var batch = this.getBatch(layer, depthTest);
			batch.addLinesArrays(tempPoints, color);
			tempPoints.length = 0;
		};
		_proto.drawWireSphere = function drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
			var step = 2 * Math.PI / numSegments;
			var angle = 0;
			for (var i = 0; i < numSegments; i++) {
				var sin0 = Math.sin(angle);
				var cos0 = Math.cos(angle);
				angle += step;
				var sin1 = Math.sin(angle);
				var cos1 = Math.cos(angle);
				tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
				tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
				tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
				tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
				tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
				tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
			}
			var batch = this.getBatch(layer, depthTest);
			batch.addLinesArrays(tempPoints, color);
			tempPoints.length = 0;
		};
		_proto.getGraphNode = function getGraphNode(matrix) {
			var graphNode = new GraphNode('ImmediateDebug');
			graphNode.worldTransform = matrix;
			graphNode._dirtyWorld = graphNode._dirtyNormal = false;
			return graphNode;
		};
		_proto.onPreRenderLayer = function onPreRenderLayer(layer, visibleList, transparent) {
			this.batchesMap.forEach(function (batches, batchLayer) {
				if (batchLayer === layer) {
					batches.onPreRender(visibleList, transparent);
				}
			});
			if (!this.updatedLayers.has(layer)) {
				this.updatedLayers.add(layer);
				var meshInstances = this.layerMeshInstances.get(layer);
				if (meshInstances) {
					for (var i = 0; i < meshInstances.length; i++) {
						visibleList.push(meshInstances[i]);
					}
					meshInstances.length = 0;
				}
			}
		};
		_proto.onPostRender = function onPostRender() {
			this.allBatches.forEach(function (batch) {
				return batch.clear();
			});
			this.allBatches.clear();
			this.updatedLayers.clear();
		};
		return _createClass(Immediate, [{
			key: "materialDepth",
			get: function get() {
				if (!this._materialDepth) {
					this._materialDepth = this.createMaterial(true);
				}
				return this._materialDepth;
			}
		}, {
			key: "materialNoDepth",
			get: function get() {
				if (!this._materialNoDepth) {
					this._materialNoDepth = this.createMaterial(false);
				}
				return this._materialNoDepth;
			}
		}]);
	}();

	var FogParams = function FogParams() {
		this.type = FOG_NONE;
		this.color = new Color(0, 0, 0);
		this.density = 0;
		this.start = 1;
		this.end = 1000;
	};

	var Scene = function (_EventHandler) {
		function Scene(graphicsDevice) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.ambientBake = false;
			_this.ambientBakeOcclusionBrightness = 0;
			_this.ambientBakeOcclusionContrast = 0;
			_this.ambientLight = new Color(0, 0, 0);
			_this.ambientLuminance = 0;
			_this.exposure = 1;
			_this.lightmapSizeMultiplier = 1;
			_this.lightmapMaxResolution = 2048;
			_this.lightmapMode = BAKE_COLORDIR;
			_this.lightmapFilterEnabled = false;
			_this.lightmapHDR = false;
			_this.root = null;
			_this.physicalUnits = false;
			_this._envAtlas = null;
			_this._skyboxCubeMap = null;
			_this._fogParams = new FogParams();
			_this.device = graphicsDevice;
			_this._gravity = new Vec3(0, -9.8, 0);
			_this._layers = null;
			_this._prefilteredCubemaps = [];
			_this._internalEnvAtlas = null;
			_this._skyboxIntensity = 1;
			_this._skyboxLuminance = 0;
			_this._skyboxMip = 0;
			_this._skyboxHighlightMultiplier = 1;
			_this._skyboxRotationShaderInclude = false;
			_this._skyboxRotation = new Quat();
			_this._skyboxRotationMat3 = new Mat3();
			_this._skyboxRotationMat4 = new Mat4();
			_this._ambientBakeNumSamples = 1;
			_this._ambientBakeSpherePart = 0.4;
			_this._lightmapFilterRange = 10;
			_this._lightmapFilterSmoothness = 0.2;
			_this._clusteredLightingEnabled = true;
			_this._lightingParams = new LightingParams(_this.device.supportsAreaLights, _this.device.maxTextureSize, function () {
				_this.updateShaders = true;
			});
			_this._sky = new Sky(_this);
			_this._stats = {
				meshInstances: 0,
				lights: 0,
				dynamicLights: 0,
				bakedLights: 0,
				updateShadersTime: 0
			};
			_this.updateShaders = true;
			_this._shaderVersion = 0;
			_this.immediate = new Immediate(_this.device);
			return _this;
		}
		_inheritsLoose(Scene, _EventHandler);
		var _proto = Scene.prototype;
		_proto.destroy = function destroy() {
			this._resetSkyMesh();
			this.root = null;
			this.off();
		};
		_proto.drawLine = function drawLine(start, end, color, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}
			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLines([start, end], [color, color]);
		};
		_proto.drawLines = function drawLines(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}
			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLines(positions, colors);
		};
		_proto.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.defaultDrawLayer;
			}
			var batch = this.immediate.getBatch(layer, depthTest);
			batch.addLinesArrays(positions, colors);
		};
		_proto.applySettings = function applySettings(settings) {
			var _render$skyboxIntensi,
				_render$skyboxLuminan,
				_render$skyboxMip,
				_render$clusteredLigh,
				_this2 = this;
			var physics = settings.physics;
			var render = settings.render;
			this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);
			this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
			this.ambientLuminance = render.ambientLuminance;
			this.fog.type = render.fog;
			this.fog.color.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
			this.fog.start = render.fog_start;
			this.fog.end = render.fog_end;
			this.fog.density = render.fog_density;
			this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
			this.lightmapMaxResolution = render.lightmapMaxResolution;
			this.lightmapMode = render.lightmapMode;
			this.exposure = render.exposure;
			this._skyboxIntensity = (_render$skyboxIntensi = render.skyboxIntensity) != null ? _render$skyboxIntensi : 1;
			this._skyboxLuminance = (_render$skyboxLuminan = render.skyboxLuminance) != null ? _render$skyboxLuminan : 20000;
			this._skyboxMip = (_render$skyboxMip = render.skyboxMip) != null ? _render$skyboxMip : 0;
			if (render.skyboxRotation) {
				this.skyboxRotation = new Quat().setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
			}
			this.sky.applySettings(render);
			this.clusteredLightingEnabled = (_render$clusteredLigh = render.clusteredLightingEnabled) != null ? _render$clusteredLigh : false;
			this.lighting.applySettings(render);
			['lightmapFilterEnabled', 'lightmapFilterRange', 'lightmapFilterSmoothness', 'ambientBake', 'ambientBakeNumSamples', 'ambientBakeSpherePart', 'ambientBakeOcclusionBrightness', 'ambientBakeOcclusionContrast'].forEach(function (setting) {
				if (render.hasOwnProperty(setting)) {
					_this2[setting] = render[setting];
				}
			});
			this._resetSkyMesh();
		};
		_proto._getSkyboxTex = function _getSkyboxTex() {
			var cubemaps = this._prefilteredCubemaps;
			if (this._skyboxMip) {
				var skyboxMapping = [0, 1, 3, 4, 5, 6];
				return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
			}
			return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
		};
		_proto._updateSkyMesh = function _updateSkyMesh() {
			if (!this.sky.skyMesh) {
				this.sky.updateSkyMesh();
			}
			this.sky.update();
		};
		_proto._resetSkyMesh = function _resetSkyMesh() {
			this.sky.resetSkyMesh();
			this.updateShaders = true;
		};
		_proto.setSkybox = function setSkybox(cubemaps) {
			if (!cubemaps) {
				this.skybox = null;
				this.envAtlas = null;
			} else {
				this.skybox = cubemaps[0] || null;
				if (cubemaps[1] && !cubemaps[1].cubemap) {
					this.envAtlas = cubemaps[1];
				} else {
					this.prefilteredCubemaps = cubemaps.slice(1);
				}
			}
		};
		return _createClass(Scene, [{
			key: "defaultDrawLayer",
			get: function get() {
				return this.layers.getLayerById(LAYERID_IMMEDIATE);
			}
		}, {
			key: "ambientBakeNumSamples",
			get: function get() {
				return this._ambientBakeNumSamples;
			},
			set: function set(value) {
				this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
			}
		}, {
			key: "ambientBakeSpherePart",
			get: function get() {
				return this._ambientBakeSpherePart;
			},
			set: function set(value) {
				this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
			}
		}, {
			key: "clusteredLightingEnabled",
			get: function get() {
				return this._clusteredLightingEnabled;
			},
			set: function set(value) {
				if (this.device.isWebGPU && !value) {
					return;
				}
				if (!this._clusteredLightingEnabled && value) {
					console.error('Turning on disabled clustered lighting is not currently supported');
					return;
				}
				this._clusteredLightingEnabled = value;
			}
		}, {
			key: "envAtlas",
			get: function get() {
				return this._envAtlas;
			},
			set: function set(value) {
				if (value !== this._envAtlas) {
					this._envAtlas = value;
					if (value) {
						value.addressU = ADDRESS_CLAMP_TO_EDGE;
						value.addressV = ADDRESS_CLAMP_TO_EDGE;
						value.minFilter = FILTER_LINEAR;
						value.magFilter = FILTER_LINEAR;
						value.mipmaps = false;
					}
					this._prefilteredCubemaps = [];
					if (this._internalEnvAtlas) {
						this._internalEnvAtlas.destroy();
						this._internalEnvAtlas = null;
					}
					this._resetSkyMesh();
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(layers) {
				var prev = this._layers;
				this._layers = layers;
				this.fire('set:layers', prev, layers);
			}
		}, {
			key: "sky",
			get: function get() {
				return this._sky;
			}
		}, {
			key: "lighting",
			get: function get() {
				return this._lightingParams;
			}
		}, {
			key: "fog",
			get: function get() {
				return this._fogParams;
			}
		}, {
			key: "lightmapFilterRange",
			get: function get() {
				return this._lightmapFilterRange;
			},
			set: function set(value) {
				this._lightmapFilterRange = Math.max(value, 0.001);
			}
		}, {
			key: "lightmapFilterSmoothness",
			get: function get() {
				return this._lightmapFilterSmoothness;
			},
			set: function set(value) {
				this._lightmapFilterSmoothness = Math.max(value, 0.001);
			}
		}, {
			key: "prefilteredCubemaps",
			get: function get() {
				return this._prefilteredCubemaps;
			},
			set: function set(value) {
				value = value || [];
				var cubemaps = this._prefilteredCubemaps;
				var changed = cubemaps.length !== value.length || cubemaps.some(function (c, i) {
					return c !== value[i];
				});
				if (changed) {
					var complete = value.length === 6 && value.every(function (c) {
						return !!c;
					});
					if (complete) {
						this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(value, {
							target: this._internalEnvAtlas
						});
						this._envAtlas = this._internalEnvAtlas;
					} else {
						if (this._internalEnvAtlas) {
							this._internalEnvAtlas.destroy();
							this._internalEnvAtlas = null;
						}
						this._envAtlas = null;
					}
					this._prefilteredCubemaps = value.slice();
					this._resetSkyMesh();
				}
			}
		}, {
			key: "skybox",
			get: function get() {
				return this._skyboxCubeMap;
			},
			set: function set(value) {
				if (value !== this._skyboxCubeMap) {
					this._skyboxCubeMap = value;
					this._resetSkyMesh();
				}
			}
		}, {
			key: "skyboxIntensity",
			get: function get() {
				return this._skyboxIntensity;
			},
			set: function set(value) {
				if (value !== this._skyboxIntensity) {
					this._skyboxIntensity = value;
					this._resetSkyMesh();
				}
			}
		}, {
			key: "skyboxLuminance",
			get: function get() {
				return this._skyboxLuminance;
			},
			set: function set(value) {
				if (value !== this._skyboxLuminance) {
					this._skyboxLuminance = value;
					this._resetSkyMesh();
				}
			}
		}, {
			key: "skyboxMip",
			get: function get() {
				return this._skyboxMip;
			},
			set: function set(value) {
				if (value !== this._skyboxMip) {
					this._skyboxMip = value;
					this._resetSkyMesh();
				}
			}
		}, {
			key: "skyboxHighlightMultiplier",
			get: function get() {
				return this._skyboxHighlightMultiplier;
			},
			set: function set(value) {
				if (value !== this._skyboxHighlightMultiplier) {
					this._skyboxHighlightMultiplier = value;
					this._resetSkyMesh();
				}
			}
		}, {
			key: "skyboxRotation",
			get: function get() {
				return this._skyboxRotation;
			},
			set: function set(value) {
				if (!this._skyboxRotation.equals(value)) {
					var isIdentity = value.equals(Quat.IDENTITY);
					this._skyboxRotation.copy(value);
					if (isIdentity) {
						this._skyboxRotationMat3.setIdentity();
					} else {
						this._skyboxRotationMat4.setTRS(Vec3.ZERO, value, Vec3.ONE);
						this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4);
					}
					if (!this._skyboxRotationShaderInclude && !isIdentity) {
						this._skyboxRotationShaderInclude = true;
						this._resetSkyMesh();
					}
				}
			}
		}, {
			key: "lightmapPixelFormat",
			get: function get() {
				return this.lightmapHDR && this.device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;
			}
		}]);
	}(EventHandler);
	Scene.EVENT_SETLAYERS = 'set:layers';
	Scene.EVENT_SETSKYBOX = 'set:skybox';
	Scene.EVENT_PRERENDER = 'prerender';
	Scene.EVENT_POSTRENDER = 'postrender';
	Scene.EVENT_PRERENDER_LAYER = 'prerender:layer';
	Scene.EVENT_POSTRENDER_LAYER = 'postrender:layer';
	Scene.EVENT_PRECULL = 'precull';
	Scene.EVENT_POSTCULL = 'postcull';

	var Skin = function Skin(graphicsDevice, ibp, boneNames) {
		this.device = graphicsDevice;
		this.inverseBindPose = ibp;
		this.boneNames = boneNames;
	};

	var spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
	var spriteIndices = [0, 1, 3, 2, 3, 1];
	var Sprite = function (_EventHandler) {
		function Sprite(device, options) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._device = device;
			_this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
			_this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
			_this._atlas = options && options.atlas !== undefined ? options.atlas : null;
			_this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
			_this._meshes = [];
			_this._updatingProperties = false;
			_this._meshesDirty = false;
			if (_this._atlas && _this._frameKeys) {
				_this._createMeshes();
			}
			return _this;
		}
		_inheritsLoose(Sprite, _EventHandler);
		var _proto = Sprite.prototype;
		_proto._createMeshes = function _createMeshes() {
			var len = this._meshes.length;
			for (var i = 0; i < len; i++) {
				var mesh = this._meshes[i];
				if (mesh) {
					mesh.destroy();
				}
			}
			var count = this._frameKeys.length;
			this._meshes = new Array(count);
			var createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;
			for (var _i = 0; _i < count; _i++) {
				var frame = this._atlas.frames[this._frameKeys[_i]];
				this._meshes[_i] = frame ? createMeshFunc.call(this, frame) : null;
			}
			this.fire('set:meshes');
		};
		_proto._createSimpleMesh = function _createSimpleMesh(frame) {
			var rect = frame.rect;
			var texWidth = this._atlas.texture.width;
			var texHeight = this._atlas.texture.height;
			var w = rect.z / this._pixelsPerUnit;
			var h = rect.w / this._pixelsPerUnit;
			var hp = frame.pivot.x;
			var vp = frame.pivot.y;
			var positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];
			var lu = rect.x / texWidth;
			var bv = 1.0 - rect.y / texHeight;
			var ru = (rect.x + rect.z) / texWidth;
			var tv = 1.0 - (rect.y + rect.w) / texHeight;
			var uvs = [lu, bv, ru, bv, ru, tv, lu, tv];
			var geom = new Geometry();
			geom.positions = positions;
			geom.normals = spriteNormals;
			geom.uvs = uvs;
			geom.indices = spriteIndices;
			return Mesh.fromGeometry(this._device, geom);
		};
		_proto._create9SliceMesh = function _create9SliceMesh() {
			var he = Vec2.ONE;
			var ws = 3;
			var ls = 3;
			var positions = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var vcounter = 0;
			for (var i = 0; i <= ws; i++) {
				var u = i === 0 || i === ws ? 0 : 1;
				for (var j = 0; j <= ls; j++) {
					var x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
					var y = 0.0;
					var z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
					var v = j === 0 || j === ls ? 0 : 1;
					positions.push(-x, y, z);
					normals.push(0.0, 1.0, 0.0);
					uvs.push(u, v);
					if (i < ws && j < ls) {
						indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
						indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
					}
					vcounter++;
				}
			}
			var geom = new Geometry();
			geom.positions = positions;
			geom.normals = normals;
			geom.uvs = uvs;
			geom.indices = indices;
			return Mesh.fromGeometry(this._device, geom);
		};
		_proto._onSetFrames = function _onSetFrames(frames) {
			if (this._updatingProperties) {
				this._meshesDirty = true;
			} else {
				this._createMeshes();
			}
		};
		_proto._onFrameChanged = function _onFrameChanged(frameKey, frame) {
			var idx = this._frameKeys.indexOf(frameKey);
			if (idx < 0) return;
			if (frame) {
				if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
					this._meshes[idx] = this._createSimpleMesh(frame);
				}
			} else {
				this._meshes[idx] = null;
			}
			this.fire('set:meshes');
		};
		_proto._onFrameRemoved = function _onFrameRemoved(frameKey) {
			var idx = this._frameKeys.indexOf(frameKey);
			if (idx < 0) return;
			this._meshes[idx] = null;
			this.fire('set:meshes');
		};
		_proto.startUpdate = function startUpdate() {
			this._updatingProperties = true;
			this._meshesDirty = false;
		};
		_proto.endUpdate = function endUpdate() {
			this._updatingProperties = false;
			if (this._meshesDirty && this._atlas && this._frameKeys) {
				this._createMeshes();
			}
			this._meshesDirty = false;
		};
		_proto.destroy = function destroy() {
			for (var _iterator = _createForOfIteratorHelperLoose(this._meshes), _step; !(_step = _iterator()).done;) {
				var mesh = _step.value;
				if (mesh) {
					mesh.destroy();
				}
			}
			this._meshes.length = 0;
		};
		return _createClass(Sprite, [{
			key: "frameKeys",
			get: function get() {
				return this._frameKeys;
			},
			set: function set(value) {
				this._frameKeys = value;
				if (this._atlas && this._frameKeys) {
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
				this.fire('set:frameKeys', value);
			}
		}, {
			key: "atlas",
			get: function get() {
				return this._atlas;
			},
			set: function set(value) {
				if (value === this._atlas) return;
				if (this._atlas) {
					this._atlas.off('set:frames', this._onSetFrames, this);
					this._atlas.off('set:frame', this._onFrameChanged, this);
					this._atlas.off('remove:frame', this._onFrameRemoved, this);
				}
				this._atlas = value;
				if (this._atlas && this._frameKeys) {
					this._atlas.on('set:frames', this._onSetFrames, this);
					this._atlas.on('set:frame', this._onFrameChanged, this);
					this._atlas.on('remove:frame', this._onFrameRemoved, this);
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
				this.fire('set:atlas', value);
			}
		}, {
			key: "pixelsPerUnit",
			get: function get() {
				return this._pixelsPerUnit;
			},
			set: function set(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;
				this.fire('set:pixelsPerUnit', value);
				if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
					if (this._updatingProperties) {
						this._meshesDirty = true;
					} else {
						this._createMeshes();
					}
				}
			}
		}, {
			key: "renderMode",
			get: function get() {
				return this._renderMode;
			},
			set: function set(value) {
				if (this._renderMode === value) {
					return;
				}
				var prev = this._renderMode;
				this._renderMode = value;
				this.fire('set:renderMode', value);
				if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
					if (this._atlas && this._frameKeys) {
						if (this._updatingProperties) {
							this._meshesDirty = true;
						} else {
							this._createMeshes();
						}
					}
				}
			}
		}, {
			key: "meshes",
			get: function get() {
				return this._meshes;
			}
		}]);
	}(EventHandler);

	var TextureAtlas = function (_EventHandler) {
		function TextureAtlas() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._texture = null;
			_this._frames = null;
			return _this;
		}
		_inheritsLoose(TextureAtlas, _EventHandler);
		var _proto = TextureAtlas.prototype;
		_proto.setFrame = function setFrame(key, data) {
			var frame = this._frames[key];
			if (!frame) {
				frame = {
					rect: data.rect.clone(),
					pivot: data.pivot.clone(),
					border: data.border.clone()
				};
				this._frames[key] = frame;
			} else {
				frame.rect.copy(data.rect);
				frame.pivot.copy(data.pivot);
				frame.border.copy(data.border);
			}
			this.fire('set:frame', key.toString(), frame);
		};
		_proto.removeFrame = function removeFrame(key) {
			var frame = this._frames[key];
			if (frame) {
				delete this._frames[key];
				this.fire('remove:frame', key.toString(), frame);
			}
		};
		_proto.destroy = function destroy() {
			if (this._texture) {
				this._texture.destroy();
			}
		};
		return _createClass(TextureAtlas, [{
			key: "texture",
			get: function get() {
				return this._texture;
			},
			set: function set(value) {
				this._texture = value;
				this.fire('set:texture', value);
			}
		}, {
			key: "frames",
			get: function get() {
				return this._frames;
			},
			set: function set(value) {
				this._frames = value;
				this.fire('set:frames', value);
			}
		}]);
	}(EventHandler);

	var Key = function Key(time, position, rotation, scale) {
		this.time = time;
		this.position = position;
		this.rotation = rotation;
		this.scale = scale;
	};
	var Node = function Node() {
		this._name = '';
		this._keys = [];
	};
	var Animation = function () {
		function Animation() {
			this.name = '';
			this.duration = 0;
			this._nodes = [];
			this._nodeDict = {};
		}
		var _proto = Animation.prototype;
		_proto.getNode = function getNode(name) {
			return this._nodeDict[name];
		};
		_proto.addNode = function addNode(node) {
			this._nodes.push(node);
			this._nodeDict[node._name] = node;
		};
		return _createClass(Animation, [{
			key: "nodes",
			get: function get() {
				return this._nodes;
			}
		}]);
	}();

	var InterpolatedKey = function () {
		function InterpolatedKey() {
			this._written = false;
			this._name = '';
			this._keyFrames = [];
			this._quat = new Quat();
			this._pos = new Vec3();
			this._scale = new Vec3();
			this._targetNode = null;
		}
		var _proto = InterpolatedKey.prototype;
		_proto.getTarget = function getTarget() {
			return this._targetNode;
		};
		_proto.setTarget = function setTarget(node) {
			this._targetNode = node;
		};
		return InterpolatedKey;
	}();
	var Skeleton = function () {
		function Skeleton(graph) {
			var _this = this;
			this.looping = true;
			this._animation = null;
			this._time = 0;
			this._interpolatedKeys = [];
			this._interpolatedKeyDict = {};
			this._currKeyIndices = {};
			this.graph = null;
			var _addInterpolatedKeys = function addInterpolatedKeys(node) {
				var interpKey = new InterpolatedKey();
				interpKey._name = node.name;
				_this._interpolatedKeys.push(interpKey);
				_this._interpolatedKeyDict[node.name] = interpKey;
				_this._currKeyIndices[node.name] = 0;
				for (var i = 0; i < node._children.length; i++) {
					_addInterpolatedKeys(node._children[i]);
				}
			};
			_addInterpolatedKeys(graph);
		}
		var _proto2 = Skeleton.prototype;
		_proto2.addTime = function addTime(delta) {
			if (this._animation !== null) {
				var nodes = this._animation._nodes;
				var duration = this._animation.duration;
				if (this._time === duration && !this.looping) {
					return;
				}
				this._time += delta;
				if (this._time > duration) {
					this._time = this.looping ? 0.0 : duration;
					for (var i = 0; i < nodes.length; i++) {
						var node = nodes[i];
						var nodeName = node._name;
						this._currKeyIndices[nodeName] = 0;
					}
				} else if (this._time < 0) {
					this._time = this.looping ? duration : 0.0;
					for (var _i = 0; _i < nodes.length; _i++) {
						var _node = nodes[_i];
						var _nodeName = _node._name;
						this._currKeyIndices[_nodeName] = _node._keys.length - 2;
					}
				}
				var offset = delta >= 0 ? 1 : -1;
				for (var _i2 = 0; _i2 < nodes.length; _i2++) {
					var _node2 = nodes[_i2];
					var _nodeName2 = _node2._name;
					var keys = _node2._keys;
					var interpKey = this._interpolatedKeyDict[_nodeName2];
					if (interpKey === undefined) {
						continue;
					}
					var foundKey = false;
					if (keys.length !== 1) {
						for (var currKeyIndex = this._currKeyIndices[_nodeName2]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
							var k1 = keys[currKeyIndex];
							var k2 = keys[currKeyIndex + 1];
							if (k1.time <= this._time && k2.time >= this._time) {
								var alpha = (this._time - k1.time) / (k2.time - k1.time);
								interpKey._pos.lerp(k1.position, k2.position, alpha);
								interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
								interpKey._scale.lerp(k1.scale, k2.scale, alpha);
								interpKey._written = true;
								this._currKeyIndices[_nodeName2] = currKeyIndex;
								foundKey = true;
								break;
							}
						}
					}
					if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
						interpKey._pos.copy(keys[0].position);
						interpKey._quat.copy(keys[0].rotation);
						interpKey._scale.copy(keys[0].scale);
						interpKey._written = true;
					}
				}
			}
		};
		_proto2.blend = function blend(skel1, skel2, alpha) {
			var numNodes = this._interpolatedKeys.length;
			for (var i = 0; i < numNodes; i++) {
				var key1 = skel1._interpolatedKeys[i];
				var key2 = skel2._interpolatedKeys[i];
				var dstKey = this._interpolatedKeys[i];
				if (key1._written && key2._written) {
					dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
					dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
					dstKey._scale.lerp(key1._scale, key2._scale, alpha);
					dstKey._written = true;
				} else if (key1._written) {
					dstKey._quat.copy(key1._quat);
					dstKey._pos.copy(key1._pos);
					dstKey._scale.copy(key1._scale);
					dstKey._written = true;
				} else if (key2._written) {
					dstKey._quat.copy(key2._quat);
					dstKey._pos.copy(key2._pos);
					dstKey._scale.copy(key2._scale);
					dstKey._written = true;
				}
			}
		};
		_proto2.setGraph = function setGraph(graph) {
			this.graph = graph;
			if (graph) {
				for (var i = 0; i < this._interpolatedKeys.length; i++) {
					var interpKey = this._interpolatedKeys[i];
					var graphNode = graph.findByName(interpKey._name);
					this._interpolatedKeys[i].setTarget(graphNode);
				}
			} else {
				for (var _i3 = 0; _i3 < this._interpolatedKeys.length; _i3++) {
					this._interpolatedKeys[_i3].setTarget(null);
				}
			}
		};
		_proto2.updateGraph = function updateGraph() {
			if (this.graph) {
				for (var i = 0; i < this._interpolatedKeys.length; i++) {
					var interpKey = this._interpolatedKeys[i];
					if (interpKey._written) {
						var transform = interpKey.getTarget();
						transform.localPosition.copy(interpKey._pos);
						transform.localRotation.copy(interpKey._quat);
						transform.localScale.copy(interpKey._scale);
						if (!transform._dirtyLocal) {
							transform._dirtifyLocal();
						}
						interpKey._written = false;
					}
				}
			}
		};
		return _createClass(Skeleton, [{
			key: "animation",
			get: function get() {
				return this._animation;
			},
			set: function set(value) {
				this._animation = value;
				this.currentTime = 0;
			}
		}, {
			key: "currentTime",
			get: function get() {
				return this._time;
			},
			set: function set(value) {
				this._time = value;
				var numNodes = this._interpolatedKeys.length;
				for (var i = 0; i < numNodes; i++) {
					var node = this._interpolatedKeys[i];
					var nodeName = node._name;
					this._currKeyIndices[nodeName] = 0;
				}
				this.addTime(0);
				this.updateGraph();
			}
		}, {
			key: "numNodes",
			get: function get() {
				return this._interpolatedKeys.length;
			}
		}]);
	}();

	var _viewport$1 = new Vec4();
	var PostEffect = function () {
		function PostEffect(graphicsDevice) {
			this.device = graphicsDevice;
			this.needsDepthBuffer = false;
		}
		var _proto = PostEffect.prototype;
		_proto.render = function render(inputTarget, outputTarget, rect) {};
		_proto.drawQuad = function drawQuad(target, shader, rect) {
			var viewport;
			if (rect) {
				var w = target ? target.width : this.device.width;
				var h = target ? target.height : this.device.height;
				viewport = _viewport$1.set(rect.x * w, rect.y * h, rect.z * w, rect.w * h);
			}
			this.device.setBlendState(BlendState.NOBLEND);
			drawQuadWithShader(this.device, target, shader, viewport);
		};
		return PostEffect;
	}();
	PostEffect.quadVertexShader = "\n        attribute vec2 aPosition;\n        varying vec2 vUv0;\n        void main(void)\n        {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            vUv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);\n        }\n    ";

	var RenderPassShaderQuad = function (_RenderPass) {
		function RenderPassShaderQuad() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
			_this._shader = null;
			_this.quadRender = null;
			_this.cullMode = CULLFACE_NONE;
			_this.blendState = BlendState.NOBLEND;
			_this.depthState = DepthState.NODEPTH;
			_this.stencilFront = null;
			_this.stencilBack = null;
			return _this;
		}
		_inheritsLoose(RenderPassShaderQuad, _RenderPass);
		var _proto = RenderPassShaderQuad.prototype;
		_proto.createQuadShader = function createQuadShader(name, fs, shaderDefinitionOptions) {
			if (shaderDefinitionOptions === void 0) {
				shaderDefinitionOptions = {};
			}
			return createShaderFromCode(this.device, RenderPassShaderQuad.quadVertexShader, fs, name, {
				aPosition: SEMANTIC_POSITION
			}, shaderDefinitionOptions);
		};
		_proto.execute = function execute() {
			var device = this.device;
			device.setBlendState(this.blendState);
			device.setCullMode(this.cullMode);
			device.setDepthState(this.depthState);
			device.setStencilState(this.stencilFront, this.stencilBack);
			this.quadRender.render();
		};
		return _createClass(RenderPassShaderQuad, [{
			key: "shader",
			get: function get() {
				return this._shader;
			},
			set: function set(shader) {
				var _this$quadRender;
				(_this$quadRender = this.quadRender) == null || _this$quadRender.destroy();
				this.quadRender = null;
				this._shader = shader;
				if (shader) {
					this.quadRender = new QuadRender(shader);
				}
			}
		}]);
	}(RenderPass);
	RenderPassShaderQuad.quadVertexShader = "\n        attribute vec2 aPosition;\n        varying vec2 uv0;\n        void main(void)\n        {\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n            uv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);\n        }\n    ";

	var LitMaterialOptions = function LitMaterialOptions() {
		this.usedUvs = void 0;
		this.shaderChunk = void 0;
		this.litOptions = new LitShaderOptions();
	};

	var dummyUvs = [0, 1, 2, 3, 4, 5, 6, 7];
	var ShaderGeneratorLit = function (_ShaderGenerator) {
		function ShaderGeneratorLit() {
			return _ShaderGenerator.apply(this, arguments) || this;
		}
		_inheritsLoose(ShaderGeneratorLit, _ShaderGenerator);
		var _proto = ShaderGeneratorLit.prototype;
		_proto.generateKey = function generateKey(options) {
			var definesHash = ShaderGenerator.definesHash(options.defines);
			var key = "lit_" + definesHash + "_" + dummyUvs.map(function (dummy, index) {
				return options.usedUvs[index] ? '1' : '0';
			}).join('') + options.shaderChunk + LitOptionsUtils.generateKey(options.litOptions);
			return key;
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var litShader = new LitShader(device, options.litOptions);
			var decl = new ChunkBuilder();
			var code = new ChunkBuilder();
			var func = new ChunkBuilder();
			decl.append('uniform float textureBias;');
			decl.append(litShader.chunks.litShaderArgsPS);
			code.append(options.shaderChunk);
			func.code = 'evaluateFrontend();';
			func.code = "\n" + func.code.split('\n').map(function (l) {
				return "    " + l;
			}).join('\n') + "\n\n";
			var usedUvSets = options.usedUvs || [true];
			var mapTransforms = [];
			litShader.generateVertexShader(usedUvSets, usedUvSets, mapTransforms);
			litShader.generateFragmentShader(decl.code, code.code, func.code, 'vUv0');
			return litShader.getDefinition(options);
		};
		return ShaderGeneratorLit;
	}(ShaderGenerator);
	var lit = new ShaderGeneratorLit();

	var options = new LitMaterialOptions();
	var LitMaterial = function (_Material) {
		function LitMaterial() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Material.call.apply(_Material, [this].concat(args)) || this;
			_this.usedUvs = [true];
			_this.shaderChunk = 'void evaluateFrontend() {}\n';
			_this.chunks = null;
			_this.useLighting = true;
			_this.useFog = true;
			_this.useTonemap = true;
			_this.useSkybox = true;
			_this.ambientSH = null;
			_this.pixelSnap = false;
			_this.nineSlicedMode = null;
			_this.twoSidedLighting = false;
			_this.occludeDirect = false;
			_this.occludeSpecular = SPECOCC_AO;
			_this.occludeSpecularIntensity = 1;
			_this.opacityFadesSpecular = true;
			_this.opacityDither = DITHER_NONE;
			_this.opacityShadowDither = DITHER_NONE;
			_this.ggxSpecular = false;
			_this.fresnelModel = FRESNEL_SCHLICK;
			_this.dynamicRefraction = false;
			_this.hasAo = false;
			_this.hasSpecular = false;
			_this.hasSpecularityFactor = false;
			_this.hasLighting = false;
			_this.hasHeights = false;
			_this.hasNormals = false;
			_this.hasSheen = false;
			_this.hasRefraction = false;
			_this.hasIrridescence = false;
			_this.hasMetalness = false;
			_this.hasClearCoat = false;
			_this.hasClearCoatNormals = false;
			return _this;
		}
		_inheritsLoose(LitMaterial, _Material);
		var _proto = LitMaterial.prototype;
		_proto.getShaderVariant = function getShaderVariant(params) {
			var cameraShaderParams = params.cameraShaderParams;
			options.usedUvs = this.usedUvs.slice();
			options.shaderChunk = this.shaderChunk;
			options.defines = getMaterialShaderDefines(this, cameraShaderParams);
			LitMaterialOptionsBuilder.update(options.litOptions, this, params.scene, params.cameraShaderParams, params.objDefs, params.pass, params.sortedLights);
			var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
			var library = getProgramLibrary(params.device);
			library.register('lit', lit);
			var shader = library.getProgram('lit', options, processingOptions, this.userId);
			return shader;
		};
		return LitMaterial;
	}(Material);

	var primitiveUv1Padding = 4.0 / 64;
	var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
	var ConeBaseGeometry = function (_Geometry) {
		function ConeBaseGeometry(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
			var _this;
			_this = _Geometry.call(this) || this;
			var pos = new Vec3();
			var bottomToTop = new Vec3();
			var norm = new Vec3();
			var top = new Vec3();
			var bottom = new Vec3();
			var tangent = new Vec3();
			var positions = [];
			var normals = [];
			var uvs = [];
			var uvs1 = [];
			var indices = [];
			var offset;
			if (height > 0) {
				for (var i = 0; i <= heightSegments; i++) {
					for (var j = 0; j <= capSegments; j++) {
						var theta = j / capSegments * 2 * Math.PI - Math.PI;
						var sinTheta = Math.sin(theta);
						var cosTheta = Math.cos(theta);
						bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
						top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
						pos.lerp(bottom, top, i / heightSegments);
						bottomToTop.sub2(top, bottom).normalize();
						tangent.set(cosTheta, 0, -sinTheta);
						norm.cross(tangent, bottomToTop).normalize();
						positions.push(pos.x, pos.y, pos.z);
						normals.push(norm.x, norm.y, norm.z);
						var u = j / capSegments;
						var v = i / heightSegments;
						uvs.push(u, 1 - v);
						var _v = v;
						v = u;
						u = _v;
						u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
						v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
						u /= 3;
						uvs1.push(u, 1 - v);
						if (i < heightSegments && j < capSegments) {
							var first = i * (capSegments + 1) + j;
							var second = i * (capSegments + 1) + (j + 1);
							var third = (i + 1) * (capSegments + 1) + j;
							var fourth = (i + 1) * (capSegments + 1) + (j + 1);
							indices.push(first, second, third);
							indices.push(second, fourth, third);
						}
					}
				}
			}
			if (roundedCaps) {
				var latitudeBands = Math.floor(capSegments / 2);
				var longitudeBands = capSegments;
				var capOffset = height / 2;
				for (var lat = 0; lat <= latitudeBands; lat++) {
					var _theta = lat * Math.PI * 0.5 / latitudeBands;
					var _sinTheta = Math.sin(_theta);
					var _cosTheta = Math.cos(_theta);
					for (var lon = 0; lon <= longitudeBands; lon++) {
						var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
						var sinPhi = Math.sin(phi);
						var cosPhi = Math.cos(phi);
						var x = cosPhi * _sinTheta;
						var y = _cosTheta;
						var z = sinPhi * _sinTheta;
						var _u = 1 - lon / longitudeBands;
						var _v2 = 1 - lat / latitudeBands;
						positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
						normals.push(x, y, z);
						uvs.push(_u, 1 - _v2);
						_u = _u * primitiveUv1PaddingScale + primitiveUv1Padding;
						_v2 = _v2 * primitiveUv1PaddingScale + primitiveUv1Padding;
						_u /= 3;
						_v2 /= 3;
						_u += 1.0 / 3;
						uvs1.push(_u, 1 - _v2);
					}
				}
				offset = (heightSegments + 1) * (capSegments + 1);
				for (var _lat = 0; _lat < latitudeBands; ++_lat) {
					for (var _lon = 0; _lon < longitudeBands; ++_lon) {
						var _first = _lat * (longitudeBands + 1) + _lon;
						var _second = _first + longitudeBands + 1;
						indices.push(offset + _first + 1, offset + _second, offset + _first);
						indices.push(offset + _first + 1, offset + _second + 1, offset + _second);
					}
				}
				for (var _lat2 = 0; _lat2 <= latitudeBands; _lat2++) {
					var _theta2 = Math.PI * 0.5 + _lat2 * Math.PI * 0.5 / latitudeBands;
					var _sinTheta2 = Math.sin(_theta2);
					var _cosTheta2 = Math.cos(_theta2);
					for (var _lon2 = 0; _lon2 <= longitudeBands; _lon2++) {
						var _phi = _lon2 * 2 * Math.PI / longitudeBands - Math.PI / 2;
						var _sinPhi = Math.sin(_phi);
						var _cosPhi = Math.cos(_phi);
						var _x = _cosPhi * _sinTheta2;
						var _y = _cosTheta2;
						var _z = _sinPhi * _sinTheta2;
						var _u2 = 1 - _lon2 / longitudeBands;
						var _v3 = 1 - _lat2 / latitudeBands;
						positions.push(_x * peakRadius, _y * peakRadius - capOffset, _z * peakRadius);
						normals.push(_x, _y, _z);
						uvs.push(_u2, 1 - _v3);
						_u2 = _u2 * primitiveUv1PaddingScale + primitiveUv1Padding;
						_v3 = _v3 * primitiveUv1PaddingScale + primitiveUv1Padding;
						_u2 /= 3;
						_v3 /= 3;
						_u2 += 2.0 / 3;
						uvs1.push(_u2, 1 - _v3);
					}
				}
				offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
				for (var _lat3 = 0; _lat3 < latitudeBands; ++_lat3) {
					for (var _lon3 = 0; _lon3 < longitudeBands; ++_lon3) {
						var _first2 = _lat3 * (longitudeBands + 1) + _lon3;
						var _second2 = _first2 + longitudeBands + 1;
						indices.push(offset + _first2 + 1, offset + _second2, offset + _first2);
						indices.push(offset + _first2 + 1, offset + _second2 + 1, offset + _second2);
					}
				}
			} else {
				offset = (heightSegments + 1) * (capSegments + 1);
				if (baseRadius > 0) {
					for (var _i = 0; _i < capSegments; _i++) {
						var _theta3 = _i / capSegments * 2 * Math.PI;
						var _x2 = Math.sin(_theta3);
						var _y2 = -height / 2;
						var _z2 = Math.cos(_theta3);
						var _u3 = 1 - (_x2 + 1) / 2;
						var _v4 = (_z2 + 1) / 2;
						positions.push(_x2 * baseRadius, _y2, _z2 * baseRadius);
						normals.push(0, -1, 0);
						uvs.push(_u3, 1 - _v4);
						_u3 = _u3 * primitiveUv1PaddingScale + primitiveUv1Padding;
						_v4 = _v4 * primitiveUv1PaddingScale + primitiveUv1Padding;
						_u3 /= 3;
						_v4 /= 3;
						_u3 += 1 / 3;
						uvs1.push(_u3, 1 - _v4);
						if (_i > 1) {
							indices.push(offset, offset + _i, offset + _i - 1);
						}
					}
				}
				offset += capSegments;
				if (peakRadius > 0) {
					for (var _i2 = 0; _i2 < capSegments; _i2++) {
						var _theta4 = _i2 / capSegments * 2 * Math.PI;
						var _x3 = Math.sin(_theta4);
						var _y3 = height / 2;
						var _z3 = Math.cos(_theta4);
						var _u4 = 1 - (_x3 + 1) / 2;
						var _v5 = (_z3 + 1) / 2;
						positions.push(_x3 * peakRadius, _y3, _z3 * peakRadius);
						normals.push(0, 1, 0);
						uvs.push(_u4, 1 - _v5);
						_u4 = _u4 * primitiveUv1PaddingScale + primitiveUv1Padding;
						_v5 = _v5 * primitiveUv1PaddingScale + primitiveUv1Padding;
						_u4 /= 3;
						_v5 /= 3;
						_u4 += 2 / 3;
						uvs1.push(_u4, 1 - _v5);
						if (_i2 > 1) {
							indices.push(offset, offset + _i2 - 1, offset + _i2);
						}
					}
				}
			}
			_this.positions = positions;
			_this.normals = normals;
			_this.uvs = uvs;
			_this.uvs1 = uvs1;
			_this.indices = indices;
			return _this;
		}
		_inheritsLoose(ConeBaseGeometry, _Geometry);
		return ConeBaseGeometry;
	}(Geometry);

	var CapsuleGeometry = function (_ConeBaseGeometry) {
		function CapsuleGeometry(opts) {
			var _opts$radius, _opts$height, _opts$heightSegments, _opts$sides;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			var radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.3;
			var height = (_opts$height = opts.height) != null ? _opts$height : 1;
			var heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 1;
			var sides = (_opts$sides = opts.sides) != null ? _opts$sides : 20;
			_this = _ConeBaseGeometry.call(this, radius, radius, height - 2 * radius, heightSegments, sides, true) || this;
			if (opts.calculateTangents) {
				_this.tangents = calculateTangents(_this.positions, _this.normals, _this.uvs, _this.indices);
			}
			return _this;
		}
		_inheritsLoose(CapsuleGeometry, _ConeBaseGeometry);
		return CapsuleGeometry;
	}(ConeBaseGeometry);

	var ConeGeometry = function (_ConeBaseGeometry) {
		function ConeGeometry(opts) {
			var _opts$baseRadius, _opts$peakRadius, _opts$height, _opts$heightSegments, _opts$capSegments;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			var baseRadius = (_opts$baseRadius = opts.baseRadius) != null ? _opts$baseRadius : 0.5;
			var peakRadius = (_opts$peakRadius = opts.peakRadius) != null ? _opts$peakRadius : 0;
			var height = (_opts$height = opts.height) != null ? _opts$height : 1;
			var heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 5;
			var capSegments = (_opts$capSegments = opts.capSegments) != null ? _opts$capSegments : 18;
			_this = _ConeBaseGeometry.call(this, baseRadius, peakRadius, height, heightSegments, capSegments, false) || this;
			if (opts.calculateTangents) {
				_this.tangents = calculateTangents(_this.positions, _this.normals, _this.uvs, _this.indices);
			}
			return _this;
		}
		_inheritsLoose(ConeGeometry, _ConeBaseGeometry);
		return ConeGeometry;
	}(ConeBaseGeometry);

	var CylinderGeometry = function (_ConeBaseGeometry) {
		function CylinderGeometry(opts) {
			var _opts$radius, _opts$height, _opts$heightSegments, _opts$capSegments;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			var radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.5;
			var height = (_opts$height = opts.height) != null ? _opts$height : 1;
			var heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 5;
			var capSegments = (_opts$capSegments = opts.capSegments) != null ? _opts$capSegments : 20;
			_this = _ConeBaseGeometry.call(this, radius, radius, height, heightSegments, capSegments, false) || this;
			if (opts.calculateTangents) {
				_this.tangents = calculateTangents(_this.positions, _this.normals, _this.uvs, _this.indices);
			}
			return _this;
		}
		_inheritsLoose(CylinderGeometry, _ConeBaseGeometry);
		return CylinderGeometry;
	}(ConeBaseGeometry);

	var PlaneGeometry = function (_Geometry) {
		function PlaneGeometry(opts) {
			var _opts$halfExtents, _opts$widthSegments, _opts$lengthSegments;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			_this = _Geometry.call(this) || this;
			var he = (_opts$halfExtents = opts.halfExtents) != null ? _opts$halfExtents : new Vec2(0.5, 0.5);
			var ws = (_opts$widthSegments = opts.widthSegments) != null ? _opts$widthSegments : 5;
			var ls = (_opts$lengthSegments = opts.lengthSegments) != null ? _opts$lengthSegments : 5;
			var positions = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var vcounter = 0;
			for (var i = 0; i <= ws; i++) {
				for (var j = 0; j <= ls; j++) {
					var x = -he.x + 2 * he.x * i / ws;
					var y = 0.0;
					var z = -(-he.y + 2 * he.y * j / ls);
					var u = i / ws;
					var v = j / ls;
					positions.push(x, y, z);
					normals.push(0, 1, 0);
					uvs.push(u, 1 - v);
					if (i < ws && j < ls) {
						indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
						indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
					}
					vcounter++;
				}
			}
			_this.positions = positions;
			_this.normals = normals;
			_this.uvs = uvs;
			_this.uvs1 = uvs;
			_this.indices = indices;
			if (opts.calculateTangents) {
				_this.tangents = calculateTangents(positions, normals, uvs, indices);
			}
			return _this;
		}
		_inheritsLoose(PlaneGeometry, _Geometry);
		return PlaneGeometry;
	}(Geometry);

	var TorusGeometry = function (_Geometry) {
		function TorusGeometry(opts) {
			var _opts$tubeRadius, _opts$ringRadius, _opts$sectorAngle, _opts$segments, _opts$sides;
			var _this;
			if (opts === void 0) {
				opts = {};
			}
			_this = _Geometry.call(this) || this;
			var rc = (_opts$tubeRadius = opts.tubeRadius) != null ? _opts$tubeRadius : 0.2;
			var rt = (_opts$ringRadius = opts.ringRadius) != null ? _opts$ringRadius : 0.3;
			var sectorAngle = ((_opts$sectorAngle = opts.sectorAngle) != null ? _opts$sectorAngle : 360) * math.DEG_TO_RAD;
			var segments = (_opts$segments = opts.segments) != null ? _opts$segments : 30;
			var sides = (_opts$sides = opts.sides) != null ? _opts$sides : 20;
			var positions = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			for (var i = 0; i <= sides; i++) {
				for (var j = 0; j <= segments; j++) {
					var x = Math.cos(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
					var y = Math.sin(2 * Math.PI * i / sides) * rc;
					var z = Math.sin(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
					var nx = Math.cos(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
					var ny = Math.sin(2 * Math.PI * i / sides);
					var nz = Math.sin(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
					var u = i / sides;
					var v = 1 - j / segments;
					positions.push(x, y, z);
					normals.push(nx, ny, nz);
					uvs.push(u, 1.0 - v);
					if (i < sides && j < segments) {
						var first = i * (segments + 1) + j;
						var second = (i + 1) * (segments + 1) + j;
						var third = i * (segments + 1) + (j + 1);
						var fourth = (i + 1) * (segments + 1) + (j + 1);
						indices.push(first, second, third);
						indices.push(second, fourth, third);
					}
				}
			}
			_this.positions = positions;
			_this.normals = normals;
			_this.uvs = uvs;
			_this.uvs1 = uvs;
			_this.indices = indices;
			if (opts.calculateTangents) {
				_this.tangents = calculateTangents(positions, normals, uvs, indices);
			}
			return _this;
		}
		_inheritsLoose(TorusGeometry, _Geometry);
		return TorusGeometry;
	}(Geometry);

	var ProgramLibrary = function () {
		function ProgramLibrary(device, standardMaterial) {
			var _this = this;
			this.processedCache = new Map();
			this.definitionsCache = new Map();
			this._generators = new Map();
			this._device = device;
			this._isClearingCache = false;
			this._precached = false;
			this._programsCollection = [];
			this._defaultStdMatOption = new StandardMaterialOptions();
			this._defaultStdMatOptionMin = new StandardMaterialOptions();
			var defaultCameraShaderParams = new CameraShaderParams();
			standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, defaultCameraShaderParams, standardMaterial, null, [], SHADER_FORWARD, null);
			standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, SHADER_SHADOW, null);
			device.on('destroy:shader', function (shader) {
				_this.removeFromCache(shader);
			});
		}
		var _proto = ProgramLibrary.prototype;
		_proto.destroy = function destroy() {
			this.clearCache();
		};
		_proto.register = function register(name, generator) {
			if (!this._generators.has(name)) {
				this._generators.set(name, generator);
			}
		};
		_proto.unregister = function unregister(name) {
			if (this._generators.has(name)) {
				this._generators.delete(name);
			}
		};
		_proto.isRegistered = function isRegistered(name) {
			return this._generators.has(name);
		};
		_proto.generateShaderDefinition = function generateShaderDefinition(generator, name, key, options) {
			var def = this.definitionsCache.get(key);
			if (!def) {
				var _options$litOptions, _options$litOptions2, _def$name;
				var lights;
				if ((_options$litOptions = options.litOptions) != null && _options$litOptions.lights) {
					lights = options.litOptions.lights;
					options.litOptions.lights = lights.map(function (l) {
						var lcopy = l.clone ? l.clone() : l;
						lcopy.key = l.key;
						return lcopy;
					});
				}
				this.storeNewProgram(name, options);
				if ((_options$litOptions2 = options.litOptions) != null && _options$litOptions2.lights) {
					options.litOptions.lights = lights;
				}
				if (this._precached) ;
				var device = this._device;
				def = generator.createShaderDefinition(device, options);
				def.name = (_def$name = def.name) != null ? _def$name : options.pass ? name + "-pass:" + options.pass : name;
				this.definitionsCache.set(key, def);
			}
			return def;
		};
		_proto.getCachedShader = function getCachedShader(key) {
			return this.processedCache.get(key);
		};
		_proto.setCachedShader = function setCachedShader(key, shader) {
			this.processedCache.set(key, shader);
		};
		_proto.getProgram = function getProgram(name, options, processingOptions, userMaterialId) {
			var generator = this._generators.get(name);
			if (!generator) {
				return null;
			}
			var generationKeyString = generator.generateKey(options);
			var generationKey = hashCode(generationKeyString);
			var processingKeyString = processingOptions.generateKey(this._device);
			var processingKey = hashCode(processingKeyString);
			var totalKey = generationKey + "#" + processingKey;
			var processedShader = this.getCachedShader(totalKey);
			if (!processedShader) {
				var generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options);
				var passName = '';
				var shaderPassInfo;
				if (options.pass !== undefined) {
					shaderPassInfo = ShaderPass.get(this._device).getByIndex(options.pass);
					passName = "-" + shaderPassInfo.name;
				}
				this._device.fire('shader:generate', {
					userMaterialId: userMaterialId,
					shaderPassInfo: shaderPassInfo,
					definition: generatedShaderDef
				});
				var shaderDefinition = {
					name: "" + generatedShaderDef.name + passName + "-proc",
					attributes: generatedShaderDef.attributes,
					vshader: generatedShaderDef.vshader,
					vincludes: generatedShaderDef.vincludes,
					fincludes: generatedShaderDef.fincludes,
					fshader: generatedShaderDef.fshader,
					processingOptions: processingOptions,
					shaderLanguage: generatedShaderDef.shaderLanguage,
					meshUniformBufferFormat: generatedShaderDef.meshUniformBufferFormat,
					meshBindGroupFormat: generatedShaderDef.meshBindGroupFormat
				};
				processedShader = new Shader(this._device, shaderDefinition);
				this.setCachedShader(totalKey, processedShader);
			}
			return processedShader;
		};
		_proto.storeNewProgram = function storeNewProgram(name, options) {
			var opt = {};
			if (name === 'standard') {
				var defaultMat = this._getDefaultStdMatOptions(options.pass);
				for (var p in options) {
					if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === 'pass') {
						opt[p] = options[p];
					}
				}
				for (var _p in options.litOptions) {
					opt[_p] = options.litOptions[_p];
				}
			} else {
				opt = options;
			}
			this._programsCollection.push(JSON.stringify({
				name: name,
				options: opt
			}));
		};
		_proto.dumpPrograms = function dumpPrograms() {
			var text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
			text += 'let shaders = [';
			if (this._programsCollection[0]) {
				text += "\n\t" + this._programsCollection[0];
			}
			for (var i = 1; i < this._programsCollection.length; ++i) {
				text += ",\n\t" + this._programsCollection[i];
			}
			text += '\n];\n';
			text += 'pc.getProgramLibrary(device).precompile(shaders);\n';
			text += "if (pc.version != \"" + version + "\" || pc.revision != \"" + revision + "\")\n";
			text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
			var element = document.createElement('a');
			element.setAttribute('href', "data:text/plain;charset=utf-8," + encodeURIComponent(text));
			element.setAttribute('download', 'precompile-shaders.js');
			element.style.display = 'none';
			document.body.appendChild(element);
			element.click();
			document.body.removeChild(element);
		};
		_proto.clearCache = function clearCache() {
			this._isClearingCache = true;
			this.processedCache.forEach(function (shader) {
				shader.destroy();
			});
			this.processedCache.clear();
			this._isClearingCache = false;
		};
		_proto.removeFromCache = function removeFromCache(shader) {
			var _this2 = this;
			if (this._isClearingCache) {
				return;
			}
			this.processedCache.forEach(function (cachedShader, key) {
				if (shader === cachedShader) {
					_this2.processedCache.delete(key);
				}
			});
		};
		_proto._getDefaultStdMatOptions = function _getDefaultStdMatOptions(pass) {
			var shaderPassInfo = ShaderPass.get(this._device).getByIndex(pass);
			return pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS || shaderPassInfo.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
		};
		_proto.precompile = function precompile(cache) {
			if (cache) {
				var shaders = new Array(cache.length);
				for (var i = 0; i < cache.length; i++) {
					if (cache[i].name === 'standard') {
						var opt = cache[i].options;
						var defaultMat = this._getDefaultStdMatOptions(opt.pass);
						for (var p in defaultMat) {
							if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) {
								opt[p] = defaultMat[p];
							}
						}
					}
					shaders[i] = this.getProgram(cache[i].name, cache[i].options);
				}
			}
			this._precached = true;
		};
		return ProgramLibrary;
	}();

	var bakeDirLmEndPS = "\n\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n";

	var bakeLmEndPS = "\n#ifdef LIGHTMAP_RGBM\n\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n#else\n\tgl_FragColor = vec4(dDiffuseLight, 1.0);\n#endif\n";

	var dilatePS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2DLod(source, vUv0, 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 - pixelOffset, 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 + vec2(0, pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLod(source, vUv0 + pixelOffset, 0.0);\n\tgl_FragColor = c;\n}\n";

	var bilateralDeNoisePS = "\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n\t\n\tvec4 pixelRgbm = texture2DLod(source, vUv0, 0.0);\n\tif (pixelRgbm.a <= 0.0) {\n\t\tgl_FragColor = pixelRgbm;\n\t\treturn ;\n\t}\n\tfloat sigma = sigmas.x;\n\tfloat bSigma = sigmas.y;\n\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\tvec3 accumulatedHdr = vec3(0.0);\n\tfloat accumulatedFactor = 0.0;\n\tconst int kSize = (MSIZE-1)/2;\n\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\t\n\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\tvec4 rgbm = texture2DLod(source, coord, 0.0);\n\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\taccumulatedFactor += factor;\n\t\t\t}\n\t\t}\n\t}\n\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n";

	var shaderChunksLightmapper = {
		bakeDirLmEndPS: bakeDirLmEndPS,
		bakeLmEndPS: bakeLmEndPS,
		dilatePS: dilatePS,
		bilateralDeNoisePS: bilateralDeNoisePS
	};

	var mat4$1 = new Mat4();
	var quat$2 = new Quat();
	var aabb = new BoundingBox();
	var aabb2 = new BoundingBox();
	var debugColor = new Color(1, 1, 0, 0.4);
	var SH_C0$1 = 0.28209479177387814;
	var SplatIterator = function SplatIterator(gsplatData, p, r, s, c) {
		var x = gsplatData.getProp('x');
		var y = gsplatData.getProp('y');
		var z = gsplatData.getProp('z');
		var rx = gsplatData.getProp('rot_1');
		var ry = gsplatData.getProp('rot_2');
		var rz = gsplatData.getProp('rot_3');
		var rw = gsplatData.getProp('rot_0');
		var sx = gsplatData.getProp('scale_0');
		var sy = gsplatData.getProp('scale_1');
		var sz = gsplatData.getProp('scale_2');
		var cr = gsplatData.getProp('f_dc_0');
		var cg = gsplatData.getProp('f_dc_1');
		var cb = gsplatData.getProp('f_dc_2');
		var ca = gsplatData.getProp('opacity');
		var sigmoid = function sigmoid(v) {
			if (v > 0) {
				return 1 / (1 + Math.exp(-v));
			}
			var t = Math.exp(v);
			return t / (1 + t);
		};
		this.read = function (i) {
			if (p) {
				p.x = x[i];
				p.y = y[i];
				p.z = z[i];
			}
			if (r) {
				r.set(rx[i], ry[i], rz[i], rw[i]);
			}
			if (s) {
				s.set(Math.exp(sx[i]), Math.exp(sy[i]), Math.exp(sz[i]));
			}
			if (c) {
				c.set(0.5 + cr[i] * SH_C0$1, 0.5 + cg[i] * SH_C0$1, 0.5 + cb[i] * SH_C0$1, sigmoid(ca[i]));
			}
		};
	};
	var calcSplatMat = function calcSplatMat(result, p, r) {
		quat$2.set(r.x, r.y, r.z, r.w).normalize();
		result.setTRS(p, quat$2, Vec3.ONE);
	};
	var GSplatData = function () {
		function GSplatData(elements) {
			this.elements = void 0;
			this.numSplats = void 0;
			this.elements = elements;
			this.numSplats = this.getElement('vertex').count;
		}
		GSplatData.calcSplatAabb = function calcSplatAabb(result, p, r, s) {
			calcSplatMat(mat4$1, p, r);
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(s.x * 2, s.y * 2, s.z * 2);
			result.setFromTransformedAabb(aabb, mat4$1);
		};
		var _proto = GSplatData.prototype;
		_proto.getProp = function getProp(name, elementName) {
			var _this$getElement;
			if (elementName === void 0) {
				elementName = 'vertex';
			}
			return (_this$getElement = this.getElement(elementName)) == null || (_this$getElement = _this$getElement.properties.find(function (p) {
				return p.name === name;
			})) == null ? void 0 : _this$getElement.storage;
		};
		_proto.getElement = function getElement(name) {
			return this.elements.find(function (e) {
				return e.name === name;
			});
		};
		_proto.addProp = function addProp(name, storage) {
			this.getElement('vertex').properties.push({
				type: 'float',
				name: name,
				storage: storage,
				byteSize: 4
			});
		};
		_proto.createIter = function createIter(p, r, s, c) {
			return new SplatIterator(this, p, r, s, c);
		};
		_proto.calcAabb = function calcAabb(result, pred) {
			var mx, my, mz, Mx, My, Mz;
			var first = true;
			var x = this.getProp('x');
			var y = this.getProp('y');
			var z = this.getProp('z');
			var sx = this.getProp('scale_0');
			var sy = this.getProp('scale_1');
			var sz = this.getProp('scale_2');
			for (var i = 0; i < this.numSplats; ++i) {
				if (pred && !pred(i)) {
					continue;
				}
				var scaleVal = 2.0 * Math.exp(Math.max(sx[i], sy[i], sz[i]));
				var px = x[i];
				var py = y[i];
				var pz = z[i];
				if (first) {
					first = false;
					mx = px - scaleVal;
					my = py - scaleVal;
					mz = pz - scaleVal;
					Mx = px + scaleVal;
					My = py + scaleVal;
					Mz = pz + scaleVal;
				} else {
					mx = Math.min(mx, px - scaleVal);
					my = Math.min(my, py - scaleVal);
					mz = Math.min(mz, pz - scaleVal);
					Mx = Math.max(Mx, px + scaleVal);
					My = Math.max(My, py + scaleVal);
					Mz = Math.max(Mz, pz + scaleVal);
				}
			}
			if (!first) {
				result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
				result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
			}
			return !first;
		};
		_proto.calcAabbExact = function calcAabbExact(result, pred) {
			var p = new Vec3();
			var r = new Quat();
			var s = new Vec3();
			var iter = this.createIter(p, r, s);
			var first = true;
			for (var i = 0; i < this.numSplats; ++i) {
				if (pred && !pred(i)) {
					continue;
				}
				iter.read(i);
				if (first) {
					first = false;
					GSplatData.calcSplatAabb(result, p, r, s);
				} else {
					GSplatData.calcSplatAabb(aabb2, p, r, s);
					result.add(aabb2);
				}
			}
			return !first;
		};
		_proto.getCenters = function getCenters(result) {
			var x = this.getProp('x');
			var y = this.getProp('y');
			var z = this.getProp('z');
			for (var i = 0; i < this.numSplats; ++i) {
				result[i * 3 + 0] = x[i];
				result[i * 3 + 1] = y[i];
				result[i * 3 + 2] = z[i];
			}
		};
		_proto.calcFocalPoint = function calcFocalPoint(result, pred) {
			var x = this.getProp('x');
			var y = this.getProp('y');
			var z = this.getProp('z');
			var sx = this.getProp('scale_0');
			var sy = this.getProp('scale_1');
			var sz = this.getProp('scale_2');
			result.x = 0;
			result.y = 0;
			result.z = 0;
			var sum = 0;
			for (var i = 0; i < this.numSplats; ++i) {
				if (pred && !pred(i)) {
					continue;
				}
				var weight = 1.0 / (1.0 + Math.exp(Math.max(sx[i], sy[i], sz[i])));
				result.x += x[i] * weight;
				result.y += y[i] * weight;
				result.z += z[i] * weight;
				sum += weight;
			}
			result.mulScalar(1 / sum);
		};
		_proto.renderWireframeBounds = function renderWireframeBounds(scene, worldMat) {
			var p = new Vec3();
			var r = new Quat();
			var s = new Vec3();
			var min = new Vec3();
			var max = new Vec3();
			var iter = this.createIter(p, r, s);
			for (var i = 0; i < this.numSplats; ++i) {
				iter.read(i);
				calcSplatMat(mat4$1, p, r);
				mat4$1.mul2(worldMat, mat4$1);
				min.set(s.x * -2.0, s.y * -2.0, s.z * -2.0);
				max.set(s.x * 2.0, s.y * 2.0, s.z * 2.0);
				scene.immediate.drawWireAlignedBox(min, max, debugColor, true, scene.defaultDrawLayer, mat4$1);
			}
		};
		_proto.calcMortonOrder = function calcMortonOrder() {
			var calcMinMax = function calcMinMax(arr) {
				var min = arr[0];
				var max = arr[0];
				for (var i = 1; i < arr.length; i++) {
					if (arr[i] < min) min = arr[i];
					if (arr[i] > max) max = arr[i];
				}
				return {
					min: min,
					max: max
				};
			};
			var encodeMorton3 = function encodeMorton3(x, y, z) {
				var Part1By2 = function Part1By2(x) {
					x &= 0x000003ff;
					x = (x ^ x << 16) & 0xff0000ff;
					x = (x ^ x << 8) & 0x0300f00f;
					x = (x ^ x << 4) & 0x030c30c3;
					x = (x ^ x << 2) & 0x09249249;
					return x;
				};
				return (Part1By2(z) << 2) + (Part1By2(y) << 1) + Part1By2(x);
			};
			var x = this.getProp('x');
			var y = this.getProp('y');
			var z = this.getProp('z');
			var _calcMinMax = calcMinMax(x),
				minX = _calcMinMax.min,
				maxX = _calcMinMax.max;
			var _calcMinMax2 = calcMinMax(y),
				minY = _calcMinMax2.min,
				maxY = _calcMinMax2.max;
			var _calcMinMax3 = calcMinMax(z),
				minZ = _calcMinMax3.min,
				maxZ = _calcMinMax3.max;
			var sizeX = minX === maxX ? 0 : 1024 / (maxX - minX);
			var sizeY = minY === maxY ? 0 : 1024 / (maxY - minY);
			var sizeZ = minZ === maxZ ? 0 : 1024 / (maxZ - minZ);
			var codes = new Map();
			for (var i = 0; i < this.numSplats; i++) {
				var ix = Math.floor((x[i] - minX) * sizeX);
				var iy = Math.floor((y[i] - minY) * sizeY);
				var iz = Math.floor((z[i] - minZ) * sizeZ);
				var code = encodeMorton3(ix, iy, iz);
				var val = codes.get(code);
				if (val) {
					val.push(i);
				} else {
					codes.set(code, [i]);
				}
			}
			var keys = Array.from(codes.keys()).sort(function (a, b) {
				return a - b;
			});
			var indices = new Uint32Array(this.numSplats);
			var idx = 0;
			for (var _i = 0; _i < keys.length; ++_i) {
				var _val = codes.get(keys[_i]);
				for (var j = 0; j < _val.length; ++j) {
					indices[idx++] = _val[j];
				}
			}
			return indices;
		};
		_proto.reorder = function reorder(order) {
			var cache = new Map();
			var getStorage = function getStorage(size) {
				if (cache.has(size)) {
					var buffer = cache.get(size);
					cache.delete(size);
					return buffer;
				}
				return new ArrayBuffer(size);
			};
			var returnStorage = function returnStorage(buffer) {
				cache.set(buffer.byteLength, buffer);
			};
			var reorder = function reorder(data) {
				var result = new data.constructor(getStorage(data.byteLength));
				for (var i = 0; i < order.length; i++) {
					result[i] = data[order[i]];
				}
				returnStorage(data.buffer);
				return result;
			};
			this.elements.forEach(function (element) {
				element.properties.forEach(function (property) {
					if (property.storage) {
						property.storage = reorder(property.storage);
					}
				});
			});
		};
		_proto.reorderData = function reorderData() {
			this.reorder(this.calcMortonOrder());
		};
		return _createClass(GSplatData, [{
			key: "isCompressed",
			get: function get() {
				return false;
			}
		}, {
			key: "hasSHData",
			get: function get() {
				for (var i = 0; i < 45; ++i) {
					if (!this.getProp("f_rest_" + i)) {
						return false;
					}
				}
				return true;
			}
		}]);
	}();

	var _gammaNames;
	var gammaNames = (_gammaNames = {}, _gammaNames[GAMMA_NONE] = 'NONE', _gammaNames[GAMMA_SRGB] = 'SRGB', _gammaNames);
	var defaultChunks = new Map(Object.entries(shaderChunks));
	var GSplatShaderGenerator = function () {
		function GSplatShaderGenerator() {}
		var _proto = GSplatShaderGenerator.prototype;
		_proto.generateKey = function generateKey(options) {
			var pass = options.pass,
				gamma = options.gamma,
				toneMapping = options.toneMapping,
				vertex = options.vertex,
				fragment = options.fragment,
				dither = options.dither,
				defines = options.defines,
				chunks = options.chunks;
			return "splat-" + pass + "-" + gamma + "-" + toneMapping + "-" + hashCode(vertex) + "-" + hashCode(fragment) + "-" + dither + "-" + ShaderGenerator.definesHash(defines) + "-" + (chunks && Object.keys(chunks).sort().join(':'));
		};
		_proto.createShaderDefinition = function createShaderDefinition(device, options) {
			var _tonemapNames$options, _gammaNames$options$g, _options$vertex, _options$fragment;
			var shaderPassInfo = ShaderPass.get(device).getByIndex(options.pass);
			var shaderPassDefines = shaderPassInfo.shaderDefines;
			var defineMap = new Map();
			defineMap.set('TONEMAP', (_tonemapNames$options = tonemapNames[options.toneMapping]) != null ? _tonemapNames$options : true);
			defineMap.set('GAMMA', (_gammaNames$options$g = gammaNames[options.gamma]) != null ? _gammaNames$options$g : true);
			defineMap.set("DITHER_" + options.dither.toUpperCase(), true);
			options.defines.forEach(function (value, key) {
				defineMap.set(key, value);
			});
			var defines = shaderPassDefines + "\n";
			var vs = defines + ((_options$vertex = options.vertex) != null ? _options$vertex : shaderChunks.gsplatVS);
			var fs = defines + ((_options$fragment = options.fragment) != null ? _options$fragment : shaderChunks.gsplatPS);
			var includes = options.chunks ? new Map(Object.entries(_extends({}, shaderChunks, options.chunks))) : defaultChunks;
			return ShaderUtils.createDefinition(device, {
				name: 'SplatShader',
				attributes: {
					vertex_position: SEMANTIC_POSITION,
					vertex_id_attrib: SEMANTIC_ATTR13
				},
				vertexCode: vs,
				vertexDefines: defineMap,
				vertexIncludes: includes,
				fragmentCode: fs,
				fragmentDefines: defineMap,
				fragmentIncludes: includes
			});
		};
		return GSplatShaderGenerator;
	}();
	var gsplat = new GSplatShaderGenerator();
	var createGSplatMaterial = function createGSplatMaterial(options) {
		var _options$dither;
		if (options === void 0) {
			options = {};
		}
		var ditherEnum = (_options$dither = options.dither) != null ? _options$dither : DITHER_NONE;
		var dither = ditherEnum !== DITHER_NONE;
		var material = new ShaderMaterial();
		material.name = 'splatMaterial';
		material.cull = CULLFACE_NONE;
		material.blendType = dither ? BLEND_NONE : BLEND_NORMAL;
		material.depthWrite = dither;
		material.getShaderVariant = function (params) {
			var cameraShaderParams = params.cameraShaderParams;
			var programOptions = {
				defines: getMaterialShaderDefines(material, cameraShaderParams),
				pass: params.pass,
				gamma: cameraShaderParams.shaderOutputGamma,
				toneMapping: cameraShaderParams.toneMapping,
				vertex: options.vertex,
				fragment: options.fragment,
				chunks: options.chunks,
				dither: ditherEnum
			};
			var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat);
			var library = getProgramLibrary(params.device);
			library.register('splat', gsplat);
			return library.getProgram('splat', programOptions, processingOptions);
		};
		material.update();
		return material;
	};

	var getSHData = function getSHData(gsplatData) {
		var result = [];
		for (var i = 0; i < 45; ++i) {
			result.push(gsplatData.getProp("f_rest_" + i));
		}
		return result;
	};
	var GSplat = function () {
		function GSplat(device, gsplatData) {
			this.device = void 0;
			this.numSplats = void 0;
			this.numSplatsVisible = void 0;
			this.centers = void 0;
			this.aabb = void 0;
			this.colorTexture = void 0;
			this.transformATexture = void 0;
			this.transformBTexture = void 0;
			this.hasSH = void 0;
			this.sh1to3Texture = void 0;
			this.sh4to7Texture = void 0;
			this.sh8to11Texture = void 0;
			this.sh12to15Texture = void 0;
			var numSplats = gsplatData.numSplats;
			this.device = device;
			this.numSplats = numSplats;
			this.numSplatsVisible = numSplats;
			this.centers = new Float32Array(gsplatData.numSplats * 3);
			gsplatData.getCenters(this.centers);
			this.aabb = new BoundingBox();
			gsplatData.calcAabb(this.aabb);
			var size = this.evalTextureSize(numSplats);
			this.colorTexture = this.createTexture('splatColor', PIXELFORMAT_RGBA8, size);
			this.transformATexture = this.createTexture('transformA', PIXELFORMAT_RGBA32U, size);
			this.transformBTexture = this.createTexture('transformB', PIXELFORMAT_RGBA16F, size);
			this.updateColorData(gsplatData);
			this.updateTransformData(gsplatData);
			this.hasSH = gsplatData.hasSHData;
			if (this.hasSH) {
				this.sh1to3Texture = this.createTexture('splatSH_1to3', PIXELFORMAT_RGBA32U, size);
				this.sh4to7Texture = this.createTexture('splatSH_4to7', PIXELFORMAT_RGBA32U, size);
				this.sh8to11Texture = this.createTexture('splatSH_8to11', PIXELFORMAT_RGBA32U, size);
				this.sh12to15Texture = this.createTexture('splatSH_12to15', PIXELFORMAT_RGBA32U, size);
				this.updateSHData(gsplatData);
			}
		}
		var _proto = GSplat.prototype;
		_proto.destroy = function destroy() {
			var _this$colorTexture, _this$transformATextu, _this$transformBTextu, _this$sh1to3Texture, _this$sh4to7Texture, _this$sh8to11Texture, _this$sh12to15Texture;
			(_this$colorTexture = this.colorTexture) == null || _this$colorTexture.destroy();
			(_this$transformATextu = this.transformATexture) == null || _this$transformATextu.destroy();
			(_this$transformBTextu = this.transformBTexture) == null || _this$transformBTextu.destroy();
			(_this$sh1to3Texture = this.sh1to3Texture) == null || _this$sh1to3Texture.destroy();
			(_this$sh4to7Texture = this.sh4to7Texture) == null || _this$sh4to7Texture.destroy();
			(_this$sh8to11Texture = this.sh8to11Texture) == null || _this$sh8to11Texture.destroy();
			(_this$sh12to15Texture = this.sh12to15Texture) == null || _this$sh12to15Texture.destroy();
		};
		_proto.createMaterial = function createMaterial(options) {
			var result = createGSplatMaterial(options);
			result.setParameter('splatColor', this.colorTexture);
			result.setParameter('transformA', this.transformATexture);
			result.setParameter('transformB', this.transformBTexture);
			result.setParameter('numSplats', this.numSplatsVisible);
			if (this.hasSH) {
				result.setDefine('SH_BANDS', 3);
				result.setParameter('splatSH_1to3', this.sh1to3Texture);
				result.setParameter('splatSH_4to7', this.sh4to7Texture);
				result.setParameter('splatSH_8to11', this.sh8to11Texture);
				result.setParameter('splatSH_12to15', this.sh12to15Texture);
			} else {
				result.setDefine('SH_BANDS', 0);
			}
			return result;
		};
		_proto.evalTextureSize = function evalTextureSize(count) {
			var width = Math.ceil(Math.sqrt(count));
			var height = Math.ceil(count / width);
			return new Vec2(width, height);
		};
		_proto.createTexture = function createTexture(name, format, size) {
			return new Texture(this.device, {
				name: name,
				width: size.x,
				height: size.y,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
		};
		_proto.updateColorData = function updateColorData(gsplatData) {
			var texture = this.colorTexture;
			if (!texture) {
				return;
			}
			var data = texture.lock();
			var cr = gsplatData.getProp('f_dc_0');
			var cg = gsplatData.getProp('f_dc_1');
			var cb = gsplatData.getProp('f_dc_2');
			var ca = gsplatData.getProp('opacity');
			var SH_C0 = 0.28209479177387814;
			for (var i = 0; i < this.numSplats; ++i) {
				var r = (cr[i] * SH_C0 + 0.5) * 255;
				var g = (cg[i] * SH_C0 + 0.5) * 255;
				var b = (cb[i] * SH_C0 + 0.5) * 255;
				var a = 255 / (1 + Math.exp(-ca[i]));
				data[i * 4 + 0] = r < 0 ? 0 : r > 255 ? 255 : r;
				data[i * 4 + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
				data[i * 4 + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
				data[i * 4 + 3] = a < 0 ? 0 : a > 255 ? 255 : a;
			}
			texture.unlock();
		};
		_proto.updateTransformData = function updateTransformData(gsplatData) {
			var float2Half = FloatPacking.float2Half;
			if (!this.transformATexture) {
				return;
			}
			var dataA = this.transformATexture.lock();
			var dataAFloat32 = new Float32Array(dataA.buffer);
			var dataB = this.transformBTexture.lock();
			var p = new Vec3();
			var r = new Quat();
			var s = new Vec3();
			var iter = gsplatData.createIter(p, r, s);
			var mat = new Mat3();
			var cA = new Vec3();
			var cB = new Vec3();
			for (var i = 0; i < this.numSplats; i++) {
				iter.read(i);
				r.normalize();
				mat.setFromQuat(r);
				this.computeCov3d(mat, s, cA, cB);
				dataAFloat32[i * 4 + 0] = p.x;
				dataAFloat32[i * 4 + 1] = p.y;
				dataAFloat32[i * 4 + 2] = p.z;
				dataA[i * 4 + 3] = float2Half(cB.x) | float2Half(cB.y) << 16;
				dataB[i * 4 + 0] = float2Half(cA.x);
				dataB[i * 4 + 1] = float2Half(cA.y);
				dataB[i * 4 + 2] = float2Half(cA.z);
				dataB[i * 4 + 3] = float2Half(cB.z);
			}
			this.transformATexture.unlock();
			this.transformBTexture.unlock();
		};
		_proto.computeCov3d = function computeCov3d(rot, scale, covA, covB) {
			var sx = scale.x;
			var sy = scale.y;
			var sz = scale.z;
			var data = rot.data;
			var r00 = data[0] * sx;
			var r01 = data[1] * sx;
			var r02 = data[2] * sx;
			var r10 = data[3] * sy;
			var r11 = data[4] * sy;
			var r12 = data[5] * sy;
			var r20 = data[6] * sz;
			var r21 = data[7] * sz;
			var r22 = data[8] * sz;
			covA.x = r00 * r00 + r10 * r10 + r20 * r20;
			covA.y = r00 * r01 + r10 * r11 + r20 * r21;
			covA.z = r00 * r02 + r10 * r12 + r20 * r22;
			covB.x = r01 * r01 + r11 * r11 + r21 * r21;
			covB.y = r01 * r02 + r11 * r12 + r21 * r22;
			covB.z = r02 * r02 + r12 * r12 + r22 * r22;
		};
		_proto.updateSHData = function updateSHData(gsplatData) {
			var sh1to3Data = this.sh1to3Texture.lock();
			var sh4to7Data = this.sh4to7Texture.lock();
			var sh8to11Data = this.sh8to11Texture.lock();
			var sh12to15Data = this.sh12to15Texture.lock();
			var src = getSHData(gsplatData);
			var t11 = (1 << 11) - 1;
			var t10 = (1 << 10) - 1;
			var float32 = new Float32Array(1);
			var uint32 = new Uint32Array(float32.buffer);
			var c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
			for (var i = 0; i < gsplatData.numSplats; ++i) {
				for (var j = 0; j < 15; ++j) {
					c[j * 3] = src[j][i];
					c[j * 3 + 1] = src[j + 15][i];
					c[j * 3 + 2] = src[j + 30][i];
				}
				var max = c[0];
				for (var _j = 1; _j < 45; ++_j) {
					max = Math.max(max, Math.abs(c[_j]));
				}
				if (max === 0) {
					continue;
				}
				for (var _j2 = 0; _j2 < 15; ++_j2) {
					c[_j2 * 3 + 0] = Math.max(0, Math.min(t11, Math.floor((c[_j2 * 3 + 0] / max * 0.5 + 0.5) * t11 + 0.5)));
					c[_j2 * 3 + 1] = Math.max(0, Math.min(t10, Math.floor((c[_j2 * 3 + 1] / max * 0.5 + 0.5) * t10 + 0.5)));
					c[_j2 * 3 + 2] = Math.max(0, Math.min(t11, Math.floor((c[_j2 * 3 + 2] / max * 0.5 + 0.5) * t11 + 0.5)));
				}
				float32[0] = max;
				sh1to3Data[i * 4 + 0] = uint32[0];
				sh1to3Data[i * 4 + 1] = c[0] << 21 | c[1] << 11 | c[2];
				sh1to3Data[i * 4 + 2] = c[3] << 21 | c[4] << 11 | c[5];
				sh1to3Data[i * 4 + 3] = c[6] << 21 | c[7] << 11 | c[8];
				sh4to7Data[i * 4 + 0] = c[9] << 21 | c[10] << 11 | c[11];
				sh4to7Data[i * 4 + 1] = c[12] << 21 | c[13] << 11 | c[14];
				sh4to7Data[i * 4 + 2] = c[15] << 21 | c[16] << 11 | c[17];
				sh4to7Data[i * 4 + 3] = c[18] << 21 | c[19] << 11 | c[20];
				sh8to11Data[i * 4 + 0] = c[21] << 21 | c[22] << 11 | c[23];
				sh8to11Data[i * 4 + 1] = c[24] << 21 | c[25] << 11 | c[26];
				sh8to11Data[i * 4 + 2] = c[27] << 21 | c[28] << 11 | c[29];
				sh8to11Data[i * 4 + 3] = c[30] << 21 | c[31] << 11 | c[32];
				sh12to15Data[i * 4 + 0] = c[33] << 21 | c[34] << 11 | c[35];
				sh12to15Data[i * 4 + 1] = c[36] << 21 | c[37] << 11 | c[38];
				sh12to15Data[i * 4 + 2] = c[39] << 21 | c[40] << 11 | c[41];
				sh12to15Data[i * 4 + 3] = c[42] << 21 | c[43] << 11 | c[44];
			}
			this.sh1to3Texture.unlock();
			this.sh4to7Texture.unlock();
			this.sh8to11Texture.unlock();
			this.sh12to15Texture.unlock();
		};
		return GSplat;
	}();

	function SortWorker() {
		var order;
		var centers;
		var mapping;
		var cameraPosition;
		var cameraDirection;
		var forceUpdate = false;
		var lastCameraPosition = {
			x: 0,
			y: 0,
			z: 0
		};
		var lastCameraDirection = {
			x: 0,
			y: 0,
			z: 0
		};
		var boundMin = {
			x: 0,
			y: 0,
			z: 0
		};
		var boundMax = {
			x: 0,
			y: 0,
			z: 0
		};
		var distances;
		var countBuffer;
		var binarySearch = function binarySearch(m, n, compare_fn) {
			while (m <= n) {
				var k = n + m >> 1;
				var cmp = compare_fn(k);
				if (cmp > 0) {
					m = k + 1;
				} else if (cmp < 0) {
					n = k - 1;
				} else {
					return k;
				}
			}
			return ~m;
		};
		var update = function update() {
			var _distances;
			if (!order || !centers || centers.length === 0 || !cameraPosition || !cameraDirection) return;
			var px = cameraPosition.x;
			var py = cameraPosition.y;
			var pz = cameraPosition.z;
			var dx = cameraDirection.x;
			var dy = cameraDirection.y;
			var dz = cameraDirection.z;
			var epsilon = 0.001;
			if (!forceUpdate && Math.abs(px - lastCameraPosition.x) < epsilon && Math.abs(py - lastCameraPosition.y) < epsilon && Math.abs(pz - lastCameraPosition.z) < epsilon && Math.abs(dx - lastCameraDirection.x) < epsilon && Math.abs(dy - lastCameraDirection.y) < epsilon && Math.abs(dz - lastCameraDirection.z) < epsilon) {
				return;
			}
			forceUpdate = false;
			lastCameraPosition.x = px;
			lastCameraPosition.y = py;
			lastCameraPosition.z = pz;
			lastCameraDirection.x = dx;
			lastCameraDirection.y = dy;
			lastCameraDirection.z = dz;
			var minDist;
			var maxDist;
			for (var i = 0; i < 8; ++i) {
				var x = (i & 1 ? boundMin.x : boundMax.x) - px;
				var y = (i & 2 ? boundMin.y : boundMax.y) - py;
				var z = (i & 4 ? boundMin.z : boundMax.z) - pz;
				var d = x * dx + y * dy + z * dz;
				if (i === 0) {
					minDist = maxDist = d;
				} else {
					minDist = Math.min(minDist, d);
					maxDist = Math.max(maxDist, d);
				}
			}
			var numVertices = centers.length / 3;
			var compareBits = Math.max(10, Math.min(20, Math.round(Math.log2(numVertices / 4))));
			var bucketCount = Math.pow(2, compareBits) + 1;
			if (((_distances = distances) == null ? void 0 : _distances.length) !== numVertices) {
				distances = new Uint32Array(numVertices);
			}
			if (!countBuffer || countBuffer.length !== bucketCount) {
				countBuffer = new Uint32Array(bucketCount);
			} else {
				countBuffer.fill(0);
			}
			var range = maxDist - minDist;
			var divider = range < 1e-6 ? 0 : 1 / range * Math.pow(2, compareBits);
			for (var _i = 0; _i < numVertices; ++_i) {
				var istride = _i * 3;
				var _x = centers[istride + 0] - px;
				var _y = centers[istride + 1] - py;
				var _z = centers[istride + 2] - pz;
				var _d = _x * dx + _y * dy + _z * dz;
				if (isNaN(_d)) {
					continue;
				}
				var sortKey = Math.floor((_d - minDist) * divider);
				distances[_i] = sortKey;
				countBuffer[sortKey]++;
			}
			for (var _i2 = 1; _i2 < bucketCount; _i2++) {
				countBuffer[_i2] += countBuffer[_i2 - 1];
			}
			for (var _i3 = 0; _i3 < numVertices; _i3++) {
				var distance = distances[_i3];
				var destIndex = --countBuffer[distance];
				order[destIndex] = _i3;
			}
			var dist = function dist(i) {
				return distances[order[i]] / divider + minDist;
			};
			var findZero = function findZero() {
				var result = binarySearch(0, numVertices - 1, function (i) {
					return -dist(i);
				});
				return Math.min(numVertices, Math.abs(result));
			};
			var count = dist(numVertices - 1) >= 0 ? findZero() : numVertices;
			if (mapping) {
				for (var _i4 = 0; _i4 < numVertices; ++_i4) {
					order[_i4] = mapping[order[_i4]];
				}
			}
			self.postMessage({
				order: order.buffer,
				count: count
			}, [order.buffer]);
			order = null;
		};
		self.onmessage = function (message) {
			if (message.data.order) {
				order = new Uint32Array(message.data.order);
			}
			if (message.data.centers) {
				centers = new Float32Array(message.data.centers);
				var initialized = false;
				var numVertices = centers.length / 3;
				for (var i = 0; i < numVertices; ++i) {
					var x = centers[i * 3 + 0];
					var y = centers[i * 3 + 1];
					var z = centers[i * 3 + 2];
					if (isNaN(x) || isNaN(y) || isNaN(z)) {
						continue;
					}
					if (!initialized) {
						initialized = true;
						boundMin.x = boundMax.x = x;
						boundMin.y = boundMax.y = y;
						boundMin.z = boundMax.z = z;
					} else {
						boundMin.x = Math.min(boundMin.x, x);
						boundMax.x = Math.max(boundMax.x, x);
						boundMin.y = Math.min(boundMin.y, y);
						boundMax.y = Math.max(boundMax.y, y);
						boundMin.z = Math.min(boundMin.z, z);
						boundMax.z = Math.max(boundMax.z, z);
					}
				}
				if (!initialized) {
					boundMin.x = boundMax.x = boundMin.y = boundMax.y = boundMin.z = boundMax.z = 0;
				}
				forceUpdate = true;
			}
			if (message.data.hasOwnProperty('mapping')) {
				mapping = message.data.mapping ? new Uint32Array(message.data.mapping) : null;
				forceUpdate = true;
			}
			if (message.data.cameraPosition) cameraPosition = message.data.cameraPosition;
			if (message.data.cameraDirection) cameraDirection = message.data.cameraDirection;
			update();
		};
	}
	var GSplatSorter = function (_EventHandler) {
		function GSplatSorter() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.worker = void 0;
			_this.orderTexture = void 0;
			_this.centers = void 0;
			_this.worker = new Worker(URL.createObjectURL(new Blob(["(" + SortWorker.toString() + ")()"], {
				type: 'application/javascript'
			})));
			_this.worker.onmessage = function (message) {
				var newOrder = message.data.order;
				var oldOrder = _this.orderTexture._levels[0].buffer;
				_this.worker.postMessage({
					order: oldOrder
				}, [oldOrder]);
				_this.orderTexture._levels[0] = new Uint32Array(newOrder);
				_this.orderTexture.upload();
				_this.fire('updated', message.data.count);
			};
			return _this;
		}
		_inheritsLoose(GSplatSorter, _EventHandler);
		var _proto = GSplatSorter.prototype;
		_proto.destroy = function destroy() {
			this.worker.terminate();
			this.worker = null;
		};
		_proto.init = function init(orderTexture, centers) {
			this.orderTexture = orderTexture;
			this.centers = centers.slice();
			var orderBuffer = this.orderTexture.lock({
				mode: TEXTURELOCK_READ
			}).buffer.slice();
			this.orderTexture.unlock();
			this.worker.postMessage({
				order: orderBuffer,
				centers: centers.buffer
			}, [orderBuffer, centers.buffer]);
		};
		_proto.setMapping = function setMapping(mapping) {
			if (mapping) {
				var centers = new Float32Array(mapping.length * 3);
				for (var i = 0; i < mapping.length; ++i) {
					var src = mapping[i] * 3;
					var dst = i * 3;
					centers[dst + 0] = this.centers[src + 0];
					centers[dst + 1] = this.centers[src + 1];
					centers[dst + 2] = this.centers[src + 2];
				}
				this.worker.postMessage({
					centers: centers.buffer,
					mapping: mapping.buffer
				}, [centers.buffer, mapping.buffer]);
			} else {
				var _centers = this.centers.slice();
				this.worker.postMessage({
					centers: _centers.buffer,
					mapping: null
				}, [_centers.buffer]);
			}
		};
		_proto.setCamera = function setCamera(pos, dir) {
			this.worker.postMessage({
				cameraPosition: {
					x: pos.x,
					y: pos.y,
					z: pos.z
				},
				cameraDirection: {
					x: dir.x,
					y: dir.y,
					z: dir.z
				}
			});
		};
		return GSplatSorter;
	}(EventHandler);

	var mat = new Mat4();
	var cameraPosition = new Vec3();
	var cameraDirection = new Vec3();
	var viewport = [0, 0];
	var GSplatInstance = function () {
		function GSplatInstance(splat, options) {
			var _this = this;
			this.splat = void 0;
			this.mesh = void 0;
			this.meshInstance = void 0;
			this.material = void 0;
			this.orderTexture = void 0;
			this.options = {};
			this.sorter = null;
			this.lastCameraPosition = new Vec3();
			this.lastCameraDirection = new Vec3();
			this.cameras = [];
			this.splat = splat;
			options = Object.assign(this.options, options);
			var device = splat.device;
			this.orderTexture = this.splat.createTexture('splatOrder', PIXELFORMAT_R32U, this.splat.evalTextureSize(this.splat.numSplats));
			this.createMaterial(options);
			var splatInstanceSize = 128;
			var numSplats = Math.ceil(splat.numSplats / splatInstanceSize) * splatInstanceSize;
			var numSplatInstances = numSplats / splatInstanceSize;
			var indexData = new Uint32Array(numSplatInstances);
			for (var i = 0; i < numSplatInstances; ++i) {
				indexData[i] = i * splatInstanceSize;
			}
			var vertexFormat = new VertexFormat(device, [{
				semantic: SEMANTIC_ATTR13,
				components: 1,
				type: TYPE_UINT32,
				asInt: true
			}]);
			var indicesVB = new VertexBuffer(device, vertexFormat, numSplatInstances, {
				usage: BUFFER_STATIC,
				data: indexData.buffer
			});
			var meshPositions = new Float32Array(12 * splatInstanceSize);
			var meshIndices = new Uint32Array(6 * splatInstanceSize);
			for (var _i = 0; _i < splatInstanceSize; ++_i) {
				meshPositions.set([-1, -1, _i, 1, -1, _i, 1, 1, _i, -1, 1, _i], _i * 12);
				var b = _i * 4;
				meshIndices.set([0 + b, 1 + b, 2 + b, 0 + b, 2 + b, 3 + b], _i * 6);
			}
			var mesh = new Mesh(device);
			mesh.setPositions(meshPositions, 3);
			mesh.setIndices(meshIndices);
			mesh.update();
			this.mesh = mesh;
			this.mesh.aabb.copy(splat.aabb);
			this.meshInstance = new MeshInstance(this.mesh, this.material);
			this.meshInstance.setInstancing(indicesVB, true);
			this.meshInstance.gsplatInstance = this;
			this.meshInstance.instancingCount = 0;
			this.centers = new Float32Array(splat.centers);
			if (!options.dither || options.dither === DITHER_NONE) {
				this.sorter = new GSplatSorter();
				this.sorter.init(this.orderTexture, this.centers);
				this.sorter.on('updated', function (count) {
					_this.meshInstance.instancingCount = Math.ceil(count / splatInstanceSize);
					_this.material.setParameter('numSplats', count);
				});
			}
		}
		var _proto = GSplatInstance.prototype;
		_proto.destroy = function destroy() {
			var _this$material, _this$meshInstance, _this$sorter;
			(_this$material = this.material) == null || _this$material.destroy();
			(_this$meshInstance = this.meshInstance) == null || _this$meshInstance.destroy();
			(_this$sorter = this.sorter) == null || _this$sorter.destroy();
		};
		_proto.clone = function clone() {
			return new GSplatInstance(this.splat, this.options);
		};
		_proto.createMaterial = function createMaterial(options) {
			this.material = this.splat.createMaterial(options);
			this.material.setParameter('splatOrder', this.orderTexture);
			if (this.meshInstance) {
				this.meshInstance.material = this.material;
			}
		};
		_proto.updateViewport = function updateViewport() {
			var device = this.splat.device;
			viewport[0] = device.width;
			viewport[1] = device.height;
			if (this.cameras.length > 0) {
				var camera = this.cameras[0];
				var xr = camera.xr;
				if (xr && xr.active && xr.views.list.length === 2) {
					viewport[0] /= 2;
				}
			}
			this.material.setParameter('viewport', viewport);
		};
		_proto.sort = function sort(cameraNode) {
			if (this.sorter) {
				var cameraMat = cameraNode.getWorldTransform();
				cameraMat.getTranslation(cameraPosition);
				cameraMat.getZ(cameraDirection);
				var modelMat = this.meshInstance.node.getWorldTransform();
				var invModelMat = mat.invert(modelMat);
				invModelMat.transformPoint(cameraPosition, cameraPosition);
				invModelMat.transformVector(cameraDirection, cameraDirection);
				if (!cameraPosition.equalsApprox(this.lastCameraPosition) || !cameraDirection.equalsApprox(this.lastCameraDirection)) {
					this.lastCameraPosition.copy(cameraPosition);
					this.lastCameraDirection.copy(cameraDirection);
					this.sorter.setCamera(cameraPosition, cameraDirection);
				}
			}
			this.updateViewport();
		};
		_proto.update = function update() {
			if (this.cameras.length > 0) {
				var camera = this.cameras[0];
				this.sort(camera._node);
				this.cameras.length = 0;
			}
		};
		return GSplatInstance;
	}();

	var FILLMODE_NONE = 'NONE';
	var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
	var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
	var RESOLUTION_AUTO = 'AUTO';
	var RESOLUTION_FIXED = 'FIXED';

	var currentApplication;
	function getApplication() {
		return currentApplication;
	}
	function setApplication(app) {
		currentApplication = app;
	}

	var _createdLoadingScreen = false;
	var script = {
		app: null,
		createLoadingScreen: function createLoadingScreen(callback) {
			if (_createdLoadingScreen) {
				return;
			}
			_createdLoadingScreen = true;
			var app = getApplication();
			callback(app);
		}
	};

	var FrameGraph = function () {
		function FrameGraph() {
			this.renderPasses = [];
			this.renderTargetMap = new Map();
		}
		var _proto = FrameGraph.prototype;
		_proto.addRenderPass = function addRenderPass(renderPass) {
			renderPass.frameUpdate();
			var beforePasses = renderPass.beforePasses;
			for (var i = 0; i < beforePasses.length; i++) {
				var pass = beforePasses[i];
				if (pass.enabled) {
					this.addRenderPass(pass);
				}
			}
			if (renderPass.enabled) {
				this.renderPasses.push(renderPass);
			}
			var afterPasses = renderPass.afterPasses;
			for (var _i = 0; _i < afterPasses.length; _i++) {
				var _pass = afterPasses[_i];
				if (_pass.enabled) {
					this.addRenderPass(_pass);
				}
			}
		};
		_proto.reset = function reset() {
			this.renderPasses.length = 0;
		};
		_proto.compile = function compile() {
			var renderTargetMap = this.renderTargetMap;
			var renderPasses = this.renderPasses;
			for (var i = 0; i < renderPasses.length; i++) {
				var renderPass = renderPasses[i];
				var renderTarget = renderPass.renderTarget;
				if (renderTarget !== undefined) {
					var prevPass = renderTargetMap.get(renderTarget);
					if (prevPass) {
						var count = renderPass.colorArrayOps.length;
						for (var j = 0; j < count; j++) {
							var colorOps = renderPass.colorArrayOps[j];
							if (!colorOps.clear) {
								prevPass.colorArrayOps[j].store = true;
							}
						}
						if (!renderPass.depthStencilOps.clearDepth) {
							prevPass.depthStencilOps.storeDepth = true;
						}
						if (!renderPass.depthStencilOps.clearStencil) {
							prevPass.depthStencilOps.storeStencil = true;
						}
					}
					renderTargetMap.set(renderTarget, renderPass);
				}
			}
			for (var _i2 = 0; _i2 < renderPasses.length - 1; _i2++) {
				var firstPass = renderPasses[_i2];
				var firstRT = firstPass.renderTarget;
				var secondPass = renderPasses[_i2 + 1];
				var secondRT = secondPass.renderTarget;
				if (firstRT !== secondRT || firstRT === undefined) {
					continue;
				}
				if (secondPass.depthStencilOps.clearDepth || secondPass.depthStencilOps.clearStencil || secondPass.colorArrayOps.some(function (colorOps) {
					return colorOps.clear;
				})) {
					continue;
				}
				if (firstPass.afterPasses.length > 0) {
					continue;
				}
				if (secondPass.beforePasses.length > 0) {
					continue;
				}
				firstPass._skipEnd = true;
				secondPass._skipStart = true;
			}
			var lastCubeTexture = null;
			var lastCubeRenderPass = null;
			for (var _i3 = 0; _i3 < renderPasses.length; _i3++) {
				var _renderPass = renderPasses[_i3];
				var _renderTarget = _renderPass.renderTarget;
				var thisTexture = _renderTarget == null ? void 0 : _renderTarget.colorBuffer;
				if (thisTexture != null && thisTexture.cubemap) {
					if (lastCubeTexture === thisTexture) {
						var _count = lastCubeRenderPass.colorArrayOps.length;
						for (var _j = 0; _j < _count; _j++) {
							lastCubeRenderPass.colorArrayOps[_j].mipmaps = false;
						}
					}
					lastCubeTexture = _renderTarget.colorBuffer;
					lastCubeRenderPass = _renderPass;
				} else if (_renderPass.requiresCubemaps) {
					lastCubeTexture = null;
					lastCubeRenderPass = null;
				}
			}
			renderTargetMap.clear();
		};
		_proto.render = function render(device) {
			this.compile();
			var renderPasses = this.renderPasses;
			for (var i = 0; i < renderPasses.length; i++) {
				renderPasses[i].render();
			}
		};
		return FrameGraph;
	}();

	var AreaLightCacheEntry = function () {
		function AreaLightCacheEntry(texture0, texture1) {
			this.texture0 = texture0;
			this.texture1 = texture1;
		}
		var _proto = AreaLightCacheEntry.prototype;
		_proto.destroy = function destroy() {
			var _this$texture, _this$texture2;
			(_this$texture = this.texture0) == null || _this$texture.destroy();
			(_this$texture2 = this.texture1) == null || _this$texture2.destroy();
		};
		return AreaLightCacheEntry;
	}();
	var deviceCache = new DeviceCache();
	var AreaLightLuts = function () {
		function AreaLightLuts() {}
		AreaLightLuts.createTexture = function createTexture(device, format, size, postfix) {
			if (postfix === void 0) {
				postfix = '';
			}
			var tex = new Texture(device, {
				name: "AreaLightLUT" + postfix,
				width: size,
				height: size,
				format: format,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				type: TEXTURETYPE_DEFAULT,
				magFilter: FILTER_LINEAR,
				minFilter: FILTER_NEAREST,
				anisotropy: 1,
				mipmaps: false
			});
			return tex;
		};
		AreaLightLuts.applyTextures = function applyTextures(device, texture1, texture2) {
			deviceCache.remove(device);
			deviceCache.get(device, function () {
				return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);
			});
			device.scope.resolve('areaLightsLutTex1').setValue(texture1);
			device.scope.resolve('areaLightsLutTex2').setValue(texture2);
		};
		AreaLightLuts.createPlaceholder = function createPlaceholder(device) {
			var texture = AreaLightLuts.createTexture(device, PIXELFORMAT_RGBA16F, 2, 'placeholder');
			var pixels = texture.lock();
			pixels.fill(0);
			texture.unlock();
			AreaLightLuts.applyTextures(device, texture, texture);
		};
		AreaLightLuts.set = function set(device, ltcMat1, ltcMat2) {
			function buildTexture(device, data, format) {
				var texture = AreaLightLuts.createTexture(device, format, 64);
				texture.lock().set(data);
				texture.unlock();
				return texture;
			}
			function convertToHalfFloat(data) {
				var count = data.length;
				var ret = new Uint16Array(count);
				var float2Half = FloatPacking.float2Half;
				for (var i = 0; i < count; i++) {
					ret[i] = float2Half(data[i]);
				}
				return ret;
			}
			var srcData1 = ltcMat1;
			var srcData2 = ltcMat2;
			var data1 = convertToHalfFloat(srcData1);
			var data2 = convertToHalfFloat(srcData2);
			var tex1 = buildTexture(device, data1, PIXELFORMAT_RGBA16F);
			var tex2 = buildTexture(device, data2, PIXELFORMAT_RGBA16F);
			AreaLightLuts.applyTextures(device, tex1, tex2);
		};
		return AreaLightLuts;
	}();

	var DEFAULT_LOCALE = 'en-US';
	var DEFAULT_LOCALE_FALLBACKS = {
		'en': 'en-US',
		'es': 'en-ES',
		'zh': 'zh-CN',
		'zh-HK': 'zh-TW',
		'zh-TW': 'zh-HK',
		'zh-MO': 'zh-HK',
		'fr': 'fr-FR',
		'de': 'de-DE',
		'it': 'it-IT',
		'ru': 'ru-RU',
		'ja': 'ja-JP'
	};

	var PLURALS = {};
	function definePluralFn(locales, fn) {
		for (var i = 0, len = locales.length; i < len; i++) {
			PLURALS[locales[i]] = fn;
		}
	}
	function getLang(locale) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
			return locale.substring(0, idx);
		}
		return locale;
	}
	function replaceLang(locale, desiredLang) {
		var idx = locale.indexOf('-');
		if (idx !== -1) {
			return desiredLang + locale.substring(idx);
		}
		return desiredLang;
	}
	function findAvailableLocale(desiredLocale, availableLocales) {
		if (availableLocales[desiredLocale]) {
			return desiredLocale;
		}
		var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];
		if (fallback && availableLocales[fallback]) {
			return fallback;
		}
		var lang = getLang(desiredLocale);
		fallback = DEFAULT_LOCALE_FALLBACKS[lang];
		if (availableLocales[fallback]) {
			return fallback;
		}
		if (availableLocales[lang]) {
			return lang;
		}
		return DEFAULT_LOCALE;
	}
	definePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {
		return 0;
	});
	definePluralFn(['fa', 'hi'], function (n) {
		if (n >= 0 && n <= 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['fr', 'pt'], function (n) {
		if (n >= 0 && n < 2) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['da'], function (n) {
		if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {
		if (n === 1) {
			return 0;
		}
		return 1;
	});
	definePluralFn(['ru', 'uk'], function (n) {
		if (Number.isInteger(n)) {
			var mod10 = n % 10;
			var mod100 = n % 100;
			if (mod10 === 1 && mod100 !== 11) {
				return 0;
			} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
				return 2;
			}
		}
		return 3;
	});
	definePluralFn(['pl'], function (n) {
		if (Number.isInteger(n)) {
			if (n === 1) {
				return 0;
			}
			var mod10 = n % 10;
			var mod100 = n % 100;
			if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
				return 1;
			} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
				return 2;
			}
		}
		return 3;
	});
	definePluralFn(['ar'], function (n) {
		if (n === 0) {
			return 0;
		} else if (n === 1) {
			return 1;
		} else if (n === 2) {
			return 2;
		}
		if (Number.isInteger(n)) {
			var mod100 = n % 100;
			if (mod100 >= 3 && mod100 <= 10) {
				return 3;
			} else if (mod100 >= 11 && mod100 <= 99) {
				return 4;
			}
		}
		return 5;
	});
	var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];
	function getPluralFn(lang) {
		return PLURALS[lang] || DEFAULT_PLURAL_FN;
	}

	var ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-+.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');
	var ASSET_ANIMATION = 'animation';
	var ASSET_AUDIO = 'audio';
	var ASSET_IMAGE = 'image';
	var ASSET_JSON = 'json';
	var ASSET_MODEL = 'model';
	var ASSET_MATERIAL = 'material';
	var ASSET_TEXT = 'text';
	var ASSET_TEXTURE = 'texture';
	var ASSET_TEXTUREATLAS = 'textureatlas';
	var ASSET_CUBEMAP = 'cubemap';
	var ASSET_SHADER = 'shader';
	var ASSET_CSS = 'css';
	var ASSET_HTML = 'html';
	var ASSET_SCRIPT = 'script';
	var ASSET_CONTAINER = 'container';

	var AssetFile = function () {
		function AssetFile(url, filename, hash, size, opt, contents) {
			if (url === void 0) {
				url = '';
			}
			if (filename === void 0) {
				filename = '';
			}
			if (hash === void 0) {
				hash = null;
			}
			if (size === void 0) {
				size = null;
			}
			if (opt === void 0) {
				opt = null;
			}
			if (contents === void 0) {
				contents = null;
			}
			this.url = url;
			this.filename = filename;
			this.hash = hash;
			this.size = size;
			this.opt = opt;
			this.contents = contents;
		}
		var _proto = AssetFile.prototype;
		_proto.equals = function equals(other) {
			return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
		};
		return AssetFile;
	}();

	var assetIdCounter = -1;
	var VARIANT_SUPPORT = {
		pvr: 'extCompressedTexturePVRTC',
		dxt: 'extCompressedTextureS3TC',
		etc2: 'extCompressedTextureETC',
		etc1: 'extCompressedTextureETC1',
		basis: 'canvas'
	};
	var VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];
	var Asset = function (_EventHandler) {
		function Asset(name, type, file, data, options) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._id = assetIdCounter--;
			_this._name = name || '';
			_this.type = type;
			_this.tags = new Tags(_this);
			_this._preload = false;
			_this._file = null;
			_this._data = data || {};
			_this.options = options || {};
			_this._resources = [];
			_this.urlObject = null;
			_this._i18n = {};
			_this.loaded = false;
			_this.loading = false;
			_this.registry = null;
			if (file) _this.file = file;
			return _this;
		}
		_inheritsLoose(Asset, _EventHandler);
		var _proto = Asset.prototype;
		_proto.getFileUrl = function getFileUrl() {
			var file = this.file;
			if (!file || !file.url) {
				return null;
			}
			var url = file.url;
			if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) {
				url = this.registry.prefix + url;
			}
			if (this.type !== 'script' && file.hash) {
				var separator = url.indexOf('?') !== -1 ? '&' : '?';
				url += separator + "t=" + file.hash;
			}
			return url;
		};
		_proto.getAbsoluteUrl = function getAbsoluteUrl(relativePath) {
			if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
				return relativePath;
			}
			var base = path.getDirectory(this.file.url);
			return path.join(base, relativePath);
		};
		_proto.getLocalizedAssetId = function getLocalizedAssetId(locale) {
			locale = findAvailableLocale(locale, this._i18n);
			return this._i18n[locale] || null;
		};
		_proto.addLocalizedAssetId = function addLocalizedAssetId(locale, assetId) {
			this._i18n[locale] = assetId;
			this.fire('add:localized', locale, assetId);
		};
		_proto.removeLocalizedAssetId = function removeLocalizedAssetId(locale) {
			var assetId = this._i18n[locale];
			if (assetId) {
				delete this._i18n[locale];
				this.fire('remove:localized', locale, assetId);
			}
		};
		_proto.ready = function ready(callback, scope) {
			scope = scope || this;
			if (this.loaded) {
				callback.call(scope, this);
			} else {
				this.once('load', function (asset) {
					callback.call(scope, asset);
				});
			}
		};
		_proto.reload = function reload() {
			if (this.loaded) {
				this.loaded = false;
				this.registry.load(this);
			}
		};
		_proto.unload = function unload() {
			if (!this.loaded && this._resources.length === 0) {
				return;
			}
			this.fire('unload', this);
			this.registry.fire("unload:" + this.id, this);
			var old = this._resources;
			if (this.urlObject) {
				URL.revokeObjectURL(this.urlObject);
				this.urlObject = null;
			}
			this.resources = [];
			this.loaded = false;
			if (this.file) {
				this.registry._loader.clearCache(this.getFileUrl(), this.type);
			}
			for (var i = 0; i < old.length; ++i) {
				var resource = old[i];
				if (resource && resource.destroy) {
					resource.destroy();
				}
			}
		};
		Asset.fetchArrayBuffer = function fetchArrayBuffer(loadUrl, callback, asset, maxRetries) {
			var _asset$file;
			if (maxRetries === void 0) {
				maxRetries = 0;
			}
			if (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {
				setTimeout(function () {
					callback(null, asset.file.contents);
				});
			} else {
				http.get(loadUrl, {
					cache: true,
					responseType: 'arraybuffer',
					retry: maxRetries > 0,
					maxRetries: maxRetries
				}, callback);
			}
		};
		return _createClass(Asset, [{
			key: "id",
			get: function get() {
				return this._id;
			},
			set: function set(value) {
				this._id = value;
			}
		}, {
			key: "name",
			get: function get() {
				return this._name;
			},
			set: function set(value) {
				if (this._name === value) {
					return;
				}
				var old = this._name;
				this._name = value;
				this.fire('name', this, this._name, old);
			}
		}, {
			key: "file",
			get: function get() {
				return this._file;
			},
			set: function set(value) {
				var _this2 = this;
				if (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {
					var _this$registry;
					var app = ((_this$registry = this.registry) == null || (_this$registry = _this$registry._loader) == null ? void 0 : _this$registry._app) || getApplication();
					var device = app == null ? void 0 : app.graphicsDevice;
					if (device) {
						var _loop = function _loop() {
								var variant = VARIANT_DEFAULT_PRIORITY[i];
								if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
									value = value.variants[variant];
									return 0;
								}
								if (app.enableBundles) {
									var bundles = app.bundles.listBundlesForAsset(_this2);
									if (bundles && bundles.find(function (b) {
										var _b$file;
										return b == null || (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];
									})) {
										return 0;
									}
								}
							},
							_ret;
						for (var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
							_ret = _loop();
							if (_ret === 0) break;
						}
					}
				}
				var oldFile = this._file;
				var newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;
				if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
					this._file = newFile;
					this.fire('change', this, 'file', newFile, oldFile);
					this.reload();
				}
			}
		}, {
			key: "data",
			get: function get() {
				return this._data;
			},
			set: function set(value) {
				var old = this._data;
				this._data = value;
				if (value !== old) {
					this.fire('change', this, 'data', value, old);
					if (this.loaded) {
						this.registry._loader.patch(this, this.registry);
					}
				}
			}
		}, {
			key: "resource",
			get: function get() {
				return this._resources[0];
			},
			set: function set(value) {
				var _old = this._resources[0];
				this._resources[0] = value;
				this.fire('change', this, 'resource', value, _old);
			}
		}, {
			key: "resources",
			get: function get() {
				return this._resources;
			},
			set: function set(value) {
				var _old = this._resources;
				this._resources = value;
				this.fire('change', this, 'resources', value, _old);
			}
		}, {
			key: "preload",
			get: function get() {
				return this._preload;
			},
			set: function set(value) {
				value = !!value;
				if (this._preload === value) {
					return;
				}
				this._preload = value;
				if (this._preload && !this.loaded && !this.loading && this.registry) {
					this.registry.load(this);
				}
			}
		}, {
			key: "loadFaces",
			get: function get() {
				return this._loadFaces;
			},
			set: function set(value) {
				value = !!value;
				if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
					this._loadFaces = value;
					if (this.loaded) {
						this.registry._loader.patch(this, this.registry);
					}
				}
			}
		}]);
	}(EventHandler);
	Asset.EVENT_LOAD = 'load';
	Asset.EVENT_UNLOAD = 'unload';
	Asset.EVENT_REMOVE = 'remove';
	Asset.EVENT_ERROR = 'error';
	Asset.EVENT_CHANGE = 'change';
	Asset.EVENT_ADDLOCALIZED = 'add:localized';
	Asset.EVENT_REMOVELOCALIZED = 'remove:localized';

	var TagsCache = function () {
		function TagsCache(key) {
			if (key === void 0) {
				key = null;
			}
			this._index = {};
			this._key = void 0;
			this._key = key;
		}
		var _proto = TagsCache.prototype;
		_proto.addItem = function addItem(item) {
			var tags = item.tags._list;
			for (var _iterator = _createForOfIteratorHelperLoose(tags), _step; !(_step = _iterator()).done;) {
				var tag = _step.value;
				this.add(tag, item);
			}
		};
		_proto.removeItem = function removeItem(item) {
			var tags = item.tags._list;
			for (var _iterator2 = _createForOfIteratorHelperLoose(tags), _step2; !(_step2 = _iterator2()).done;) {
				var tag = _step2.value;
				this.remove(tag, item);
			}
		};
		_proto.add = function add(tag, item) {
			if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) {
				return;
			}
			if (!this._index[tag]) {
				this._index[tag] = {
					list: []
				};
				if (this._key) {
					this._index[tag].keys = {};
				}
			}
			this._index[tag].list.push(item);
			if (this._key) {
				this._index[tag].keys[item[this._key]] = item;
			}
		};
		_proto.remove = function remove(tag, item) {
			if (!this._index[tag]) {
				return;
			}
			if (this._key) {
				if (!this._index[tag].keys[item[this._key]]) {
					return;
				}
			}
			var ind = this._index[tag].list.indexOf(item);
			if (ind === -1) {
				return;
			}
			this._index[tag].list.splice(ind, 1);
			if (this._key) {
				delete this._index[tag].keys[item[this._key]];
			}
			if (this._index[tag].list.length === 0) {
				delete this._index[tag];
			}
		};
		_proto.find = function find(args) {
			var _this = this;
			var index = {};
			var items = [];
			var item, tag, tags, tagsRest, missingIndex;
			var sort = function sort(a, b) {
				return _this._index[a].list.length - _this._index[b].list.length;
			};
			for (var i = 0; i < args.length; i++) {
				tag = args[i];
				if (tag instanceof Array) {
					if (tag.length === 0) {
						continue;
					}
					if (tag.length === 1) {
						tag = tag[0];
					} else {
						missingIndex = false;
						for (var t = 0; t < tag.length; t++) {
							if (!this._index[tag[t]]) {
								missingIndex = true;
								break;
							}
						}
						if (missingIndex) {
							continue;
						}
						tags = tag.slice(0).sort(sort);
						tagsRest = tags.slice(1);
						if (tagsRest.length === 1) {
							tagsRest = tagsRest[0];
						}
						for (var n = 0; n < this._index[tags[0]].list.length; n++) {
							item = this._index[tags[0]].list[n];
							if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
								if (this._key) {
									index[item[this._key]] = true;
								}
								items.push(item);
							}
						}
						continue;
					}
				}
				if (tag && typeof tag === 'string' && this._index[tag]) {
					for (var _n = 0; _n < this._index[tag].list.length; _n++) {
						item = this._index[tag].list[_n];
						if (this._key) {
							if (!index[item[this._key]]) {
								index[item[this._key]] = true;
								items.push(item);
							}
						} else if (items.indexOf(item) === -1) {
							items.push(item);
						}
					}
				}
			}
			return items;
		};
		return TagsCache;
	}();

	var AssetRegistry = function (_EventHandler) {
		function AssetRegistry(loader) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._assets = new Set();
			_this._loader = void 0;
			_this._idToAsset = new Map();
			_this._urlToAsset = new Map();
			_this._nameToAsset = new Map();
			_this._tags = new TagsCache('_id');
			_this.prefix = null;
			_this.bundles = null;
			_this._loader = loader;
			return _this;
		}
		_inheritsLoose(AssetRegistry, _EventHandler);
		var _proto = AssetRegistry.prototype;
		_proto.list = function list(filters) {
			if (filters === void 0) {
				filters = {};
			}
			var assets = Array.from(this._assets);
			if (filters.preload !== undefined) {
				return assets.filter(function (asset) {
					return asset.preload === filters.preload;
				});
			}
			return assets;
		};
		_proto.add = function add(asset) {
			var _asset$file, _asset$file2;
			if (this._assets.has(asset)) return;
			this._assets.add(asset);
			this._idToAsset.set(asset.id, asset);
			if ((_asset$file = asset.file) != null && _asset$file.url) {
				this._urlToAsset.set(asset.file.url, asset);
			}
			if (!this._nameToAsset.has(asset.name)) {
				this._nameToAsset.set(asset.name, new Set());
			}
			this._nameToAsset.get(asset.name).add(asset);
			asset.on('name', this._onNameChange, this);
			asset.registry = this;
			this._tags.addItem(asset);
			asset.tags.on('add', this._onTagAdd, this);
			asset.tags.on('remove', this._onTagRemove, this);
			this.fire('add', asset);
			this.fire("add:" + asset.id, asset);
			if ((_asset$file2 = asset.file) != null && _asset$file2.url) {
				this.fire("add:url:" + asset.file.url, asset);
			}
			if (asset.preload) {
				this.load(asset);
			}
		};
		_proto.remove = function remove(asset) {
			var _asset$file3, _asset$file4;
			if (!this._assets.has(asset)) return false;
			this._assets.delete(asset);
			this._idToAsset.delete(asset.id);
			if ((_asset$file3 = asset.file) != null && _asset$file3.url) {
				this._urlToAsset.delete(asset.file.url);
			}
			asset.off('name', this._onNameChange, this);
			if (this._nameToAsset.has(asset.name)) {
				var items = this._nameToAsset.get(asset.name);
				items.delete(asset);
				if (items.size === 0) {
					this._nameToAsset.delete(asset.name);
				}
			}
			this._tags.removeItem(asset);
			asset.tags.off('add', this._onTagAdd, this);
			asset.tags.off('remove', this._onTagRemove, this);
			asset.fire('remove', asset);
			this.fire('remove', asset);
			this.fire("remove:" + asset.id, asset);
			if ((_asset$file4 = asset.file) != null && _asset$file4.url) {
				this.fire("remove:url:" + asset.file.url, asset);
			}
			return true;
		};
		_proto.get = function get(id) {
			return this._idToAsset.get(Number(id));
		};
		_proto.getByUrl = function getByUrl(url) {
			return this._urlToAsset.get(url);
		};
		_proto.load = function load(asset, options) {
			var _this2 = this;
			if ((asset.loading || asset.loaded) && !(options != null && options.force)) {
				return;
			}
			var file = asset.file;
			var _fireLoad = function _fireLoad() {
				_this2.fire('load', asset);
				_this2.fire("load:" + asset.id, asset);
				if (file && file.url) {
					_this2.fire("load:url:" + file.url, asset);
				}
				asset.fire('load', asset);
			};
			var _opened = function _opened(resource) {
				if (resource instanceof Array) {
					asset.resources = resource;
				} else {
					asset.resource = resource;
				}
				_this2._loader.patch(asset, _this2);
				if (asset.type === 'bundle') {
					var assetIds = asset.data.assets;
					for (var i = 0; i < assetIds.length; i++) {
						var assetInBundle = _this2._idToAsset.get(assetIds[i]);
						if (assetInBundle && !assetInBundle.loaded) {
							_this2.load(assetInBundle, {
								force: true
							});
						}
					}
					if (asset.resource.loaded) {
						_fireLoad();
					} else {
						_this2.fire('load:start', asset);
						_this2.fire("load:start:" + asset.id, asset);
						if (file && file.url) {
							_this2.fire("load:start:url:" + file.url, asset);
						}
						asset.fire('load:start', asset);
						asset.resource.on('load', _fireLoad);
					}
				} else {
					_fireLoad();
				}
			};
			var _loaded = function _loaded(err, resource, extra) {
				asset.loaded = true;
				asset.loading = false;
				if (err) {
					_this2.fire('error', err, asset);
					_this2.fire("error:" + asset.id, err, asset);
					asset.fire('error', err, asset);
				} else {
					if (asset.type === 'script') {
						var handler = _this2._loader.getHandler('script');
						if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
							document.head.removeChild(handler._cache[asset.id]);
						}
						handler._cache[asset.id] = extra;
					}
					_opened(resource);
				}
			};
			if (file || asset.type === 'cubemap') {
				this.fire('load:start', asset);
				this.fire("load:" + asset.id + ":start", asset);
				asset.loading = true;
				var fileUrl = asset.getFileUrl();
				if (asset.type === 'bundle') {
					var assetIds = asset.data.assets;
					for (var i = 0; i < assetIds.length; i++) {
						var assetInBundle = this._idToAsset.get(assetIds[i]);
						if (!assetInBundle) {
							continue;
						}
						if (assetInBundle.loaded || assetInBundle.resource || assetInBundle.loading) {
							continue;
						}
						assetInBundle.loading = true;
					}
				}
				this._loader.load(fileUrl, asset.type, _loaded, asset, options);
			} else {
				var resource = this._loader.open(asset.type, asset.data);
				asset.loaded = true;
				_opened(resource);
			}
		};
		_proto.loadFromUrl = function loadFromUrl(url, type, callback) {
			this.loadFromUrlAndFilename(url, null, type, callback);
		};
		_proto.loadFromUrlAndFilename = function loadFromUrlAndFilename(url, filename, type, callback) {
			var _this3 = this;
			var name = path.getBasename(filename || url);
			var file = {
				filename: filename || name,
				url: url
			};
			var asset = this.getByUrl(url);
			if (!asset) {
				asset = new Asset(name, type, file);
				this.add(asset);
			} else if (asset.loaded) {
				callback(asset.loadFromUrlError || null, asset);
				return;
			}
			var startLoad = function startLoad(asset) {
				asset.once('load', function (loadedAsset) {
					if (type === 'material') {
						_this3._loadTextures(loadedAsset, function (err, textures) {
							callback(err, loadedAsset);
						});
					} else {
						callback(null, loadedAsset);
					}
				});
				asset.once('error', function (err) {
					if (err) {
						_this3.loadFromUrlError = err;
					}
					callback(err, asset);
				});
				_this3.load(asset);
			};
			if (asset.resource) {
				callback(null, asset);
			} else if (type === 'model') {
				this._loadModel(asset, startLoad);
			} else {
				startLoad(asset);
			}
		};
		_proto._loadModel = function _loadModel(modelAsset, continuation) {
			var _this4 = this;
			var url = modelAsset.getFileUrl();
			var ext = path.getExtension(url);
			if (ext === '.json' || ext === '.glb') {
				var dir = path.getDirectory(url);
				var basename = path.getBasename(url);
				var mappingUrl = path.join(dir, basename.replace(ext, '.mapping.json'));
				this._loader.load(mappingUrl, 'json', function (err, data) {
					if (err) {
						modelAsset.data = {
							mapping: []
						};
						continuation(modelAsset);
					} else {
						_this4._loadMaterials(modelAsset, data, function (e, materials) {
							modelAsset.data = data;
							continuation(modelAsset);
						});
					}
				});
			} else {
				continuation(modelAsset);
			}
		};
		_proto._loadMaterials = function _loadMaterials(modelAsset, mapping, callback) {
			var _this5 = this;
			var materials = [];
			var count = 0;
			var onMaterialLoaded = function onMaterialLoaded(err, materialAsset) {
				_this5._loadTextures(materialAsset, function (err, textures) {
					materials.push(materialAsset);
					if (materials.length === count) {
						callback(null, materials);
					}
				});
			};
			for (var i = 0; i < mapping.mapping.length; i++) {
				var _path = mapping.mapping[i].path;
				if (_path) {
					count++;
					var url = modelAsset.getAbsoluteUrl(_path);
					this.loadFromUrl(url, 'material', onMaterialLoaded);
				}
			}
			if (count === 0) {
				callback(null, materials);
			}
		};
		_proto._loadTextures = function _loadTextures(materialAsset, callback) {
			var textures = [];
			var count = 0;
			var data = materialAsset.data;
			if (data.mappingFormat !== 'path') {
				callback(null, textures);
				return;
			}
			var onTextureLoaded = function onTextureLoaded(err, texture) {
				if (err) console.error(err);
				textures.push(texture);
				if (textures.length === count) {
					callback(null, textures);
				}
			};
			var texParams = standardMaterialTextureParameters;
			for (var i = 0; i < texParams.length; i++) {
				var _path2 = data[texParams[i]];
				if (_path2 && typeof _path2 === 'string') {
					count++;
					var url = materialAsset.getAbsoluteUrl(_path2);
					this.loadFromUrl(url, 'texture', onTextureLoaded);
				}
			}
			if (count === 0) {
				callback(null, textures);
			}
		};
		_proto._onTagAdd = function _onTagAdd(tag, asset) {
			this._tags.add(tag, asset);
		};
		_proto._onTagRemove = function _onTagRemove(tag, asset) {
			this._tags.remove(tag, asset);
		};
		_proto._onNameChange = function _onNameChange(asset, name, nameOld) {
			if (this._nameToAsset.has(nameOld)) {
				var items = this._nameToAsset.get(nameOld);
				items.delete(asset);
				if (items.size === 0) {
					this._nameToAsset.delete(nameOld);
				}
			}
			if (!this._nameToAsset.has(asset.name)) {
				this._nameToAsset.set(asset.name, new Set());
			}
			this._nameToAsset.get(asset.name).add(asset);
		};
		_proto.findByTag = function findByTag() {
			for (var _len = arguments.length, query = new Array(_len), _key = 0; _key < _len; _key++) {
				query[_key] = arguments[_key];
			}
			return this._tags.find(query);
		};
		_proto.filter = function filter(callback) {
			return Array.from(this._assets).filter(function (asset) {
				return callback(asset);
			});
		};
		_proto.find = function find(name, type) {
			var items = this._nameToAsset.get(name);
			if (!items) return null;
			for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
				var asset = _step.value;
				if (!type || asset.type === type) {
					return asset;
				}
			}
			return null;
		};
		_proto.findAll = function findAll(name, type) {
			var items = this._nameToAsset.get(name);
			if (!items) return [];
			var results = Array.from(items);
			if (!type) return results;
			return results.filter(function (asset) {
				return asset.type === type;
			});
		};
		return AssetRegistry;
	}(EventHandler);
	AssetRegistry.EVENT_LOAD = 'load';
	AssetRegistry.EVENT_ADD = 'add';
	AssetRegistry.EVENT_REMOVE = 'remove';
	AssetRegistry.EVENT_ERROR = 'error';

	var BundleRegistry = function () {
		function BundleRegistry(assets) {
			this._idToBundle = new Map();
			this._assetToBundles = new Map();
			this._urlsToBundles = new Map();
			this._fileRequests = new Map();
			this._assets = assets;
			this._assets.bundles = this;
			this._assets.on('add', this._onAssetAdd, this);
			this._assets.on('remove', this._onAssetRemove, this);
		}
		var _proto = BundleRegistry.prototype;
		_proto._onAssetAdd = function _onAssetAdd(asset) {
			if (asset.type === 'bundle') {
				this._idToBundle.set(asset.id, asset);
				this._assets.on("load:start:" + asset.id, this._onBundleLoadStart, this);
				this._assets.on("load:" + asset.id, this._onBundleLoad, this);
				this._assets.on("error:" + asset.id, this._onBundleError, this);
				var assetIds = asset.data.assets;
				for (var i = 0; i < assetIds.length; i++) {
					this._indexAssetInBundle(assetIds[i], asset);
				}
			} else {
				if (this._assetToBundles.has(asset.id)) {
					this._indexAssetFileUrls(asset);
				}
			}
		};
		_proto._unbindAssetEvents = function _unbindAssetEvents(id) {
			this._assets.off("load:start:" + id, this._onBundleLoadStart, this);
			this._assets.off("load:" + id, this._onBundleLoad, this);
			this._assets.off("error:" + id, this._onBundleError, this);
		};
		_proto._indexAssetInBundle = function _indexAssetInBundle(id, bundle) {
			var bundles = this._assetToBundles.get(id);
			if (!bundles) {
				bundles = new Set();
				this._assetToBundles.set(id, bundles);
			}
			bundles.add(bundle);
			var asset = this._assets.get(id);
			if (asset) this._indexAssetFileUrls(asset);
		};
		_proto._indexAssetFileUrls = function _indexAssetFileUrls(asset) {
			var urls = this._getAssetFileUrls(asset);
			if (!urls) return;
			for (var i = 0; i < urls.length; i++) {
				var bundles = this._assetToBundles.get(asset.id);
				if (!bundles) continue;
				this._urlsToBundles.set(urls[i], bundles);
			}
		};
		_proto._getAssetFileUrls = function _getAssetFileUrls(asset) {
			var url = asset.getFileUrl();
			if (!url) return null;
			url = url.split('?')[0];
			var urls = [url];
			if (asset.type === 'font') {
				var numFiles = asset.data.info.maps.length;
				for (var i = 1; i < numFiles; i++) {
					urls.push(url.replace('.png', i + ".png"));
				}
			}
			return urls;
		};
		_proto._onAssetRemove = function _onAssetRemove(asset) {
			if (asset.type === 'bundle') {
				this._idToBundle.delete(asset.id);
				this._unbindAssetEvents(asset.id);
				var assetIds = asset.data.assets;
				for (var i = 0; i < assetIds.length; i++) {
					var bundles = this._assetToBundles.get(assetIds[i]);
					if (!bundles) continue;
					bundles.delete(asset);
					if (bundles.size === 0) {
						this._assetToBundles.delete(assetIds[i]);
						for (var _iterator = _createForOfIteratorHelperLoose(this._urlsToBundles), _step; !(_step = _iterator()).done;) {
							var _step$value = _step.value,
								url = _step$value[0],
								otherBundles = _step$value[1];
							if (otherBundles !== bundles) {
								continue;
							}
							this._urlsToBundles.delete(url);
						}
					}
				}
				this._onBundleError("Bundle " + asset.id + " was removed");
			} else {
				var _bundles = this._assetToBundles.get(asset.id);
				if (!_bundles) return;
				this._assetToBundles.delete(asset.id);
				var urls = this._getAssetFileUrls(asset);
				if (!urls) return;
				for (var _i = 0; _i < urls.length; _i++) {
					this._urlsToBundles.delete(urls[_i]);
				}
			}
		};
		_proto._onBundleLoadStart = function _onBundleLoadStart(asset) {
			var _this = this;
			asset.resource.on('add', function (url, data) {
				var callbacks = _this._fileRequests.get(url);
				if (!callbacks) return;
				for (var i = 0; i < callbacks.length; i++) {
					callbacks[i](null, data);
				}
				_this._fileRequests.delete(url);
			});
		};
		_proto._onBundleLoad = function _onBundleLoad(asset) {
			if (!asset.resource) {
				this._onBundleError("Bundle " + asset.id + " failed to load");
				return;
			}
			if (!this._fileRequests) {
				return;
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(this._fileRequests), _step2; !(_step2 = _iterator2()).done;) {
				var _step2$value = _step2.value,
					url = _step2$value[0],
					requests = _step2$value[1];
				var bundles = this._urlsToBundles.get(url);
				if (!bundles || !bundles.has(asset)) continue;
				var decodedUrl = decodeURIComponent(url);
				var err = void 0,
					data = void 0;
				if (asset.resource.has(decodedUrl)) {
					data = asset.resource.get(decodedUrl);
				} else if (asset.resource.loaded) {
					err = "Bundle " + asset.id + " does not contain URL " + url;
				} else {
					continue;
				}
				for (var i = 0; i < requests.length; i++) {
					requests[i](err, err || data);
				}
				this._fileRequests.delete(url);
			}
		};
		_proto._onBundleError = function _onBundleError(err) {
			for (var _iterator3 = _createForOfIteratorHelperLoose(this._fileRequests), _step3; !(_step3 = _iterator3()).done;) {
				var _step3$value = _step3.value,
					url = _step3$value[0],
					requests = _step3$value[1];
				var bundle = this._findLoadedOrLoadingBundleForUrl(url);
				if (!bundle) {
					for (var i = 0; i < requests.length; i++) {
						requests[i](err);
					}
					this._fileRequests.delete(url);
				}
			}
		};
		_proto._findLoadedOrLoadingBundleForUrl = function _findLoadedOrLoadingBundleForUrl(url) {
			var bundles = this._urlsToBundles.get(url);
			if (!bundles) return null;
			var candidate = null;
			for (var _iterator4 = _createForOfIteratorHelperLoose(bundles), _step4; !(_step4 = _iterator4()).done;) {
				var bundle = _step4.value;
				if (bundle.loaded && bundle.resource) {
					return bundle;
				} else if (bundle.loading) {
					candidate = bundle;
				}
			}
			return candidate;
		};
		_proto.listBundlesForAsset = function listBundlesForAsset(asset) {
			var bundles = this._assetToBundles.get(asset.id);
			if (bundles) return Array.from(bundles);
			return null;
		};
		_proto.list = function list() {
			return Array.from(this._idToBundle.values());
		};
		_proto.hasUrl = function hasUrl(url) {
			return this._urlsToBundles.has(url);
		};
		_proto.urlIsLoadedOrLoading = function urlIsLoadedOrLoading(url) {
			return !!this._findLoadedOrLoadingBundleForUrl(url);
		};
		_proto.loadUrl = function loadUrl(url, callback) {
			var bundle = this._findLoadedOrLoadingBundleForUrl(url);
			if (!bundle) {
				callback("URL " + url + " not found in any bundles");
				return;
			}
			if (bundle.loaded) {
				var decodedUrl = decodeURIComponent(url);
				if (bundle.resource.has(decodedUrl)) {
					callback(null, bundle.resource.get(decodedUrl));
					return;
				} else if (bundle.resource.loaded) {
					callback("Bundle " + bundle.id + " does not contain URL " + url);
					return;
				}
			}
			var callbacks = this._fileRequests.get(url);
			if (!callbacks) {
				callbacks = [];
				this._fileRequests.set(url, callbacks);
			}
			callbacks.push(callback);
		};
		_proto.destroy = function destroy() {
			this._assets.off('add', this._onAssetAdd, this);
			this._assets.off('remove', this._onAssetRemove, this);
			for (var _iterator5 = _createForOfIteratorHelperLoose(this._idToBundle.keys()), _step5; !(_step5 = _iterator5()).done;) {
				var id = _step5.value;
				this._unbindAssetEvents(id);
			}
			this._assets = null;
			this._idToBundle.clear();
			this._idToBundle = null;
			this._assetToBundles.clear();
			this._assetToBundles = null;
			this._urlsToBundles.clear();
			this._urlsToBundles = null;
			this._fileRequests.clear();
			this._fileRequests = null;
		};
		return BundleRegistry;
	}();

	var ComponentSystemRegistry = function (_EventHandler) {
		function ComponentSystemRegistry() {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.anim = void 0;
			_this.animation = void 0;
			_this.audiolistener = void 0;
			_this.button = void 0;
			_this.camera = void 0;
			_this.collision = void 0;
			_this.element = void 0;
			_this.joint = void 0;
			_this.layoutchild = void 0;
			_this.layoutgroup = void 0;
			_this.light = void 0;
			_this.model = void 0;
			_this.particlesystem = void 0;
			_this.render = void 0;
			_this.rigidbody = void 0;
			_this.screen = void 0;
			_this.script = void 0;
			_this.scrollbar = void 0;
			_this.scrollview = void 0;
			_this.sound = void 0;
			_this.sprite = void 0;
			_this.zone = void 0;
			_this.list = [];
			return _this;
		}
		_inheritsLoose(ComponentSystemRegistry, _EventHandler);
		var _proto = ComponentSystemRegistry.prototype;
		_proto.add = function add(system) {
			var id = system.id;
			if (this[id]) {
				throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
			}
			this[id] = system;
			this.list.push(system);
		};
		_proto.remove = function remove(system) {
			var id = system.id;
			if (!this[id]) {
				throw new Error("No ComponentSystem named '" + id + "' registered");
			}
			delete this[id];
			var index = this.list.indexOf(this[id]);
			if (index !== -1) {
				this.list.splice(index, 1);
			}
		};
		_proto.destroy = function destroy() {
			this.off();
			for (var i = 0; i < this.list.length; i++) {
				this.list[i].destroy();
			}
		};
		return ComponentSystemRegistry;
	}(EventHandler);

	var Bundle = function (_EventHandler) {
		function Bundle() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _EventHandler.call.apply(_EventHandler, [this].concat(args)) || this;
			_this._index = new Map();
			_this._loaded = false;
			return _this;
		}
		_inheritsLoose(Bundle, _EventHandler);
		var _proto = Bundle.prototype;
		_proto.addFile = function addFile(url, data) {
			if (this._index.has(url)) {
				return;
			}
			this._index.set(url, data);
			this.fire('add', url, data);
		};
		_proto.has = function has(url) {
			return this._index.has(url);
		};
		_proto.get = function get(url) {
			return this._index.get(url) || null;
		};
		_proto.destroy = function destroy() {
			this._index.clear();
		};
		return _createClass(Bundle, [{
			key: "loaded",
			get: function get() {
				return this._loaded;
			},
			set: function set(value) {
				if (!value || this._loaded) {
					return;
				}
				this._loaded = true;
				this.fire('load');
			}
		}]);
	}(EventHandler);
	Bundle.EVENT_ADD = 'add';
	Bundle.EVENT_LOAD = 'load';

	var Untar = function (_EventHandler) {
		function Untar(fetchPromise, assetsPrefix) {
			var _this;
			if (assetsPrefix === void 0) {
				assetsPrefix = '';
			}
			_this = _EventHandler.call(this) || this;
			_this.headerSize = 512;
			_this.paddingSize = 512;
			_this.bytesRead = 0;
			_this.bytesReceived = 0;
			_this.headerRead = false;
			_this.reader = null;
			_this.data = new Uint8Array(0);
			_this.decoder = null;
			_this.prefix = '';
			_this.fileName = '';
			_this.fileSize = 0;
			_this.fileType = '';
			_this.ustarFormat = '';
			_this.prefix = assetsPrefix || '';
			_this.reader = fetchPromise.body.getReader();
			_this.reader.read().then(function (res) {
				_this.pump(res.done, res.value);
			}).catch(function (err) {
				_this.fire('error', err);
			});
			return _this;
		}
		_inheritsLoose(Untar, _EventHandler);
		var _proto = Untar.prototype;
		_proto.pump = function pump(done, value) {
			var _this2 = this;
			if (done) {
				this.fire('done');
				return null;
			}
			this.bytesReceived += value.byteLength;
			var data = new Uint8Array(this.data.length + value.length);
			data.set(this.data);
			data.set(value, this.data.length);
			this.data = data;
			while (this.readFile());
			return this.reader.read().then(function (res) {
				_this2.pump(res.done, res.value);
			}).catch(function (err) {
				_this2.fire('error', err);
			});
		};
		_proto.readFile = function readFile() {
			if (!this.headerRead && this.bytesReceived > this.bytesRead + this.headerSize) {
				var _this$decoder;
				this.headerRead = true;
				var view = new DataView(this.data.buffer, this.bytesRead, this.headerSize);
				(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('windows-1252');
				var headers = this.decoder.decode(view);
				this.fileName = headers.substring(0, 100).replace(/\0/g, '');
				this.fileSize = parseInt(headers.substring(124, 136), 8);
				this.fileType = headers.substring(156, 157);
				this.ustarFormat = headers.substring(257, 263);
				if (this.ustarFormat.indexOf('ustar') !== -1) {
					var prefix = headers.substring(345, 500).replace(/\0/g, '');
					if (prefix.length > 0) {
						this.fileName = prefix.trim() + this.fileName.trim();
					}
				}
				this.bytesRead += 512;
			}
			if (this.headerRead) {
				if (this.bytesReceived < this.bytesRead + this.fileSize) {
					return false;
				}
				if (this.fileType === '' || this.fileType === '0') {
					var dataView = new DataView(this.data.buffer, this.bytesRead, this.fileSize);
					var file = {
						name: this.prefix + this.fileName,
						size: this.fileSize,
						data: dataView
					};
					this.fire('file', file);
				}
				this.bytesRead += this.fileSize;
				this.headerRead = false;
				var bytesRemained = this.bytesRead % this.paddingSize;
				if (bytesRemained !== 0) {
					this.bytesRead += this.paddingSize - bytesRemained;
				}
				return true;
			}
			return false;
		};
		return Untar;
	}(EventHandler);

	var ResourceHandler = function () {
		function ResourceHandler(app, handlerType) {
			this.handlerType = '';
			this._app = void 0;
			this._maxRetries = 0;
			this._app = app;
			this.handlerType = handlerType;
		}
		var _proto = ResourceHandler.prototype;
		_proto.load = function load(url, callback, asset) {};
		_proto.open = function open(url, data, asset) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return _createClass(ResourceHandler, [{
			key: "maxRetries",
			get: function get() {
				return this._maxRetries;
			},
			set: function set(value) {
				this._maxRetries = value;
			}
		}]);
	}();

	var BundleHandler = function (_ResourceHandler) {
		function BundleHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'bundle') || this;
			_this._assets = app.assets;
			return _this;
		}
		_inheritsLoose(BundleHandler, _ResourceHandler);
		var _proto = BundleHandler.prototype;
		_proto._fetchRetries = function _fetchRetries(url, options, retries) {
			var _this2 = this;
			if (retries === void 0) {
				retries = 0;
			}
			return new Promise(function (resolve, reject) {
				var _tryFetch = function tryFetch() {
					fetch(url, options).then(resolve).catch(function (err) {
						retries++;
						if (retries < _this2.maxRetries) {
							_tryFetch();
						} else {
							reject(err);
						}
					});
				};
				_tryFetch();
			});
		};
		_proto.load = function load(url, callback) {
			var _this3 = this;
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			this._fetchRetries(url.load, {
				mode: 'cors',
				credentials: 'include'
			}, this.maxRetries).then(function (res) {
				var bundle = new Bundle();
				callback(null, bundle);
				var untar = new Untar(res, _this3._assets.prefix);
				untar.on('file', function (file) {
					bundle.addFile(file.name, file.data);
				});
				untar.on('done', function () {
					bundle.loaded = true;
				});
				untar.on('error', function (err) {
					callback(err);
				});
			}).catch(function (err) {
				callback(err);
			});
		};
		_proto.open = function open(url, bundle) {
			return bundle;
		};
		return BundleHandler;
	}(ResourceHandler);

	var ResourceLoader = function () {
		function ResourceLoader(app) {
			this._handlers = {};
			this._requests = {};
			this._cache = {};
			this._app = app;
		}
		var _proto = ResourceLoader.prototype;
		_proto.addHandler = function addHandler(type, handler) {
			this._handlers[type] = handler;
			handler._loader = this;
		};
		_proto.removeHandler = function removeHandler(type) {
			delete this._handlers[type];
		};
		_proto.getHandler = function getHandler(type) {
			return this._handlers[type];
		};
		ResourceLoader.makeKey = function makeKey(url, type) {
			return url + "-" + type;
		};
		_proto.load = function load(url, type, callback, asset, options) {
			var handler = this._handlers[type];
			if (!handler) {
				var err = "No resource handler for asset type: '" + type + "' when loading [" + url + "]";
				callback(err);
				return;
			}
			if (!url) {
				this._loadNull(handler, callback, asset);
				return;
			}
			var key = ResourceLoader.makeKey(url, type);
			if (this._cache[key] !== undefined) {
				callback(null, this._cache[key]);
			} else if (this._requests[key]) {
				this._requests[key].push(callback);
			} else {
				this._requests[key] = [callback];
				var self = this;
				var handleLoad = function handleLoad(err, urlObj) {
					if (err) {
						self._onFailure(key, err);
						return;
					}
					if (urlObj.load instanceof DataView) {
						if (handler.openBinary) {
							if (!self._requests[key]) {
								return;
							}
							try {
								var data = handler.openBinary(urlObj.load);
								self._onSuccess(key, data);
							} catch (err) {
								self._onFailure(key, err);
							}
							return;
						}
						urlObj.load = URL.createObjectURL(new Blob([urlObj.load]));
						if (asset) {
							if (asset.urlObject) {
								URL.revokeObjectURL(asset.urlObject);
							}
							asset.urlObject = urlObj.load;
						}
					}
					handler.load(urlObj, function (err, data, extra) {
						if (!self._requests[key]) {
							return;
						}
						if (err) {
							self._onFailure(key, err);
							return;
						}
						try {
							self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
						} catch (e) {
							self._onFailure(key, e);
						}
					}, asset);
				};
				var normalizedUrl = url.split('?')[0];
				if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl) && !(options && options.bundlesIgnore)) {
					if (!this._app.bundles.urlIsLoadedOrLoading(normalizedUrl)) {
						var _this$_app$assets;
						var bundles = this._app.bundles.listBundlesForAsset(asset);
						var bundle;
						if (options && options.bundlesFilter) {
							bundle = options.bundlesFilter(bundles);
						}
						if (!bundle) {
							bundles == null || bundles.sort(function (a, b) {
								return a.file.size - b.file.size;
							});
							bundle = bundles == null ? void 0 : bundles[0];
						}
						if (bundle) (_this$_app$assets = this._app.assets) == null || _this$_app$assets.load(bundle);
					}
					this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
						handleLoad(err, {
							load: fileUrlFromBundle,
							original: normalizedUrl
						});
					});
				} else {
					handleLoad(null, {
						load: url,
						original: asset && asset.file.filename || url
					});
				}
			}
		};
		_proto._loadNull = function _loadNull(handler, callback, asset) {
			var onLoad = function onLoad(err, data, extra) {
				if (err) {
					callback(err);
				} else {
					try {
						callback(null, handler.open(null, data, asset), extra);
					} catch (e) {
						callback(e);
					}
				}
			};
			handler.load(null, onLoad, asset);
		};
		_proto._onSuccess = function _onSuccess(key, result, extra) {
			if (result !== null) {
				this._cache[key] = result;
			} else {
				delete this._cache[key];
			}
			for (var i = 0; i < this._requests[key].length; i++) {
				this._requests[key][i](null, result, extra);
			}
			delete this._requests[key];
		};
		_proto._onFailure = function _onFailure(key, err) {
			console.error(err);
			if (this._requests[key]) {
				for (var i = 0; i < this._requests[key].length; i++) {
					this._requests[key][i](err);
				}
				delete this._requests[key];
			}
		};
		_proto.open = function open(type, data) {
			var handler = this._handlers[type];
			if (!handler) {
				console.warn("No resource handler found for: " + type);
				return data;
			}
			return handler.open(null, data);
		};
		_proto.patch = function patch(asset, assets) {
			var handler = this._handlers[asset.type];
			if (!handler) {
				console.warn("No resource handler found for: " + asset.type);
				return;
			}
			if (handler.patch) {
				handler.patch(asset, assets);
			}
		};
		_proto.clearCache = function clearCache(url, type) {
			var key = ResourceLoader.makeKey(url, type);
			delete this._cache[key];
		};
		_proto.getFromCache = function getFromCache(url, type) {
			var key = ResourceLoader.makeKey(url, type);
			if (this._cache[key]) {
				return this._cache[key];
			}
			return undefined;
		};
		_proto.enableRetry = function enableRetry(maxRetries) {
			if (maxRetries === void 0) {
				maxRetries = 5;
			}
			maxRetries = Math.max(0, maxRetries) || 0;
			for (var key in this._handlers) {
				this._handlers[key].maxRetries = maxRetries;
			}
		};
		_proto.disableRetry = function disableRetry() {
			for (var key in this._handlers) {
				this._handlers[key].maxRetries = 0;
			}
		};
		_proto.destroy = function destroy() {
			this._handlers = {};
			this._requests = {};
			this._cache = {};
		};
		return ResourceLoader;
	}();

	var I18nParser = function () {
		function I18nParser() {}
		var _proto = I18nParser.prototype;
		_proto._validate = function _validate(data) {
			if (!data.header) {
				throw new Error('pc.I18n#addData: Missing "header" field');
			}
			if (!data.header.version) {
				throw new Error('pc.I18n#addData: Missing "header.version" field');
			}
			if (data.header.version !== 1) {
				throw new Error('pc.I18n#addData: Invalid "header.version" field');
			}
			if (!data.data) {
				throw new Error('pc.I18n#addData: Missing "data" field');
			} else if (!Array.isArray(data.data)) {
				throw new Error('pc.I18n#addData: "data" field must be an array');
			}
			for (var i = 0, len = data.data.length; i < len; i++) {
				var entry = data.data[i];
				if (!entry.info) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].info\" field");
				}
				if (!entry.info.locale) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].info.locale\" field");
				}
				if (typeof entry.info.locale !== 'string') {
					throw new Error("pc.I18n#addData: \"data[" + i + "].info.locale\" must be a string");
				}
				if (!entry.messages) {
					throw new Error("pc.I18n#addData: missing \"data[" + i + "].messages\" field");
				}
			}
		};
		_proto.parse = function parse(data) {
			return data.data;
		};
		return I18nParser;
	}();

	var I18n = function (_EventHandler) {
		function I18n(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.locale = DEFAULT_LOCALE;
			_this._translations = {};
			_this._availableLangs = {};
			_this._app = app;
			_this._assets = [];
			_this._parser = new I18nParser();
			return _this;
		}
		_inheritsLoose(I18n, _EventHandler);
		I18n.findAvailableLocale = function findAvailableLocale$1(desiredLocale, availableLocales) {
			return findAvailableLocale(desiredLocale, availableLocales);
		};
		var _proto = I18n.prototype;
		_proto.findAvailableLocale = function findAvailableLocale(desiredLocale) {
			if (this._translations[desiredLocale]) {
				return desiredLocale;
			}
			var lang = getLang(desiredLocale);
			return this._findFallbackLocale(desiredLocale, lang);
		};
		_proto.getText = function getText(key, locale) {
			var result = key;
			var lang;
			if (!locale) {
				locale = this._locale;
				lang = this._lang;
			}
			var translations = this._translations[locale];
			if (!translations) {
				if (!lang) {
					lang = getLang(locale);
				}
				locale = this._findFallbackLocale(locale, lang);
				translations = this._translations[locale];
			}
			if (translations && translations.hasOwnProperty(key)) {
				result = translations[key];
				if (Array.isArray(result)) {
					result = result[0];
				}
				if (result === null || result === undefined) {
					result = key;
				}
			}
			return result;
		};
		_proto.getPluralText = function getPluralText(key, n, locale) {
			var result = key;
			var lang;
			var pluralFn;
			if (!locale) {
				locale = this._locale;
				lang = this._lang;
				pluralFn = this._pluralFn;
			} else {
				lang = getLang(locale);
				pluralFn = getPluralFn(lang);
			}
			var translations = this._translations[locale];
			if (!translations) {
				locale = this._findFallbackLocale(locale, lang);
				lang = getLang(locale);
				pluralFn = getPluralFn(lang);
				translations = this._translations[locale];
			}
			if (translations && translations[key] && pluralFn) {
				var index = pluralFn(n);
				result = translations[key][index];
				if (result === null || result === undefined) {
					result = key;
				}
			}
			return result;
		};
		_proto.addData = function addData(data) {
			var parsed;
			try {
				parsed = this._parser.parse(data);
			} catch (err) {
				console.error(err);
				return;
			}
			for (var i = 0, len = parsed.length; i < len; i++) {
				var entry = parsed[i];
				var locale = entry.info.locale;
				var messages = entry.messages;
				if (!this._translations[locale]) {
					this._translations[locale] = {};
					var lang = getLang(locale);
					if (!this._availableLangs[lang]) {
						this._availableLangs[lang] = locale;
					}
				}
				Object.assign(this._translations[locale], messages);
				this.fire('data:add', locale, messages);
			}
		};
		_proto.removeData = function removeData(data) {
			var parsed;
			try {
				parsed = this._parser.parse(data);
			} catch (err) {
				console.error(err);
				return;
			}
			for (var i = 0, len = parsed.length; i < len; i++) {
				var entry = parsed[i];
				var locale = entry.info.locale;
				var translations = this._translations[locale];
				if (!translations) continue;
				var messages = entry.messages;
				for (var key in messages) {
					delete translations[key];
				}
				if (Object.keys(translations).length === 0) {
					delete this._translations[locale];
					delete this._availableLangs[getLang(locale)];
				}
				this.fire('data:remove', locale, messages);
			}
		};
		_proto.destroy = function destroy() {
			this._translations = null;
			this._availableLangs = null;
			this._assets = null;
			this._parser = null;
			this.off();
		};
		_proto._findFallbackLocale = function _findFallbackLocale(locale, lang) {
			var result = DEFAULT_LOCALE_FALLBACKS[locale];
			if (result && this._translations[result]) {
				return result;
			}
			result = DEFAULT_LOCALE_FALLBACKS[lang];
			if (result && this._translations[result]) {
				return result;
			}
			result = this._availableLangs[lang];
			if (result && this._translations[result]) {
				return result;
			}
			return DEFAULT_LOCALE;
		};
		_proto._onAssetAdd = function _onAssetAdd(asset) {
			asset.on('load', this._onAssetLoad, this);
			asset.on('change', this._onAssetChange, this);
			asset.on('remove', this._onAssetRemove, this);
			asset.on('unload', this._onAssetUnload, this);
			if (asset.resource) {
				this._onAssetLoad(asset);
			}
		};
		_proto._onAssetLoad = function _onAssetLoad(asset) {
			this.addData(asset.resource);
		};
		_proto._onAssetChange = function _onAssetChange(asset) {
			if (asset.resource) {
				this.addData(asset.resource);
			}
		};
		_proto._onAssetRemove = function _onAssetRemove(asset) {
			asset.off('load', this._onAssetLoad, this);
			asset.off('change', this._onAssetChange, this);
			asset.off('remove', this._onAssetRemove, this);
			asset.off('unload', this._onAssetUnload, this);
			if (asset.resource) {
				this.removeData(asset.resource);
			}
			this._app.assets.once("add:" + asset.id, this._onAssetAdd, this);
		};
		_proto._onAssetUnload = function _onAssetUnload(asset) {
			if (asset.resource) {
				this.removeData(asset.resource);
			}
		};
		return _createClass(I18n, [{
			key: "assets",
			get: function get() {
				return this._assets;
			},
			set: function set(value) {
				var index = {};
				for (var _i = 0, len = value.length; _i < len; _i++) {
					var id = value[_i] instanceof Asset ? value[_i].id : value[_i];
					index[id] = true;
				}
				var i = this._assets.length;
				while (i--) {
					var _id = this._assets[i];
					if (!index[_id]) {
						this._app.assets.off("add:" + _id, this._onAssetAdd, this);
						var asset = this._app.assets.get(_id);
						if (asset) {
							this._onAssetRemove(asset);
						}
						this._assets.splice(i, 1);
					}
				}
				for (var _id2 in index) {
					var idNum = parseInt(_id2, 10);
					if (this._assets.indexOf(idNum) !== -1) continue;
					this._assets.push(idNum);
					var _asset = this._app.assets.get(idNum);
					if (!_asset) {
						this._app.assets.once("add:" + idNum, this._onAssetAdd, this);
					} else {
						this._onAssetAdd(_asset);
					}
				}
			}
		}, {
			key: "locale",
			get: function get() {
				return this._locale;
			},
			set: function set(value) {
				if (this._locale === value) {
					return;
				}
				var lang = getLang(value);
				if (lang === 'in') {
					lang = 'id';
					value = replaceLang(value, lang);
					if (this._locale === value) {
						return;
					}
				}
				var old = this._locale;
				this._locale = value;
				this._lang = lang;
				this._pluralFn = getPluralFn(this._lang);
				this.fire('set:locale', value, old);
			}
		}]);
	}(EventHandler);

	var ScriptRegistry = function (_EventHandler) {
		function ScriptRegistry(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._scripts = {};
			_this._list = [];
			_this._scriptSchemas = new Map();
			_this.app = app;
			return _this;
		}
		_inheritsLoose(ScriptRegistry, _EventHandler);
		var _proto = ScriptRegistry.prototype;
		_proto.destroy = function destroy() {
			this.app = null;
			this.off();
		};
		_proto.addSchema = function addSchema(id, schema) {
			if (!schema) return;
			this._scriptSchemas.set(id, schema);
		};
		_proto.getSchema = function getSchema(id) {
			return this._scriptSchemas.get(id);
		};
		_proto.add = function add(script) {
			var _this2 = this;
			var scriptName = script.__name;
			if (this._scripts.hasOwnProperty(scriptName)) {
				setTimeout(function () {
					if (script.prototype.swap) {
						var old = _this2._scripts[scriptName];
						var ind = _this2._list.indexOf(old);
						_this2._list[ind] = script;
						_this2._scripts[scriptName] = script;
						_this2.fire('swap', scriptName, script);
						_this2.fire("swap:" + scriptName, script);
					} else {
						console.warn("script registry already has '" + scriptName + "' script, define 'swap' method for new script type to enable code hot swapping");
					}
				});
				return false;
			}
			this._scripts[scriptName] = script;
			this._list.push(script);
			this.fire('add', scriptName, script);
			this.fire("add:" + scriptName, script);
			setTimeout(function () {
				if (!_this2._scripts.hasOwnProperty(scriptName)) {
					return;
				}
				if (!_this2.app || !_this2.app.systems || !_this2.app.systems.script) {
					return;
				}
				var components = _this2.app.systems.script._components;
				var attributes;
				var scriptInstances = [];
				var scriptInstancesInitialized = [];
				for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
					var component = components.items[components.loopIndex];
					if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
						if (component._scriptsData && component._scriptsData[scriptName]) {
							attributes = component._scriptsData[scriptName].attributes;
						}
						var scriptInstance = component.create(scriptName, {
							preloading: true,
							ind: component._scriptsIndex[scriptName].ind,
							attributes: attributes
						});
						if (scriptInstance) {
							scriptInstances.push(scriptInstance);
						}
						for (var _iterator = _createForOfIteratorHelperLoose(component.scripts), _step; !(_step = _iterator()).done;) {
							var _script = _step.value;
							component.initializeAttributes(_script);
						}
					}
				}
				for (var i = 0; i < scriptInstances.length; i++) {
					if (scriptInstances[i].enabled) {
						scriptInstances[i]._initialized = true;
						scriptInstancesInitialized.push(scriptInstances[i]);
						if (scriptInstances[i].initialize) {
							scriptInstances[i].initialize();
						}
					}
				}
				for (var _i = 0; _i < scriptInstancesInitialized.length; _i++) {
					if (!scriptInstancesInitialized[_i].enabled || scriptInstancesInitialized[_i]._postInitialized) {
						continue;
					}
					scriptInstancesInitialized[_i]._postInitialized = true;
					if (scriptInstancesInitialized[_i].postInitialize) {
						scriptInstancesInitialized[_i].postInitialize();
					}
				}
			});
			return true;
		};
		_proto.remove = function remove(nameOrType) {
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptName !== 'string') {
				scriptName = scriptType.__name;
			} else {
				scriptType = this.get(scriptName);
			}
			if (this.get(scriptName) !== scriptType) {
				return false;
			}
			delete this._scripts[scriptName];
			var ind = this._list.indexOf(scriptType);
			this._list.splice(ind, 1);
			this.fire('remove', scriptName, scriptType);
			this.fire("remove:" + scriptName, scriptType);
			return true;
		};
		_proto.get = function get(name) {
			return this._scripts[name] || null;
		};
		_proto.has = function has(nameOrType) {
			if (typeof nameOrType === 'string') {
				return this._scripts.hasOwnProperty(nameOrType);
			}
			if (!nameOrType) return false;
			var scriptName = nameOrType.__name;
			return this._scripts[scriptName] === nameOrType;
		};
		_proto.list = function list() {
			return this._list;
		};
		return ScriptRegistry;
	}(EventHandler);

	var cmpStaticOrder = function cmpStaticOrder(a, b) {
		return a.constructor.order - b.constructor.order;
	};
	var sortStaticOrder = function sortStaticOrder(arr) {
		return arr.sort(cmpStaticOrder);
	};
	var _enableList = [];
	var tmpPool = [];
	var getTempArray = function getTempArray() {
		var _tmpPool$pop;
		return (_tmpPool$pop = tmpPool.pop()) != null ? _tmpPool$pop : [];
	};
	var releaseTempArray = function releaseTempArray(a) {
		a.length = 0;
		tmpPool.push(a);
	};
	var Entity = function (_GraphNode) {
		function Entity(name, app) {
			var _this;
			if (app === void 0) {
				app = getApplication();
			}
			_this = _GraphNode.call(this, name) || this;
			_this.anim = void 0;
			_this.animation = void 0;
			_this.audiolistener = void 0;
			_this.button = void 0;
			_this.camera = void 0;
			_this.collision = void 0;
			_this.element = void 0;
			_this.gsplat = void 0;
			_this.layoutchild = void 0;
			_this.layoutgroup = void 0;
			_this.light = void 0;
			_this.model = void 0;
			_this.particlesystem = void 0;
			_this.render = void 0;
			_this.rigidbody = void 0;
			_this.screen = void 0;
			_this.script = void 0;
			_this.scrollbar = void 0;
			_this.scrollview = void 0;
			_this.sound = void 0;
			_this.sprite = void 0;
			_this.c = {};
			_this._app = void 0;
			_this._destroying = false;
			_this._guid = null;
			_this._template = false;
			_this._app = app;
			return _this;
		}
		_inheritsLoose(Entity, _GraphNode);
		var _proto = Entity.prototype;
		_proto.addComponent = function addComponent(type, data) {
			var system = this._app.systems[type];
			if (!system) {
				return null;
			}
			if (this.c[type]) {
				return null;
			}
			return system.addComponent(this, data);
		};
		_proto.removeComponent = function removeComponent(type) {
			var system = this._app.systems[type];
			if (!system) {
				return;
			}
			if (!this.c[type]) {
				return;
			}
			system.removeComponent(this);
		};
		_proto.findComponent = function findComponent(type) {
			var entity = this.findOne(function (entity) {
				var _entity$c;
				return (_entity$c = entity.c) == null ? void 0 : _entity$c[type];
			});
			return entity && entity.c[type];
		};
		_proto.findComponents = function findComponents(type) {
			return this.find(function (entity) {
				var _entity$c2;
				return (_entity$c2 = entity.c) == null ? void 0 : _entity$c2[type];
			}).map(function (entity) {
				return entity.c[type];
			});
		};
		_proto.findScript = function findScript(nameOrType) {
			var entity = this.findOne(function (node) {
				var _node$c;
				return (_node$c = node.c) == null || (_node$c = _node$c.script) == null ? void 0 : _node$c.has(nameOrType);
			});
			return entity == null ? void 0 : entity.c.script.get(nameOrType);
		};
		_proto.findScripts = function findScripts(nameOrType) {
			var entities = this.find(function (node) {
				var _node$c2;
				return (_node$c2 = node.c) == null || (_node$c2 = _node$c2.script) == null ? void 0 : _node$c2.has(nameOrType);
			});
			return entities.map(function (entity) {
				return entity.c.script.get(nameOrType);
			});
		};
		_proto.getGuid = function getGuid() {
			if (!this._guid) {
				this.setGuid(guid.create());
			}
			return this._guid;
		};
		_proto.setGuid = function setGuid(guid) {
			var index = this._app._entityIndex;
			if (this._guid) {
				delete index[this._guid];
			}
			this._guid = guid;
			index[this._guid] = this;
		};
		_proto._notifyHierarchyStateChanged = function _notifyHierarchyStateChanged(node, enabled) {
			var enableFirst = false;
			if (node === this && _enableList.length === 0) {
				enableFirst = true;
			}
			node._beingEnabled = true;
			node._onHierarchyStateChanged(enabled);
			if (node._onHierarchyStatePostChanged) {
				_enableList.push(node);
			}
			var c = node._children;
			for (var i = 0, len = c.length; i < len; i++) {
				if (c[i]._enabled) {
					this._notifyHierarchyStateChanged(c[i], enabled);
				}
			}
			node._beingEnabled = false;
			if (enableFirst) {
				for (var _i = 0; _i < _enableList.length; _i++) {
					_enableList[_i]._onHierarchyStatePostChanged();
				}
				_enableList.length = 0;
			}
		};
		_proto._onHierarchyStateChanged = function _onHierarchyStateChanged(enabled) {
			_GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);
			var components = this._getSortedComponents();
			for (var i = 0; i < components.length; i++) {
				var component = components[i];
				if (component.enabled) {
					if (enabled) {
						component.onEnable();
					} else {
						component.onDisable();
					}
				}
			}
			releaseTempArray(components);
		};
		_proto._onHierarchyStatePostChanged = function _onHierarchyStatePostChanged() {
			var components = this._getSortedComponents();
			for (var i = 0; i < components.length; i++) {
				components[i].onPostStateChange();
			}
			releaseTempArray(components);
		};
		_proto.findByGuid = function findByGuid(guid) {
			if (this._guid === guid) return this;
			var e = this._app._entityIndex[guid];
			if (e && (e === this || e.isDescendantOf(this))) {
				return e;
			}
			return null;
		};
		_proto.destroy = function destroy() {
			this._destroying = true;
			for (var name in this.c) {
				this.c[name].enabled = false;
			}
			for (var _name in this.c) {
				this.c[_name].system.removeComponent(this);
			}
			_GraphNode.prototype.destroy.call(this);
			if (this._guid) {
				delete this._app._entityIndex[this._guid];
			}
			this._destroying = false;
		};
		_proto.clone = function clone() {
			var duplicatedIdsMap = {};
			var clone = this._cloneRecursively(duplicatedIdsMap);
			duplicatedIdsMap[this.getGuid()] = clone;
			resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
			return clone;
		};
		_proto._getSortedComponents = function _getSortedComponents() {
			var components = this.c;
			var sortedArray = getTempArray();
			var needSort = 0;
			for (var type in components) {
				if (components.hasOwnProperty(type)) {
					var component = components[type];
					needSort |= component.constructor.order !== 0;
					sortedArray.push(component);
				}
			}
			if (needSort && sortedArray.length > 1) {
				sortStaticOrder(sortedArray);
			}
			return sortedArray;
		};
		_proto._cloneRecursively = function _cloneRecursively(duplicatedIdsMap) {
			var clone = new this.constructor(undefined, this._app);
			_GraphNode.prototype._cloneInternal.call(this, clone);
			for (var type in this.c) {
				var component = this.c[type];
				component.system.cloneComponent(this, clone);
			}
			for (var i = 0; i < this._children.length; i++) {
				var oldChild = this._children[i];
				if (oldChild instanceof Entity) {
					var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
					clone.addChild(newChild);
					duplicatedIdsMap[oldChild.getGuid()] = newChild;
				}
			}
			return clone;
		};
		return Entity;
	}(GraphNode);
	Entity.EVENT_DESTROY = 'destroy';
	function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
		if (oldEntity instanceof Entity) {
			var components = oldEntity.c;
			for (var componentName in components) {
				var component = components[componentName];
				var entityProperties = component.system.getPropertiesOfType('entity');
				for (var i = 0, len = entityProperties.length; i < len; i++) {
					var propertyDescriptor = entityProperties[i];
					var propertyName = propertyDescriptor.name;
					var oldEntityReferenceId = component[propertyName];
					var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
					if (entityIsWithinOldSubtree) {
						var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();
						if (newEntityReferenceId) {
							newEntity.c[componentName][propertyName] = newEntityReferenceId;
						}
					}
				}
			}
			if (components.script) {
				newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
			}
			if (components.render) {
				newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
			}
			if (components.anim) {
				newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
			}
			var _old = oldEntity.children.filter(function (e) {
				return e instanceof Entity;
			});
			var _new = newEntity.children.filter(function (e) {
				return e instanceof Entity;
			});
			for (var _i2 = 0, _len = _old.length; _i2 < _len; _i2++) {
				resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[_i2], _new[_i2], duplicatedIdsMap);
			}
		}
	}

	var SceneRegistryItem = function () {
		function SceneRegistryItem(name, url) {
			this.name = void 0;
			this.url = void 0;
			this.data = null;
			this._loading = false;
			this._onLoadedCallbacks = [];
			this.name = name;
			this.url = url;
		}
		return _createClass(SceneRegistryItem, [{
			key: "loaded",
			get: function get() {
				return !!this.data;
			}
		}, {
			key: "loading",
			get: function get() {
				return this._loading;
			}
		}]);
	}();

	var SceneRegistry = function () {
		function SceneRegistry(app) {
			this._app = void 0;
			this._list = [];
			this._index = {};
			this._urlIndex = {};
			this._app = app;
		}
		var _proto = SceneRegistry.prototype;
		_proto.destroy = function destroy() {
			this._app = null;
		};
		_proto.list = function list() {
			return this._list;
		};
		_proto.add = function add(name, url) {
			if (this._index.hasOwnProperty(name)) {
				return false;
			}
			var item = new SceneRegistryItem(name, url);
			var i = this._list.push(item);
			this._index[item.name] = i - 1;
			this._urlIndex[item.url] = i - 1;
			return true;
		};
		_proto.find = function find(name) {
			if (this._index.hasOwnProperty(name)) {
				return this._list[this._index[name]];
			}
			return null;
		};
		_proto.findByUrl = function findByUrl(url) {
			if (this._urlIndex.hasOwnProperty(url)) {
				return this._list[this._urlIndex[url]];
			}
			return null;
		};
		_proto.remove = function remove(name) {
			if (this._index.hasOwnProperty(name)) {
				var idx = this._index[name];
				var item = this._list[idx];
				delete this._urlIndex[item.url];
				delete this._index[name];
				this._list.splice(idx, 1);
				for (var i = 0; i < this._list.length; i++) {
					item = this._list[i];
					this._index[item.name] = i;
					this._urlIndex[item.url] = i;
				}
			}
		};
		_proto._loadSceneData = function _loadSceneData(sceneItem, storeInCache, callback) {
			var app = this._app;
			var url = sceneItem;
			if (typeof sceneItem === 'string') {
				sceneItem = this.findByUrl(url) || this.find(url) || new SceneRegistryItem('Untitled', url);
			}
			url = sceneItem.url;
			if (!url) {
				callback('Cannot find scene to load');
				return;
			}
			if (sceneItem.loaded) {
				callback(null, sceneItem);
				return;
			}
			if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
				url = path.join(app.assets.prefix, url);
			}
			sceneItem._onLoadedCallbacks.push(callback);
			if (!sceneItem._loading) {
				var handler = app.loader.getHandler('hierarchy');
				handler.load(url, function (err, data) {
					sceneItem.data = data;
					sceneItem._loading = false;
					for (var i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {
						sceneItem._onLoadedCallbacks[i](err, sceneItem);
					}
					if (!storeInCache) {
						sceneItem.data = null;
					}
					sceneItem._onLoadedCallbacks.length = 0;
				});
			}
			sceneItem._loading = true;
		};
		_proto.loadSceneData = function loadSceneData(sceneItem, callback) {
			this._loadSceneData(sceneItem, true, callback);
		};
		_proto.unloadSceneData = function unloadSceneData(sceneItem) {
			if (typeof sceneItem === 'string') {
				sceneItem = this.findByUrl(sceneItem);
			}
			if (sceneItem) {
				sceneItem.data = null;
			}
		};
		_proto._loadSceneHierarchy = function _loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback) {
			var _this = this;
			this._loadSceneData(sceneItem, false, function (err, sceneItem) {
				if (err) {
					if (callback) {
						callback(err);
					}
					return;
				}
				if (onBeforeAddHierarchy) {
					onBeforeAddHierarchy(sceneItem);
				}
				var app = _this._app;
				var _loaded = function _loaded() {
					var handler = app.loader.getHandler('hierarchy');
					app.systems.script.preloading = true;
					var entity = handler.open(sceneItem.url, sceneItem.data);
					app.systems.script.preloading = false;
					app.loader.clearCache(sceneItem.url, 'hierarchy');
					app.root.addChild(entity);
					app.systems.fire('initialize', entity);
					app.systems.fire('postInitialize', entity);
					app.systems.fire('postPostInitialize', entity);
					if (callback) callback(null, entity);
				};
				app._preloadScripts(sceneItem.data, _loaded);
			});
		};
		_proto.loadSceneHierarchy = function loadSceneHierarchy(sceneItem, callback) {
			this._loadSceneHierarchy(sceneItem, null, callback);
		};
		_proto.loadSceneSettings = function loadSceneSettings(sceneItem, callback) {
			var _this2 = this;
			this._loadSceneData(sceneItem, false, function (err, sceneItem) {
				if (!err) {
					_this2._app.applySceneSettings(sceneItem.data.settings);
					if (callback) {
						callback(null);
					}
				} else {
					if (callback) {
						callback(err);
					}
				}
			});
		};
		_proto.changeScene = function changeScene(sceneItem, callback) {
			var app = this._app;
			var onBeforeAddHierarchy = function onBeforeAddHierarchy(sceneItem) {
				var children = app.root.children;
				while (children.length) {
					children[0].destroy();
				}
				app.applySceneSettings(sceneItem.data.settings);
			};
			this._loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback);
		};
		_proto.loadScene = function loadScene(url, callback) {
			var _this3 = this;
			var app = this._app;
			var handler = app.loader.getHandler('scene');
			if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
				url = path.join(app.assets.prefix, url);
			}
			handler.load(url, function (err, data) {
				if (!err) {
					var _loaded = function _loaded() {
						app.systems.script.preloading = true;
						var scene = handler.open(url, data);
						var sceneItem = _this3.findByUrl(url);
						if (sceneItem && !sceneItem.loaded) {
							sceneItem.data = data;
						}
						app.systems.script.preloading = false;
						app.loader.clearCache(url, 'scene');
						app.loader.patch({
							resource: scene,
							type: 'scene'
						}, app.assets);
						app.root.addChild(scene.root);
						if (app.systems.rigidbody && typeof Ammo !== 'undefined') {
							app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
						}
						if (callback) {
							callback(null, scene);
						}
					};
					app._preloadScripts(data, _loaded);
				} else {
					if (callback) {
						callback(err);
					}
				}
			});
		};
		return SceneRegistry;
	}();

	var ApplicationStats = function () {
		function ApplicationStats(device) {
			this.frame = {
				fps: 0,
				ms: 0,
				dt: 0,
				updateStart: 0,
				updateTime: 0,
				renderStart: 0,
				renderTime: 0,
				physicsStart: 0,
				physicsTime: 0,
				cullTime: 0,
				sortTime: 0,
				skinTime: 0,
				morphTime: 0,
				instancingTime: 0,
				triangles: 0,
				otherPrimitives: 0,
				shaders: 0,
				materials: 0,
				cameras: 0,
				shadowMapUpdates: 0,
				shadowMapTime: 0,
				depthMapTime: 0,
				forwardTime: 0,
				lightClustersTime: 0,
				lightClusters: 0,
				_timeToCountFrames: 0,
				_fpsAccum: 0
			};
			this.drawCalls = {
				forward: 0,
				depth: 0,
				shadow: 0,
				immediate: 0,
				misc: 0,
				total: 0,
				skinned: 0,
				instanced: 0,
				removedByInstancing: 0
			};
			this.misc = {
				renderTargetCreationTime: 0
			};
			this.particles = {
				updatesPerFrame: 0,
				_updatesPerFrame: 0,
				frameTime: 0,
				_frameTime: 0
			};
			this.shaders = device._shaderStats;
			this.vram = device._vram;
			Object.defineProperty(this.vram, 'totalUsed', {
				get: function get() {
					return this.tex + this.vb + this.ib;
				}
			});
			Object.defineProperty(this.vram, 'geom', {
				get: function get() {
					return this.vb + this.ib;
				}
			});
		}
		return _createClass(ApplicationStats, [{
			key: "scene",
			get: function get() {
				return getApplication().scene._stats;
			}
		}, {
			key: "lightmapper",
			get: function get() {
				var _getApplication$light;
				return (_getApplication$light = getApplication().lightmapper) == null ? void 0 : _getApplication$light.stats;
			}
		}, {
			key: "batcher",
			get: function get() {
				var batcher = getApplication()._batcher;
				return batcher ? batcher._stats : null;
			}
		}]);
	}();

	exports.app = null;
	var AppBase = function (_EventHandler) {
		function AppBase(canvas) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._batcher = null;
			_this._destroyRequested = false;
			_this._inFrameUpdate = false;
			_this._librariesLoaded = false;
			_this._fillMode = FILLMODE_KEEP_ASPECT;
			_this._resolutionMode = RESOLUTION_FIXED;
			_this._allowResize = true;
			_this._skyboxAsset = null;
			_this._soundManager = void 0;
			_this._visibilityChangeHandler = void 0;
			_this._entityIndex = {};
			_this._inTools = false;
			_this._scriptPrefix = '';
			_this._time = 0;
			_this.enableBundles = typeof TextDecoder !== 'undefined';
			_this.frameRequestId = void 0;
			_this.timeScale = 1;
			_this.maxDeltaTime = 0.1;
			_this.frame = 0;
			_this.frameGraph = new FrameGraph();
			_this.renderer = void 0;
			_this.scriptsOrder = [];
			_this.stats = void 0;
			_this.autoRender = true;
			_this.renderNextFrame = false;
			_this.graphicsDevice = void 0;
			_this.root = void 0;
			_this.scene = void 0;
			_this.lightmapper = null;
			_this.loader = new ResourceLoader(_this);
			_this.assets = void 0;
			_this.bundles = void 0;
			_this.scenes = new SceneRegistry(_this);
			_this.scripts = new ScriptRegistry(_this);
			_this.systems = new ComponentSystemRegistry();
			_this.i18n = new I18n(_this);
			_this.keyboard = null;
			_this.mouse = null;
			_this.touch = null;
			_this.gamepads = null;
			_this.elementInput = null;
			_this.xr = null;
			AppBase._applications[canvas.id] = _this;
			setApplication(_this);
			exports.app = _this;
			_this.root = new Entity();
			_this.root._enabledInHierarchy = true;
			return _this;
		}
		_inheritsLoose(AppBase, _EventHandler);
		var _proto = AppBase.prototype;
		_proto.init = function init(appOptions) {
			var _this2 = this;
			var assetPrefix = appOptions.assetPrefix,
				batchManager = appOptions.batchManager,
				componentSystems = appOptions.componentSystems,
				elementInput = appOptions.elementInput,
				gamepads = appOptions.gamepads,
				graphicsDevice = appOptions.graphicsDevice,
				keyboard = appOptions.keyboard,
				lightmapper = appOptions.lightmapper,
				mouse = appOptions.mouse,
				resourceHandlers = appOptions.resourceHandlers,
				scriptsOrder = appOptions.scriptsOrder,
				scriptPrefix = appOptions.scriptPrefix,
				soundManager = appOptions.soundManager,
				touch = appOptions.touch,
				xr = appOptions.xr;
			this.graphicsDevice = graphicsDevice;
			this._initDefaultMaterial();
			this._initProgramLibrary();
			this.stats = new ApplicationStats(graphicsDevice);
			this._soundManager = soundManager;
			this.scene = new Scene(graphicsDevice);
			this._registerSceneImmediate(this.scene);
			this.assets = new AssetRegistry(this.loader);
			if (assetPrefix) this.assets.prefix = assetPrefix;
			this.bundles = new BundleRegistry(this.assets);
			this.scriptsOrder = scriptsOrder || [];
			this.defaultLayerWorld = new Layer({
				name: 'World',
				id: LAYERID_WORLD
			});
			this.defaultLayerDepth = new Layer({
				name: 'Depth',
				id: LAYERID_DEPTH,
				enabled: false,
				opaqueSortMode: SORTMODE_NONE
			});
			this.defaultLayerSkybox = new Layer({
				name: 'Skybox',
				id: LAYERID_SKYBOX,
				opaqueSortMode: SORTMODE_NONE
			});
			this.defaultLayerUi = new Layer({
				name: 'UI',
				id: LAYERID_UI,
				transparentSortMode: SORTMODE_MANUAL
			});
			this.defaultLayerImmediate = new Layer({
				name: 'Immediate',
				id: LAYERID_IMMEDIATE,
				opaqueSortMode: SORTMODE_NONE
			});
			var defaultLayerComposition = new LayerComposition('default');
			defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
			defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
			defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
			defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
			defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
			defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
			defaultLayerComposition.pushTransparent(this.defaultLayerUi);
			this.scene.layers = defaultLayerComposition;
			AreaLightLuts.createPlaceholder(graphicsDevice);
			this.renderer = new ForwardRenderer(graphicsDevice);
			this.renderer.scene = this.scene;
			if (lightmapper) {
				this.lightmapper = new lightmapper(graphicsDevice, this.root, this.scene, this.renderer, this.assets);
				this.once('prerender', this._firstBake, this);
			}
			if (batchManager) {
				this._batcher = new batchManager(graphicsDevice, this.root, this.scene);
				this.once('prerender', this._firstBatch, this);
			}
			this.keyboard = keyboard || null;
			this.mouse = mouse || null;
			this.touch = touch || null;
			this.gamepads = gamepads || null;
			if (elementInput) {
				this.elementInput = elementInput;
				this.elementInput.app = this;
			}
			this.xr = xr ? new xr(this) : null;
			if (this.elementInput) this.elementInput.attachSelectEvents();
			this._scriptPrefix = scriptPrefix || '';
			if (this.enableBundles) {
				this.loader.addHandler('bundle', new BundleHandler(this));
			}
			resourceHandlers.forEach(function (resourceHandler) {
				var handler = new resourceHandler(_this2);
				_this2.loader.addHandler(handler.handlerType, handler);
			});
			componentSystems.forEach(function (componentSystem) {
				_this2.systems.add(new componentSystem(_this2));
			});
			this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
			if (typeof document !== 'undefined') {
				if (document.hidden !== undefined) {
					this._hiddenAttr = 'hidden';
					document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
				} else if (document.mozHidden !== undefined) {
					this._hiddenAttr = 'mozHidden';
					document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
				} else if (document.msHidden !== undefined) {
					this._hiddenAttr = 'msHidden';
					document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
				} else if (document.webkitHidden !== undefined) {
					this._hiddenAttr = 'webkitHidden';
					document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
				}
			}
			this.tick = makeTick(this);
		};
		AppBase.getApplication = function getApplication$1(id) {
			return id ? AppBase._applications[id] : getApplication();
		};
		_proto._initDefaultMaterial = function _initDefaultMaterial() {
			var material = new StandardMaterial();
			material.name = 'Default Material';
			setDefaultMaterial(this.graphicsDevice, material);
		};
		_proto._initProgramLibrary = function _initProgramLibrary() {
			var library = new ProgramLibrary(this.graphicsDevice, new StandardMaterial());
			setProgramLibrary(this.graphicsDevice, library);
		};
		_proto.configure = function configure(url, callback) {
			var _this3 = this;
			http.get(url, function (err, response) {
				if (err) {
					callback(err);
					return;
				}
				var props = response.application_properties;
				var scenes = response.scenes;
				var assets = response.assets;
				_this3._parseApplicationProperties(props, function (err) {
					_this3._parseScenes(scenes);
					_this3._parseAssets(assets);
					if (!err) {
						callback(null);
					} else {
						callback(err);
					}
				});
			});
		};
		_proto.preload = function preload(callback) {
			var _this4 = this;
			this.fire('preload:start');
			var assets = this.assets.list({
				preload: true
			});
			if (assets.length === 0) {
				this.fire('preload:end');
				callback();
				return;
			}
			var loadedCount = 0;
			var onAssetLoadOrError = function onAssetLoadOrError() {
				loadedCount++;
				_this4.fire('preload:progress', loadedCount / assets.length);
				if (loadedCount === assets.length) {
					_this4.fire('preload:end');
					callback();
				}
			};
			assets.forEach(function (asset) {
				if (!asset.loaded) {
					asset.once('load', onAssetLoadOrError);
					asset.once('error', onAssetLoadOrError);
					_this4.assets.load(asset);
				} else {
					onAssetLoadOrError();
				}
			});
		};
		_proto._preloadScripts = function _preloadScripts(sceneData, callback) {
			callback();
		};
		_proto._parseApplicationProperties = function _parseApplicationProperties(props, callback) {
			if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
				this.loader.enableRetry(props.maxAssetRetries);
			}
			if (!props.useDevicePixelRatio) {
				props.useDevicePixelRatio = props.use_device_pixel_ratio;
			}
			if (!props.resolutionMode) {
				props.resolutionMode = props.resolution_mode;
			}
			if (!props.fillMode) {
				props.fillMode = props.fill_mode;
			}
			this._width = props.width;
			this._height = props.height;
			if (props.useDevicePixelRatio) {
				this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
			}
			this.setCanvasResolution(props.resolutionMode, this._width, this._height);
			this.setCanvasFillMode(props.fillMode, this._width, this._height);
			if (props.layers && props.layerOrder) {
				var composition = new LayerComposition('application');
				var layers = {};
				for (var key in props.layers) {
					var data = props.layers[key];
					data.id = parseInt(key, 10);
					data.enabled = data.id !== LAYERID_DEPTH;
					layers[key] = new Layer(data);
				}
				for (var i = 0, len = props.layerOrder.length; i < len; i++) {
					var sublayer = props.layerOrder[i];
					var layer = layers[sublayer.layer];
					if (!layer) continue;
					if (sublayer.transparent) {
						composition.pushTransparent(layer);
					} else {
						composition.pushOpaque(layer);
					}
					composition.subLayerEnabled[i] = sublayer.enabled;
				}
				this.scene.layers = composition;
			}
			if (props.batchGroups) {
				var batcher = this.batcher;
				if (batcher) {
					for (var _i = 0, _len = props.batchGroups.length; _i < _len; _i++) {
						var grp = props.batchGroups[_i];
						batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
					}
				}
			}
			if (props.i18nAssets) {
				this.i18n.assets = props.i18nAssets;
			}
			this._loadLibraries(props.libraries, callback);
		};
		_proto._loadLibraries = function _loadLibraries(urls, callback) {
			var _this5 = this;
			var len = urls.length;
			var count = len;
			var regex = /^https?:\/\//;
			if (len) {
				var onLoad = function onLoad(err, script) {
					count--;
					if (err) {
						callback(err);
					} else if (count === 0) {
						_this5.onLibrariesLoaded();
						callback(null);
					}
				};
				for (var i = 0; i < len; ++i) {
					var url = urls[i];
					if (!regex.test(url.toLowerCase()) && this._scriptPrefix) {
						url = path.join(this._scriptPrefix, url);
					}
					this.loader.load(url, 'script', onLoad);
				}
			} else {
				this.onLibrariesLoaded();
				callback(null);
			}
		};
		_proto._parseScenes = function _parseScenes(scenes) {
			if (!scenes) return;
			for (var i = 0; i < scenes.length; i++) {
				this.scenes.add(scenes[i].name, scenes[i].url);
			}
		};
		_proto._parseAssets = function _parseAssets(assets) {
			var list = [];
			var scriptsIndex = {};
			var bundlesIndex = {};
			for (var i = 0; i < this.scriptsOrder.length; i++) {
				var id = this.scriptsOrder[i];
				if (!assets[id]) {
					continue;
				}
				scriptsIndex[id] = true;
				list.push(assets[id]);
			}
			if (this.enableBundles) {
				for (var _id in assets) {
					if (assets[_id].type === 'bundle') {
						bundlesIndex[_id] = true;
						list.push(assets[_id]);
					}
				}
			}
			for (var _id2 in assets) {
				if (scriptsIndex[_id2] || bundlesIndex[_id2]) {
					continue;
				}
				list.push(assets[_id2]);
			}
			for (var _i2 = 0; _i2 < list.length; _i2++) {
				var data = list[_i2];
				var asset = new Asset(data.name, data.type, data.file, data.data);
				asset.id = parseInt(data.id, 10);
				asset.preload = data.preload ? data.preload : false;
				asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
				asset.tags.add(data.tags);
				if (data.i18n) {
					for (var locale in data.i18n) {
						asset.addLocalizedAssetId(locale, data.i18n[locale]);
					}
				}
				this.assets.add(asset);
			}
		};
		_proto.start = function start() {
			this.frame = 0;
			this.fire('start', {
				timestamp: now(),
				target: this
			});
			if (!this._librariesLoaded) {
				this.onLibrariesLoaded();
			}
			this.systems.fire('initialize', this.root);
			this.fire('initialize');
			this.systems.fire('postInitialize', this.root);
			this.systems.fire('postPostInitialize', this.root);
			this.fire('postinitialize');
			this.tick();
		};
		_proto.inputUpdate = function inputUpdate(dt) {
			if (this.controller) {
				this.controller.update(dt);
			}
			if (this.mouse) {
				this.mouse.update();
			}
			if (this.keyboard) {
				this.keyboard.update();
			}
			if (this.gamepads) {
				this.gamepads.update();
			}
		};
		_proto.update = function update(dt) {
			this.frame++;
			this.graphicsDevice.updateClientRect();
			this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
			this.systems.fire('animationUpdate', dt);
			this.systems.fire('postUpdate', dt);
			this.fire('update', dt);
			this.inputUpdate(dt);
		};
		_proto.frameStart = function frameStart() {
			this.graphicsDevice.frameStart();
		};
		_proto.frameEnd = function frameEnd() {
			this.graphicsDevice.frameEnd();
		};
		_proto.render = function render() {
			this.fire('prerender');
			this.root.syncHierarchy();
			if (this._batcher) {
				this._batcher.updateAll();
			}
			this.renderComposition(this.scene.layers);
			this.fire('postrender');
		};
		_proto.renderComposition = function renderComposition(layerComposition) {
			this.renderer.update(layerComposition);
			this.renderer.buildFrameGraph(this.frameGraph, layerComposition);
			this.frameGraph.render(this.graphicsDevice);
		};
		_proto._fillFrameStatsBasic = function _fillFrameStatsBasic(now, dt, ms) {
			var stats = this.stats.frame;
			stats.dt = dt;
			stats.ms = ms;
			if (now > stats._timeToCountFrames) {
				stats.fps = stats._fpsAccum;
				stats._fpsAccum = 0;
				stats._timeToCountFrames = now + 1000;
			} else {
				stats._fpsAccum++;
			}
			this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
			this.graphicsDevice._drawCallsPerFrame = 0;
		};
		_proto._fillFrameStats = function _fillFrameStats() {
			var stats = this.stats.frame;
			stats.cameras = this.renderer._camerasRendered;
			stats.materials = this.renderer._materialSwitches;
			stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
			stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
			stats.shadowMapTime = this.renderer._shadowMapTime;
			stats.depthMapTime = this.renderer._depthMapTime;
			stats.forwardTime = this.renderer._forwardTime;
			var prims = this.graphicsDevice._primsPerFrame;
			stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
			stats.cullTime = this.renderer._cullTime;
			stats.sortTime = this.renderer._sortTime;
			stats.skinTime = this.renderer._skinTime;
			stats.morphTime = this.renderer._morphTime;
			stats.lightClusters = this.renderer._lightClusters;
			stats.lightClustersTime = this.renderer._lightClustersTime;
			stats.otherPrimitives = 0;
			for (var i = 0; i < prims.length; i++) {
				if (i < PRIMITIVE_TRIANGLES) {
					stats.otherPrimitives += prims[i];
				}
				prims[i] = 0;
			}
			this.renderer._camerasRendered = 0;
			this.renderer._materialSwitches = 0;
			this.renderer._shadowMapUpdates = 0;
			this.graphicsDevice._shaderSwitchesPerFrame = 0;
			this.renderer._cullTime = 0;
			this.renderer._layerCompositionUpdateTime = 0;
			this.renderer._lightClustersTime = 0;
			this.renderer._sortTime = 0;
			this.renderer._skinTime = 0;
			this.renderer._morphTime = 0;
			this.renderer._shadowMapTime = 0;
			this.renderer._depthMapTime = 0;
			this.renderer._forwardTime = 0;
			stats = this.stats.drawCalls;
			stats.forward = this.renderer._forwardDrawCalls;
			stats.culled = this.renderer._numDrawCallsCulled;
			stats.depth = 0;
			stats.shadow = this.renderer._shadowDrawCalls;
			stats.skinned = this.renderer._skinDrawCalls;
			stats.immediate = 0;
			stats.instanced = 0;
			stats.removedByInstancing = 0;
			stats.misc = stats.total - (stats.forward + stats.shadow);
			this.renderer._depthDrawCalls = 0;
			this.renderer._shadowDrawCalls = 0;
			this.renderer._forwardDrawCalls = 0;
			this.renderer._numDrawCallsCulled = 0;
			this.renderer._skinDrawCalls = 0;
			this.renderer._immediateRendered = 0;
			this.renderer._instancedDrawCalls = 0;
			this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
			stats = this.stats.particles;
			stats.updatesPerFrame = stats._updatesPerFrame;
			stats.frameTime = stats._frameTime;
			stats._updatesPerFrame = 0;
			stats._frameTime = 0;
		};
		_proto.setCanvasFillMode = function setCanvasFillMode(mode, width, height) {
			this._fillMode = mode;
			this.resizeCanvas(width, height);
		};
		_proto.setCanvasResolution = function setCanvasResolution(mode, width, height) {
			this._resolutionMode = mode;
			if (mode === RESOLUTION_AUTO && width === undefined) {
				width = this.graphicsDevice.canvas.clientWidth;
				height = this.graphicsDevice.canvas.clientHeight;
			}
			this.graphicsDevice.resizeCanvas(width, height);
		};
		_proto.isHidden = function isHidden() {
			return document[this._hiddenAttr];
		};
		_proto.onVisibilityChange = function onVisibilityChange() {
			if (this.isHidden()) {
				if (this._soundManager) {
					this._soundManager.suspend();
				}
			} else {
				if (this._soundManager) {
					this._soundManager.resume();
				}
			}
		};
		_proto.resizeCanvas = function resizeCanvas(width, height) {
			if (!this._allowResize) return undefined;
			if (this.xr && this.xr.session) {
				return undefined;
			}
			var windowWidth = window.innerWidth;
			var windowHeight = window.innerHeight;
			if (this._fillMode === FILLMODE_KEEP_ASPECT) {
				var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
				var winR = windowWidth / windowHeight;
				if (r > winR) {
					width = windowWidth;
					height = width / r;
				} else {
					height = windowHeight;
					width = height * r;
				}
			} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
				width = windowWidth;
				height = windowHeight;
			}
			this.graphicsDevice.canvas.style.width = width + "px";
			this.graphicsDevice.canvas.style.height = height + "px";
			this.updateCanvasSize();
			return {
				width: width,
				height: height
			};
		};
		_proto.updateCanvasSize = function updateCanvasSize() {
			var _this$xr;
			if (!this._allowResize || (_this$xr = this.xr) != null && _this$xr.active) {
				return;
			}
			if (this._resolutionMode === RESOLUTION_AUTO) {
				var canvas = this.graphicsDevice.canvas;
				this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
			}
		};
		_proto.onLibrariesLoaded = function onLibrariesLoaded() {
			this._librariesLoaded = true;
			if (this.systems.rigidbody) {
				this.systems.rigidbody.onLibraryLoaded();
			}
		};
		_proto.applySceneSettings = function applySceneSettings(settings) {
			var asset;
			if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
				var _settings$physics$gra = settings.physics.gravity,
					x = _settings$physics$gra[0],
					y = _settings$physics$gra[1],
					z = _settings$physics$gra[2];
				this.systems.rigidbody.gravity.set(x, y, z);
			}
			this.scene.applySettings(settings);
			if (settings.render.hasOwnProperty('skybox')) {
				if (settings.render.skybox) {
					asset = this.assets.get(settings.render.skybox);
					if (asset) {
						this.setSkybox(asset);
					} else {
						this.assets.once("add:" + settings.render.skybox, this.setSkybox, this);
					}
				} else {
					this.setSkybox(null);
				}
			}
		};
		_proto.setAreaLightLuts = function setAreaLightLuts(ltcMat1, ltcMat2) {
			if (ltcMat1 && ltcMat2) {
				AreaLightLuts.set(this.graphicsDevice, ltcMat1, ltcMat2);
			}
		};
		_proto.setSkybox = function setSkybox(asset) {
			var _this6 = this;
			if (asset !== this._skyboxAsset) {
				var onSkyboxRemoved = function onSkyboxRemoved() {
					_this6.setSkybox(null);
				};
				var onSkyboxChanged = function onSkyboxChanged() {
					_this6.scene.setSkybox(_this6._skyboxAsset ? _this6._skyboxAsset.resources : null);
				};
				if (this._skyboxAsset) {
					this.assets.off("load:" + this._skyboxAsset.id, onSkyboxChanged, this);
					this.assets.off("remove:" + this._skyboxAsset.id, onSkyboxRemoved, this);
					this._skyboxAsset.off('change', onSkyboxChanged, this);
				}
				this._skyboxAsset = asset;
				if (this._skyboxAsset) {
					this.assets.on("load:" + this._skyboxAsset.id, onSkyboxChanged, this);
					this.assets.once("remove:" + this._skyboxAsset.id, onSkyboxRemoved, this);
					this._skyboxAsset.on('change', onSkyboxChanged, this);
					if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
						this._skyboxAsset.loadFaces = true;
					}
					this.assets.load(this._skyboxAsset);
				}
				onSkyboxChanged();
			}
		};
		_proto._firstBake = function _firstBake() {
			var _this$lightmapper;
			(_this$lightmapper = this.lightmapper) == null || _this$lightmapper.bake(null, this.scene.lightmapMode);
		};
		_proto._firstBatch = function _firstBatch() {
			var _this$batcher;
			(_this$batcher = this.batcher) == null || _this$batcher.generate();
		};
		_proto._processTimestamp = function _processTimestamp(timestamp) {
			return timestamp;
		};
		_proto.drawLine = function drawLine(start, end, color, depthTest, layer) {
			this.scene.drawLine(start, end, color, depthTest, layer);
		};
		_proto.drawLines = function drawLines(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.drawLines(positions, colors, depthTest, layer);
		};
		_proto.drawLineArrays = function drawLineArrays(positions, colors, depthTest, layer) {
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.drawLineArrays(positions, colors, depthTest, layer);
		};
		_proto.drawWireSphere = function drawWireSphere(center, radius, color, segments, depthTest, layer) {
			if (color === void 0) {
				color = Color.WHITE;
			}
			if (segments === void 0) {
				segments = 20;
			}
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
		};
		_proto.drawWireAlignedBox = function drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat) {
			if (color === void 0) {
				color = Color.WHITE;
			}
			if (depthTest === void 0) {
				depthTest = true;
			}
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat);
		};
		_proto.drawMeshInstance = function drawMeshInstance(meshInstance, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
		};
		_proto.drawMesh = function drawMesh(mesh, material, matrix, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
		};
		_proto.drawQuad = function drawQuad(matrix, material, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
		};
		_proto.drawTexture = function drawTexture(x, y, width, height, texture, material, layer, filterable) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			if (filterable === void 0) {
				filterable = true;
			}
			if (filterable === false && !this.graphicsDevice.isWebGPU) {
				return;
			}
			var matrix = new Mat4();
			matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, -height, 0.0));
			if (!material) {
				material = new ShaderMaterial();
				material.cull = CULLFACE_NONE;
				material.setParameter('colorMap', texture);
				material.shaderDesc = filterable ? this.scene.immediate.getTextureShaderDesc(texture.encoding) : this.scene.immediate.getUnfilterableTextureShaderDesc();
				material.update();
			}
			this.drawQuad(matrix, material, layer);
		};
		_proto.drawDepthTexture = function drawDepthTexture(x, y, width, height, layer) {
			if (layer === void 0) {
				layer = this.scene.defaultDrawLayer;
			}
			var material = new ShaderMaterial();
			material.cull = CULLFACE_NONE;
			material.shaderDesc = this.scene.immediate.getDepthTextureShaderDesc();
			material.update();
			this.drawTexture(x, y, width, height, null, material, layer);
		};
		_proto.destroy = function destroy() {
			var _this$lightmapper2, _this$xr2, _this$xr3, _this$_soundManager;
			if (this._inFrameUpdate) {
				this._destroyRequested = true;
				return;
			}
			var canvasId = this.graphicsDevice.canvas.id;
			this.fire('destroy', this);
			this.off('librariesloaded');
			if (typeof document !== 'undefined') {
				document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
				document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
			}
			this._visibilityChangeHandler = null;
			this.root.destroy();
			this.root = null;
			if (this.mouse) {
				this.mouse.off();
				this.mouse.detach();
				this.mouse = null;
			}
			if (this.keyboard) {
				this.keyboard.off();
				this.keyboard.detach();
				this.keyboard = null;
			}
			if (this.touch) {
				this.touch.off();
				this.touch.detach();
				this.touch = null;
			}
			if (this.elementInput) {
				this.elementInput.detach();
				this.elementInput = null;
			}
			if (this.gamepads) {
				this.gamepads.destroy();
				this.gamepads = null;
			}
			if (this.controller) {
				this.controller = null;
			}
			this.systems.destroy();
			if (this.scene.layers) {
				this.scene.layers.destroy();
			}
			var assets = this.assets.list();
			for (var i = 0; i < assets.length; i++) {
				assets[i].unload();
				assets[i].off();
			}
			this.assets.off();
			this.bundles.destroy();
			this.bundles = null;
			this.i18n.destroy();
			this.i18n = null;
			var scriptHandler = this.loader.getHandler('script');
			scriptHandler == null || scriptHandler.clearCache();
			this.loader.destroy();
			this.loader = null;
			this.scene.destroy();
			this.scene = null;
			this.systems = null;
			this.context = null;
			this.scripts.destroy();
			this.scripts = null;
			this.scenes.destroy();
			this.scenes = null;
			(_this$lightmapper2 = this.lightmapper) == null || _this$lightmapper2.destroy();
			this.lightmapper = null;
			if (this._batcher) {
				this._batcher.destroy();
				this._batcher = null;
			}
			this._entityIndex = {};
			this.defaultLayerDepth.onDisable = null;
			this.defaultLayerDepth.onEnable = null;
			this.defaultLayerDepth = null;
			this.defaultLayerWorld = null;
			(_this$xr2 = this.xr) == null || _this$xr2.end();
			(_this$xr3 = this.xr) == null || _this$xr3.destroy();
			this.renderer.destroy();
			this.renderer = null;
			this.graphicsDevice.destroy();
			this.graphicsDevice = null;
			this.tick = null;
			this.off();
			(_this$_soundManager = this._soundManager) == null || _this$_soundManager.destroy();
			this._soundManager = null;
			script.app = null;
			AppBase._applications[canvasId] = null;
			if (getApplication() === this) {
				setApplication(null);
			}
			AppBase.cancelTick(this);
		};
		AppBase.cancelTick = function cancelTick(app) {
			if (app.frameRequestId) {
				window.cancelAnimationFrame(app.frameRequestId);
				app.frameRequestId = undefined;
			}
		};
		_proto.getEntityFromIndex = function getEntityFromIndex(guid) {
			return this._entityIndex[guid];
		};
		_proto._registerSceneImmediate = function _registerSceneImmediate(scene) {
			this.on('postrender', scene.immediate.onPostRender, scene.immediate);
		};
		return _createClass(AppBase, [{
			key: "soundManager",
			get: function get() {
				return this._soundManager;
			}
		}, {
			key: "batcher",
			get: function get() {
				return this._batcher;
			}
		}, {
			key: "fillMode",
			get: function get() {
				return this._fillMode;
			}
		}, {
			key: "resolutionMode",
			get: function get() {
				return this._resolutionMode;
			}
		}]);
	}(EventHandler);
	AppBase._applications = {};
	var _frameEndData = {};
	var makeTick = function makeTick(_app) {
		var application = _app;
		return function (timestamp, frame) {
			var _application$xr2;
			if (!application.graphicsDevice) {
				return;
			}
			if (application.frameRequestId) {
				var _application$xr;
				(_application$xr = application.xr) == null || (_application$xr = _application$xr.session) == null || _application$xr.cancelAnimationFrame(application.frameRequestId);
				cancelAnimationFrame(application.frameRequestId);
				application.frameRequestId = null;
			}
			application._inFrameUpdate = true;
			setApplication(application);
			exports.app = application;
			var currentTime = application._processTimestamp(timestamp) || now();
			var ms = currentTime - (application._time || currentTime);
			var dt = ms / 1000.0;
			dt = math.clamp(dt, 0, application.maxDeltaTime);
			dt *= application.timeScale;
			application._time = currentTime;
			if ((_application$xr2 = application.xr) != null && _application$xr2.session) {
				application.frameRequestId = application.xr.session.requestAnimationFrame(application.tick);
			} else {
				application.frameRequestId = platform.browser || platform.worker ? requestAnimationFrame(application.tick) : null;
			}
			if (application.graphicsDevice.contextLost) {
				return;
			}
			application._fillFrameStatsBasic(currentTime, dt, ms);
			application.fire('frameupdate', ms);
			var shouldRenderFrame = true;
			if (frame) {
				var _application$xr3;
				shouldRenderFrame = (_application$xr3 = application.xr) == null ? void 0 : _application$xr3.update(frame);
				application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
			} else {
				application.graphicsDevice.defaultFramebuffer = null;
			}
			if (shouldRenderFrame) {
				application.update(dt);
				application.fire('framerender');
				if (application.autoRender || application.renderNextFrame) {
					application.updateCanvasSize();
					application.frameStart();
					application.render();
					application.frameEnd();
					application.renderNextFrame = false;
				}
				_frameEndData.timestamp = now();
				_frameEndData.target = application;
				application.fire('frameend', _frameEndData);
			}
			application._inFrameUpdate = false;
			if (application._destroyRequested) {
				application.destroy();
			}
		};
	};

	var AppOptions = function AppOptions() {
		this.elementInput = void 0;
		this.keyboard = void 0;
		this.mouse = void 0;
		this.touch = void 0;
		this.gamepads = void 0;
		this.scriptPrefix = void 0;
		this.assetPrefix = void 0;
		this.scriptsOrder = void 0;
		this.soundManager = void 0;
		this.graphicsDevice = void 0;
		this.lightmapper = void 0;
		this.batchManager = void 0;
		this.xr = void 0;
		this.componentSystems = [];
		this.resourceHandlers = [];
	};

	var tempSphere = new BoundingSphere();
	var BakeLight = function () {
		function BakeLight(scene, light, lightingParams) {
			this.scene = scene;
			this.light = light;
			this.store();
			light.numCascades = 1;
			if (this.scene.clusteredLightingEnabled) {
				light.castShadows = light.bakeShadows && lightingParams.shadowsEnabled;
			}
			if (light.type !== LIGHTTYPE_DIRECTIONAL) {
				light._node.getWorldTransform();
				light.getBoundingSphere(tempSphere);
				this.lightBounds = new BoundingBox();
				this.lightBounds.center.copy(tempSphere.center);
				this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
			}
		}
		var _proto = BakeLight.prototype;
		_proto.store = function store() {
			this.mask = this.light.mask;
			this.shadowUpdateMode = this.light.shadowUpdateMode;
			this.enabled = this.light.enabled;
			this.intensity = this.light.intensity;
			this.rotation = this.light._node.getLocalRotation().clone();
			this.numCascades = this.light.numCascades;
			this.castShadows = this.light._castShadows;
		};
		_proto.restore = function restore() {
			var light = this.light;
			light.mask = this.mask;
			light.shadowUpdateMode = this.shadowUpdateMode;
			light.enabled = this.enabled;
			light.intensity = this.intensity;
			light._node.setLocalRotation(this.rotation);
			light.numCascades = this.numCascades;
			light._castShadows = this.castShadows;
		};
		_proto.startBake = function startBake() {
			this.light.enabled = true;
			this.light._destroyShadowMap();
			this.light.beginFrame();
		};
		_proto.endBake = function endBake(shadowMapCache) {
			var light = this.light;
			light.enabled = false;
			if (light.shadowMap) {
				if (light.shadowMap.cached) {
					shadowMapCache.add(light, light.shadowMap);
				}
				light.shadowMap = null;
			}
		};
		return BakeLight;
	}();

	var _tempPoint$1 = new Vec2();
	var BakeLightSimple = function (_BakeLight) {
		function BakeLightSimple(lightmapper, light) {
			return _BakeLight.call(this, lightmapper.scene, light, lightmapper.lightingParams) || this;
		}
		_inheritsLoose(BakeLightSimple, _BakeLight);
		var _proto = BakeLightSimple.prototype;
		_proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
			var light = this.light;
			light._node.setLocalRotation(this.rotation);
			if (index > 0) {
				var directionalSpreadAngle = light.bakeArea;
				random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);
				_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);
				light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
			}
			light._node.getWorldTransform();
			var gamma = 2.2;
			var linearIntensity = Math.pow(this.intensity, gamma);
			light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		};
		return _createClass(BakeLightSimple, [{
			key: "numVirtualLights",
			get: function get() {
				if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
					return this.light.bakeNumSamples;
				}
				return 1;
			}
		}]);
	}(BakeLight);

	var _tempPoint = new Vec3();
	var BakeLightAmbient = function (_BakeLight) {
		function BakeLightAmbient(lightmapper) {
			var scene = lightmapper.scene;
			var lightEntity = new Entity('AmbientLight');
			lightEntity.addComponent('light', {
				type: 'directional',
				affectDynamic: true,
				affectLightmapped: false,
				bake: true,
				bakeNumSamples: scene.ambientBakeNumSamples,
				castShadows: true,
				normalOffsetBias: 0.05,
				shadowBias: 0.2,
				shadowDistance: 1,
				shadowResolution: 2048,
				shadowType: SHADOW_PCF3_32F,
				color: Color.WHITE,
				intensity: 1,
				bakeDir: false
			});
			return _BakeLight.call(this, scene, lightEntity.light.light, lightmapper.lightingParams) || this;
		}
		_inheritsLoose(BakeLightAmbient, _BakeLight);
		var _proto = BakeLightAmbient.prototype;
		_proto.prepareVirtualLight = function prepareVirtualLight(index, numVirtualLights) {
			random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);
			this.light._node.lookAt(_tempPoint.mulScalar(-1));
			this.light._node.rotateLocal(90, 0, 0);
			var gamma = 2.2;
			var fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
			var linearIntensity = Math.pow(fullIntensity, gamma);
			this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
		};
		return _createClass(BakeLightAmbient, [{
			key: "numVirtualLights",
			get: function get() {
				return this.light.bakeNumSamples;
			}
		}]);
	}(BakeLight);

	var BakeMeshNode = function () {
		function BakeMeshNode(node, meshInstances) {
			if (meshInstances === void 0) {
				meshInstances = null;
			}
			this.node = node;
			this.component = node.render || node.model;
			meshInstances = meshInstances || this.component.meshInstances;
			this.store();
			this.meshInstances = meshInstances;
			this.bounds = null;
			this.renderTargets = [];
		}
		var _proto = BakeMeshNode.prototype;
		_proto.store = function store() {
			this.castShadows = this.component.castShadows;
		};
		_proto.restore = function restore() {
			this.component.castShadows = this.castShadows;
		};
		return BakeMeshNode;
	}();

	var DENOISE_FILTER_SIZE = 15;
	var LightmapFilters = function () {
		function LightmapFilters(device) {
			this.device = device;
			this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.dilatePS, 'lmDilate');
			this.constantTexSource = device.scope.resolve('source');
			this.constantPixelOffset = device.scope.resolve('pixelOffset');
			this.pixelOffset = new Float32Array(2);
			this.shaderDenoise = null;
			this.sigmas = null;
			this.constantSigmas = null;
			this.kernel = null;
		}
		var _proto = LightmapFilters.prototype;
		_proto.setSourceTexture = function setSourceTexture(texture) {
			this.constantTexSource.setValue(texture);
		};
		_proto.prepare = function prepare(textureWidth, textureHeight) {
			this.pixelOffset[0] = 1 / textureWidth;
			this.pixelOffset[1] = 1 / textureHeight;
			this.constantPixelOffset.setValue(this.pixelOffset);
		};
		_proto.prepareDenoise = function prepareDenoise(filterRange, filterSmoothness) {
			if (!this.shaderDenoise) {
				this.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.bilateralDeNoisePS, 'lmBilateralDeNoise');
				this.sigmas = new Float32Array(2);
				this.constantSigmas = this.device.scope.resolve('sigmas');
				this.constantKernel = this.device.scope.resolve('kernel[0]');
				this.bZnorm = this.device.scope.resolve('bZnorm');
			}
			this.sigmas[0] = filterRange;
			this.sigmas[1] = filterSmoothness;
			this.constantSigmas.setValue(this.sigmas);
			this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
		};
		_proto.evaluateDenoiseUniforms = function evaluateDenoiseUniforms(filterRange, filterSmoothness) {
			function normpdf(x, sigma) {
				return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
			}
			this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
			var kernel = this.kernel;
			var kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);
			for (var j = 0; j <= kSize; ++j) {
				var value = normpdf(j, filterRange);
				kernel[kSize + j] = value;
				kernel[kSize - j] = value;
			}
			this.constantKernel.setValue(this.kernel);
			var bZnorm = 1 / normpdf(0.0, filterSmoothness);
			this.bZnorm.setValue(bZnorm);
		};
		return LightmapFilters;
	}();

	var RenderPassLightmapper = function (_RenderPass) {
		function RenderPassLightmapper(device, renderer, camera, worldClusters, receivers, lightArray) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.viewBindGroups = [];
			_this.renderer = renderer;
			_this.camera = camera;
			_this.worldClusters = worldClusters;
			_this.receivers = receivers;
			_this.lightArray = lightArray;
			return _this;
		}
		_inheritsLoose(RenderPassLightmapper, _RenderPass);
		var _proto = RenderPassLightmapper.prototype;
		_proto.destroy = function destroy() {
			this.viewBindGroups.forEach(function (bg) {
				bg.defaultUniformBuffer.destroy();
				bg.destroy();
			});
			this.viewBindGroups.length = 0;
		};
		_proto.execute = function execute() {
			this.device;
			var renderer = this.renderer,
				camera = this.camera,
				receivers = this.receivers,
				renderTarget = this.renderTarget,
				worldClusters = this.worldClusters,
				lightArray = this.lightArray;
			renderer.renderForwardLayer(camera, renderTarget, null, undefined, SHADER_FORWARD, this.viewBindGroups, {
				meshInstances: receivers,
				splitLights: lightArray,
				lightClusters: worldClusters
			});
		};
		return RenderPassLightmapper;
	}(RenderPass);

	var MAX_LIGHTMAP_SIZE = 2048;
	var PASS_COLOR = 0;
	var PASS_DIR = 1;
	var tempVec$1 = new Vec3();
	var Lightmapper = function () {
		function Lightmapper(device, root, scene, renderer, assets) {
			this.device = device;
			this.root = root;
			this.scene = scene;
			this.renderer = renderer;
			this.assets = assets;
			this.shadowMapCache = renderer.shadowMapCache;
			this._tempSet = new Set();
			this._initCalled = false;
			this.passMaterials = [];
			this.ambientAOMaterial = null;
			this.fog = '';
			this.ambientLight = new Color();
			this.renderTargets = new Map();
			this.stats = {
				renderPasses: 0,
				lightmapCount: 0,
				totalRenderTime: 0,
				forwardTime: 0,
				fboTime: 0,
				shadowMapTime: 0,
				compileTime: 0,
				shadersLinked: 0
			};
		}
		var _proto = Lightmapper.prototype;
		_proto.destroy = function destroy() {
			var _this$camera;
			LightmapCache.decRef(this.blackTex);
			this.blackTex = null;
			LightmapCache.destroy();
			this.device = null;
			this.root = null;
			this.scene = null;
			this.renderer = null;
			this.assets = null;
			(_this$camera = this.camera) == null || _this$camera.destroy();
			this.camera = null;
		};
		_proto.initBake = function initBake(device) {
			if (!this._initCalled) {
				this._initCalled = true;
				this.lightmapFilters = new LightmapFilters(device);
				this.constantBakeDir = device.scope.resolve('bakeDir');
				this.materials = [];
				this.blackTex = new Texture(this.device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_RGBA8,
					type: TEXTURETYPE_RGBM,
					name: 'lightmapBlack'
				});
				LightmapCache.incRef(this.blackTex);
				var camera = new Camera();
				camera.clearColor.set(0, 0, 0, 0);
				camera.clearColorBuffer = true;
				camera.clearDepthBuffer = false;
				camera.clearStencilBuffer = false;
				camera.frustumCulling = false;
				camera.projection = PROJECTION_ORTHOGRAPHIC;
				camera.aspectRatio = 1;
				camera.node = new GraphNode();
				this.camera = camera;
				this.camera.shaderParams.gammaCorrection = GAMMA_NONE;
				this.camera.shaderParams.toneMapping = TONEMAP_LINEAR;
			}
			if (this.scene.clusteredLightingEnabled) {
				var lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, function () {});
				this.lightingParams = lightingParams;
				var srcParams = this.scene.lighting;
				lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
				lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
				lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
				lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
				lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
				lightingParams.cells = new Vec3(3, 3, 3);
				lightingParams.maxLightsPerCell = 4;
				this.worldClusters = new WorldClusters(device);
				this.worldClusters.name = 'ClusterLightmapper';
			}
		};
		_proto.finishBake = function finishBake(bakeNodes) {
			this.materials = [];
			function destroyRT(rt) {
				LightmapCache.decRef(rt.colorBuffer);
				rt.destroy();
			}
			this.renderTargets.forEach(function (rt) {
				destroyRT(rt);
			});
			this.renderTargets.clear();
			bakeNodes.forEach(function (node) {
				node.renderTargets.forEach(function (rt) {
					destroyRT(rt);
				});
				node.renderTargets.length = 0;
			});
			this.ambientAOMaterial = null;
			if (this.worldClusters) {
				this.worldClusters.destroy();
				this.worldClusters = null;
			}
		};
		_proto.createMaterialForPass = function createMaterialForPass(device, scene, pass, addAmbient) {
			var material = new StandardMaterial();
			material.name = "lmMaterial-pass:" + pass + "-ambient:" + addAmbient;
			material.chunks.APIVersion = CHUNKAPI_1_65;
			var transformDefines = '#define UV1LAYOUT\n';
			material.chunks.transformVS = transformDefines + shaderChunks.transformVS;
			if (pass === PASS_COLOR) {
				var bakeLmEndChunk = shaderChunksLightmapper.bakeLmEndPS;
				if (addAmbient) {
					bakeLmEndChunk = "\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(" + scene.ambientBakeOcclusionContrast.toFixed(1) + " + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(" + scene.ambientBakeOcclusionBrightness.toFixed(1) + ");\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                " + bakeLmEndChunk;
				} else {
					material.ambient = new Color(0, 0, 0);
				}
				material.chunks.basePS = shaderChunks.basePS + (scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? '\n#define LIGHTMAP_RGBM\n' : '');
				material.chunks.endPS = bakeLmEndChunk;
				material.lightMap = this.blackTex;
			} else {
				material.chunks.basePS = shaderChunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
				material.chunks.endPS = shaderChunksLightmapper.bakeDirLmEndPS;
			}
			material.chunks.outputAlphaPS = '\n';
			material.chunks.outputAlphaOpaquePS = '\n';
			material.chunks.outputAlphaPremulPS = '\n';
			material.cull = CULLFACE_NONE;
			material.forceUv1 = true;
			material.update();
			return material;
		};
		_proto.createMaterials = function createMaterials(device, scene, passCount) {
			for (var pass = 0; pass < passCount; pass++) {
				if (!this.passMaterials[pass]) {
					this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
				}
			}
			if (!this.ambientAOMaterial) {
				this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);
				this.ambientAOMaterial.onUpdateShader = function (options) {
					options.litOptions.lightMapWithoutAmbient = true;
					options.litOptions.separateAmbient = true;
					return options;
				};
			}
		};
		_proto.createTexture = function createTexture(size, name) {
			return new Texture(this.device, {
				width: size,
				height: size,
				format: this.scene.lightmapPixelFormat,
				mipmaps: false,
				type: this.scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: name
			});
		};
		_proto.collectModels = function collectModels(node, bakeNodes, allNodes) {
			var _node$model, _node$model2, _node$render;
			if (!node.enabled) return;
			var meshInstances;
			if ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {
				if (allNodes) allNodes.push(new BakeMeshNode(node));
				if (node.model.lightmapped) {
					if (bakeNodes) {
						meshInstances = node.model.model.meshInstances;
					}
				}
			}
			if ((_node$render = node.render) != null && _node$render.enabled) {
				if (allNodes) allNodes.push(new BakeMeshNode(node));
				if (node.render.lightmapped) {
					if (bakeNodes) {
						meshInstances = node.render.meshInstances;
					}
				}
			}
			if (meshInstances) {
				var hasUv1 = true;
				for (var i = 0; i < meshInstances.length; i++) {
					if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
						hasUv1 = false;
						break;
					}
				}
				if (hasUv1) {
					var notInstancedMeshInstances = [];
					for (var _i = 0; _i < meshInstances.length; _i++) {
						var mesh = meshInstances[_i].mesh;
						if (this._tempSet.has(mesh)) {
							bakeNodes.push(new BakeMeshNode(node, [meshInstances[_i]]));
						} else {
							notInstancedMeshInstances.push(meshInstances[_i]);
						}
						this._tempSet.add(mesh);
					}
					this._tempSet.clear();
					if (notInstancedMeshInstances.length > 0) {
						bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
					}
				}
			}
			for (var _i2 = 0; _i2 < node._children.length; _i2++) {
				this.collectModels(node._children[_i2], bakeNodes, allNodes);
			}
		};
		_proto.prepareShadowCasters = function prepareShadowCasters(nodes) {
			var casters = [];
			for (var n = 0; n < nodes.length; n++) {
				var component = nodes[n].component;
				component.castShadows = component.castShadowsLightmap;
				if (component.castShadowsLightmap) {
					var meshes = nodes[n].meshInstances;
					for (var i = 0; i < meshes.length; i++) {
						meshes[i].visibleThisFrame = true;
						casters.push(meshes[i]);
					}
				}
			}
			return casters;
		};
		_proto.updateTransforms = function updateTransforms(nodes) {
			for (var i = 0; i < nodes.length; i++) {
				var meshInstances = nodes[i].meshInstances;
				for (var j = 0; j < meshInstances.length; j++) {
					meshInstances[j].node.getWorldTransform();
				}
			}
		};
		_proto.calculateLightmapSize = function calculateLightmapSize(node) {
			var data;
			var sizeMult = this.scene.lightmapSizeMultiplier || 16;
			var scale = tempVec$1;
			var srcArea, lightmapSizeMultiplier;
			if (node.model) {
				lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;
				if (node.model.asset) {
					data = this.assets.get(node.model.asset).data;
					if (data.area) {
						srcArea = data.area;
					}
				} else if (node.model._area) {
					data = node.model;
					if (data._area) {
						srcArea = data._area;
					}
				}
			} else if (node.render) {
				lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;
				if (node.render.type !== 'asset') {
					if (node.render._area) {
						data = node.render;
						if (data._area) {
							srcArea = data._area;
						}
					}
				}
			}
			var area = {
				x: 1,
				y: 1,
				z: 1,
				uv: 1
			};
			if (srcArea) {
				area.x = srcArea.x;
				area.y = srcArea.y;
				area.z = srcArea.z;
				area.uv = srcArea.uv;
			}
			var areaMult = lightmapSizeMultiplier || 1;
			area.x *= areaMult;
			area.y *= areaMult;
			area.z *= areaMult;
			var component = node.render || node.model;
			var bounds = this.computeNodeBounds(component.meshInstances);
			scale.copy(bounds.halfExtents);
			var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
			totalArea /= area.uv;
			totalArea = Math.sqrt(totalArea);
			var lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
			return lightmapSize;
		};
		_proto.setLightmapping = function setLightmapping(nodes, value, passCount, shaderDefs) {
			for (var i = 0; i < nodes.length; i++) {
				var node = nodes[i];
				var meshInstances = node.meshInstances;
				for (var j = 0; j < meshInstances.length; j++) {
					var meshInstance = meshInstances[j];
					meshInstance.setLightmapped(value);
					if (value) {
						if (shaderDefs) {
							meshInstance._shaderDefs |= shaderDefs;
						}
						meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;
						for (var pass = 0; pass < passCount; pass++) {
							var tex = node.renderTargets[pass].colorBuffer;
							tex.minFilter = FILTER_LINEAR;
							tex.magFilter = FILTER_LINEAR;
							meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
						}
					}
				}
			}
		};
		_proto.bake = function bake(nodes, mode) {
			if (mode === void 0) {
				mode = BAKE_COLORDIR;
			}
			var device = this.device;
			var startTime = now();
			this.scene._updateSkyMesh();
			this.stats.renderPasses = 0;
			this.stats.shadowMapTime = 0;
			this.stats.forwardTime = 0;
			var startShaders = device._shaderStats.linked;
			var startFboTime = device._renderTargetCreationTime;
			var startCompileTime = device._shaderStats.compileTime;
			var bakeNodes = [];
			var allNodes = [];
			if (nodes) {
				for (var i = 0; i < nodes.length; i++) {
					this.collectModels(nodes[i], bakeNodes, null);
				}
				this.collectModels(this.root, null, allNodes);
			} else {
				this.collectModels(this.root, bakeNodes, allNodes);
			}
			if (bakeNodes.length > 0) {
				this.renderer.shadowRenderer.frameUpdate();
				var passCount = mode === BAKE_COLORDIR ? 2 : 1;
				this.setLightmapping(bakeNodes, false, passCount);
				this.initBake(device);
				this.bakeInternal(passCount, bakeNodes, allNodes);
				var shaderDefs = SHADERDEF_LM;
				if (mode === BAKE_COLORDIR) {
					shaderDefs |= SHADERDEF_DIRLM;
				}
				if (this.scene.ambientBake) {
					shaderDefs |= SHADERDEF_LMAMBIENT;
				}
				this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
				this.finishBake(bakeNodes);
			}
			var nowTime = now();
			this.stats.totalRenderTime = nowTime - startTime;
			this.stats.shadersLinked = device._shaderStats.linked - startShaders;
			this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
			this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
			this.stats.lightmapCount = bakeNodes.length;
		};
		_proto.allocateTextures = function allocateTextures(bakeNodes, passCount) {
			for (var i = 0; i < bakeNodes.length; i++) {
				var bakeNode = bakeNodes[i];
				var size = this.calculateLightmapSize(bakeNode.node);
				for (var pass = 0; pass < passCount; pass++) {
					var tex = this.createTexture(size, "lightmapper_lightmap_" + i);
					LightmapCache.incRef(tex);
					bakeNode.renderTargets[pass] = new RenderTarget({
						colorBuffer: tex,
						depth: false
					});
				}
				if (!this.renderTargets.has(size)) {
					var _tex = this.createTexture(size, "lightmapper_temp_lightmap_" + size);
					LightmapCache.incRef(_tex);
					this.renderTargets.set(size, new RenderTarget({
						colorBuffer: _tex,
						depth: false
					}));
				}
			}
		};
		_proto.prepareLightsToBake = function prepareLightsToBake(allLights, bakeLights) {
			if (this.scene.ambientBake) {
				var ambientLight = new BakeLightAmbient(this);
				bakeLights.push(ambientLight);
			}
			var sceneLights = this.renderer.lights;
			for (var i = 0; i < sceneLights.length; i++) {
				var light = sceneLights[i];
				var bakeLight = new BakeLightSimple(this, light);
				allLights.push(bakeLight);
				if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
					light.mask = MASK_BAKE | MASK_AFFECT_LIGHTMAPPED | MASK_AFFECT_DYNAMIC;
					light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
					bakeLights.push(bakeLight);
				}
			}
			bakeLights.sort();
		};
		_proto.restoreLights = function restoreLights(allLights) {
			for (var i = 0; i < allLights.length; i++) {
				allLights[i].restore();
			}
		};
		_proto.setupScene = function setupScene() {
			this.ambientLight.copy(this.scene.ambientLight);
			if (!this.scene.ambientBake) {
				this.scene.ambientLight.set(0, 0, 0);
			}
			this.renderer.setSceneConstants();
		};
		_proto.restoreScene = function restoreScene() {
			this.scene.ambientLight.copy(this.ambientLight);
		};
		_proto.computeNodeBounds = function computeNodeBounds(meshInstances) {
			var bounds = new BoundingBox();
			if (meshInstances.length > 0) {
				bounds.copy(meshInstances[0].aabb);
				for (var m = 1; m < meshInstances.length; m++) {
					bounds.add(meshInstances[m].aabb);
				}
			}
			return bounds;
		};
		_proto.computeNodesBounds = function computeNodesBounds(nodes) {
			for (var i = 0; i < nodes.length; i++) {
				var meshInstances = nodes[i].meshInstances;
				nodes[i].bounds = this.computeNodeBounds(meshInstances);
			}
		};
		_proto.computeBounds = function computeBounds(meshInstances) {
			var bounds = new BoundingBox();
			for (var i = 0; i < meshInstances.length; i++) {
				bounds.copy(meshInstances[0].aabb);
				for (var m = 1; m < meshInstances.length; m++) {
					bounds.add(meshInstances[m].aabb);
				}
			}
			return bounds;
		};
		_proto.backupMaterials = function backupMaterials(meshInstances) {
			for (var i = 0; i < meshInstances.length; i++) {
				this.materials[i] = meshInstances[i].material;
			}
		};
		_proto.restoreMaterials = function restoreMaterials(meshInstances) {
			for (var i = 0; i < meshInstances.length; i++) {
				meshInstances[i].material = this.materials[i];
			}
		};
		_proto.lightCameraPrepare = function lightCameraPrepare(device, bakeLight) {
			var light = bakeLight.light;
			var shadowCam;
			if (light.type === LIGHTTYPE_SPOT) {
				var lightRenderData = light.getRenderData(null, 0);
				shadowCam = lightRenderData.shadowCamera;
				shadowCam._node.setPosition(light._node.getPosition());
				shadowCam._node.setRotation(light._node.getRotation());
				shadowCam._node.rotateLocal(-90, 0, 0);
				shadowCam.projection = PROJECTION_PERSPECTIVE;
				shadowCam.nearClip = light.attenuationEnd / 1000;
				shadowCam.farClip = light.attenuationEnd;
				shadowCam.aspectRatio = 1;
				shadowCam.fov = light._outerConeAngle * 2;
				this.renderer.updateCameraFrustum(shadowCam);
			}
			return shadowCam;
		};
		_proto.lightCameraPrepareAndCull = function lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
			var light = bakeLight.light;
			var lightAffectsNode = true;
			if (light.type === LIGHTTYPE_DIRECTIONAL) {
				tempVec$1.copy(casterBounds.center);
				tempVec$1.y += casterBounds.halfExtents.y;
				this.camera.node.setPosition(tempVec$1);
				this.camera.node.setEulerAngles(-90, 0, 0);
				this.camera.nearClip = 0;
				this.camera.farClip = casterBounds.halfExtents.y * 2;
				var frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
				this.camera.orthoHeight = frustumSize;
			} else {
				if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
					lightAffectsNode = false;
				}
			}
			if (light.type === LIGHTTYPE_SPOT) {
				var nodeVisible = false;
				var meshInstances = bakeNode.meshInstances;
				for (var i = 0; i < meshInstances.length; i++) {
					if (meshInstances[i]._isVisible(shadowCam)) {
						nodeVisible = true;
						break;
					}
				}
				if (!nodeVisible) {
					lightAffectsNode = false;
				}
			}
			return lightAffectsNode;
		};
		_proto.setupLightArray = function setupLightArray(lightArray, light) {
			lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
			lightArray[LIGHTTYPE_OMNI].length = 0;
			lightArray[LIGHTTYPE_SPOT].length = 0;
			lightArray[light.type][0] = light;
			light.visibleThisFrame = true;
		};
		_proto.renderShadowMap = function renderShadowMap(comp, shadowMapRendered, casters, bakeLight) {
			var light = bakeLight.light;
			var isClustered = this.scene.clusteredLightingEnabled;
			var castShadow = light.castShadows && (!isClustered || this.scene.lighting.shadowsEnabled);
			if (!shadowMapRendered && castShadow) {
				if (!light.shadowMap && !isClustered) {
					light.shadowMap = this.shadowMapCache.get(this.device, light);
				}
				if (light.type === LIGHTTYPE_DIRECTIONAL) {
					this.renderer._shadowRendererDirectional.cull(light, comp, this.camera, casters);
					var shadowPass = this.renderer._shadowRendererDirectional.getLightRenderPass(light, this.camera);
					shadowPass == null || shadowPass.render();
				} else {
					if (this.device.isWebGPU) {
						return true;
					}
					this.renderer._shadowRendererLocal.cull(light, comp, casters);
					var insideRenderPass = false;
					this.renderer.shadowRenderer.render(light, this.camera, insideRenderPass);
				}
			}
			return true;
		};
		_proto.postprocessTextures = function postprocessTextures(device, bakeNodes, passCount) {
			var numDilates2x = 1;
			var dilateShader = this.lightmapFilters.shaderDilate;
			var filterLightmap = this.scene.lightmapFilterEnabled;
			if (filterLightmap) {
				this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
			}
			device.setBlendState(BlendState.NOBLEND);
			device.setDepthState(DepthState.NODEPTH);
			device.setStencilState(null, null);
			for (var node = 0; node < bakeNodes.length; node++) {
				var bakeNode = bakeNodes[node];
				for (var pass = 0; pass < passCount; pass++) {
					var nodeRT = bakeNode.renderTargets[pass];
					var lightmap = nodeRT.colorBuffer;
					var tempRT = this.renderTargets.get(lightmap.width);
					var tempTex = tempRT.colorBuffer;
					this.lightmapFilters.prepare(lightmap.width, lightmap.height);
					for (var i = 0; i < numDilates2x; i++) {
						this.lightmapFilters.setSourceTexture(lightmap);
						var bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
						drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);
						this.lightmapFilters.setSourceTexture(tempTex);
						drawQuadWithShader(device, nodeRT, dilateShader);
					}
				}
			}
		};
		_proto.bakeInternal = function bakeInternal(passCount, bakeNodes, allNodes) {
			var scene = this.scene;
			var comp = scene.layers;
			var device = this.device;
			var clusteredLightingEnabled = scene.clusteredLightingEnabled;
			this.createMaterials(device, scene, passCount);
			this.setupScene();
			comp._update();
			this.computeNodesBounds(bakeNodes);
			this.allocateTextures(bakeNodes, passCount);
			this.renderer.collectLights(comp);
			var allLights = [],
				bakeLights = [];
			this.prepareLightsToBake(allLights, bakeLights);
			this.updateTransforms(allNodes);
			var casters = this.prepareShadowCasters(allNodes);
			this.renderer.updateCpuSkinMatrices(casters);
			this.renderer.gpuUpdate(casters);
			var casterBounds = this.computeBounds(casters);
			var i, j, rcv, m;
			for (i = 0; i < bakeNodes.length; i++) {
				var bakeNode = bakeNodes[i];
				rcv = bakeNode.meshInstances;
				for (j = 0; j < rcv.length; j++) {
					m = rcv[j];
					m.setLightmapped(false);
					m.mask = MASK_BAKE;
					m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], this.blackTex);
					m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
				}
			}
			for (j = 0; j < bakeLights.length; j++) {
				bakeLights[j].light.enabled = false;
			}
			var lightArray = [[], [], []];
			var pass, node;
			var shadersUpdatedOn1stPass = false;
			for (i = 0; i < bakeLights.length; i++) {
				var bakeLight = bakeLights[i];
				var isAmbientLight = bakeLight instanceof BakeLightAmbient;
				var isDirectional = bakeLight.light.type === LIGHTTYPE_DIRECTIONAL;
				var numVirtualLights = bakeLight.numVirtualLights;
				if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
					numVirtualLights = 1;
				}
				for (var virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {
					if (numVirtualLights > 1) {
						bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
					}
					bakeLight.startBake();
					var shadowMapRendered = false;
					var shadowCam = this.lightCameraPrepare(device, bakeLight);
					for (node = 0; node < bakeNodes.length; node++) {
						var _bakeNode = bakeNodes[node];
						rcv = _bakeNode.meshInstances;
						var lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, _bakeNode, shadowCam, casterBounds);
						if (!lightAffectsNode) {
							continue;
						}
						this.setupLightArray(lightArray, bakeLight.light);
						var clusterLights = isDirectional ? [] : [bakeLight.light];
						if (clusteredLightingEnabled) {
							this.renderer.lightTextureAtlas.update(clusterLights, this.lightingParams);
						}
						shadowMapRendered = this.renderShadowMap(comp, shadowMapRendered, casters, bakeLight);
						if (clusteredLightingEnabled) {
							this.worldClusters.update(clusterLights, this.lightingParams);
						}
						this.backupMaterials(rcv);
						for (pass = 0; pass < passCount; pass++) {
							if (pass > 0 && virtualLightIndex > 0) {
								break;
							}
							if (isAmbientLight && pass > 0) {
								break;
							}
							var nodeRT = _bakeNode.renderTargets[pass];
							var lightmapSize = _bakeNode.renderTargets[pass].colorBuffer.width;
							var tempRT = this.renderTargets.get(lightmapSize);
							var tempTex = tempRT.colorBuffer;
							if (pass === 0) {
								shadersUpdatedOn1stPass = scene.updateShaders;
							} else if (shadersUpdatedOn1stPass) {
								scene.updateShaders = true;
							}
							var passMaterial = this.passMaterials[pass];
							if (isAmbientLight) {
								var lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;
								if (lastVirtualLightForPass && pass === 0) {
									passMaterial = this.ambientAOMaterial;
								}
							}
							for (j = 0; j < rcv.length; j++) {
								rcv[j].material = passMaterial;
							}
							this.renderer.updateShaders(rcv);
							if (pass === PASS_DIR) {
								this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
							}
							if (device.isWebGPU) {
								var renderPass = new RenderPassLightmapper(device, this.renderer, this.camera, clusteredLightingEnabled ? this.worldClusters : null, rcv, lightArray);
								renderPass.init(tempRT);
								renderPass.render();
								renderPass.destroy();
							} else {
								this.renderer.setCamera(this.camera, tempRT, true);
								if (clusteredLightingEnabled) {
									this.worldClusters.activate();
								}
								this.renderer._forwardTime = 0;
								this.renderer._shadowMapTime = 0;
								this.renderer.renderForward(this.camera, tempRT, rcv, lightArray, SHADER_FORWARD);
								device.updateEnd();
							}
							_bakeNode.renderTargets[pass] = tempRT;
							this.renderTargets.set(lightmapSize, nodeRT);
							for (j = 0; j < rcv.length; j++) {
								m = rcv[j];
								m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
								m._shaderDefs |= SHADERDEF_LM;
							}
						}
						this.restoreMaterials(rcv);
					}
					bakeLight.endBake(this.shadowMapCache);
				}
			}
			this.postprocessTextures(device, bakeNodes, passCount);
			for (node = 0; node < allNodes.length; node++) {
				allNodes[node].restore();
			}
			this.restoreLights(allLights);
			this.restoreScene();
			if (!clusteredLightingEnabled) {
				this.shadowMapCache.clear();
			}
		};
		return Lightmapper;
	}();

	var Component = function (_EventHandler) {
		function Component(system, entity) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.system = void 0;
			_this.entity = void 0;
			_this.system = system;
			_this.entity = entity;
			if (_this.system.schema && !_this._accessorsBuilt) {
				_this.buildAccessors(_this.system.schema);
			}
			_this.on('set', function (name, oldValue, newValue) {
				this.fire("set_" + name, name, oldValue, newValue);
			});
			_this.on('set_enabled', _this.onSetEnabled, _this);
			return _this;
		}
		_inheritsLoose(Component, _EventHandler);
		Component._buildAccessors = function _buildAccessors(obj, schema) {
			schema.forEach(function (descriptor) {
				var name = typeof descriptor === 'object' ? descriptor.name : descriptor;
				Object.defineProperty(obj, name, {
					get: function get() {
						return this.data[name];
					},
					set: function set(value) {
						var data = this.data;
						var oldValue = data[name];
						data[name] = value;
						this.fire('set', name, oldValue, value);
					},
					configurable: true
				});
			});
			obj._accessorsBuilt = true;
		};
		var _proto = Component.prototype;
		_proto.buildAccessors = function buildAccessors(schema) {
			Component._buildAccessors(this, schema);
		};
		_proto.onSetEnabled = function onSetEnabled(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (this.entity.enabled) {
					if (newValue) {
						this.onEnable();
					} else {
						this.onDisable();
					}
				}
			}
		};
		_proto.onEnable = function onEnable() {};
		_proto.onDisable = function onDisable() {};
		_proto.onPostStateChange = function onPostStateChange() {};
		return _createClass(Component, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return true;
			},
			set: function set(arg) {}
		}]);
	}(EventHandler);
	Component.order = 0;

	var ComponentSystem = function (_EventHandler) {
		function ComponentSystem(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.app = app;
			_this.store = {};
			_this.schema = [];
			return _this;
		}
		_inheritsLoose(ComponentSystem, _EventHandler);
		var _proto = ComponentSystem.prototype;
		_proto.addComponent = function addComponent(entity, data) {
			if (data === void 0) {
				data = {};
			}
			var component = new this.ComponentType(this, entity);
			var componentData = new this.DataType();
			this.store[entity.getGuid()] = {
				entity: entity,
				data: componentData
			};
			entity[this.id] = component;
			entity.c[this.id] = component;
			this.initializeComponentData(component, data, []);
			this.fire('add', entity, component);
			return component;
		};
		_proto.removeComponent = function removeComponent(entity) {
			var id = this.id;
			var record = this.store[entity.getGuid()];
			var component = entity.c[id];
			this.fire('beforeremove', entity, component);
			delete this.store[entity.getGuid()];
			entity[id] = undefined;
			delete entity.c[id];
			this.fire('remove', entity, record.data);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var src = this.store[entity.getGuid()];
			return this.addComponent(clone, src.data);
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data === void 0) {
				data = {};
			}
			for (var i = 0, len = properties.length; i < len; i++) {
				var descriptor = properties[i];
				var name = void 0,
					type = void 0;
				if (typeof descriptor === 'object') {
					name = descriptor.name;
					type = descriptor.type;
				} else {
					name = descriptor;
					type = undefined;
				}
				var value = data[name];
				if (value !== undefined) {
					if (type !== undefined) {
						value = convertValue(value, type);
					}
					component[name] = value;
				} else {
					component[name] = component.data[name];
				}
			}
			if (component.enabled && component.entity.enabled) {
				component.onEnable();
			}
		};
		_proto.getPropertiesOfType = function getPropertiesOfType(type) {
			var matchingProperties = [];
			var schema = this.schema || [];
			schema.forEach(function (descriptor) {
				if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
					matchingProperties.push(descriptor);
				}
			});
			return matchingProperties;
		};
		_proto.destroy = function destroy() {
			this.off();
		};
		return ComponentSystem;
	}(EventHandler);
	function convertValue(value, type) {
		if (!value) {
			return value;
		}
		switch (type) {
			case 'rgb':
				if (value instanceof Color) {
					return value.clone();
				}
				return new Color(value[0], value[1], value[2]);
			case 'rgba':
				if (value instanceof Color) {
					return value.clone();
				}
				return new Color(value[0], value[1], value[2], value[3]);
			case 'vec2':
				if (value instanceof Vec2) {
					return value.clone();
				}
				return new Vec2(value[0], value[1]);
			case 'vec3':
				if (value instanceof Vec3) {
					return value.clone();
				}
				return new Vec3(value[0], value[1], value[2]);
			case 'vec4':
				if (value instanceof Vec4) {
					return value.clone();
				}
				return new Vec4(value[0], value[1], value[2], value[3]);
			case 'boolean':
			case 'number':
			case 'string':
				return value;
			case 'entity':
				return value;
			default:
				throw new Error("Could not convert unhandled type: " + type);
		}
	}

	var INTERPOLATION_STEP = 0;
	var INTERPOLATION_LINEAR = 1;
	var INTERPOLATION_CUBIC = 2;

	var AnimCache = function () {
		function AnimCache() {
			this._left = Infinity;
			this._right = -Infinity;
			this._len = 0;
			this._recip = 0;
			this._p0 = 0;
			this._p1 = 0;
			this._t = 0;
			this._hermite = {
				valid: false,
				p0: 0,
				m0: 0,
				p1: 0,
				m1: 0
			};
		}
		var _proto = AnimCache.prototype;
		_proto.update = function update(time, input) {
			if (time < this._left || time >= this._right) {
				var len = input.length;
				if (!len) {
					this._left = -Infinity;
					this._right = Infinity;
					this._len = 0;
					this._recip = 0;
					this._p0 = this._p1 = 0;
				} else {
					if (time < input[0]) {
						this._left = -Infinity;
						this._right = input[0];
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = 0;
					} else if (time >= input[len - 1]) {
						this._left = input[len - 1];
						this._right = Infinity;
						this._len = 0;
						this._recip = 0;
						this._p0 = this._p1 = len - 1;
					} else {
						var index = this._findKey(time, input);
						this._left = input[index];
						this._right = input[index + 1];
						this._len = this._right - this._left;
						var diff = 1.0 / this._len;
						this._recip = isFinite(diff) ? diff : 0;
						this._p0 = index;
						this._p1 = index + 1;
					}
				}
			}
			this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
			this._hermite.valid = false;
		};
		_proto._findKey = function _findKey(time, input) {
			var index = 0;
			while (time >= input[index + 1]) {
				index++;
			}
			return index;
		};
		_proto.eval = function _eval(result, interpolation, output) {
			var data = output._data;
			var comp = output._components;
			var idx0 = this._p0 * comp;
			if (interpolation === INTERPOLATION_STEP) {
				for (var i = 0; i < comp; ++i) {
					result[i] = data[idx0 + i];
				}
			} else {
				var t = this._t;
				var idx1 = this._p1 * comp;
				switch (interpolation) {
					case INTERPOLATION_LINEAR:
						for (var _i = 0; _i < comp; ++_i) {
							result[_i] = math.lerp(data[idx0 + _i], data[idx1 + _i], t);
						}
						break;
					case INTERPOLATION_CUBIC:
						{
							var hermite = this._hermite;
							if (!hermite.valid) {
								var t2 = t * t;
								var twot = t + t;
								var omt = 1 - t;
								var omt2 = omt * omt;
								hermite.valid = true;
								hermite.p0 = (1 + twot) * omt2;
								hermite.m0 = t * omt2;
								hermite.p1 = t2 * (3 - twot);
								hermite.m1 = t2 * (t - 1);
							}
							var p0 = (this._p0 * 3 + 1) * comp;
							var m0 = (this._p0 * 3 + 2) * comp;
							var p1 = (this._p1 * 3 + 1) * comp;
							var m1 = (this._p1 * 3 + 0) * comp;
							for (var _i2 = 0; _i2 < comp; ++_i2) {
								result[_i2] = hermite.p0 * data[p0 + _i2] + hermite.m0 * data[m0 + _i2] * this._len + hermite.p1 * data[p1 + _i2] + hermite.m1 * data[m1 + _i2] * this._len;
							}
							break;
						}
				}
			}
		};
		return AnimCache;
	}();

	var AnimSnapshot = function AnimSnapshot(animTrack) {
		this._name = animTrack.name + "Snapshot";
		this._time = -1;
		this._cache = [];
		this._results = [];
		for (var i = 0; i < animTrack._inputs.length; ++i) {
			this._cache[i] = new AnimCache();
		}
		var curves = animTrack._curves;
		var outputs = animTrack._outputs;
		for (var _i = 0; _i < curves.length; ++_i) {
			var curve = curves[_i];
			var output = outputs[curve._output];
			var storage = [];
			for (var j = 0; j < output._components; ++j) {
				storage[j] = 0;
			}
			this._results[_i] = storage;
		}
	};

	var AnimClip = function () {
		function AnimClip(track, time, speed, playing, loop, eventHandler) {
			this._name = track.name;
			this._track = track;
			this._snapshot = new AnimSnapshot(track);
			this._playing = playing;
			this._time = time;
			this._speed = speed;
			this._loop = loop;
			this._blendWeight = 1.0;
			this._blendOrder = 0.0;
			this._eventHandler = eventHandler;
			this.alignCursorToCurrentTime();
		}
		var _proto = AnimClip.prototype;
		_proto.nextEventAheadOfTime = function nextEventAheadOfTime(time) {
			if (!this.nextEvent) return false;
			return this.isReverse ? this.nextEvent.time <= time : this.nextEvent.time >= time;
		};
		_proto.nextEventBehindTime = function nextEventBehindTime(time) {
			if (!this.nextEvent) return false;
			if (time === this.track.duration) {
				return this.isReverse ? this.nextEvent.time >= time : this.nextEvent.time <= time;
			}
			return this.isReverse ? this.nextEvent.time > time : this.nextEvent.time < time;
		};
		_proto.resetEventCursor = function resetEventCursor() {
			this._eventCursor = this.isReverse ? this._track.events.length - 1 : 0;
		};
		_proto.moveEventCursor = function moveEventCursor() {
			this._eventCursor += this.isReverse ? -1 : 1;
			if (this._eventCursor >= this.track.events.length) {
				this._eventCursor = 0;
			} else if (this._eventCursor < 0) {
				this._eventCursor = this.track.events.length - 1;
			}
		};
		_proto.clipFrameTime = function clipFrameTime(frameEndTime) {
			var eventFrame = AnimClip.eventFrame;
			eventFrame.start = 0;
			eventFrame.end = frameEndTime;
			eventFrame.residual = 0;
			if (this.isReverse) {
				if (frameEndTime < 0) {
					eventFrame.start = this.track.duration;
					eventFrame.end = 0;
					eventFrame.residual = frameEndTime + this.track.duration;
				}
			} else {
				if (frameEndTime > this.track.duration) {
					eventFrame.start = 0;
					eventFrame.end = this.track.duration;
					eventFrame.residual = frameEndTime - this.track.duration;
				}
			}
		};
		_proto.alignCursorToCurrentTime = function alignCursorToCurrentTime() {
			this.resetEventCursor();
			while (this.nextEventBehindTime(this._time) && this._eventCursor !== this.eventCursorEnd) {
				this.moveEventCursor();
			}
		};
		_proto.fireNextEvent = function fireNextEvent() {
			this._eventHandler.fire(this.nextEvent.name, _extends({
				track: this.track
			}, this.nextEvent));
			this.moveEventCursor();
		};
		_proto.fireNextEventInFrame = function fireNextEventInFrame(frameStartTime, frameEndTime) {
			if (this.nextEventAheadOfTime(frameStartTime) && this.nextEventBehindTime(frameEndTime)) {
				this.fireNextEvent();
				return true;
			}
			return false;
		};
		_proto.activeEventsForFrame = function activeEventsForFrame(frameStartTime, frameEndTime) {
			var eventFrame = AnimClip.eventFrame;
			this.clipFrameTime(frameEndTime);
			var initialCursor = this.eventCursor;
			while (this.fireNextEventInFrame(frameStartTime, eventFrame.end)) {
				if (initialCursor === this.eventCursor) {
					break;
				}
			}
			if (this.loop && Math.abs(eventFrame.residual) > 0) {
				this.activeEventsForFrame(eventFrame.start, eventFrame.residual);
			}
		};
		_proto.progressForTime = function progressForTime(time) {
			return time * this._speed / this._track.duration;
		};
		_proto._update = function _update(deltaTime) {
			if (this._playing) {
				var time = this._time;
				var duration = this._track.duration;
				var speed = this._speed;
				var loop = this._loop;
				if (this._track.events.length > 0 && duration > 0) {
					this.activeEventsForFrame(time, time + speed * deltaTime);
				}
				time += speed * deltaTime;
				if (speed >= 0) {
					if (time > duration) {
						if (loop) {
							time = time % duration || 0;
						} else {
							time = this._track.duration;
							this.pause();
						}
					}
				} else {
					if (time < 0) {
						if (loop) {
							time = duration + (time % duration || 0);
						} else {
							time = 0;
							this.pause();
						}
					}
				}
				this._time = time;
			}
			if (this._time !== this._snapshot._time) {
				this._track.eval(this._time, this._snapshot);
			}
		};
		_proto.play = function play() {
			this._playing = true;
			this._time = 0;
		};
		_proto.stop = function stop() {
			this._playing = false;
			this._time = 0;
		};
		_proto.pause = function pause() {
			this._playing = false;
		};
		_proto.resume = function resume() {
			this._playing = true;
		};
		_proto.reset = function reset() {
			this._time = 0;
		};
		return _createClass(AnimClip, [{
			key: "name",
			get: function get() {
				return this._name;
			},
			set: function set(name) {
				this._name = name;
			}
		}, {
			key: "track",
			get: function get() {
				return this._track;
			},
			set: function set(track) {
				this._track = track;
				this._snapshot = new AnimSnapshot(track);
			}
		}, {
			key: "snapshot",
			get: function get() {
				return this._snapshot;
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			},
			set: function set(time) {
				this._time = time;
				this.alignCursorToCurrentTime();
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(speed) {
				var signChanged = Math.sign(speed) !== Math.sign(this._speed);
				this._speed = speed;
				if (signChanged) {
					this.alignCursorToCurrentTime();
				}
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(loop) {
				this._loop = loop;
			}
		}, {
			key: "blendWeight",
			get: function get() {
				return this._blendWeight;
			},
			set: function set(blendWeight) {
				this._blendWeight = blendWeight;
			}
		}, {
			key: "blendOrder",
			get: function get() {
				return this._blendOrder;
			},
			set: function set(blendOrder) {
				this._blendOrder = blendOrder;
			}
		}, {
			key: "eventCursor",
			get: function get() {
				return this._eventCursor;
			},
			set: function set(value) {
				this._eventCursor = value;
			}
		}, {
			key: "eventCursorEnd",
			get: function get() {
				return this.isReverse ? 0 : this._track.events.length - 1;
			}
		}, {
			key: "nextEvent",
			get: function get() {
				return this._track.events[this._eventCursor];
			}
		}, {
			key: "isReverse",
			get: function get() {
				return this._speed < 0;
			}
		}]);
	}();
	AnimClip.eventFrame = {
		start: 0,
		end: 0,
		residual: 0
	};

	var ANIM_INTERRUPTION_NONE = 'NONE';
	var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
	var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
	var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
	var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
	var ANIM_GREATER_THAN = 'GREATER_THAN';
	var ANIM_LESS_THAN = 'LESS_THAN';
	var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
	var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
	var ANIM_EQUAL_TO = 'EQUAL_TO';
	var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
	var ANIM_PARAMETER_INTEGER = 'INTEGER';
	var ANIM_PARAMETER_FLOAT = 'FLOAT';
	var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
	var ANIM_PARAMETER_TRIGGER = 'TRIGGER';
	var ANIM_BLEND_1D = '1D';
	var ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
	var ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
	var ANIM_BLEND_DIRECT = 'DIRECT';
	var ANIM_STATE_START = 'START';
	var ANIM_STATE_END = 'END';
	var ANIM_STATE_ANY = 'ANY';
	var ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];
	var ANIM_LAYER_OVERWRITE = 'OVERWRITE';
	var ANIM_LAYER_ADDITIVE = 'ADDITIVE';

	var AnimBlend = function () {
		function AnimBlend() {}
		AnimBlend.dot = function dot(a, b) {
			var len = a.length;
			var result = 0;
			for (var i = 0; i < len; ++i) {
				result += a[i] * b[i];
			}
			return result;
		};
		AnimBlend.normalize = function normalize(a) {
			var l = AnimBlend.dot(a, a);
			if (l > 0) {
				l = 1.0 / Math.sqrt(l);
				var len = a.length;
				for (var i = 0; i < len; ++i) {
					a[i] *= l;
				}
			}
		};
		AnimBlend.set = function set(a, b, type) {
			var len = a.length;
			if (type === 'quaternion') {
				var l = AnimBlend.dot(b, b);
				if (l > 0) {
					l = 1.0 / Math.sqrt(l);
				}
				for (var i = 0; i < len; ++i) {
					a[i] = b[i] * l;
				}
			} else {
				for (var _i = 0; _i < len; ++_i) {
					a[_i] = b[_i];
				}
			}
		};
		AnimBlend.blendVec = function blendVec(a, b, t, additive) {
			var it = additive ? 1.0 : 1.0 - t;
			var len = a.length;
			for (var i = 0; i < len; ++i) {
				a[i] = a[i] * it + b[i] * t;
			}
		};
		AnimBlend.blendQuat = function blendQuat(a, b, t, additive) {
			var len = a.length;
			var it = additive ? 1.0 : 1.0 - t;
			if (AnimBlend.dot(a, b) < 0) {
				t = -t;
			}
			for (var i = 0; i < len; ++i) {
				a[i] = a[i] * it + b[i] * t;
			}
			if (!additive) {
				AnimBlend.normalize(a);
			}
		};
		AnimBlend.blend = function blend(a, b, t, type, additive) {
			if (type === 'quaternion') {
				AnimBlend.blendQuat(a, b, t, additive);
			} else {
				AnimBlend.blendVec(a, b, t, additive);
			}
		};
		AnimBlend.stableSort = function stableSort(a, lessFunc) {
			var len = a.length;
			for (var i = 0; i < len - 1; ++i) {
				for (var j = i + 1; j < len; ++j) {
					if (lessFunc(a[j], a[i])) {
						var tmp = a[i];
						a[i] = a[j];
						a[j] = tmp;
					}
				}
			}
		};
		return AnimBlend;
	}();

	var AnimTargetValue = function () {
		function AnimTargetValue(component, type) {
			this._component = component;
			this.mask = new Int8Array(component.layers.length);
			this.weights = new Float32Array(component.layers.length);
			this.totalWeight = 0;
			this.counter = 0;
			this.layerCounter = 0;
			this.valueType = type;
			this.dirty = true;
			this.value = type === AnimTargetValue.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0];
			this.baseValue = null;
			this.setter = null;
		}
		var _proto = AnimTargetValue.prototype;
		_proto.getWeight = function getWeight(index) {
			if (this.dirty) this.updateWeights();
			if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {
				return 0;
			} else if (this._normalizeWeights) {
				return this.weights[index] / this.totalWeight;
			}
			return math.clamp(this.weights[index], 0, 1);
		};
		_proto._layerBlendType = function _layerBlendType(index) {
			return this._component.layers[index].blendType;
		};
		_proto.setMask = function setMask(index, value) {
			this.mask[index] = value;
			if (this._normalizeWeights) {
				if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
					this.mask = this.mask.fill(0, 0, index);
				}
				this.dirty = true;
			}
		};
		_proto.updateWeights = function updateWeights() {
			this.totalWeight = 0;
			for (var i = 0; i < this.weights.length; i++) {
				this.weights[i] = this._component.layers[i].weight;
				this.totalWeight += this.mask[i] * this.weights[i];
			}
			this.dirty = false;
		};
		_proto.updateValue = function updateValue(index, value) {
			if (this.counter === 0) {
				AnimBlend.set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);
				if (!this._normalizeWeights) {
					AnimBlend.blend(this.value, this.baseValue, 1, this.valueType);
				}
			}
			if (!this.mask[index] || this.getWeight(index) === 0) return;
			if (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {
				if (this.valueType === AnimTargetValue.TYPE_QUAT) {
					var v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);
					var aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);
					var aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);
					var aV = aV1.invert().mul(aV2);
					aV.slerp(Quat.IDENTITY, aV, this.getWeight(index));
					v.mul(aV);
					AnimTargetValue.quatArr[0] = v.x;
					AnimTargetValue.quatArr[1] = v.y;
					AnimTargetValue.quatArr[2] = v.z;
					AnimTargetValue.quatArr[3] = v.w;
					AnimBlend.set(this.value, AnimTargetValue.quatArr, this.valueType);
				} else {
					AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];
					AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];
					AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];
					AnimBlend.blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);
				}
			} else {
				AnimBlend.blend(this.value, value, this.getWeight(index), this.valueType);
			}
			if (this.setter) this.setter(this.value);
		};
		_proto.unbind = function unbind() {
			if (this.setter) {
				this.setter(this.baseValue);
			}
		};
		return _createClass(AnimTargetValue, [{
			key: "_normalizeWeights",
			get: function get() {
				return this._component.normalizeWeights;
			}
		}]);
	}();
	AnimTargetValue.TYPE_QUAT = 'quaternion';
	AnimTargetValue.TYPE_VEC3 = 'vector3';
	AnimTargetValue.q1 = new Quat();
	AnimTargetValue.q2 = new Quat();
	AnimTargetValue.q3 = new Quat();
	AnimTargetValue.quatArr = [0, 0, 0, 1];
	AnimTargetValue.vecArr = [0, 0, 0];
	AnimTargetValue.IDENTITY_QUAT_ARR = [0, 0, 0, 1];

	var AnimEvaluator = function () {
		function AnimEvaluator(binder) {
			this._binder = binder;
			this._clips = [];
			this._inputs = [];
			this._outputs = [];
			this._targets = {};
		}
		var _proto = AnimEvaluator.prototype;
		_proto.addClip = function addClip(clip) {
			var targets = this._targets;
			var binder = this._binder;
			var curves = clip.track.curves;
			var snapshot = clip.snapshot;
			var inputs = [];
			var outputs = [];
			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;
				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];
					var resolved = binder.resolve(path);
					var target = targets[resolved && resolved.targetPath || null];
					if (!target && resolved) {
						target = {
							target: resolved,
							value: [],
							curves: 0,
							blendCounter: 0
						};
						for (var k = 0; k < target.target.components; ++k) {
							target.value.push(0);
						}
						targets[resolved.targetPath] = target;
						if (binder.animComponent) {
							if (!binder.animComponent.targets[resolved.targetPath]) {
								var type = void 0;
								if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
									type = AnimTargetValue.TYPE_QUAT;
								} else {
									type = AnimTargetValue.TYPE_VEC3;
								}
								binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
							}
							binder.animComponent.targets[resolved.targetPath].layerCounter++;
							binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
						}
					}
					if (target) {
						target.curves++;
						inputs.push(snapshot._results[i]);
						outputs.push(target);
					}
				}
			}
			this._clips.push(clip);
			this._inputs.push(inputs);
			this._outputs.push(outputs);
		};
		_proto.removeClip = function removeClip(index) {
			var targets = this._targets;
			var binder = this._binder;
			var clips = this._clips;
			var clip = clips[index];
			var curves = clip.track.curves;
			for (var i = 0; i < curves.length; ++i) {
				var curve = curves[i];
				var paths = curve.paths;
				for (var j = 0; j < paths.length; ++j) {
					var path = paths[j];
					var target = this._binder.resolve(path);
					if (target) {
						target.curves--;
						if (target.curves === 0) {
							binder.unresolve(path);
							delete targets[target.targetPath];
							if (binder.animComponent) {
								binder.animComponent.targets[target.targetPath].layerCounter--;
							}
						}
					}
				}
			}
			clips.splice(index, 1);
			this._inputs.splice(index, 1);
			this._outputs.splice(index, 1);
		};
		_proto.removeClips = function removeClips() {
			while (this._clips.length > 0) {
				this.removeClip(0);
			}
		};
		_proto.updateClipTrack = function updateClipTrack(name, animTrack) {
			this._clips.forEach(function (clip) {
				if (clip.name.includes(name)) {
					clip.track = animTrack;
				}
			});
			this.rebind();
		};
		_proto.findClip = function findClip(name) {
			var clips = this._clips;
			for (var i = 0; i < clips.length; ++i) {
				var clip = clips[i];
				if (clip.name === name) {
					return clip;
				}
			}
			return null;
		};
		_proto.rebind = function rebind() {
			var _this = this;
			this._binder.rebind();
			this._targets = {};
			var clips = [].concat(this.clips);
			this.removeClips();
			clips.forEach(function (clip) {
				_this.addClip(clip);
			});
		};
		_proto.assignMask = function assignMask(mask) {
			return this._binder.assignMask(mask);
		};
		_proto.update = function update(deltaTime, outputAnimation) {
			if (outputAnimation === void 0) {
				outputAnimation = true;
			}
			var clips = this._clips;
			var order = clips.map(function (c, i) {
				return i;
			});
			AnimBlend.stableSort(order, function (a, b) {
				return clips[a].blendOrder < clips[b].blendOrder;
			});
			for (var i = 0; i < order.length; ++i) {
				var index = order[i];
				var clip = clips[index];
				var inputs = this._inputs[index];
				var outputs = this._outputs[index];
				var blendWeight = clip.blendWeight;
				if (blendWeight > 0.0) {
					clip._update(deltaTime);
				}
				if (!outputAnimation) break;
				var input = void 0;
				var output = void 0;
				var value = void 0;
				if (blendWeight >= 1.0) {
					for (var j = 0; j < inputs.length; ++j) {
						input = inputs[j];
						output = outputs[j];
						value = output.value;
						AnimBlend.set(value, input, output.target.type);
						output.blendCounter++;
					}
				} else if (blendWeight > 0.0) {
					for (var _j = 0; _j < inputs.length; ++_j) {
						input = inputs[_j];
						output = outputs[_j];
						value = output.value;
						if (output.blendCounter === 0) {
							AnimBlend.set(value, input, output.target.type);
						} else {
							AnimBlend.blend(value, input, blendWeight, output.target.type);
						}
						output.blendCounter++;
					}
				}
			}
			var targets = this._targets;
			var binder = this._binder;
			for (var path in targets) {
				if (targets.hasOwnProperty(path)) {
					var target = targets[path];
					if (binder.animComponent && target.target.isTransform) {
						var animTarget = binder.animComponent.targets[path];
						if (animTarget.counter === animTarget.layerCounter) {
							animTarget.counter = 0;
						}
						if (!animTarget.path) {
							animTarget.path = path;
							animTarget.baseValue = target.target.get();
							animTarget.setter = target.target.set;
						}
						animTarget.updateValue(binder.layerIndex, target.value);
						animTarget.counter++;
					} else {
						target.target.set(target.value);
					}
					target.blendCounter = 0;
				}
			}
			this._binder.update(deltaTime);
		};
		return _createClass(AnimEvaluator, [{
			key: "clips",
			get: function get() {
				return this._clips;
			}
		}]);
	}();

	var AnimEvents = function () {
		function AnimEvents(events) {
			this._events = [].concat(events);
			this._events.sort(function (a, b) {
				return a.time - b.time;
			});
		}
		return _createClass(AnimEvents, [{
			key: "events",
			get: function get() {
				return this._events;
			}
		}]);
	}();

	var _AnimTrack;
	var AnimTrack = function () {
		function AnimTrack(name, duration, inputs, outputs, curves, animEvents) {
			if (animEvents === void 0) {
				animEvents = new AnimEvents([]);
			}
			this._name = name;
			this._duration = duration;
			this._inputs = inputs;
			this._outputs = outputs;
			this._curves = curves;
			this._animEvents = animEvents;
		}
		var _proto = AnimTrack.prototype;
		_proto.eval = function _eval(time, snapshot) {
			snapshot._time = time;
			var inputs = this._inputs;
			var outputs = this._outputs;
			var curves = this._curves;
			var cache = snapshot._cache;
			var results = snapshot._results;
			for (var i = 0; i < inputs.length; ++i) {
				cache[i].update(time, inputs[i]._data);
			}
			for (var _i = 0; _i < curves.length; ++_i) {
				var curve = curves[_i];
				var output = outputs[curve._output];
				var result = results[_i];
				cache[curve._input].eval(result, curve._interpolation, output);
			}
		};
		return _createClass(AnimTrack, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "duration",
			get: function get() {
				return this._duration;
			}
		}, {
			key: "inputs",
			get: function get() {
				return this._inputs;
			}
		}, {
			key: "outputs",
			get: function get() {
				return this._outputs;
			}
		}, {
			key: "curves",
			get: function get() {
				return this._curves;
			}
		}, {
			key: "events",
			get: function get() {
				return this._animEvents.events;
			},
			set: function set(animEvents) {
				this._animEvents = animEvents;
			}
		}]);
	}();
	_AnimTrack = AnimTrack;
	AnimTrack.EMPTY = Object.freeze(new _AnimTrack('empty', Number.MAX_VALUE, [], [], []));

	var AnimBinder = function () {
		function AnimBinder() {}
		AnimBinder.joinPath = function joinPath(pathSegments, character) {
			character = character || '.';
			var escape = function escape(string) {
				return string.replace(/\\/g, '\\\\').replace(new RegExp("\\" + character, 'g'), "\\" + character);
			};
			return pathSegments.map(escape).join(character);
		};
		AnimBinder.splitPath = function splitPath(path, character) {
			character = character || '.';
			var result = [];
			var curr = '';
			var i = 0;
			while (i < path.length) {
				var c = path[i++];
				if (c === '\\' && i < path.length) {
					c = path[i++];
					if (c === '\\' || c === character) {
						curr += c;
					} else {
						curr += "\\" + c;
					}
				} else if (c === character) {
					result.push(curr);
					curr = '';
				} else {
					curr += c;
				}
			}
			if (curr.length > 0) {
				result.push(curr);
			}
			return result;
		};
		AnimBinder.encode = function encode(entityPath, component, propertyPath) {
			return (Array.isArray(entityPath) ? entityPath.join('/') : entityPath) + "/" + component + "/" + (Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath);
		};
		var _proto = AnimBinder.prototype;
		_proto.resolve = function resolve(path) {
			return null;
		};
		_proto.unresolve = function unresolve(path) {};
		_proto.update = function update(deltaTime) {};
		return AnimBinder;
	}();

	var AnimTarget = function () {
		function AnimTarget(func, type, components, targetPath) {
			if (func.set) {
				this._set = func.set;
				this._get = func.get;
			} else {
				this._set = func;
			}
			this._type = type;
			this._components = components;
			this._targetPath = targetPath;
			this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
		}
		return _createClass(AnimTarget, [{
			key: "set",
			get: function get() {
				return this._set;
			}
		}, {
			key: "get",
			get: function get() {
				return this._get;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			}
		}, {
			key: "components",
			get: function get() {
				return this._components;
			}
		}, {
			key: "targetPath",
			get: function get() {
				return this._targetPath;
			}
		}, {
			key: "isTransform",
			get: function get() {
				return this._isTransform;
			}
		}]);
	}();

	var DefaultAnimBinder = function () {
		function DefaultAnimBinder(graph) {
			var _this = this;
			this._isPathInMask = function (path, checkMaskValue) {
				var maskItem = _this._mask[path];
				if (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
				return false;
			};
			this.graph = graph;
			if (!graph) return;
			this._mask = null;
			var nodes = {};
			var _flatten = function flatten(node) {
				nodes[node.name] = node;
				for (var i = 0; i < node.children.length; ++i) {
					_flatten(node.children[i]);
				}
			};
			_flatten(graph);
			this.nodes = nodes;
			this.targetCache = {};
			var findMeshInstances = function findMeshInstances(node) {
				var object = node;
				while (object && !(object instanceof Entity)) {
					object = object.parent;
				}
				var meshInstances;
				if (object) {
					if (object.render) {
						meshInstances = object.render.meshInstances;
					} else if (object.model) {
						meshInstances = object.model.meshInstances;
					}
				}
				return meshInstances;
			};
			this.nodeCounts = {};
			this.activeNodes = [];
			this.handlers = {
				'localPosition': function localPosition(node) {
					var object = node.localPosition;
					var func = function func(value) {
						object.set.apply(object, value);
					};
					return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
				},
				'localRotation': function localRotation(node) {
					var object = node.localRotation;
					var func = function func(value) {
						object.set.apply(object, value);
					};
					return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
				},
				'localScale': function localScale(node) {
					var object = node.localScale;
					var func = function func(value) {
						object.set.apply(object, value);
					};
					return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
				},
				'weight': function weight(node, weightName) {
					if (weightName.indexOf('name.') === 0) {
						weightName = weightName.replace('name.', '');
					} else {
						weightName = Number(weightName);
					}
					var meshInstances = findMeshInstances(node);
					var setters;
					if (meshInstances) {
						var _loop = function _loop() {
							if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
								var morphInstance = meshInstances[i].morphInstance;
								var func = function func(value) {
									morphInstance.setWeight(weightName, value[0]);
								};
								if (!setters) setters = [];
								setters.push(func);
							}
						};
						for (var i = 0; i < meshInstances.length; ++i) {
							_loop();
						}
					}
					if (setters) {
						var callSetters = function callSetters(value) {
							for (var _i = 0; _i < setters.length; ++_i) {
								setters[_i](value);
							}
						};
						return DefaultAnimBinder.createAnimTarget(callSetters, 'number', 1, node, "weight." + weightName);
					}
					return null;
				},
				'materialTexture': function materialTexture(node, textureName) {
					var meshInstances = findMeshInstances(node);
					if (meshInstances) {
						var meshInstance;
						for (var i = 0; i < meshInstances.length; ++i) {
							if (meshInstances[i].node.name === node.name) {
								meshInstance = meshInstances[i];
								break;
							}
						}
						if (meshInstance) {
							var func = function func(value) {
								var textureAsset = _this.animComponent.system.app.assets.get(value[0]);
								if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
									meshInstance.material[textureName] = textureAsset.resource;
									meshInstance.material.update();
								}
							};
							return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
						}
					}
					return null;
				}
			};
		}
		var _proto = DefaultAnimBinder.prototype;
		_proto._isPathActive = function _isPathActive(path) {
			if (!this._mask) return true;
			var rootNodeNames = [path.entityPath[0], this.graph.name];
			for (var j = 0; j < rootNodeNames.length; ++j) {
				var currEntityPath = rootNodeNames[j];
				if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;
				for (var i = 1; i < path.entityPath.length; i++) {
					currEntityPath += "/" + path.entityPath[i];
					if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
				}
			}
			return false;
		};
		_proto.findNode = function findNode(path) {
			if (!this._isPathActive(path)) {
				return null;
			}
			var node;
			if (this.graph) {
				node = this.graph.findByPath(path.entityPath);
				if (!node) {
					node = this.graph.findByPath(path.entityPath.slice(1));
				}
			}
			if (!node) {
				node = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];
			}
			return node;
		};
		DefaultAnimBinder.createAnimTarget = function createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
			var targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
			return new AnimTarget(func, type, valueCount, targetPath);
		};
		_proto.resolve = function resolve(path) {
			var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
			var target = this.targetCache[encodedPath];
			if (target) return target;
			var node = this.findNode(path);
			if (!node) {
				return null;
			}
			var handler = this.handlers[path.propertyPath];
			if (!handler) {
				return null;
			}
			target = handler(node);
			if (!target) {
				return null;
			}
			this.targetCache[encodedPath] = target;
			if (!this.nodeCounts[node.path]) {
				this.activeNodes.push(node);
				this.nodeCounts[node.path] = 1;
			} else {
				this.nodeCounts[node.path]++;
			}
			return target;
		};
		_proto.unresolve = function unresolve(path) {
			if (path.component !== 'graph') {
				return;
			}
			var node = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];
			this.nodeCounts[node.path]--;
			if (this.nodeCounts[node.path] === 0) {
				var activeNodes = this.activeNodes;
				var i = activeNodes.indexOf(node.node);
				var len = activeNodes.length;
				if (i < len - 1) {
					activeNodes[i] = activeNodes[len - 1];
				}
				activeNodes.pop();
			}
		};
		_proto.update = function update(deltaTime) {
			var activeNodes = this.activeNodes;
			for (var i = 0; i < activeNodes.length; ++i) {
				activeNodes[i]._dirtifyLocal();
			}
		};
		_proto.assignMask = function assignMask(mask) {
			if (mask !== this._mask) {
				this._mask = mask;
				return true;
			}
			return false;
		};
		return DefaultAnimBinder;
	}();

	var AnimationComponent = function (_Component) {
		function AnimationComponent() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Component.call.apply(_Component, [this].concat(args)) || this;
			_this._animations = {};
			_this._assets = [];
			_this._loop = true;
			_this.animEvaluator = null;
			_this.model = null;
			_this.skeleton = null;
			_this.fromSkel = null;
			_this.toSkel = null;
			_this.animationsIndex = {};
			_this.prevAnim = null;
			_this.currAnim = null;
			_this.blend = 0;
			_this.blending = false;
			_this.blendSpeed = 0;
			_this.activate = true;
			_this.speed = 1;
			return _this;
		}
		_inheritsLoose(AnimationComponent, _Component);
		var _proto = AnimationComponent.prototype;
		_proto.play = function play(name, blendTime) {
			if (blendTime === void 0) {
				blendTime = 0;
			}
			if (!this.enabled || !this.entity.enabled) {
				return;
			}
			if (!this.animations[name]) {
				return;
			}
			this.prevAnim = this.currAnim;
			this.currAnim = name;
			if (this.model) {
				if (!this.skeleton && !this.animEvaluator) {
					this._createAnimationController();
				}
				var prevAnim = this.animations[this.prevAnim];
				var currAnim = this.animations[this.currAnim];
				this.blending = blendTime > 0 && !!this.prevAnim;
				if (this.blending) {
					this.blend = 0;
					this.blendSpeed = 1 / blendTime;
				}
				if (this.skeleton) {
					if (this.blending) {
						this.fromSkel.animation = prevAnim;
						this.fromSkel.addTime(this.skeleton._time);
						this.toSkel.animation = currAnim;
					} else {
						this.skeleton.animation = currAnim;
					}
				}
				if (this.animEvaluator) {
					var animEvaluator = this.animEvaluator;
					if (this.blending) {
						while (animEvaluator.clips.length > 1) {
							animEvaluator.removeClip(0);
						}
					} else {
						this.animEvaluator.removeClips();
					}
					var clip = new AnimClip(this.animations[this.currAnim], 0, 1.0, true, this.loop);
					clip.name = this.currAnim;
					clip.blendWeight = this.blending ? 0 : 1;
					clip.reset();
					this.animEvaluator.addClip(clip);
				}
			}
			this.playing = true;
		};
		_proto.getAnimation = function getAnimation(name) {
			return this.animations[name];
		};
		_proto.setModel = function setModel(model) {
			if (model !== this.model) {
				this._resetAnimationController();
				this.model = model;
				if (this.animations && this.currAnim && this.animations[this.currAnim]) {
					this.play(this.currAnim);
				}
			}
		};
		_proto.onSetAnimations = function onSetAnimations() {
			var modelComponent = this.entity.model;
			if (modelComponent) {
				var m = modelComponent.model;
				if (m && m !== this.model) {
					this.setModel(m);
				}
			}
			if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
				var animationNames = Object.keys(this._animations);
				if (animationNames.length > 0) {
					this.play(animationNames[0]);
				}
			}
		};
		_proto._resetAnimationController = function _resetAnimationController() {
			this.skeleton = null;
			this.fromSkel = null;
			this.toSkel = null;
			this.animEvaluator = null;
		};
		_proto._createAnimationController = function _createAnimationController() {
			var model = this.model;
			var animations = this.animations;
			var hasJson = false;
			var hasGlb = false;
			for (var animation in animations) {
				if (animations.hasOwnProperty(animation)) {
					var anim = animations[animation];
					if (anim.constructor === AnimTrack) {
						hasGlb = true;
					} else {
						hasJson = true;
					}
				}
			}
			var graph = model.getGraph();
			if (hasJson) {
				this.fromSkel = new Skeleton(graph);
				this.toSkel = new Skeleton(graph);
				this.skeleton = new Skeleton(graph);
				this.skeleton.looping = this.loop;
				this.skeleton.setGraph(graph);
			} else if (hasGlb) {
				this.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
			}
		};
		_proto.loadAnimationAssets = function loadAnimationAssets(ids) {
			var _this2 = this;
			if (!ids || !ids.length) {
				return;
			}
			var assets = this.system.app.assets;
			var onAssetReady = function onAssetReady(asset) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						_this2.animations[asset.resources[i].name] = asset.resources[i];
						_this2.animationsIndex[asset.id] = asset.resources[i].name;
					}
				} else {
					_this2.animations[asset.name] = asset.resource;
					_this2.animationsIndex[asset.id] = asset.name;
				}
				_this2.animations = _this2.animations;
			};
			var onAssetAdd = function onAssetAdd(asset) {
				asset.off('change', _this2.onAssetChanged, _this2);
				asset.on('change', _this2.onAssetChanged, _this2);
				asset.off('remove', _this2.onAssetRemoved, _this2);
				asset.on('remove', _this2.onAssetRemoved, _this2);
				if (asset.resource) {
					onAssetReady(asset);
				} else {
					asset.once('load', onAssetReady, _this2);
					if (_this2.enabled && _this2.entity.enabled) {
						assets.load(asset);
					}
				}
			};
			for (var i = 0, l = ids.length; i < l; i++) {
				var asset = assets.get(ids[i]);
				if (asset) {
					onAssetAdd(asset);
				} else {
					assets.on("add:" + ids[i], onAssetAdd);
				}
			}
		};
		_proto.onAssetChanged = function onAssetChanged(asset, attribute, newValue, oldValue) {
			if (attribute === 'resource' || attribute === 'resources') {
				if (attribute === 'resources' && newValue && newValue.length === 0) {
					newValue = null;
				}
				if (newValue) {
					var restarted = false;
					if (newValue.length > 1) {
						if (oldValue && oldValue.length > 1) {
							for (var i = 0; i < oldValue.length; i++) {
								delete this.animations[oldValue[i].name];
							}
						} else {
							delete this.animations[asset.name];
						}
						restarted = false;
						for (var _i = 0; _i < newValue.length; _i++) {
							this.animations[newValue[_i].name] = newValue[_i];
							if (!restarted && this.currAnim === newValue[_i].name) {
								if (this.playing && this.enabled && this.entity.enabled) {
									restarted = true;
									this.play(newValue[_i].name);
								}
							}
						}
						if (!restarted) {
							this._stopCurrentAnimation();
							this.onSetAnimations();
						}
					} else {
						if (oldValue && oldValue.length > 1) {
							for (var _i2 = 0; _i2 < oldValue.length; _i2++) {
								delete this.animations[oldValue[_i2].name];
							}
						}
						this.animations[asset.name] = newValue[0] || newValue;
						restarted = false;
						if (this.currAnim === asset.name) {
							if (this.playing && this.enabled && this.entity.enabled) {
								restarted = true;
								this.play(asset.name);
							}
						}
						if (!restarted) {
							this._stopCurrentAnimation();
							this.onSetAnimations();
						}
					}
					this.animationsIndex[asset.id] = asset.name;
				} else {
					if (oldValue.length > 1) {
						for (var _i3 = 0; _i3 < oldValue.length; _i3++) {
							delete this.animations[oldValue[_i3].name];
							if (this.currAnim === oldValue[_i3].name) {
								this._stopCurrentAnimation();
							}
						}
					} else {
						delete this.animations[asset.name];
						if (this.currAnim === asset.name) {
							this._stopCurrentAnimation();
						}
					}
					delete this.animationsIndex[asset.id];
				}
			}
		};
		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.animations) {
				if (asset.resources.length > 1) {
					for (var i = 0; i < asset.resources.length; i++) {
						delete this.animations[asset.resources[i].name];
						if (this.currAnim === asset.resources[i].name) {
							this._stopCurrentAnimation();
						}
					}
				} else {
					delete this.animations[asset.name];
					if (this.currAnim === asset.name) {
						this._stopCurrentAnimation();
					}
				}
				delete this.animationsIndex[asset.id];
			}
		};
		_proto._stopCurrentAnimation = function _stopCurrentAnimation() {
			this.currAnim = null;
			this.playing = false;
			if (this.skeleton) {
				this.skeleton.currentTime = 0;
				this.skeleton.animation = null;
			}
			if (this.animEvaluator) {
				for (var i = 0; i < this.animEvaluator.clips.length; ++i) {
					this.animEvaluator.clips[i].stop();
				}
				this.animEvaluator.update(0);
				this.animEvaluator.removeClips();
			}
		};
		_proto.onEnable = function onEnable() {
			_Component.prototype.onEnable.call(this);
			var assets = this.assets;
			var registry = this.system.app.assets;
			if (assets) {
				for (var i = 0, len = assets.length; i < len; i++) {
					var asset = assets[i];
					if (!(asset instanceof Asset)) {
						asset = registry.get(asset);
					}
					if (asset && !asset.resource) {
						registry.load(asset);
					}
				}
			}
			if (this.activate && !this.currAnim) {
				var animationNames = Object.keys(this.animations);
				if (animationNames.length > 0) {
					this.play(animationNames[0]);
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			for (var i = 0; i < this.assets.length; i++) {
				var asset = this.assets[i];
				if (typeof asset === 'number') {
					asset = this.system.app.assets.get(asset);
				}
				if (!asset) continue;
				asset.off('change', this.onAssetChanged, this);
				asset.off('remove', this.onAssetRemoved, this);
			}
			this.skeleton = null;
			this.fromSkel = null;
			this.toSkel = null;
			this.animEvaluator = null;
		};
		_proto.update = function update(dt) {
			if (this.blending) {
				this.blend += dt * this.blendSpeed;
				if (this.blend >= 1) {
					this.blend = 1;
				}
			}
			if (this.playing) {
				var skeleton = this.skeleton;
				if (skeleton !== null && this.model !== null) {
					if (this.blending) {
						skeleton.blend(this.fromSkel, this.toSkel, this.blend);
					} else {
						var delta = dt * this.speed;
						skeleton.addTime(delta);
						if (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {
							this.playing = false;
						} else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {
							this.playing = false;
						}
					}
					if (this.blending && this.blend === 1) {
						skeleton.animation = this.toSkel.animation;
					}
					skeleton.updateGraph();
				}
			}
			var animEvaluator = this.animEvaluator;
			if (animEvaluator) {
				for (var i = 0; i < animEvaluator.clips.length; ++i) {
					var clip = animEvaluator.clips[i];
					clip.speed = this.speed;
					if (!this.playing) {
						clip.pause();
					} else {
						clip.resume();
					}
				}
				if (this.blending && animEvaluator.clips.length > 1) {
					animEvaluator.clips[1].blendWeight = this.blend;
				}
				animEvaluator.update(dt);
			}
			if (this.blending && this.blend === 1) {
				this.blending = false;
			}
		};
		return _createClass(AnimationComponent, [{
			key: "animations",
			get: function get() {
				return this._animations;
			},
			set: function set(value) {
				this._animations = value;
				this.onSetAnimations();
			}
		}, {
			key: "assets",
			get: function get() {
				return this._assets;
			},
			set: function set(value) {
				var assets = this._assets;
				if (assets && assets.length) {
					for (var i = 0; i < assets.length; i++) {
						if (assets[i]) {
							var asset = this.system.app.assets.get(assets[i]);
							if (asset) {
								asset.off('change', this.onAssetChanged, this);
								asset.off('remove', this.onAssetRemoved, this);
								var animName = this.animationsIndex[asset.id];
								if (this.currAnim === animName) {
									this._stopCurrentAnimation();
								}
								delete this.animations[animName];
								delete this.animationsIndex[asset.id];
							}
						}
					}
				}
				this._assets = value;
				var assetIds = value.map(function (value) {
					return value instanceof Asset ? value.id : value;
				});
				this.loadAnimationAssets(assetIds);
			}
		}, {
			key: "currentTime",
			get: function get() {
				if (this.skeleton) {
					return this.skeleton._time;
				}
				if (this.animEvaluator) {
					var clips = this.animEvaluator.clips;
					if (clips.length > 0) {
						return clips[clips.length - 1].time;
					}
				}
				return 0;
			},
			set: function set(currentTime) {
				if (this.skeleton) {
					this.skeleton.currentTime = currentTime;
					this.skeleton.addTime(0);
					this.skeleton.updateGraph();
				}
				if (this.animEvaluator) {
					var clips = this.animEvaluator.clips;
					for (var i = 0; i < clips.length; ++i) {
						clips[i].time = currentTime;
					}
				}
			}
		}, {
			key: "duration",
			get: function get() {
				if (this.currAnim) {
					return this.animations[this.currAnim].duration;
				}
				return 0;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = value;
				if (this.skeleton) {
					this.skeleton.looping = value;
				}
				if (this.animEvaluator) {
					for (var i = 0; i < this.animEvaluator.clips.length; ++i) {
						this.animEvaluator.clips[i].loop = value;
					}
				}
			}
		}]);
	}(Component);

	var AnimationComponentData = function AnimationComponentData() {
		this.enabled = true;
	};

	var _schema$k = ['enabled'];
	var AnimationComponentSystem = function (_ComponentSystem) {
		function AnimationComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'animation';
			_this.ComponentType = AnimationComponent;
			_this.DataType = AnimationComponentData;
			_this.schema = _schema$k;
			_this.on('beforeremove', _this.onBeforeRemove, _this);
			_this.app.systems.on('update', _this.onUpdate, _this);
			return _this;
		}
		_inheritsLoose(AnimationComponentSystem, _ComponentSystem);
		var _proto = AnimationComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];
			for (var _iterator = _createForOfIteratorHelperLoose(properties), _step; !(_step = _iterator()).done;) {
				var property = _step.value;
				if (data.hasOwnProperty(property)) {
					component[property] = data[property];
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$k);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			this.addComponent(clone, {});
			clone.animation.assets = entity.animation.assets.slice();
			clone.animation.speed = entity.animation.speed;
			clone.animation.loop = entity.animation.loop;
			clone.animation.activate = entity.animation.activate;
			clone.animation.enabled = entity.animation.enabled;
			var clonedAnimations = {};
			var animations = entity.animation.animations;
			for (var key in animations) {
				if (animations.hasOwnProperty(key)) {
					clonedAnimations[key] = animations[key];
				}
			}
			clone.animation.animations = clonedAnimations;
			var clonedAnimationsIndex = {};
			var animationsIndex = entity.animation.animationsIndex;
			for (var _key in animationsIndex) {
				if (animationsIndex.hasOwnProperty(_key)) {
					clonedAnimationsIndex[_key] = animationsIndex[_key];
				}
			}
			clone.animation.animationsIndex = clonedAnimationsIndex;
			return clone.animation;
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					if (component.data.enabled && component.entity.enabled) {
						component.entity.animation.update(dt);
					}
				}
			}
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return AnimationComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(AnimationComponent.prototype, _schema$k);

	var AnimNode = function () {
		function AnimNode(state, parent, name, point, speed) {
			if (speed === void 0) {
				speed = 1;
			}
			this._state = state;
			this._parent = parent;
			this._name = name;
			if (Array.isArray(point)) {
				this._point = new Vec2(point[0], point[1]);
				this._pointLength = this._point.length();
			} else {
				this._point = point;
				this._pointLength = point;
			}
			this._speed = speed;
			this._weightedSpeed = 1.0;
			this._weight = 1.0;
			this._animTrack = null;
		}
		return _createClass(AnimNode, [{
			key: "parent",
			get: function get() {
				return this._parent;
			}
		}, {
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "path",
			get: function get() {
				return this._parent ? this._parent.path + "." + this._name : this._name;
			}
		}, {
			key: "point",
			get: function get() {
				return this._point;
			}
		}, {
			key: "pointLength",
			get: function get() {
				return this._pointLength;
			}
		}, {
			key: "weight",
			get: function get() {
				return this._parent ? this._parent.weight * this._weight : this._weight;
			},
			set: function set(value) {
				this._weight = value;
			}
		}, {
			key: "normalizedWeight",
			get: function get() {
				var totalWeight = this._state.totalWeight;
				if (totalWeight === 0.0) return 0.0;
				return this.weight / totalWeight;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._weightedSpeed * this._speed;
			}
		}, {
			key: "absoluteSpeed",
			get: function get() {
				return Math.abs(this._speed);
			}
		}, {
			key: "weightedSpeed",
			get: function get() {
				return this._weightedSpeed;
			},
			set: function set(weightedSpeed) {
				this._weightedSpeed = weightedSpeed;
			}
		}, {
			key: "animTrack",
			get: function get() {
				return this._animTrack;
			},
			set: function set(value) {
				this._animTrack = value;
			}
		}]);
	}();

	var AnimBlendTree = function (_AnimNode) {
		function AnimBlendTree(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			var _this;
			_this = _AnimNode.call(this, state, parent, name, point) || this;
			_this._parameters = parameters;
			_this._parameterValues = new Array(parameters.length);
			_this._children = [];
			_this._findParameter = findParameter;
			_this._syncAnimations = syncAnimations !== false;
			_this._pointCache = {};
			for (var i = 0; i < children.length; i++) {
				var child = children[i];
				if (child.children) {
					_this._children.push(createTree(child.type, state, _this, child.name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, child.syncAnimations, createTree, findParameter));
				} else {
					_this._children.push(new AnimNode(state, _this, child.name, child.point, child.speed));
				}
			}
			return _this;
		}
		_inheritsLoose(AnimBlendTree, _AnimNode);
		var _proto = AnimBlendTree.prototype;
		_proto.getChild = function getChild(name) {
			for (var i = 0; i < this._children.length; i++) {
				if (this._children[i].name === name) return this._children[i];
			}
			return null;
		};
		_proto.updateParameterValues = function updateParameterValues() {
			var paramsEqual = true;
			for (var i = 0; i < this._parameterValues.length; i++) {
				var updatedParameter = this._findParameter(this._parameters[i]).value;
				if (this._parameterValues[i] !== updatedParameter) {
					this._parameterValues[i] = updatedParameter;
					paramsEqual = false;
				}
			}
			return paramsEqual;
		};
		_proto.getNodeWeightedDuration = function getNodeWeightedDuration(i) {
			return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
		};
		_proto.getNodeCount = function getNodeCount() {
			var count = 0;
			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				if (child.constructor === AnimBlendTree) {
					count += this._children[i].getNodeCount();
				} else {
					count++;
				}
			}
			return count;
		};
		return _createClass(AnimBlendTree, [{
			key: "weight",
			get: function get() {
				this.calculateWeights();
				return this._parent ? this._parent.weight * this._weight : this._weight;
			}
		}, {
			key: "syncAnimations",
			get: function get() {
				return this._syncAnimations;
			}
		}]);
	}(AnimNode);

	var AnimBlendTree1D = function (_AnimBlendTree) {
		function AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			children.sort(function (a, b) {
				return a.point - b.point;
			});
			return _AnimBlendTree.call(this, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) || this;
		}
		_inheritsLoose(AnimBlendTree1D, _AnimBlendTree);
		var _proto = AnimBlendTree1D.prototype;
		_proto.calculateWeights = function calculateWeights() {
			if (this.updateParameterValues()) return;
			var weightedDurationSum = 0.0;
			this._children[0].weight = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				var c1 = this._children[i];
				if (i !== this._children.length - 1) {
					var c2 = this._children[i + 1];
					if (c1.point === c2.point) {
						c1.weight = 0.5;
						c2.weight = 0.5;
					} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
						var child2Distance = Math.abs(c1.point - c2.point);
						var parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
						var weight = (child2Distance - parameterDistance) / child2Distance;
						c1.weight = weight;
						c2.weight = 1.0 - weight;
					} else {
						c2.weight = 0.0;
					}
				}
				if (this._syncAnimations) {
					weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
				}
			}
			if (this._syncAnimations) {
				for (var _i = 0; _i < this._children.length; _i++) {
					var child = this._children[_i];
					child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
				}
			}
		};
		return AnimBlendTree1D;
	}(AnimBlendTree);

	var AnimBlendTreeCartesian2D = function (_AnimBlendTree) {
		function AnimBlendTreeCartesian2D() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}
		_inheritsLoose(AnimBlendTreeCartesian2D, _AnimBlendTree);
		var _proto = AnimBlendTreeCartesian2D.prototype;
		_proto.pointDistanceCache = function pointDistanceCache(i, j) {
			var pointKey = "" + i + j;
			if (!this._pointCache[pointKey]) {
				this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
			}
			return this._pointCache[pointKey];
		};
		_proto.calculateWeights = function calculateWeights() {
			var _AnimBlendTreeCartesi;
			if (this.updateParameterValues()) return;
			var weightSum, weightedDurationSum;
			(_AnimBlendTreeCartesi = AnimBlendTreeCartesian2D._p).set.apply(_AnimBlendTreeCartesi, this._parameterValues);
			weightSum = 0.0;
			weightedDurationSum = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				var pi = child.point;
				AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);
				var minj = Number.MAX_VALUE;
				for (var j = 0; j < this._children.length; j++) {
					if (i === j) continue;
					var pipj = this.pointDistanceCache(i, j);
					var result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
					if (result < minj) minj = result;
				}
				child.weight = minj;
				weightSum += minj;
				if (this._syncAnimations) {
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}
			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				_child.weight = _child._weight / weightSum;
				if (this._syncAnimations) {
					_child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
				}
			}
		};
		return AnimBlendTreeCartesian2D;
	}(AnimBlendTree);
	AnimBlendTreeCartesian2D._p = new Vec2();
	AnimBlendTreeCartesian2D._pip = new Vec2();

	var AnimBlendTreeDirectional2D = function (_AnimBlendTree) {
		function AnimBlendTreeDirectional2D() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}
		_inheritsLoose(AnimBlendTreeDirectional2D, _AnimBlendTree);
		var _proto = AnimBlendTreeDirectional2D.prototype;
		_proto.pointCache = function pointCache(i, j) {
			var pointKey = "" + i + j;
			if (!this._pointCache[pointKey]) {
				this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
			}
			return this._pointCache[pointKey];
		};
		_proto.calculateWeights = function calculateWeights() {
			var _AnimBlendTreeDirecti;
			if (this.updateParameterValues()) return;
			var weightSum, weightedDurationSum;
			(_AnimBlendTreeDirecti = AnimBlendTreeDirectional2D._p).set.apply(_AnimBlendTreeDirecti, this._parameterValues);
			var pLength = AnimBlendTreeDirectional2D._p.length();
			weightSum = 0.0;
			weightedDurationSum = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				var pi = child.point;
				var piLength = child.pointLength;
				var minj = Number.MAX_VALUE;
				for (var j = 0; j < this._children.length; j++) {
					if (i === j) continue;
					var pipj = this.pointCache(i, j);
					var pjLength = this._children[j].pointLength;
					AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);
					var result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
					if (result < minj) minj = result;
				}
				child.weight = minj;
				weightSum += minj;
				if (this._syncAnimations) {
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}
			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				_child.weight = _child._weight / weightSum;
				if (this._syncAnimations) {
					var weightedChildDuration = _child.animTrack.duration / weightedDurationSum * weightSum;
					_child.weightedSpeed = _child.absoluteSpeed * weightedChildDuration;
				}
			}
		};
		return AnimBlendTreeDirectional2D;
	}(AnimBlendTree);
	AnimBlendTreeDirectional2D._p = new Vec2();
	AnimBlendTreeDirectional2D._pip = new Vec2();

	var AnimBlendTreeDirect = function (_AnimBlendTree) {
		function AnimBlendTreeDirect() {
			return _AnimBlendTree.apply(this, arguments) || this;
		}
		_inheritsLoose(AnimBlendTreeDirect, _AnimBlendTree);
		var _proto = AnimBlendTreeDirect.prototype;
		_proto.calculateWeights = function calculateWeights() {
			if (this.updateParameterValues()) return;
			var weightSum = 0.0;
			var weightedDurationSum = 0.0;
			for (var i = 0; i < this._children.length; i++) {
				weightSum += Math.max(this._parameterValues[i], 0.0);
				if (this._syncAnimations) {
					var child = this._children[i];
					weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
				}
			}
			for (var _i = 0; _i < this._children.length; _i++) {
				var _child = this._children[_i];
				var weight = Math.max(this._parameterValues[_i], 0.0);
				if (weightSum) {
					_child.weight = weight / weightSum;
					if (this._syncAnimations) {
						_child.weightedSpeed = _child.animTrack.duration / _child.absoluteSpeed / weightedDurationSum;
					}
				} else {
					_child.weight = 0.0;
					if (this._syncAnimations) {
						_child.weightedSpeed = 0;
					}
				}
			}
		};
		return AnimBlendTreeDirect;
	}(AnimBlendTree);

	var AnimState = function () {
		function AnimState(controller, name, speed, loop, blendTree) {
			if (speed === void 0) {
				speed = 1;
			}
			if (loop === void 0) {
				loop = true;
			}
			this._animations = {};
			this._animationList = [];
			this._controller = controller;
			this._name = name;
			this._speed = speed;
			this._loop = loop;
			this._hasAnimations = false;
			if (blendTree) {
				this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, this._controller.findParameter);
			} else {
				this._blendTree = new AnimNode(this, null, name, 1.0, speed);
			}
		}
		var _proto = AnimState.prototype;
		_proto._createTree = function _createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
			switch (type) {
				case ANIM_BLEND_1D:
					return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
				case ANIM_BLEND_2D_CARTESIAN:
					return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
				case ANIM_BLEND_2D_DIRECTIONAL:
					return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
				case ANIM_BLEND_DIRECT:
					return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
			}
			return undefined;
		};
		_proto._getNodeFromPath = function _getNodeFromPath(path) {
			var currNode = this._blendTree;
			for (var i = 1; i < path.length; i++) {
				currNode = currNode.getChild(path[i]);
			}
			return currNode;
		};
		_proto.addAnimation = function addAnimation(path, animTrack) {
			var pathString = path.join('.');
			var indexOfAnimation = this._animationList.findIndex(function (animation) {
				return animation.path === pathString;
			});
			if (indexOfAnimation >= 0) {
				this._animationList[indexOfAnimation].animTrack = animTrack;
			} else {
				var node = this._getNodeFromPath(path);
				node.animTrack = animTrack;
				this._animationList.push(node);
			}
			this._updateHasAnimations();
		};
		_proto._updateHasAnimations = function _updateHasAnimations() {
			this._hasAnimations = this._animationList.length > 0 && this._animationList.every(function (animation) {
				return animation.animTrack && animation.animTrack !== AnimTrack.EMPTY;
			});
		};
		return _createClass(AnimState, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "animations",
			get: function get() {
				return this._animationList;
			},
			set: function set(value) {
				this._animationList = value;
				this._updateHasAnimations();
			}
		}, {
			key: "hasAnimations",
			get: function get() {
				return this._hasAnimations;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = value;
			}
		}, {
			key: "nodeCount",
			get: function get() {
				if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
				return this._blendTree.getNodeCount();
			}
		}, {
			key: "playable",
			get: function get() {
				return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
			}
		}, {
			key: "looping",
			get: function get() {
				if (this.animations.length > 0) {
					var trackClipName = this.name + "." + this.animations[0].animTrack.name;
					var trackClip = this._controller.animEvaluator.findClip(trackClipName);
					if (trackClip) {
						return trackClip.loop;
					}
				}
				return false;
			}
		}, {
			key: "totalWeight",
			get: function get() {
				var sum = 0;
				for (var i = 0; i < this.animations.length; i++) {
					sum += this.animations[i].weight;
				}
				return sum;
			}
		}, {
			key: "timelineDuration",
			get: function get() {
				var duration = 0;
				for (var i = 0; i < this.animations.length; i++) {
					var animation = this.animations[i];
					if (animation.animTrack.duration > duration) {
						duration = animation.animTrack.duration;
					}
				}
				return duration;
			}
		}]);
	}();

	var AnimTransition = function () {
		function AnimTransition(_ref) {
			var from = _ref.from,
				to = _ref.to,
				_ref$time = _ref.time,
				time = _ref$time === void 0 ? 0 : _ref$time,
				_ref$priority = _ref.priority,
				priority = _ref$priority === void 0 ? 0 : _ref$priority,
				_ref$conditions = _ref.conditions,
				conditions = _ref$conditions === void 0 ? [] : _ref$conditions,
				_ref$exitTime = _ref.exitTime,
				exitTime = _ref$exitTime === void 0 ? null : _ref$exitTime,
				_ref$transitionOffset = _ref.transitionOffset,
				transitionOffset = _ref$transitionOffset === void 0 ? null : _ref$transitionOffset,
				_ref$interruptionSour = _ref.interruptionSource,
				interruptionSource = _ref$interruptionSour === void 0 ? ANIM_INTERRUPTION_NONE : _ref$interruptionSour;
			this._from = from;
			this._to = to;
			this._time = time;
			this._priority = priority;
			this._conditions = conditions;
			this._exitTime = exitTime;
			this._transitionOffset = transitionOffset;
			this._interruptionSource = interruptionSource;
		}
		return _createClass(AnimTransition, [{
			key: "from",
			get: function get() {
				return this._from;
			}
		}, {
			key: "to",
			get: function get() {
				return this._to;
			},
			set: function set(value) {
				this._to = value;
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			}
		}, {
			key: "conditions",
			get: function get() {
				return this._conditions;
			}
		}, {
			key: "exitTime",
			get: function get() {
				return this._exitTime;
			}
		}, {
			key: "transitionOffset",
			get: function get() {
				return this._transitionOffset;
			}
		}, {
			key: "interruptionSource",
			get: function get() {
				return this._interruptionSource;
			}
		}, {
			key: "hasExitTime",
			get: function get() {
				return !!this.exitTime;
			}
		}]);
	}();

	var AnimController = function () {
		function AnimController(animEvaluator, states, transitions, activate, eventHandler, findParameter, consumeTrigger) {
			var _this = this;
			this._states = {};
			this._stateNames = [];
			this._findTransitionsFromStateCache = {};
			this._findTransitionsBetweenStatesCache = {};
			this._previousStateName = null;
			this._activeStateName = ANIM_STATE_START;
			this._activeStateDuration = 0;
			this._activeStateDurationDirty = true;
			this._playing = false;
			this._activate = void 0;
			this._transitions = void 0;
			this._currTransitionTime = 1;
			this._totalTransitionTime = 1;
			this._isTransitioning = false;
			this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
			this._transitionPreviousStates = [];
			this._timeInState = 0;
			this._timeInStateBefore = 0;
			this.findParameter = function (name) {
				return _this._findParameter(name);
			};
			this._animEvaluator = animEvaluator;
			this._eventHandler = eventHandler;
			this._findParameter = findParameter;
			this._consumeTrigger = consumeTrigger;
			for (var i = 0; i < states.length; i++) {
				this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);
				this._stateNames.push(states[i].name);
			}
			this._transitions = transitions.map(function (transition) {
				return new AnimTransition(_extends({}, transition));
			});
			this._activate = activate;
		}
		var _proto = AnimController.prototype;
		_proto.assignMask = function assignMask(mask) {
			return this._animEvaluator.assignMask(mask);
		};
		_proto._findState = function _findState(stateName) {
			return this._states[stateName];
		};
		_proto._getActiveStateProgressForTime = function _getActiveStateProgressForTime(time) {
			if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) {
				return 1.0;
			}
			var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
			if (activeClip) {
				return activeClip.progressForTime(time);
			}
			return null;
		};
		_proto._findTransitionsFromState = function _findTransitionsFromState(stateName) {
			var transitions = this._findTransitionsFromStateCache[stateName];
			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === stateName;
				});
				sortPriority(transitions);
				this._findTransitionsFromStateCache[stateName] = transitions;
			}
			return transitions;
		};
		_proto._findTransitionsBetweenStates = function _findTransitionsBetweenStates(sourceStateName, destinationStateName) {
			var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + "->" + destinationStateName];
			if (!transitions) {
				transitions = this._transitions.filter(function (transition) {
					return transition.from === sourceStateName && transition.to === destinationStateName;
				});
				sortPriority(transitions);
				this._findTransitionsBetweenStatesCache[sourceStateName + "->" + destinationStateName] = transitions;
			}
			return transitions;
		};
		_proto._transitionHasConditionsMet = function _transitionHasConditionsMet(transition) {
			var conditions = transition.conditions;
			for (var i = 0; i < conditions.length; i++) {
				var condition = conditions[i];
				var parameter = this._findParameter(condition.parameterName);
				switch (condition.predicate) {
					case ANIM_GREATER_THAN:
						if (!(parameter.value > condition.value)) return false;
						break;
					case ANIM_LESS_THAN:
						if (!(parameter.value < condition.value)) return false;
						break;
					case ANIM_GREATER_THAN_EQUAL_TO:
						if (!(parameter.value >= condition.value)) return false;
						break;
					case ANIM_LESS_THAN_EQUAL_TO:
						if (!(parameter.value <= condition.value)) return false;
						break;
					case ANIM_EQUAL_TO:
						if (!(parameter.value === condition.value)) return false;
						break;
					case ANIM_NOT_EQUAL_TO:
						if (!(parameter.value !== condition.value)) return false;
						break;
				}
			}
			return true;
		};
		_proto._findTransition = function _findTransition(from, to) {
			var _this2 = this;
			var transitions = [];
			if (from && to) {
				transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
			} else {
				if (!this._isTransitioning) {
					transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
					transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
				} else {
					switch (this._transitionInterruptionSource) {
						case ANIM_INTERRUPTION_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
						case ANIM_INTERRUPTION_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
						case ANIM_INTERRUPTION_PREV_NEXT:
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
						case ANIM_INTERRUPTION_NEXT_PREV:
							transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
							transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
							transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
							break;
					}
				}
			}
			transitions = transitions.filter(function (transition) {
				if (transition.to === _this2.activeStateName) {
					return false;
				}
				if (transition.hasExitTime) {
					var progressBefore = _this2._getActiveStateProgressForTime(_this2._timeInStateBefore);
					var progress = _this2._getActiveStateProgressForTime(_this2._timeInState);
					if (transition.exitTime < 1.0 && _this2.activeState.loop) {
						progressBefore -= Math.floor(progressBefore);
						progress -= Math.floor(progress);
					}
					if (progress === progressBefore) {
						if (progress !== transition.exitTime) {
							return null;
						}
					} else if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
						return null;
					}
				}
				return _this2._transitionHasConditionsMet(transition);
			});
			if (transitions.length > 0) {
				var transition = transitions[0];
				if (transition.to === ANIM_STATE_END) {
					var startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];
					transition.to = startTransition.to;
				}
				return transition;
			}
			return null;
		};
		_proto.updateStateFromTransition = function updateStateFromTransition(transition) {
			var state;
			var animation;
			var clip;
			this.previousState = transition.from ? this.activeStateName : null;
			this.activeState = transition.to;
			this._activeStateDurationDirty = true;
			for (var i = 0; i < transition.conditions.length; i++) {
				var condition = transition.conditions[i];
				var parameter = this._findParameter(condition.parameterName);
				if (parameter.type === ANIM_PARAMETER_TRIGGER) {
					this._consumeTrigger(condition.parameterName);
				}
			}
			if (this.previousState) {
				if (!this._isTransitioning) {
					this._transitionPreviousStates = [];
				}
				this._transitionPreviousStates.push({
					name: this._previousStateName,
					weight: 1
				});
				var interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);
				for (var _i = 0; _i < this._transitionPreviousStates.length; _i++) {
					if (!this._isTransitioning) {
						this._transitionPreviousStates[_i].weight = 1.0;
					} else if (_i !== this._transitionPreviousStates.length - 1) {
						this._transitionPreviousStates[_i].weight *= 1.0 - interpolatedTime;
					} else {
						this._transitionPreviousStates[_i].weight = interpolatedTime;
					}
					state = this._findState(this._transitionPreviousStates[_i].name);
					for (var j = 0; j < state.animations.length; j++) {
						animation = state.animations[j];
						clip = this._animEvaluator.findClip(animation.name + ".previous." + _i);
						if (!clip) {
							clip = this._animEvaluator.findClip(animation.name);
							clip.name = animation.name + ".previous." + _i;
						}
						if (_i !== this._transitionPreviousStates.length - 1) {
							clip.pause();
						}
					}
				}
			}
			this._isTransitioning = true;
			this._totalTransitionTime = transition.time;
			this._currTransitionTime = 0;
			this._transitionInterruptionSource = transition.interruptionSource;
			var activeState = this.activeState;
			var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
			var timeInState = 0;
			var timeInStateBefore = 0;
			if (hasTransitionOffset) {
				var offsetTime = activeState.timelineDuration * transition.transitionOffset;
				timeInState = offsetTime;
				timeInStateBefore = offsetTime;
			}
			this._timeInState = timeInState;
			this._timeInStateBefore = timeInStateBefore;
			for (var _i2 = 0; _i2 < activeState.animations.length; _i2++) {
				clip = this._animEvaluator.findClip(activeState.animations[_i2].name);
				if (!clip) {
					var speed = Number.isFinite(activeState.animations[_i2].speed) ? activeState.animations[_i2].speed : activeState.speed;
					clip = new AnimClip(activeState.animations[_i2].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
					clip.name = activeState.animations[_i2].name;
					this._animEvaluator.addClip(clip);
				} else {
					clip.reset();
				}
				if (transition.time > 0) {
					clip.blendWeight = 0.0;
				} else {
					clip.blendWeight = activeState.animations[_i2].normalizedWeight;
				}
				clip.play();
				if (hasTransitionOffset) {
					clip.time = activeState.timelineDuration * transition.transitionOffset;
				} else {
					var startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
					clip.time = startTime;
				}
			}
		};
		_proto._transitionToState = function _transitionToState(newStateName) {
			if (!this._findState(newStateName)) {
				return;
			}
			var transition = this._findTransition(this._activeStateName, newStateName);
			if (!transition) {
				this._animEvaluator.removeClips();
				transition = new AnimTransition({
					from: null,
					to: newStateName
				});
			}
			this.updateStateFromTransition(transition);
		};
		_proto.assignAnimation = function assignAnimation(pathString, animTrack, speed, loop) {
			var path = pathString.split('.');
			var state = this._findState(path[0]);
			if (!state) {
				state = new AnimState(this, path[0], speed);
				this._states[path[0]] = state;
				this._stateNames.push(path[0]);
			}
			state.addAnimation(path, animTrack);
			this._animEvaluator.updateClipTrack(state.name, animTrack);
			if (speed !== undefined) {
				state.speed = speed;
			}
			if (loop !== undefined) {
				state.loop = loop;
			}
			if (!this._playing && this._activate && this.playable) {
				this.play();
			}
			this._activeStateDurationDirty = true;
		};
		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
			if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
				return false;
			}
			var state = this._findState(nodeName);
			if (!state) {
				return false;
			}
			state.animations = [];
			return true;
		};
		_proto.play = function play(stateName) {
			if (stateName) {
				this._transitionToState(stateName);
			}
			this._playing = true;
		};
		_proto.pause = function pause() {
			this._playing = false;
		};
		_proto.reset = function reset() {
			this._previousStateName = null;
			this._activeStateName = ANIM_STATE_START;
			this._playing = false;
			this._currTransitionTime = 1.0;
			this._totalTransitionTime = 1.0;
			this._isTransitioning = false;
			this._timeInState = 0;
			this._timeInStateBefore = 0;
			this._animEvaluator.removeClips();
		};
		_proto.rebind = function rebind() {
			this._animEvaluator.rebind();
		};
		_proto.update = function update(dt) {
			if (!this._playing) {
				return;
			}
			var state;
			var animation;
			var clip;
			if (this.activeState.loop || this._timeInState < this.activeStateDuration) {
				this._timeInStateBefore = this._timeInState;
				this._timeInState += dt * this.activeState.speed;
				if (!this.activeState.loop && this._timeInState > this.activeStateDuration) {
					this._timeInState = this.activeStateDuration;
					dt = this.activeStateDuration - this._timeInStateBefore;
				}
			}
			var transition = this._findTransition(this._activeStateName);
			if (transition) {
				this.updateStateFromTransition(transition);
			}
			if (this._isTransitioning) {
				this._currTransitionTime += dt;
				if (this._currTransitionTime <= this._totalTransitionTime) {
					var interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;
					for (var i = 0; i < this._transitionPreviousStates.length; i++) {
						state = this._findState(this._transitionPreviousStates[i].name);
						var stateWeight = this._transitionPreviousStates[i].weight;
						for (var j = 0; j < state.animations.length; j++) {
							animation = state.animations[j];
							clip = this._animEvaluator.findClip(animation.name + ".previous." + i);
							if (clip) {
								clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
							}
						}
					}
					state = this.activeState;
					for (var _i3 = 0; _i3 < state.animations.length; _i3++) {
						animation = state.animations[_i3];
						this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
					}
				} else {
					this._isTransitioning = false;
					var activeClips = this.activeStateAnimations.length;
					var totalClips = this._animEvaluator.clips.length;
					for (var _i4 = 0; _i4 < totalClips - activeClips; _i4++) {
						this._animEvaluator.removeClip(0);
					}
					this._transitionPreviousStates = [];
					state = this.activeState;
					for (var _i5 = 0; _i5 < state.animations.length; _i5++) {
						animation = state.animations[_i5];
						clip = this._animEvaluator.findClip(animation.name);
						if (clip) {
							clip.blendWeight = animation.normalizedWeight;
						}
					}
				}
			} else {
				if (this.activeState._blendTree.constructor !== AnimNode) {
					state = this.activeState;
					for (var _i6 = 0; _i6 < state.animations.length; _i6++) {
						animation = state.animations[_i6];
						clip = this._animEvaluator.findClip(animation.name);
						if (clip) {
							clip.blendWeight = animation.normalizedWeight;
							if (animation.parent.syncAnimations) {
								clip.speed = animation.speed;
							}
						}
					}
				}
			}
			this._animEvaluator.update(dt, this.activeState.hasAnimations);
		};
		return _createClass(AnimController, [{
			key: "animEvaluator",
			get: function get() {
				return this._animEvaluator;
			}
		}, {
			key: "activeState",
			get: function get() {
				return this._findState(this._activeStateName);
			},
			set: function set(stateName) {
				this._activeStateName = stateName;
			}
		}, {
			key: "activeStateName",
			get: function get() {
				return this._activeStateName;
			}
		}, {
			key: "activeStateAnimations",
			get: function get() {
				return this.activeState.animations;
			}
		}, {
			key: "previousState",
			get: function get() {
				return this._findState(this._previousStateName);
			},
			set: function set(stateName) {
				this._previousStateName = stateName;
			}
		}, {
			key: "previousStateName",
			get: function get() {
				return this._previousStateName;
			}
		}, {
			key: "playable",
			get: function get() {
				var playable = true;
				for (var i = 0; i < this._stateNames.length; i++) {
					if (!this._states[this._stateNames[i]].playable) {
						playable = false;
					}
				}
				return playable;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._playing;
			},
			set: function set(value) {
				this._playing = value;
			}
		}, {
			key: "activeStateProgress",
			get: function get() {
				return this._getActiveStateProgressForTime(this._timeInState);
			}
		}, {
			key: "activeStateDuration",
			get: function get() {
				if (this._activeStateDurationDirty) {
					var maxDuration = 0.0;
					for (var i = 0; i < this.activeStateAnimations.length; i++) {
						var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);
						if (activeClip) {
							maxDuration = Math.max(maxDuration, activeClip.track.duration);
						}
					}
					this._activeStateDuration = maxDuration;
					this._activeStateDurationDirty = false;
				}
				return this._activeStateDuration;
			}
		}, {
			key: "activeStateCurrentTime",
			get: function get() {
				return this._timeInState;
			},
			set: function set(time) {
				this._timeInStateBefore = time;
				this._timeInState = time;
				for (var i = 0; i < this.activeStateAnimations.length; i++) {
					var clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);
					if (clip) {
						clip.time = time;
					}
				}
			}
		}, {
			key: "transitioning",
			get: function get() {
				return this._isTransitioning;
			}
		}, {
			key: "transitionProgress",
			get: function get() {
				return this._currTransitionTime / this._totalTransitionTime;
			}
		}, {
			key: "states",
			get: function get() {
				return this._stateNames;
			}
		}]);
	}();

	var v2 = new Vec2();
	var v3 = new Vec3();
	var v4 = new Vec4();
	var c = new Color();
	var q = new Quat();
	var AnimComponentBinder = function (_DefaultAnimBinder) {
		function AnimComponentBinder(animComponent, graph, layerName, mask, layerIndex) {
			var _this;
			_this = _DefaultAnimBinder.call(this, graph) || this;
			_this.animComponent = animComponent;
			_this._mask = mask;
			_this.layerName = layerName;
			_this.layerIndex = layerIndex;
			return _this;
		}
		_inheritsLoose(AnimComponentBinder, _DefaultAnimBinder);
		AnimComponentBinder._packFloat = function _packFloat(values) {
			return values[0];
		};
		AnimComponentBinder._packBoolean = function _packBoolean(values) {
			return !!values[0];
		};
		AnimComponentBinder._packVec2 = function _packVec2(values) {
			v2.x = values[0];
			v2.y = values[1];
			return v2;
		};
		AnimComponentBinder._packVec3 = function _packVec3(values) {
			v3.x = values[0];
			v3.y = values[1];
			v3.z = values[2];
			return v3;
		};
		AnimComponentBinder._packVec4 = function _packVec4(values) {
			v4.x = values[0];
			v4.y = values[1];
			v4.z = values[2];
			v4.w = values[3];
			return v4;
		};
		AnimComponentBinder._packColor = function _packColor(values) {
			c.r = values[0];
			c.g = values[1];
			c.b = values[2];
			c.a = values[3];
			return c;
		};
		AnimComponentBinder._packQuat = function _packQuat(values) {
			q.x = values[0];
			q.y = values[1];
			q.z = values[2];
			q.w = values[3];
			return q;
		};
		var _proto = AnimComponentBinder.prototype;
		_proto.resolve = function resolve(path) {
			var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
			var target = this.targetCache[encodedPath];
			if (target) return target;
			var entity;
			var propertyComponent;
			var targetPath;
			switch (path.component) {
				case 'entity':
					entity = this._getEntityFromHierarchy(path.entityPath);
					targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
					propertyComponent = entity;
					break;
				case 'graph':
					propertyComponent = this.findNode(path);
					if (!propertyComponent) return null;
					targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
					break;
				default:
					entity = this._getEntityFromHierarchy(path.entityPath);
					propertyComponent = entity.findComponent(path.component);
					if (!propertyComponent) {
						return null;
					}
					targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
					break;
			}
			target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
			this.targetCache[encodedPath] = target;
			return target;
		};
		_proto.update = function update(deltaTime) {
			var activeNodes = this.activeNodes;
			if (activeNodes) {
				for (var i = 0; i < activeNodes.length; i++) {
					activeNodes[i]._dirtifyLocal();
				}
			}
		};
		_proto._getEntityFromHierarchy = function _getEntityFromHierarchy(entityHierarchy) {
			if (!this.animComponent.entity.name === entityHierarchy[0]) {
				return null;
			}
			var currEntity = this.animComponent.entity;
			if (entityHierarchy.length === 1) {
				return currEntity;
			}
			return currEntity._parent.findByPath(entityHierarchy);
		};
		_proto._resolvePath = function _resolvePath(object, path, resolveLeaf) {
			var steps = path.length - (resolveLeaf ? 0 : 1);
			for (var i = 0; i < steps; i++) {
				object = object[path[i]];
			}
			return object;
		};
		_proto._setter = function _setter(object, path, packFunc) {
			var obj = this._resolvePath(object, path);
			var key = path[path.length - 1];
			var setterFuncName = "set" + key.substring(0, 1).toUpperCase() + key.substring(1);
			if (obj[setterFuncName]) {
				var getterFunc = obj["get" + key.substring(0, 1).toUpperCase() + key.substring(1)].bind(obj);
				var baseValues = getterFunc();
				baseValues = [baseValues.x, baseValues.y, baseValues.z, baseValues.w];
				var setterFunc = obj[setterFuncName].bind(obj);
				return {
					set: function set(values) {
						setterFunc(packFunc(values));
					},
					get: function get() {
						return baseValues;
					}
				};
			}
			var prop = obj[key];
			if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
				return function (values) {
					prop.copy(packFunc(values));
				};
			}
			if ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {
				var parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
				var objKey = path[path.length - 2];
				return function (values) {
					obj[key] = packFunc(values);
					parent[objKey] = obj;
				};
			}
			return function (values) {
				obj[key] = packFunc(values);
			};
		};
		_proto._createAnimTargetForProperty = function _createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
			if (this.handlers && propertyHierarchy[0].startsWith('weight.')) {
				return this.handlers.weight(propertyComponent, propertyHierarchy[0].replace('weight.', ''));
			} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
				var materialPropertyName = propertyHierarchy[1];
				if (materialPropertyName.endsWith('Map')) {
					return this.handlers.materialTexture(propertyComponent, materialPropertyName);
				}
			}
			var property = this._resolvePath(propertyComponent, propertyHierarchy, true);
			if (typeof property === 'undefined') {
				return null;
			}
			var setter;
			var animDataType;
			var animDataComponents;
			if (typeof property === 'number') {
				setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'boolean') {
				setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
				animDataType = 'vector';
				animDataComponents = 1;
			} else if (typeof property === 'object') {
				switch (property.constructor) {
					case Vec2:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
						animDataType = 'vector';
						animDataComponents = 2;
						break;
					case Vec3:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
						animDataType = 'vector';
						animDataComponents = 3;
						break;
					case Vec4:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
						animDataType = 'vector';
						animDataComponents = 4;
						break;
					case Color:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
						animDataType = 'vector';
						animDataComponents = 4;
						break;
					case Quat:
						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
						animDataType = 'quaternion';
						animDataComponents = 4;
						break;
					default:
						return null;
				}
			}
			if (propertyHierarchy.indexOf('material') !== -1) {
				return new AnimTarget(function (values) {
					setter(values);
					propertyComponent.material.update();
				}, animDataType, animDataComponents, targetPath);
			}
			return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
		};
		_proto.rebind = function rebind() {
			this.targetCache = {};
			if (this.animComponent.rootBone) {
				this.graph = this.animComponent.rootBone;
			} else {
				this.graph = this.animComponent.entity;
			}
			var nodes = {};
			var _flatten = function flatten(node) {
				nodes[node.name] = node;
				for (var i = 0; i < node.children.length; ++i) {
					_flatten(node.children[i]);
				}
			};
			_flatten(this.graph);
			this.nodes = nodes;
		};
		return AnimComponentBinder;
	}(DefaultAnimBinder);

	var AnimComponentLayer = function () {
		function AnimComponentLayer(name, controller, component, weight, blendType) {
			if (weight === void 0) {
				weight = 1;
			}
			if (blendType === void 0) {
				blendType = ANIM_LAYER_OVERWRITE;
			}
			this._name = void 0;
			this._controller = void 0;
			this._component = void 0;
			this._weight = void 0;
			this._blendType = void 0;
			this._mask = null;
			this._blendTime = 0;
			this._blendTimeElapsed = 0;
			this._startingWeight = 0;
			this._targetWeight = 0;
			this._name = name;
			this._controller = controller;
			this._component = component;
			this._weight = weight;
			this._blendType = blendType;
		}
		var _proto = AnimComponentLayer.prototype;
		_proto.play = function play(name) {
			this._controller.play(name);
		};
		_proto.pause = function pause() {
			this._controller.pause();
		};
		_proto.reset = function reset() {
			this._controller.reset();
		};
		_proto.rebind = function rebind() {
			this._controller.rebind();
		};
		_proto.update = function update(dt) {
			if (this._blendTime) {
				if (this._blendTimeElapsed < this._blendTime) {
					this.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);
					this._blendTimeElapsed += dt;
				} else {
					this.weight = this._targetWeight;
					this._blendTime = 0;
					this._blendTimeElapsed = 0;
					this._startingWeight = 0;
					this._targetWeight = 0;
				}
			}
			this._controller.update(dt);
		};
		_proto.blendToWeight = function blendToWeight(weight, time) {
			this._startingWeight = this.weight;
			this._targetWeight = weight;
			this._blendTime = Math.max(0, time);
			this._blendTimeElapsed = 0;
		};
		_proto.assignAnimation = function assignAnimation(nodePath, animTrack, speed, loop) {
			if (!(animTrack instanceof AnimTrack)) {
				return;
			}
			this._controller.assignAnimation(nodePath, animTrack, speed, loop);
			if (this._controller._transitions.length === 0) {
				this._controller._transitions.push(new AnimTransition({
					from: 'START',
					to: nodePath
				}));
			}
			if (this._component.activate && this._component.playable) {
				this._component.playing = true;
			}
		};
		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName) {
			if (this._controller.removeNodeAnimations(nodeName)) {
				this._component.playing = false;
			}
		};
		_proto.getAnimationAsset = function getAnimationAsset(stateName) {
			return this._component.animationAssets[this.name + ":" + stateName];
		};
		_proto.transition = function transition(to, time, transitionOffset) {
			if (time === void 0) {
				time = 0;
			}
			if (transitionOffset === void 0) {
				transitionOffset = null;
			}
			this._controller.updateStateFromTransition(new AnimTransition({
				from: this._controller.activeStateName,
				to: to,
				time: time,
				transitionOffset: transitionOffset
			}));
		};
		return _createClass(AnimComponentLayer, [{
			key: "name",
			get: function get() {
				return this._name;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._controller.playing;
			},
			set: function set(value) {
				this._controller.playing = value;
			}
		}, {
			key: "playable",
			get: function get() {
				return this._controller.playable;
			}
		}, {
			key: "activeState",
			get: function get() {
				return this._controller.activeStateName;
			}
		}, {
			key: "previousState",
			get: function get() {
				return this._controller.previousStateName;
			}
		}, {
			key: "activeStateProgress",
			get: function get() {
				return this._controller.activeStateProgress;
			}
		}, {
			key: "activeStateDuration",
			get: function get() {
				return this._controller.activeStateDuration;
			}
		}, {
			key: "activeStateCurrentTime",
			get: function get() {
				return this._controller.activeStateCurrentTime;
			},
			set: function set(time) {
				var controller = this._controller;
				var layerPlaying = controller.playing;
				controller.playing = true;
				controller.activeStateCurrentTime = time;
				if (!layerPlaying) {
					controller.update(0);
				}
				controller.playing = layerPlaying;
			}
		}, {
			key: "transitioning",
			get: function get() {
				return this._controller.transitioning;
			}
		}, {
			key: "transitionProgress",
			get: function get() {
				if (this.transitioning) {
					return this._controller.transitionProgress;
				}
				return null;
			}
		}, {
			key: "states",
			get: function get() {
				return this._controller.states;
			}
		}, {
			key: "weight",
			get: function get() {
				return this._weight;
			},
			set: function set(value) {
				this._weight = value;
				this._component.dirtifyTargets();
			}
		}, {
			key: "blendType",
			get: function get() {
				return this._blendType;
			},
			set: function set(value) {
				if (value !== this._blendType) {
					this._blendType = value;
					if (this._controller.normalizeWeights) {
						this._component.rebind();
					}
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._controller.assignMask(value)) {
					this._component.rebind();
				}
				this._mask = value;
			}
		}]);
	}();

	var AnimStateGraph = function () {
		function AnimStateGraph(data) {
			this._layers = [];
			this._parameters = {};
			if (!Array.isArray(data.layers)) {
				for (var layerId in data.layers) {
					var dataLayer = data.layers[layerId];
					var layer = {
						name: dataLayer.name,
						blendType: dataLayer.blendType,
						weight: dataLayer.weight,
						states: [],
						transitions: []
					};
					for (var i = 0; i < dataLayer.states.length; i++) {
						layer.states.push(data.states[dataLayer.states[i]]);
					}
					for (var _i = 0; _i < dataLayer.transitions.length; _i++) {
						var dataLayerTransition = data.transitions[dataLayer.transitions[_i]];
						if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
							var conditionKeys = Object.keys(dataLayerTransition.conditions);
							var conditions = [];
							for (var j = 0; j < conditionKeys.length; j++) {
								var condition = dataLayerTransition.conditions[conditionKeys[j]];
								if (condition.parameterName) {
									conditions.push(condition);
								}
							}
							dataLayerTransition.conditions = conditions;
						}
						if (Number.isInteger(dataLayerTransition.from)) {
							dataLayerTransition.from = data.states[dataLayerTransition.from].name;
						}
						if (Number.isInteger(dataLayerTransition.to)) {
							dataLayerTransition.to = data.states[dataLayerTransition.to].name;
						}
						layer.transitions.push(dataLayerTransition);
					}
					this._layers.push(layer);
				}
			} else {
				this._layers = data.layers;
			}
			for (var paramId in data.parameters) {
				var param = data.parameters[paramId];
				this._parameters[param.name] = {
					type: param.type,
					value: param.value
				};
			}
		}
		return _createClass(AnimStateGraph, [{
			key: "parameters",
			get: function get() {
				return Object.assign({}, this._parameters);
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			}
		}]);
	}();

	var AnimComponent = function (_Component) {
		function AnimComponent() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Component.call.apply(_Component, [this].concat(args)) || this;
			_this._stateGraphAsset = null;
			_this._animationAssets = {};
			_this._speed = 1;
			_this._activate = true;
			_this._playing = false;
			_this._rootBone = null;
			_this._stateGraph = null;
			_this._layers = [];
			_this._layerIndices = {};
			_this._parameters = {};
			_this._targets = {};
			_this._consumedTriggers = new Set();
			_this._normalizeWeights = false;
			_this.findParameter = function (name) {
				return _this._parameters[name];
			};
			_this.consumeTrigger = function (name) {
				_this._consumedTriggers.add(name);
			};
			return _this;
		}
		_inheritsLoose(AnimComponent, _Component);
		var _proto = AnimComponent.prototype;
		_proto._onStateGraphAssetChangeEvent = function _onStateGraphAssetChangeEvent(asset) {
			var prevAnimationAssets = this.animationAssets;
			var prevMasks = this.layers.map(function (layer) {
				return layer.mask;
			});
			this.removeStateGraph();
			this._stateGraph = new AnimStateGraph(asset._data);
			this.loadStateGraph(this._stateGraph);
			this.animationAssets = prevAnimationAssets;
			this.loadAnimationAssets();
			this.layers.forEach(function (layer, i) {
				layer.mask = prevMasks[i];
			});
			this.rebind();
		};
		_proto.dirtifyTargets = function dirtifyTargets() {
			var targets = Object.values(this._targets);
			for (var i = 0; i < targets.length; i++) {
				targets[i].dirty = true;
			}
		};
		_proto._addLayer = function _addLayer(_ref) {
			var name = _ref.name,
				states = _ref.states,
				transitions = _ref.transitions,
				weight = _ref.weight,
				mask = _ref.mask,
				blendType = _ref.blendType;
			var graph;
			if (this.rootBone) {
				graph = this.rootBone;
			} else {
				graph = this.entity;
			}
			var layerIndex = this._layers.length;
			var animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
			var animEvaluator = new AnimEvaluator(animBinder);
			var controller = new AnimController(animEvaluator, states, transitions, this._activate, this, this.findParameter, this.consumeTrigger);
			this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));
			this._layerIndices[name] = layerIndex;
			return this._layers[layerIndex];
		};
		_proto.addLayer = function addLayer(name, weight, mask, blendType) {
			var layer = this.findAnimationLayer(name);
			if (layer) return layer;
			var states = [{
				'name': 'START',
				'speed': 1
			}];
			var transitions = [];
			return this._addLayer({
				name: name,
				states: states,
				transitions: transitions,
				weight: weight,
				mask: mask,
				blendType: blendType
			});
		};
		_proto._assignParameters = function _assignParameters(stateGraph) {
			this._parameters = {};
			var paramKeys = Object.keys(stateGraph.parameters);
			for (var i = 0; i < paramKeys.length; i++) {
				var paramKey = paramKeys[i];
				this._parameters[paramKey] = {
					type: stateGraph.parameters[paramKey].type,
					value: stateGraph.parameters[paramKey].value
				};
			}
		};
		_proto.loadStateGraph = function loadStateGraph(stateGraph) {
			this._stateGraph = stateGraph;
			this._assignParameters(stateGraph);
			this._layers = [];
			var containsBlendTree = false;
			for (var i = 0; i < stateGraph.layers.length; i++) {
				var layer = stateGraph.layers[i];
				this._addLayer(_extends({}, layer));
				if (layer.states.some(function (state) {
					return state.blendTree;
				})) {
					containsBlendTree = true;
				}
			}
			if (!containsBlendTree) {
				this.setupAnimationAssets();
			}
		};
		_proto.setupAnimationAssets = function setupAnimationAssets() {
			for (var i = 0; i < this._layers.length; i++) {
				var layer = this._layers[i];
				var layerName = layer.name;
				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];
					if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
						var stateKey = layerName + ":" + stateName;
						if (!this._animationAssets[stateKey]) {
							this._animationAssets[stateKey] = {
								asset: null
							};
						}
					}
				}
			}
			this.loadAnimationAssets();
		};
		_proto.loadAnimationAssets = function loadAnimationAssets() {
			for (var i = 0; i < this._layers.length; i++) {
				var layer = this._layers[i];
				for (var j = 0; j < layer.states.length; j++) {
					var stateName = layer.states[j];
					if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
					var animationAsset = this._animationAssets[layer.name + ":" + stateName];
					if (!animationAsset || !animationAsset.asset) {
						this.findAnimationLayer(layer.name).assignAnimation(stateName, AnimTrack.EMPTY);
						continue;
					}
					var assetId = animationAsset.asset;
					var asset = this.system.app.assets.get(assetId);
					if (asset) {
						if (asset.resource) {
							this.onAnimationAssetLoaded(layer.name, stateName, asset);
						} else {
							asset.once('load', function (layerName, stateName) {
								return function (asset) {
									this.onAnimationAssetLoaded(layerName, stateName, asset);
								}.bind(this);
							}.bind(this)(layer.name, stateName));
							this.system.app.assets.load(asset);
						}
					}
				}
			}
		};
		_proto.onAnimationAssetLoaded = function onAnimationAssetLoaded(layerName, stateName, asset) {
			this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
		};
		_proto.removeStateGraph = function removeStateGraph() {
			this._stateGraph = null;
			this._stateGraphAsset = null;
			this._animationAssets = {};
			this._layers = [];
			this._layerIndices = {};
			this._parameters = {};
			this._playing = false;
			this.unbind();
			this._targets = {};
		};
		_proto.reset = function reset() {
			this._assignParameters(this._stateGraph);
			for (var i = 0; i < this._layers.length; i++) {
				var layerPlaying = this._layers[i].playing;
				this._layers[i].reset();
				this._layers[i].playing = layerPlaying;
			}
		};
		_proto.unbind = function unbind() {
			var _this2 = this;
			if (!this._normalizeWeights) {
				Object.keys(this._targets).forEach(function (targetKey) {
					_this2._targets[targetKey].unbind();
				});
			}
		};
		_proto.rebind = function rebind() {
			this._targets = {};
			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].rebind();
			}
		};
		_proto.findAnimationLayer = function findAnimationLayer(name) {
			var layerIndex = this._layerIndices[name];
			return this._layers[layerIndex] || null;
		};
		_proto.addAnimationState = function addAnimationState(nodeName, animTrack, speed, loop, layerName) {
			if (speed === void 0) {
				speed = 1;
			}
			if (loop === void 0) {
				loop = true;
			}
			if (layerName === void 0) {
				layerName = 'Base';
			}
			if (!this._stateGraph) {
				this.loadStateGraph(new AnimStateGraph({
					'layers': [{
						'name': layerName,
						'states': [{
							'name': 'START',
							'speed': 1
						}, {
							'name': nodeName,
							'speed': speed,
							'loop': loop,
							'defaultState': true
						}],
						'transitions': [{
							'from': 'START',
							'to': nodeName
						}]
					}],
					'parameters': {}
				}));
			}
			var layer = this.findAnimationLayer(layerName);
			if (layer) {
				layer.assignAnimation(nodeName, animTrack, speed, loop);
			} else {
				var _this$addLayer;
				(_this$addLayer = this.addLayer(layerName)) == null || _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);
			}
		};
		_proto.assignAnimation = function assignAnimation(nodePath, animTrack, layerName, speed, loop) {
			if (speed === void 0) {
				speed = 1;
			}
			if (loop === void 0) {
				loop = true;
			}
			if (!this._stateGraph && nodePath.indexOf('.') === -1) {
				this.loadStateGraph(new AnimStateGraph({
					'layers': [{
						'name': 'Base',
						'states': [{
							'name': 'START',
							'speed': 1
						}, {
							'name': nodePath,
							'speed': speed,
							'loop': loop,
							'defaultState': true
						}],
						'transitions': [{
							'from': 'START',
							'to': nodePath
						}]
					}],
					'parameters': {}
				}));
				this.baseLayer.assignAnimation(nodePath, animTrack);
				return;
			}
			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
			if (!layer) {
				return;
			}
			layer.assignAnimation(nodePath, animTrack, speed, loop);
		};
		_proto.removeNodeAnimations = function removeNodeAnimations(nodeName, layerName) {
			var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
			if (!layer) {
				return;
			}
			layer.removeNodeAnimations(nodeName);
		};
		_proto.getParameterValue = function getParameterValue(name, type) {
			var param = this._parameters[name];
			if (param && param.type === type) {
				return param.value;
			}
			return undefined;
		};
		_proto.setParameterValue = function setParameterValue(name, type, value) {
			var param = this._parameters[name];
			if (param && param.type === type) {
				param.value = value;
				return;
			}
		};
		_proto.getFloat = function getFloat(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
		};
		_proto.setFloat = function setFloat(name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
		};
		_proto.getInteger = function getInteger(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
		};
		_proto.setInteger = function setInteger(name, value) {
			if (typeof value === 'number' && value % 1 === 0) {
				this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
			}
		};
		_proto.getBoolean = function getBoolean(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
		};
		_proto.setBoolean = function setBoolean(name, value) {
			this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
		};
		_proto.getTrigger = function getTrigger(name) {
			return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
		};
		_proto.setTrigger = function setTrigger(name, singleFrame) {
			if (singleFrame === void 0) {
				singleFrame = false;
			}
			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);
			if (singleFrame) {
				this._consumedTriggers.add(name);
			}
		};
		_proto.resetTrigger = function resetTrigger(name) {
			this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			if (Number.isFinite(this._stateGraphAsset)) {
				var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
				stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
			}
		};
		_proto.update = function update(dt) {
			var _this3 = this;
			for (var i = 0; i < this.layers.length; i++) {
				this.layers[i].update(dt * this.speed);
			}
			this._consumedTriggers.forEach(function (trigger) {
				_this3.parameters[trigger].value = false;
			});
			this._consumedTriggers.clear();
		};
		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
			if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
				this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
			} else {
				this.rebind();
			}
		};
		return _createClass(AnimComponent, [{
			key: "stateGraphAsset",
			get: function get() {
				return this._stateGraphAsset;
			},
			set: function set(value) {
				var _this4 = this;
				if (value === null) {
					this.removeStateGraph();
					return;
				}
				if (this._stateGraphAsset) {
					var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
					stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
				}
				var _id;
				var _asset;
				if (value instanceof Asset) {
					_id = value.id;
					_asset = this.system.app.assets.get(_id);
					if (!_asset) {
						this.system.app.assets.add(value);
						_asset = this.system.app.assets.get(_id);
					}
				} else {
					_id = value;
					_asset = this.system.app.assets.get(_id);
				}
				if (!_asset || this._stateGraphAsset === _id) {
					return;
				}
				if (_asset.resource) {
					this._stateGraph = _asset.resource;
					this.loadStateGraph(this._stateGraph);
					_asset.on('change', this._onStateGraphAssetChangeEvent, this);
				} else {
					_asset.once('load', function (asset) {
						_this4._stateGraph = asset.resource;
						_this4.loadStateGraph(_this4._stateGraph);
					});
					_asset.on('change', this._onStateGraphAssetChangeEvent, this);
					this.system.app.assets.load(_asset);
				}
				this._stateGraphAsset = _id;
			}
		}, {
			key: "normalizeWeights",
			get: function get() {
				return this._normalizeWeights;
			},
			set: function set(value) {
				this._normalizeWeights = value;
				this.unbind();
			}
		}, {
			key: "animationAssets",
			get: function get() {
				return this._animationAssets;
			},
			set: function set(value) {
				this._animationAssets = value;
				this.loadAnimationAssets();
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "activate",
			get: function get() {
				return this._activate;
			},
			set: function set(value) {
				this._activate = value;
			}
		}, {
			key: "playing",
			get: function get() {
				return this._playing;
			},
			set: function set(value) {
				this._playing = value;
			}
		}, {
			key: "rootBone",
			get: function get() {
				return this._rootBone;
			},
			set: function set(value) {
				if (typeof value === 'string') {
					var entity = this.entity.root.findByGuid(value);
					this._rootBone = entity;
				} else if (value instanceof Entity) {
					this._rootBone = value;
				} else {
					this._rootBone = null;
				}
				this.rebind();
			}
		}, {
			key: "stateGraph",
			get: function get() {
				return this._stateGraph;
			},
			set: function set(value) {
				this._stateGraph = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			}
		}, {
			key: "layerIndices",
			get: function get() {
				return this._layerIndices;
			},
			set: function set(value) {
				this._layerIndices = value;
			}
		}, {
			key: "parameters",
			get: function get() {
				return this._parameters;
			},
			set: function set(value) {
				this._parameters = value;
			}
		}, {
			key: "targets",
			get: function get() {
				return this._targets;
			},
			set: function set(value) {
				this._targets = value;
			}
		}, {
			key: "playable",
			get: function get() {
				for (var i = 0; i < this._layers.length; i++) {
					if (!this._layers[i].playable) {
						return false;
					}
				}
				return true;
			}
		}, {
			key: "baseLayer",
			get: function get() {
				if (this._layers.length > 0) {
					return this._layers[0];
				}
				return null;
			}
		}]);
	}(Component);

	var AnimComponentData = function AnimComponentData() {
		this.enabled = true;
	};

	var _schema$j = ['enabled'];
	var AnimComponentSystem = function (_ComponentSystem) {
		function AnimComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'anim';
			_this.ComponentType = AnimComponent;
			_this.DataType = AnimComponentData;
			_this.schema = _schema$j;
			_this.on('beforeremove', _this.onBeforeRemove, _this);
			_this.app.systems.on('animationUpdate', _this.onAnimationUpdate, _this);
			return _this;
		}
		_inheritsLoose(AnimComponentSystem, _ComponentSystem);
		var _proto = AnimComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			var _this2 = this;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$j);
			var complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];
			Object.keys(data).forEach(function (key) {
				if (complexProperties.includes(key)) return;
				component[key] = data[key];
			});
			if (data.stateGraph) {
				component.stateGraph = data.stateGraph;
				component.loadStateGraph(component.stateGraph);
			}
			if (data.layers) {
				data.layers.forEach(function (layer, i) {
					layer._controller.states.forEach(function (stateKey) {
						layer._controller._states[stateKey]._animationList.forEach(function (node) {
							if (!node.animTrack || node.animTrack === AnimTrack.EMPTY) {
								var animationAsset = _this2.app.assets.get(layer._component._animationAssets[layer.name + ":" + node.name].asset);
								if (animationAsset && !animationAsset.loaded) {
									animationAsset.once('load', function () {
										component.layers[i].assignAnimation(node.name, animationAsset.resource);
									});
								}
							} else {
								component.layers[i].assignAnimation(node.name, node.animTrack);
							}
						});
					});
				});
			}
			if (data.animationAssets) {
				component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
			}
			if (data.masks) {
				Object.keys(data.masks).forEach(function (key) {
					if (component.layers[key]) {
						var maskData = data.masks[key].mask;
						var mask = {};
						Object.keys(maskData).forEach(function (maskKey) {
							mask[decodeURI(maskKey)] = maskData[maskKey];
						});
						component.layers[key].mask = mask;
					}
				});
			}
		};
		_proto.onAnimationUpdate = function onAnimationUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id].entity.anim;
					var componentData = component.data;
					if (componentData.enabled && component.entity.enabled && component.playing) {
						component.update(dt);
					}
				}
			}
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var masks;
			if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
				masks = {};
				entity.anim.layers.forEach(function (layer, i) {
					if (layer.mask) {
						var mask = {};
						Object.keys(layer.mask).forEach(function (path) {
							var pathArr = path.split('/');
							pathArr.shift();
							var clonePath = [clone.name].concat(pathArr).join('/');
							mask[clonePath] = layer.mask[path];
						});
						masks[i] = {
							mask: mask
						};
					}
				});
			}
			var data = {
				enabled: entity.anim.enabled,
				stateGraphAsset: entity.anim.stateGraphAsset,
				animationAssets: entity.anim.animationAssets,
				speed: entity.anim.speed,
				activate: entity.anim.activate,
				playing: entity.anim.playing,
				rootBone: entity.anim.rootBone,
				stateGraph: entity.anim.stateGraph,
				layers: entity.anim.layers,
				layerIndices: entity.anim.layerIndices,
				parameters: entity.anim.parameters,
				normalizeWeights: entity.anim.normalizeWeights,
				masks: masks
			};
			return this.addComponent(clone, data);
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
		};
		return AnimComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(AnimComponent.prototype, _schema$j);

	var AudioListenerComponent = function (_Component) {
		function AudioListenerComponent() {
			return _Component.apply(this, arguments) || this;
		}
		_inheritsLoose(AudioListenerComponent, _Component);
		var _proto = AudioListenerComponent.prototype;
		_proto.setCurrentListener = function setCurrentListener() {
			if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
				this.system.current = this.entity;
				var position = this.system.current.getPosition();
				this.system.manager.listener.setPosition(position);
			}
		};
		_proto.onEnable = function onEnable() {
			this.setCurrentListener();
		};
		_proto.onDisable = function onDisable() {
			if (this.system.current === this.entity) {
				this.system.current = null;
			}
		};
		return AudioListenerComponent;
	}(Component);

	var AudioListenerComponentData = function AudioListenerComponentData() {
		this.enabled = true;
	};

	var _schema$i = ['enabled'];
	var AudioListenerComponentSystem = function (_ComponentSystem) {
		function AudioListenerComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'audiolistener';
			_this.ComponentType = AudioListenerComponent;
			_this.DataType = AudioListenerComponentData;
			_this.schema = _schema$i;
			_this.manager = app.soundManager;
			_this.current = null;
			_this.app.systems.on('update', _this.onUpdate, _this);
			return _this;
		}
		_inheritsLoose(AudioListenerComponentSystem, _ComponentSystem);
		var _proto = AudioListenerComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['enabled'];
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.onUpdate = function onUpdate(dt) {
			if (this.current) {
				var position = this.current.getPosition();
				this.manager.listener.setPosition(position);
				var wtm = this.current.getWorldTransform();
				this.manager.listener.setOrientation(wtm);
			}
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return AudioListenerComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(AudioListenerComponent.prototype, _schema$i);

	var EntityReference = function (_EventHandler) {
		function EntityReference(parentComponent, entityPropertyName, eventConfig) {
			var _this;
			_this = _EventHandler.call(this) || this;
			if (!parentComponent || !(parentComponent instanceof Component)) {
				throw new Error('The parentComponent argument is required and must be a Component');
			} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
				throw new Error('The propertyName argument is required and must be a string');
			} else if (eventConfig && typeof eventConfig !== 'object') {
				throw new Error('If provided, the eventConfig argument must be an object');
			}
			_this._parentComponent = parentComponent;
			_this._entityPropertyName = entityPropertyName;
			_this._entity = null;
			_this._app = parentComponent.system.app;
			_this._configureEventListeners(eventConfig || {}, {
				'entity#destroy': _this._onEntityDestroy
			});
			_this._toggleLifecycleListeners('on');
			return _this;
		}
		_inheritsLoose(EntityReference, _EventHandler);
		var _proto = EntityReference.prototype;
		_proto._configureEventListeners = function _configureEventListeners(externalEventConfig, internalEventConfig) {
			var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);
			var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);
			this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
			this._listenerStatusFlags = {};
			this._gainListeners = {};
			this._loseListeners = {};
		};
		_proto._parseEventListenerConfig = function _parseEventListenerConfig(eventConfig, prefix, scope) {
			return Object.keys(eventConfig).map(function (listenerDescription, index) {
				var listenerDescriptionParts = listenerDescription.split('#');
				var sourceName = listenerDescriptionParts[0];
				var eventName = listenerDescriptionParts[1];
				var callback = eventConfig[listenerDescription];
				if (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {
					throw new Error("Invalid event listener description: `" + listenerDescription + "`");
				}
				if (typeof callback !== 'function') {
					throw new Error("Invalid or missing callback for event listener `" + listenerDescription + "`");
				}
				return {
					id: prefix + "_" + index + "_" + listenerDescription,
					sourceName: sourceName,
					eventName: eventName,
					callback: callback,
					scope: scope
				};
			}, this);
		};
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this._parentComponent[onOrOff]("set_" + this._entityPropertyName, this._onSetEntity, this);
			this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);
			this._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);
			this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);
			var allComponentSystems = [];
			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];
				var componentSystem = this._app.systems[config.sourceName];
				if (componentSystem) {
					if (allComponentSystems.indexOf(componentSystem) === -1) {
						allComponentSystems.push(componentSystem);
					}
					if (componentSystem && config.eventName === 'gain') {
						this._gainListeners[config.sourceName] = config;
					}
					if (componentSystem && config.eventName === 'lose') {
						this._loseListeners[config.sourceName] = config;
					}
				}
			}
			for (var _i = 0; _i < allComponentSystems.length; ++_i) {
				allComponentSystems[_i][onOrOff]('add', this._onComponentAdd, this);
				allComponentSystems[_i][onOrOff]('beforeremove', this._onComponentRemove, this);
			}
		};
		_proto._onSetEntity = function _onSetEntity(name, oldValue, newValue) {
			if (newValue instanceof Entity) {
				this._updateEntityReference();
			} else {
				if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
					console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof newValue + "'");
					return;
				}
				if (oldValue !== newValue) {
					this._updateEntityReference();
				}
			}
		};
		_proto.onParentComponentEnable = function onParentComponentEnable() {
			if (!this._entity) {
				this._updateEntityReference();
			}
		};
		_proto._onSceneLoaded = function _onSceneLoaded() {
			this._updateEntityReference();
		};
		_proto._updateEntityReference = function _updateEntityReference() {
			var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
			var nextEntity;
			if (nextEntityGuid instanceof Entity) {
				nextEntity = nextEntityGuid;
				nextEntityGuid = nextEntity.getGuid();
				this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
			} else {
				var root = this._parentComponent.system.app.root;
				var isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);
				nextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;
			}
			var hasChanged = this._entity !== nextEntity;
			if (hasChanged) {
				if (this._entity) {
					this._onBeforeEntityChange();
				}
				this._entity = nextEntity;
				if (this._entity) {
					this._onAfterEntityChange();
				}
				this.fire('set:entity', this._entity);
			}
		};
		_proto._onBeforeEntityChange = function _onBeforeEntityChange() {
			this._toggleEntityListeners('off');
			this._callAllGainOrLoseListeners(this._loseListeners);
		};
		_proto._onAfterEntityChange = function _onAfterEntityChange() {
			this._toggleEntityListeners('on');
			this._callAllGainOrLoseListeners(this._gainListeners);
		};
		_proto._onComponentAdd = function _onComponentAdd(entity, component) {
			var componentName = component.system.id;
			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._gainListeners);
				this._toggleComponentListeners('on', componentName);
			}
		};
		_proto._onComponentRemove = function _onComponentRemove(entity, component) {
			var componentName = component.system.id;
			if (entity === this._entity) {
				this._callGainOrLoseListener(componentName, this._loseListeners);
				this._toggleComponentListeners('off', componentName, true);
			}
		};
		_proto._callAllGainOrLoseListeners = function _callAllGainOrLoseListeners(listenerMap) {
			for (var componentName in this._entity.c) {
				this._callGainOrLoseListener(componentName, listenerMap);
			}
		};
		_proto._callGainOrLoseListener = function _callGainOrLoseListener(componentName, listenerMap) {
			if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
				var config = listenerMap[componentName];
				config.callback.call(config.scope);
			}
		};
		_proto._toggleEntityListeners = function _toggleEntityListeners(onOrOff, isDestroying) {
			if (this._entity) {
				for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
					this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
				}
			}
		};
		_proto._toggleComponentListeners = function _toggleComponentListeners(onOrOff, componentName, isDestroying) {
			for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
				var config = this._eventListenerConfigs[i];
				if (config.sourceName === componentName) {
					this._safeToggleListener(onOrOff, config, isDestroying);
				}
			}
		};
		_proto._safeToggleListener = function _safeToggleListener(onOrOff, config, isDestroying) {
			var isAdding = onOrOff === 'on';
			if (isAdding && this._listenerStatusFlags[config.id]) {
				return;
			}
			var source = this._getEventSource(config.sourceName, isDestroying);
			if (source) {
				source[onOrOff](config.eventName, config.callback, config.scope);
				this._listenerStatusFlags[config.id] = isAdding;
			}
		};
		_proto._getEventSource = function _getEventSource(sourceName, isDestroying) {
			if (sourceName === 'entity') {
				return this._entity;
			}
			var component = this._entity[sourceName];
			if (component) {
				return component;
			}
			if (!isDestroying) {
				console.warn("Entity has no component with name " + sourceName);
			}
			return null;
		};
		_proto._onEntityDestroy = function _onEntityDestroy(entity) {
			if (this._entity === entity) {
				this._toggleEntityListeners('off', true);
				this._entity = null;
			}
		};
		_proto._onParentComponentRemove = function _onParentComponentRemove(entity, component) {
			if (component === this._parentComponent) {
				this._toggleLifecycleListeners('off');
				this._toggleEntityListeners('off', true);
			}
		};
		_proto.hasComponent = function hasComponent(componentName) {
			return this._entity && this._entity.c ? !!this._entity.c[componentName] : false;
		};
		return _createClass(EntityReference, [{
			key: "entity",
			get: function get() {
				return this._entity;
			}
		}]);
	}(EventHandler);

	var BUTTON_TRANSITION_MODE_TINT = 0;
	var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

	var ELEMENTTYPE_GROUP = 'group';
	var ELEMENTTYPE_IMAGE = 'image';
	var ELEMENTTYPE_TEXT = 'text';
	var FITMODE_STRETCH = 'stretch';
	var FITMODE_CONTAIN = 'contain';
	var FITMODE_COVER = 'cover';

	var VisualState = {
		DEFAULT: 'DEFAULT',
		HOVER: 'HOVER',
		PRESSED: 'PRESSED',
		INACTIVE: 'INACTIVE'
	};
	var STATES_TO_TINT_NAMES = {};
	STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
	STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
	STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
	STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
	var STATES_TO_SPRITE_ASSET_NAMES = {};
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
	STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
	var STATES_TO_SPRITE_FRAME_NAMES = {};
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
	STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';
	var ButtonComponent = function (_Component) {
		function ButtonComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._visualState = VisualState.DEFAULT;
			_this._isHovering = false;
			_this._hoveringCounter = 0;
			_this._isPressed = false;
			_this._defaultTint = new Color(1, 1, 1, 1);
			_this._defaultSpriteAsset = null;
			_this._defaultSpriteFrame = 0;
			_this._imageReference = new EntityReference(_this, 'imageEntity', {
				'element#gain': _this._onImageElementGain,
				'element#lose': _this._onImageElementLose,
				'element#set:color': _this._onSetColor,
				'element#set:opacity': _this._onSetOpacity,
				'element#set:spriteAsset': _this._onSetSpriteAsset,
				'element#set:spriteFrame': _this._onSetSpriteFrame
			});
			_this._toggleLifecycleListeners('on', system);
			return _this;
		}
		_inheritsLoose(ButtonComponent, _Component);
		var _proto = ButtonComponent.prototype;
		_proto._setValue = function _setValue(name, value) {
			var data = this.data;
			var oldValue = data[name];
			data[name] = value;
			this.fire('set', name, oldValue, value);
		};
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
			this[onOrOff]('set_active', this._onSetActive, this);
			this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
			this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
			this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		};
		_proto._onSetActive = function _onSetActive(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._updateVisualState();
			}
		};
		_proto._onSetTransitionMode = function _onSetTransitionMode(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._cancelTween();
				this._resetToDefaultVisualState(oldValue);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetTransitionValue = function _onSetTransitionValue(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this._forceReapplyVisualState();
			}
		};
		_proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('off');
			}
		};
		_proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
			if (this.entity === entity) {
				this._toggleHitElementListeners('on');
			}
		};
		_proto._onImageElementLose = function _onImageElementLose() {
			this._cancelTween();
			this._resetToDefaultVisualState(this.transitionMode);
		};
		_proto._onImageElementGain = function _onImageElementGain() {
			this._storeDefaultVisualState();
			this._forceReapplyVisualState();
		};
		_proto._toggleHitElementListeners = function _toggleHitElementListeners(onOrOff) {
			if (this.entity.element) {
				var isAdding = onOrOff === 'on';
				if (isAdding && this._hasHitElementListeners) {
					return;
				}
				this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
				this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
				this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
				this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
				this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
				this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
				this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
				this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
				this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
				this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
				this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
				this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
				this.entity.element[onOrOff]('click', this._onClick, this);
				this._hasHitElementListeners = isAdding;
			}
		};
		_proto._storeDefaultVisualState = function _storeDefaultVisualState() {
			if (this._imageReference.hasComponent('element')) {
				var element = this._imageReference.entity.element;
				if (element.type !== ELEMENTTYPE_GROUP) {
					this._storeDefaultColor(element.color);
					this._storeDefaultOpacity(element.opacity);
					this._storeDefaultSpriteAsset(element.spriteAsset);
					this._storeDefaultSpriteFrame(element.spriteFrame);
				}
			}
		};
		_proto._storeDefaultColor = function _storeDefaultColor(color) {
			this._defaultTint.r = color.r;
			this._defaultTint.g = color.g;
			this._defaultTint.b = color.b;
		};
		_proto._storeDefaultOpacity = function _storeDefaultOpacity(opacity) {
			this._defaultTint.a = opacity;
		};
		_proto._storeDefaultSpriteAsset = function _storeDefaultSpriteAsset(spriteAsset) {
			this._defaultSpriteAsset = spriteAsset;
		};
		_proto._storeDefaultSpriteFrame = function _storeDefaultSpriteFrame(spriteFrame) {
			this._defaultSpriteFrame = spriteFrame;
		};
		_proto._onSetColor = function _onSetColor(color) {
			if (!this._isApplyingTint) {
				this._storeDefaultColor(color);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetOpacity = function _onSetOpacity(opacity) {
			if (!this._isApplyingTint) {
				this._storeDefaultOpacity(opacity);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetSpriteAsset = function _onSetSpriteAsset(spriteAsset) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteAsset(spriteAsset);
				this._forceReapplyVisualState();
			}
		};
		_proto._onSetSpriteFrame = function _onSetSpriteFrame(spriteFrame) {
			if (!this._isApplyingSprite) {
				this._storeDefaultSpriteFrame(spriteFrame);
				this._forceReapplyVisualState();
			}
		};
		_proto._onMouseEnter = function _onMouseEnter(event) {
			this._isHovering = true;
			this._updateVisualState();
			this._fireIfActive('mouseenter', event);
		};
		_proto._onMouseLeave = function _onMouseLeave(event) {
			this._isHovering = false;
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('mouseleave', event);
		};
		_proto._onMouseDown = function _onMouseDown(event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('mousedown', event);
		};
		_proto._onMouseUp = function _onMouseUp(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('mouseup', event);
		};
		_proto._onTouchStart = function _onTouchStart(event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('touchstart', event);
		};
		_proto._onTouchEnd = function _onTouchEnd(event) {
			event.event.preventDefault();
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchend', event);
		};
		_proto._onTouchLeave = function _onTouchLeave(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchleave', event);
		};
		_proto._onTouchCancel = function _onTouchCancel(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('touchcancel', event);
		};
		_proto._onSelectStart = function _onSelectStart(event) {
			this._isPressed = true;
			this._updateVisualState();
			this._fireIfActive('selectstart', event);
		};
		_proto._onSelectEnd = function _onSelectEnd(event) {
			this._isPressed = false;
			this._updateVisualState();
			this._fireIfActive('selectend', event);
		};
		_proto._onSelectEnter = function _onSelectEnter(event) {
			this._hoveringCounter++;
			if (this._hoveringCounter === 1) {
				this._isHovering = true;
				this._updateVisualState();
			}
			this._fireIfActive('selectenter', event);
		};
		_proto._onSelectLeave = function _onSelectLeave(event) {
			this._hoveringCounter--;
			if (this._hoveringCounter === 0) {
				this._isHovering = false;
				this._isPressed = false;
				this._updateVisualState();
			}
			this._fireIfActive('selectleave', event);
		};
		_proto._onClick = function _onClick(event) {
			this._fireIfActive('click', event);
		};
		_proto._fireIfActive = function _fireIfActive(name, event) {
			if (this.data.active) {
				this.fire(name, event);
			}
		};
		_proto._updateVisualState = function _updateVisualState(force) {
			var oldVisualState = this._visualState;
			var newVisualState = this._determineVisualState();
			if ((oldVisualState !== newVisualState || force) && this.enabled) {
				this._visualState = newVisualState;
				if (oldVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverend');
				}
				if (oldVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedend');
				}
				if (newVisualState === VisualState.HOVER) {
					this._fireIfActive('hoverstart');
				}
				if (newVisualState === VisualState.PRESSED) {
					this._fireIfActive('pressedstart');
				}
				switch (this.transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						{
							var tintName = STATES_TO_TINT_NAMES[this._visualState];
							var tintColor = this[tintName];
							this._applyTint(tintColor);
							break;
						}
					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						{
							var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
							var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
							var spriteAsset = this[spriteAssetName];
							var spriteFrame = this[spriteFrameName];
							this._applySprite(spriteAsset, spriteFrame);
							break;
						}
				}
			}
		};
		_proto._forceReapplyVisualState = function _forceReapplyVisualState() {
			this._updateVisualState(true);
		};
		_proto._resetToDefaultVisualState = function _resetToDefaultVisualState(transitionMode) {
			if (this._imageReference.hasComponent('element')) {
				switch (transitionMode) {
					case BUTTON_TRANSITION_MODE_TINT:
						this._cancelTween();
						this._applyTintImmediately(this._defaultTint);
						break;
					case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
						this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
						break;
				}
			}
		};
		_proto._determineVisualState = function _determineVisualState() {
			if (!this.active) {
				return VisualState.INACTIVE;
			} else if (this._isPressed) {
				return VisualState.PRESSED;
			} else if (this._isHovering) {
				return VisualState.HOVER;
			}
			return VisualState.DEFAULT;
		};
		_proto._applySprite = function _applySprite(spriteAsset, spriteFrame) {
			spriteFrame = spriteFrame || 0;
			if (this._imageReference.hasComponent('element')) {
				this._isApplyingSprite = true;
				if (this._imageReference.entity.element.spriteAsset !== spriteAsset) {
					this._imageReference.entity.element.spriteAsset = spriteAsset;
				}
				if (this._imageReference.entity.element.spriteFrame !== spriteFrame) {
					this._imageReference.entity.element.spriteFrame = spriteFrame;
				}
				this._isApplyingSprite = false;
			}
		};
		_proto._applyTint = function _applyTint(tintColor) {
			this._cancelTween();
			if (this.fadeDuration === 0) {
				this._applyTintImmediately(tintColor);
			} else {
				this._applyTintWithTween(tintColor);
			}
		};
		_proto._applyTintImmediately = function _applyTintImmediately(tintColor) {
			if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) {
				return;
			}
			var color3 = toColor3(tintColor);
			this._isApplyingTint = true;
			if (!color3.equals(this._imageReference.entity.element.color)) {
				this._imageReference.entity.element.color = color3;
			}
			if (this._imageReference.entity.element.opacity !== tintColor.a) {
				this._imageReference.entity.element.opacity = tintColor.a;
			}
			this._isApplyingTint = false;
		};
		_proto._applyTintWithTween = function _applyTintWithTween(tintColor) {
			if (!tintColor || !this._imageReference.hasComponent('element') || this._imageReference.entity.element.type === ELEMENTTYPE_GROUP) {
				return;
			}
			var color3 = toColor3(tintColor);
			var color = this._imageReference.entity.element.color;
			var opacity = this._imageReference.entity.element.opacity;
			if (color3.equals(color) && tintColor.a === opacity) return;
			this._tweenInfo = {
				startTime: now(),
				from: new Color(color.r, color.g, color.b, opacity),
				to: tintColor.clone(),
				lerpColor: new Color()
			};
		};
		_proto._updateTintTween = function _updateTintTween() {
			var elapsedTime = now() - this._tweenInfo.startTime;
			var elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
			elapsedProportion = math.clamp(elapsedProportion, 0, 1);
			if (Math.abs(elapsedProportion - 1) > 1e-5) {
				var lerpColor = this._tweenInfo.lerpColor;
				lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
				this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
			} else {
				this._applyTintImmediately(this._tweenInfo.to);
				this._cancelTween();
			}
		};
		_proto._cancelTween = function _cancelTween() {
			delete this._tweenInfo;
		};
		_proto.onUpdate = function onUpdate() {
			if (this._tweenInfo) {
				this._updateTintTween();
			}
		};
		_proto.onEnable = function onEnable() {
			this._isHovering = false;
			this._hoveringCounter = 0;
			this._isPressed = false;
			this._imageReference.onParentComponentEnable();
			this._toggleHitElementListeners('on');
			this._forceReapplyVisualState();
		};
		_proto.onDisable = function onDisable() {
			this._toggleHitElementListeners('off');
			this._resetToDefaultVisualState(this.transitionMode);
		};
		_proto.onRemove = function onRemove() {
			this._toggleLifecycleListeners('off', this.system);
			this.onDisable();
		};
		return _createClass(ButtonComponent, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this.data.enabled;
			},
			set: function set(arg) {
				this._setValue('enabled', arg);
			}
		}, {
			key: "active",
			get: function get() {
				return this.data.active;
			},
			set: function set(arg) {
				this._setValue('active', arg);
			}
		}, {
			key: "imageEntity",
			get: function get() {
				return this.data.imageEntity;
			},
			set: function set(arg) {
				this._setValue('imageEntity', arg);
			}
		}, {
			key: "hitPadding",
			get: function get() {
				return this.data.hitPadding;
			},
			set: function set(arg) {
				this._setValue('hitPadding', arg);
			}
		}, {
			key: "transitionMode",
			get: function get() {
				return this.data.transitionMode;
			},
			set: function set(arg) {
				this._setValue('transitionMode', arg);
			}
		}, {
			key: "hoverTint",
			get: function get() {
				return this.data.hoverTint;
			},
			set: function set(arg) {
				this._setValue('hoverTint', arg);
			}
		}, {
			key: "pressedTint",
			get: function get() {
				return this.data.pressedTint;
			},
			set: function set(arg) {
				this._setValue('pressedTint', arg);
			}
		}, {
			key: "inactiveTint",
			get: function get() {
				return this.data.inactiveTint;
			},
			set: function set(arg) {
				this._setValue('inactiveTint', arg);
			}
		}, {
			key: "fadeDuration",
			get: function get() {
				return this.data.fadeDuration;
			},
			set: function set(arg) {
				this._setValue('fadeDuration', arg);
			}
		}, {
			key: "hoverSpriteAsset",
			get: function get() {
				return this.data.hoverSpriteAsset;
			},
			set: function set(arg) {
				this._setValue('hoverSpriteAsset', arg);
			}
		}, {
			key: "hoverSpriteFrame",
			get: function get() {
				return this.data.hoverSpriteFrame;
			},
			set: function set(arg) {
				this._setValue('hoverSpriteFrame', arg);
			}
		}, {
			key: "pressedSpriteAsset",
			get: function get() {
				return this.data.pressedSpriteAsset;
			},
			set: function set(arg) {
				this._setValue('pressedSpriteAsset', arg);
			}
		}, {
			key: "pressedSpriteFrame",
			get: function get() {
				return this.data.pressedSpriteFrame;
			},
			set: function set(arg) {
				this._setValue('pressedSpriteFrame', arg);
			}
		}, {
			key: "inactiveSpriteAsset",
			get: function get() {
				return this.data.inactiveSpriteAsset;
			},
			set: function set(arg) {
				this._setValue('inactiveSpriteAsset', arg);
			}
		}, {
			key: "inactiveSpriteFrame",
			get: function get() {
				return this.data.inactiveSpriteFrame;
			},
			set: function set(arg) {
				this._setValue('inactiveSpriteFrame', arg);
			}
		}]);
	}(Component);
	ButtonComponent.EVENT_MOUSEDOWN = 'mousedown';
	ButtonComponent.EVENT_MOUSEUP = 'mouseup';
	ButtonComponent.EVENT_MOUSEENTER = 'mouseenter';
	ButtonComponent.EVENT_MOUSELEAVE = 'mouseleave';
	ButtonComponent.EVENT_CLICK = 'click';
	ButtonComponent.EVENT_TOUCHSTART = 'touchstart';
	ButtonComponent.EVENT_TOUCHEND = 'touchend';
	ButtonComponent.EVENT_TOUCHCANCEL = 'touchcancel';
	ButtonComponent.EVENT_TOUCHLEAVE = 'touchleave';
	ButtonComponent.EVENT_SELECTSTART = 'selectstart';
	ButtonComponent.EVENT_SELECTEND = 'selectend';
	ButtonComponent.EVENT_SELECTENTER = 'selectenter';
	ButtonComponent.EVENT_SELECTLEAVE = 'selectleave';
	ButtonComponent.EVENT_HOVERSTART = 'hoverstart';
	ButtonComponent.EVENT_HOVEREND = 'hoverend';
	ButtonComponent.EVENT_PRESSEDSTART = 'pressedstart';
	ButtonComponent.EVENT_PRESSEDEND = 'pressedend';
	function toColor3(color4) {
		return new Color(color4.r, color4.g, color4.b);
	}

	var ButtonComponentData = function ButtonComponentData() {
		this.enabled = true;
		this.active = true;
		this.imageEntity = null;
		this.hitPadding = new Vec4();
		this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
		this.hoverTint = new Color(0.75, 0.75, 0.75);
		this.pressedTint = new Color(0.5, 0.5, 0.5);
		this.inactiveTint = new Color(0.25, 0.25, 0.25);
		this.fadeDuration = 0;
		this.hoverSpriteAsset = null;
		this.hoverSpriteFrame = 0;
		this.pressedSpriteAsset = null;
		this.pressedSpriteFrame = 0;
		this.inactiveSpriteAsset = null;
		this.inactiveSpriteFrame = 0;
	};

	var _schema$h = ['enabled', 'active', {
		name: 'imageEntity',
		type: 'entity'
	}, {
		name: 'hitPadding',
		type: 'vec4'
	}, 'transitionMode', {
		name: 'hoverTint',
		type: 'rgba'
	}, {
		name: 'pressedTint',
		type: 'rgba'
	}, {
		name: 'inactiveTint',
		type: 'rgba'
	}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];
	var ButtonComponentSystem = function (_ComponentSystem) {
		function ButtonComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'button';
			_this.ComponentType = ButtonComponent;
			_this.DataType = ButtonComponentData;
			_this.schema = _schema$h;
			_this.on('beforeremove', _this._onRemoveComponent, _this);
			_this.app.systems.on('update', _this.onUpdate, _this);
			return _this;
		}
		_inheritsLoose(ButtonComponentSystem, _ComponentSystem);
		var _proto = ButtonComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$h);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.button;
				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return ButtonComponentSystem;
	}(ComponentSystem);

	var _vec3$1 = new Vec3();
	var _quat = new Quat();
	var CollisionComponent = function (_Component) {
		function CollisionComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._compoundParent = null;
			_this._hasOffset = false;
			_this.entity.on('insert', _this._onInsert, _this);
			_this.on('set_type', _this.onSetType, _this);
			_this.on('set_convexHull', _this.onSetModel, _this);
			_this.on('set_halfExtents', _this.onSetHalfExtents, _this);
			_this.on('set_linearOffset', _this.onSetOffset, _this);
			_this.on('set_angularOffset', _this.onSetOffset, _this);
			_this.on('set_radius', _this.onSetRadius, _this);
			_this.on('set_height', _this.onSetHeight, _this);
			_this.on('set_axis', _this.onSetAxis, _this);
			_this.on('set_asset', _this.onSetAsset, _this);
			_this.on('set_renderAsset', _this.onSetRenderAsset, _this);
			_this.on('set_model', _this.onSetModel, _this);
			_this.on('set_render', _this.onSetRender, _this);
			return _this;
		}
		_inheritsLoose(CollisionComponent, _Component);
		var _proto = CollisionComponent.prototype;
		_proto._setValue = function _setValue(name, value) {
			var data = this.data;
			var oldValue = data[name];
			data[name] = value;
			this.fire('set', name, oldValue, value);
		};
		_proto.onSetType = function onSetType(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				this.system.changeType(this, oldValue, newValue);
			}
		};
		_proto.onSetHalfExtents = function onSetHalfExtents(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && t === 'box') {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetOffset = function onSetOffset(name, oldValue, newValue) {
			this._hasOffset = !this.data.linearOffset.equals(Vec3.ZERO) || !this.data.angularOffset.equals(Quat.IDENTITY);
			if (this.data.initialized) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetRadius = function onSetRadius(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetHeight = function onSetHeight(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetAxis = function onSetAxis(name, oldValue, newValue) {
			var t = this.data.type;
			if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetAsset = function onSetAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					asset.off('remove', this.onAssetRemoved, this);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.asset = newValue.id;
				}
				var _asset = assets.get(this.data.asset);
				if (_asset) {
					_asset.off('remove', this.onAssetRemoved, this);
					_asset.on('remove', this.onAssetRemoved, this);
				}
			}
			if (this.data.initialized && this.data.type === 'mesh') {
				if (!newValue) {
					this.data.model = null;
				}
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					asset.off('remove', this.onRenderAssetRemoved, this);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.renderAsset = newValue.id;
				}
				var _asset2 = assets.get(this.data.renderAsset);
				if (_asset2) {
					_asset2.off('remove', this.onRenderAssetRemoved, this);
					_asset2.on('remove', this.onRenderAssetRemoved, this);
				}
			}
			if (this.data.initialized && this.data.type === 'mesh') {
				if (!newValue) {
					this.data.render = null;
				}
				this.system.recreatePhysicalShapes(this);
			}
		};
		_proto.onSetModel = function onSetModel(name, oldValue, newValue) {
			if (this.data.initialized && this.data.type === 'mesh') {
				this.system.implementations.mesh.doRecreatePhysicalShape(this);
			}
		};
		_proto.onSetRender = function onSetRender(name, oldValue, newValue) {
			this.onSetModel(name, oldValue, newValue);
		};
		_proto.onAssetRemoved = function onAssetRemoved(asset) {
			asset.off('remove', this.onAssetRemoved, this);
			if (this.data.asset === asset.id) {
				this.asset = null;
			}
		};
		_proto.onRenderAssetRemoved = function onRenderAssetRemoved(asset) {
			asset.off('remove', this.onRenderAssetRemoved, this);
			if (this.data.renderAsset === asset.id) {
				this.renderAsset = null;
			}
		};
		_proto.getCompoundChildShapeIndex = function getCompoundChildShapeIndex(shape) {
			var compound = this.data.shape;
			var shapes = compound.getNumChildShapes();
			for (var i = 0; i < shapes; i++) {
				var childShape = compound.getChildShape(i);
				if (Ammo.getPointer(childShape) === Ammo.getPointer(shape)) {
					return i;
				}
			}
			return null;
		};
		_proto._onInsert = function _onInsert(parent) {
			if (typeof Ammo === 'undefined') {
				return;
			}
			if (this._compoundParent) {
				this.system.recreatePhysicalShapes(this);
			} else if (!this.entity.rigidbody) {
				var ancestor = this.entity.parent;
				while (ancestor) {
					if (ancestor.collision && ancestor.collision.type === 'compound') {
						if (ancestor.collision.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(ancestor.collision);
						} else {
							this.system.recreatePhysicalShapes(this);
						}
						break;
					}
					ancestor = ancestor.parent;
				}
			}
		};
		_proto._updateCompound = function _updateCompound() {
			var entity = this.entity;
			if (entity._dirtyWorld) {
				var dirty = entity._dirtyLocal;
				var parent = entity;
				while (parent && !dirty) {
					if (parent.collision && parent.collision === this._compoundParent) {
						break;
					}
					if (parent._dirtyLocal) {
						dirty = true;
					}
					parent = parent.parent;
				}
				if (dirty) {
					entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
					var bodyComponent = this._compoundParent.entity.rigidbody;
					if (bodyComponent) {
						bodyComponent.activate();
					}
				}
			}
		};
		_proto.getShapePosition = function getShapePosition() {
			var pos = this.entity.getPosition();
			if (this._hasOffset) {
				var rot = this.entity.getRotation();
				var lo = this.data.linearOffset;
				_quat.copy(rot).transformVector(lo, _vec3$1);
				return _vec3$1.add(pos);
			}
			return pos;
		};
		_proto.getShapeRotation = function getShapeRotation() {
			var rot = this.entity.getRotation();
			if (this._hasOffset) {
				return _quat.copy(rot).mul(this.data.angularOffset);
			}
			return rot;
		};
		_proto.onEnable = function onEnable() {
			if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
				var asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);
				if (asset && (!asset.resource || !this.data.shape)) {
					this.system.recreatePhysicalShapes(this);
					return;
				}
			}
			if (this.entity.rigidbody) {
				if (this.entity.rigidbody.enabled) {
					this.entity.rigidbody.enableSimulation();
				}
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (this._compoundParent.shape.getNumChildShapes() === 0) {
					this.system.recreatePhysicalShapes(this._compoundParent);
				} else {
					var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
					this._compoundParent.shape.addChildShape(transform, this.data.shape);
					Ammo.destroy(transform);
					if (this._compoundParent.entity.rigidbody) {
						this._compoundParent.entity.rigidbody.activate();
					}
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.enable();
			}
		};
		_proto.onDisable = function onDisable() {
			if (this.entity.rigidbody) {
				this.entity.rigidbody.disableSimulation();
			} else if (this._compoundParent && this !== this._compoundParent) {
				if (!this._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(this._compoundParent, this.data.shape);
					if (this._compoundParent.entity.rigidbody) {
						this._compoundParent.entity.rigidbody.activate();
					}
				}
			} else if (this.entity.trigger) {
				this.entity.trigger.disable();
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			if (this.asset) {
				this.asset = null;
			}
			if (this.renderAsset) {
				this.renderAsset = null;
			}
			this.entity.off('insert', this._onInsert, this);
			this.off();
		};
		return _createClass(CollisionComponent, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this.data.enabled;
			},
			set: function set(arg) {
				this._setValue('enabled', arg);
			}
		}, {
			key: "type",
			get: function get() {
				return this.data.type;
			},
			set: function set(arg) {
				this._setValue('type', arg);
			}
		}, {
			key: "halfExtents",
			get: function get() {
				return this.data.halfExtents;
			},
			set: function set(arg) {
				this._setValue('halfExtents', arg);
			}
		}, {
			key: "linearOffset",
			get: function get() {
				return this.data.linearOffset;
			},
			set: function set(arg) {
				this._setValue('linearOffset', arg);
			}
		}, {
			key: "angularOffset",
			get: function get() {
				return this.data.angularOffset;
			},
			set: function set(arg) {
				this._setValue('angularOffset', arg);
			}
		}, {
			key: "radius",
			get: function get() {
				return this.data.radius;
			},
			set: function set(arg) {
				this._setValue('radius', arg);
			}
		}, {
			key: "axis",
			get: function get() {
				return this.data.axis;
			},
			set: function set(arg) {
				this._setValue('axis', arg);
			}
		}, {
			key: "height",
			get: function get() {
				return this.data.height;
			},
			set: function set(arg) {
				this._setValue('height', arg);
			}
		}, {
			key: "asset",
			get: function get() {
				return this.data.asset;
			},
			set: function set(arg) {
				this._setValue('asset', arg);
			}
		}, {
			key: "renderAsset",
			get: function get() {
				return this.data.renderAsset;
			},
			set: function set(arg) {
				this._setValue('renderAsset', arg);
			}
		}, {
			key: "convexHull",
			get: function get() {
				return this.data.convexHull;
			},
			set: function set(arg) {
				this._setValue('convexHull', arg);
			}
		}, {
			key: "shape",
			get: function get() {
				return this.data.shape;
			},
			set: function set(arg) {
				this._setValue('shape', arg);
			}
		}, {
			key: "model",
			get: function get() {
				return this.data.model;
			},
			set: function set(arg) {
				this._setValue('model', arg);
			}
		}, {
			key: "render",
			get: function get() {
				return this.data.render;
			},
			set: function set(arg) {
				this._setValue('render', arg);
			}
		}, {
			key: "checkVertexDuplicates",
			get: function get() {
				return this.data.checkVertexDuplicates;
			},
			set: function set(arg) {
				this._setValue('checkVertexDuplicates', arg);
			}
		}]);
	}(Component);
	CollisionComponent.EVENT_CONTACT = 'contact';
	CollisionComponent.EVENT_COLLISIONSTART = 'collisionstart';
	CollisionComponent.EVENT_COLLISIONEND = 'collisionend';
	CollisionComponent.EVENT_TRIGGERENTER = 'triggerenter';
	CollisionComponent.EVENT_TRIGGERLEAVE = 'triggerleave';

	var CollisionComponentData = function CollisionComponentData() {
		this.enabled = true;
		this.type = 'box';
		this.halfExtents = new Vec3(0.5, 0.5, 0.5);
		this.linearOffset = new Vec3();
		this.angularOffset = new Quat();
		this.radius = 0.5;
		this.axis = 1;
		this.height = 2;
		this.convexHull = false;
		this.asset = null;
		this.renderAsset = null;
		this.checkVertexDuplicates = true;
		this.shape = null;
		this.model = null;
		this.render = null;
		this.initialized = false;
	};

	var BODYTYPE_STATIC = 'static';
	var BODYTYPE_DYNAMIC = 'dynamic';
	var BODYTYPE_KINEMATIC = 'kinematic';
	var BODYFLAG_STATIC_OBJECT = 1;
	var BODYFLAG_KINEMATIC_OBJECT = 2;
	var BODYFLAG_NORESPONSE_OBJECT = 4;
	var BODYSTATE_ACTIVE_TAG = 1;
	var BODYSTATE_ISLAND_SLEEPING = 2;
	var BODYSTATE_WANTS_DEACTIVATION = 3;
	var BODYSTATE_DISABLE_DEACTIVATION = 4;
	var BODYSTATE_DISABLE_SIMULATION = 5;
	var BODYGROUP_NONE = 0;
	var BODYGROUP_DEFAULT = 1;
	var BODYGROUP_DYNAMIC = 1;
	var BODYGROUP_STATIC = 2;
	var BODYGROUP_KINEMATIC = 4;
	var BODYGROUP_ENGINE_1 = 8;
	var BODYGROUP_TRIGGER = 16;
	var BODYGROUP_ENGINE_2 = 32;
	var BODYGROUP_ENGINE_3 = 64;
	var BODYGROUP_USER_1 = 128;
	var BODYGROUP_USER_2 = 256;
	var BODYGROUP_USER_3 = 512;
	var BODYGROUP_USER_4 = 1024;
	var BODYGROUP_USER_5 = 2048;
	var BODYGROUP_USER_6 = 4096;
	var BODYGROUP_USER_7 = 8192;
	var BODYGROUP_USER_8 = 16384;
	var BODYMASK_NONE = 0;
	var BODYMASK_ALL = 65535;
	var BODYMASK_STATIC = 2;
	var BODYMASK_NOT_STATIC = 65535 ^ 2;
	var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

	var _ammoVec1$1, _ammoQuat$1, _ammoTransform$1;
	var Trigger = function () {
		function Trigger(app, component, data) {
			this.entity = component.entity;
			this.component = component;
			this.app = app;
			if (typeof Ammo !== 'undefined' && !_ammoVec1$1) {
				_ammoVec1$1 = new Ammo.btVector3();
				_ammoQuat$1 = new Ammo.btQuaternion();
				_ammoTransform$1 = new Ammo.btTransform();
			}
			this.initialize(data);
		}
		var _proto = Trigger.prototype;
		_proto.initialize = function initialize(data) {
			var entity = this.entity;
			var shape = data.shape;
			if (shape && typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
				}
				var mass = 1;
				var component = this.component;
				if (component) {
					var bodyPos = component.getShapePosition();
					var bodyRot = component.getShapeRotation();
					_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
					_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
				} else {
					var pos = entity.getPosition();
					var rot = entity.getRotation();
					_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
					_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
				}
				_ammoTransform$1.setOrigin(_ammoVec1$1);
				_ammoTransform$1.setRotation(_ammoQuat$1);
				var body = this.app.systems.rigidbody.createBody(mass, shape, _ammoTransform$1);
				body.setRestitution(0);
				body.setFriction(0);
				body.setDamping(0, 0);
				_ammoVec1$1.setValue(0, 0, 0);
				body.setLinearFactor(_ammoVec1$1);
				body.setAngularFactor(_ammoVec1$1);
				body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
				body.entity = entity;
				this.body = body;
				if (this.component.enabled && entity.enabled) {
					this.enable();
				}
			}
		};
		_proto.destroy = function destroy() {
			if (!this.body) return;
			this.disable();
			this.app.systems.rigidbody.destroyBody(this.body);
			this.body = null;
		};
		_proto._getEntityTransform = function _getEntityTransform(transform) {
			var component = this.component;
			if (component) {
				var bodyPos = component.getShapePosition();
				var bodyRot = component.getShapeRotation();
				_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
				_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
			} else {
				var pos = this.entity.getPosition();
				var rot = this.entity.getRotation();
				_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
				_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
			}
			transform.setOrigin(_ammoVec1$1);
			transform.setRotation(_ammoQuat$1);
		};
		_proto.updateTransform = function updateTransform() {
			this._getEntityTransform(_ammoTransform$1);
			var body = this.body;
			body.setWorldTransform(_ammoTransform$1);
			body.activate();
		};
		_proto.enable = function enable() {
			var body = this.body;
			if (!body) return;
			var system = this.app.systems.rigidbody;
			var idx = system._triggers.indexOf(this);
			if (idx < 0) {
				system.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);
				system._triggers.push(this);
			}
			body.forceActivationState(BODYSTATE_ACTIVE_TAG);
			this.updateTransform();
		};
		_proto.disable = function disable() {
			var body = this.body;
			if (!body) return;
			var system = this.app.systems.rigidbody;
			var idx = system._triggers.indexOf(this);
			if (idx > -1) {
				system.removeBody(body);
				system._triggers.splice(idx, 1);
			}
			body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
		};
		return Trigger;
	}();

	var mat4 = new Mat4();
	var p1 = new Vec3();
	var p2 = new Vec3();
	var quat$1 = new Quat();
	var tempGraphNode = new GraphNode();
	var _schema$g = ['enabled', 'type', 'halfExtents', 'linearOffset', 'angularOffset', 'radius', 'axis', 'height', 'convexHull', 'asset', 'renderAsset', 'shape', 'model', 'render', 'checkVertexDuplicates'];
	var CollisionSystemImpl = function () {
		function CollisionSystemImpl(system) {
			this.system = system;
		}
		var _proto = CollisionSystemImpl.prototype;
		_proto.beforeInitialize = function beforeInitialize(component, data) {
			data.shape = null;
			data.model = new Model();
			data.model.graph = new GraphNode();
		};
		_proto.afterInitialize = function afterInitialize(component, data) {
			this.recreatePhysicalShapes(component);
			component.data.initialized = true;
		};
		_proto.reset = function reset(component, data) {
			this.beforeInitialize(component, data);
			this.afterInitialize(component, data);
		};
		_proto.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			var entity = component.entity;
			var data = component.data;
			if (typeof Ammo !== 'undefined') {
				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}
				if (data.shape) {
					if (component._compoundParent) {
						if (component !== component._compoundParent) {
							this.system._removeCompoundChild(component._compoundParent, data.shape);
						}
						if (component._compoundParent.entity.rigidbody) {
							component._compoundParent.entity.rigidbody.activate();
						}
					}
					this.destroyShape(data);
				}
				data.shape = this.createPhysicalShape(component.entity, data);
				var firstCompoundChild = !component._compoundParent;
				if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
					component._compoundParent = component;
					entity.forEach(this._addEachDescendant, component);
				} else if (data.type !== 'compound') {
					if (!component.rigidbody) {
						component._compoundParent = null;
						var parent = entity.parent;
						while (parent) {
							if (parent.collision && parent.collision.type === 'compound') {
								component._compoundParent = parent.collision;
								break;
							}
							parent = parent.parent;
						}
					}
				}
				if (component._compoundParent) {
					if (component !== component._compoundParent) {
						if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
							this.system.recreatePhysicalShapes(component._compoundParent);
						} else {
							this.system.updateCompoundChildTransform(entity, true);
							if (component._compoundParent.entity.rigidbody) {
								component._compoundParent.entity.rigidbody.activate();
							}
						}
					}
				}
				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();
					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else if (!component._compoundParent) {
					if (!entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			}
		};
		_proto.createPhysicalShape = function createPhysicalShape(entity, data) {
			return undefined;
		};
		_proto.updateTransform = function updateTransform(component, position, rotation, scale) {
			if (component.entity.trigger) {
				component.entity.trigger.updateTransform();
			}
		};
		_proto.destroyShape = function destroyShape(data) {
			if (data.shape) {
				Ammo.destroy(data.shape);
				data.shape = null;
			}
		};
		_proto.beforeRemove = function beforeRemove(entity, component) {
			if (component.data.shape) {
				if (component._compoundParent && !component._compoundParent.entity._destroying) {
					this.system._removeCompoundChild(component._compoundParent, component.data.shape);
					if (component._compoundParent.entity.rigidbody) {
						component._compoundParent.entity.rigidbody.activate();
					}
				}
				component._compoundParent = null;
				this.destroyShape(component.data);
			}
		};
		_proto.remove = function remove(entity, data) {
			if (entity.rigidbody && entity.rigidbody.body) {
				entity.rigidbody.disableSimulation();
			}
			if (entity.trigger) {
				entity.trigger.destroy();
				delete entity.trigger;
			}
		};
		_proto.clone = function clone(entity, _clone) {
			var src = this.system.store[entity.getGuid()];
			var data = {
				enabled: src.data.enabled,
				type: src.data.type,
				halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
				linearOffset: [src.data.linearOffset.x, src.data.linearOffset.y, src.data.linearOffset.z],
				angularOffset: [src.data.angularOffset.x, src.data.angularOffset.y, src.data.angularOffset.z, src.data.angularOffset.w],
				radius: src.data.radius,
				axis: src.data.axis,
				height: src.data.height,
				convexHull: src.data.convexHull,
				asset: src.data.asset,
				renderAsset: src.data.renderAsset,
				model: src.data.model,
				render: src.data.render,
				checkVertexDuplicates: src.data.checkVertexDuplicates
			};
			return this.system.addComponent(_clone, data);
		};
		return CollisionSystemImpl;
	}();
	var CollisionBoxSystemImpl = function (_CollisionSystemImpl) {
		function CollisionBoxSystemImpl() {
			return _CollisionSystemImpl.apply(this, arguments) || this;
		}
		_inheritsLoose(CollisionBoxSystemImpl, _CollisionSystemImpl);
		var _proto2 = CollisionBoxSystemImpl.prototype;
		_proto2.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				var he = data.halfExtents;
				var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
				var shape = new Ammo.btBoxShape(ammoHe);
				Ammo.destroy(ammoHe);
				return shape;
			}
			return undefined;
		};
		return CollisionBoxSystemImpl;
	}(CollisionSystemImpl);
	var CollisionSphereSystemImpl = function (_CollisionSystemImpl2) {
		function CollisionSphereSystemImpl() {
			return _CollisionSystemImpl2.apply(this, arguments) || this;
		}
		_inheritsLoose(CollisionSphereSystemImpl, _CollisionSystemImpl2);
		var _proto3 = CollisionSphereSystemImpl.prototype;
		_proto3.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btSphereShape(data.radius);
			}
			return undefined;
		};
		return CollisionSphereSystemImpl;
	}(CollisionSystemImpl);
	var CollisionCapsuleSystemImpl = function (_CollisionSystemImpl3) {
		function CollisionCapsuleSystemImpl() {
			return _CollisionSystemImpl3.apply(this, arguments) || this;
		}
		_inheritsLoose(CollisionCapsuleSystemImpl, _CollisionSystemImpl3);
		var _proto4 = CollisionCapsuleSystemImpl.prototype;
		_proto4.createPhysicalShape = function createPhysicalShape(entity, data) {
			var _data$axis, _data$radius, _data$height;
			var axis = (_data$axis = data.axis) != null ? _data$axis : 1;
			var radius = (_data$radius = data.radius) != null ? _data$radius : 0.5;
			var height = Math.max(((_data$height = data.height) != null ? _data$height : 2) - 2 * radius, 0);
			var shape = null;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btCapsuleShapeX(radius, height);
						break;
					case 1:
						shape = new Ammo.btCapsuleShape(radius, height);
						break;
					case 2:
						shape = new Ammo.btCapsuleShapeZ(radius, height);
						break;
				}
			}
			return shape;
		};
		return CollisionCapsuleSystemImpl;
	}(CollisionSystemImpl);
	var CollisionCylinderSystemImpl = function (_CollisionSystemImpl4) {
		function CollisionCylinderSystemImpl() {
			return _CollisionSystemImpl4.apply(this, arguments) || this;
		}
		_inheritsLoose(CollisionCylinderSystemImpl, _CollisionSystemImpl4);
		var _proto5 = CollisionCylinderSystemImpl.prototype;
		_proto5.createPhysicalShape = function createPhysicalShape(entity, data) {
			var _data$axis2, _data$radius2, _data$height2;
			var axis = (_data$axis2 = data.axis) != null ? _data$axis2 : 1;
			var radius = (_data$radius2 = data.radius) != null ? _data$radius2 : 0.5;
			var height = (_data$height2 = data.height) != null ? _data$height2 : 1;
			var halfExtents = null;
			var shape = null;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
						shape = new Ammo.btCylinderShapeX(halfExtents);
						break;
					case 1:
						halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
						shape = new Ammo.btCylinderShape(halfExtents);
						break;
					case 2:
						halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
						shape = new Ammo.btCylinderShapeZ(halfExtents);
						break;
				}
			}
			if (halfExtents) {
				Ammo.destroy(halfExtents);
			}
			return shape;
		};
		return CollisionCylinderSystemImpl;
	}(CollisionSystemImpl);
	var CollisionConeSystemImpl = function (_CollisionSystemImpl5) {
		function CollisionConeSystemImpl() {
			return _CollisionSystemImpl5.apply(this, arguments) || this;
		}
		_inheritsLoose(CollisionConeSystemImpl, _CollisionSystemImpl5);
		var _proto6 = CollisionConeSystemImpl.prototype;
		_proto6.createPhysicalShape = function createPhysicalShape(entity, data) {
			var _data$axis3, _data$radius3, _data$height3;
			var axis = (_data$axis3 = data.axis) != null ? _data$axis3 : 1;
			var radius = (_data$radius3 = data.radius) != null ? _data$radius3 : 0.5;
			var height = (_data$height3 = data.height) != null ? _data$height3 : 1;
			var shape = null;
			if (typeof Ammo !== 'undefined') {
				switch (axis) {
					case 0:
						shape = new Ammo.btConeShapeX(radius, height);
						break;
					case 1:
						shape = new Ammo.btConeShape(radius, height);
						break;
					case 2:
						shape = new Ammo.btConeShapeZ(radius, height);
						break;
				}
			}
			return shape;
		};
		return CollisionConeSystemImpl;
	}(CollisionSystemImpl);
	var CollisionMeshSystemImpl = function (_CollisionSystemImpl6) {
		function CollisionMeshSystemImpl() {
			return _CollisionSystemImpl6.apply(this, arguments) || this;
		}
		_inheritsLoose(CollisionMeshSystemImpl, _CollisionSystemImpl6);
		var _proto7 = CollisionMeshSystemImpl.prototype;
		_proto7.beforeInitialize = function beforeInitialize(component, data) {};
		_proto7.createAmmoHull = function createAmmoHull(mesh, node, shape, scale) {
			var hull = new Ammo.btConvexHullShape();
			var point = new Ammo.btVector3();
			var positions = [];
			mesh.getPositions(positions);
			for (var i = 0; i < positions.length; i += 3) {
				point.setValue(positions[i] * scale.x, positions[i + 1] * scale.y, positions[i + 2] * scale.z);
				hull.addPoint(point, false);
			}
			Ammo.destroy(point);
			hull.recalcLocalAabb();
			hull.setMargin(0.01);
			var transform = this.system._getNodeTransform(node);
			shape.addChildShape(transform, hull);
			Ammo.destroy(transform);
		};
		_proto7.createAmmoMesh = function createAmmoMesh(mesh, node, shape, scale, checkDupes) {
			if (checkDupes === void 0) {
				checkDupes = true;
			}
			var system = this.system;
			var triMesh;
			if (system._triMeshCache[mesh.id]) {
				triMesh = system._triMeshCache[mesh.id];
			} else {
				var vb = mesh.vertexBuffer;
				var format = vb.getFormat();
				var stride, positions;
				for (var i = 0; i < format.elements.length; i++) {
					var element = format.elements[i];
					if (element.name === SEMANTIC_POSITION) {
						positions = new Float32Array(vb.lock(), element.offset);
						stride = element.stride / 4;
						break;
					}
				}
				var indices = [];
				mesh.getIndices(indices);
				var numTriangles = mesh.primitive[0].count / 3;
				var v1 = new Ammo.btVector3();
				var i1, i2, i3;
				var base = mesh.primitive[0].base;
				triMesh = new Ammo.btTriangleMesh();
				system._triMeshCache[mesh.id] = triMesh;
				var vertexCache = new Map();
				var indexedArray = triMesh.getIndexedMeshArray();
				indexedArray.at(0).m_numTriangles = numTriangles;
				var sx = scale ? scale.x : 1;
				var sy = scale ? scale.y : 1;
				var sz = scale ? scale.z : 1;
				var addVertex = function addVertex(index) {
					var x = positions[index * stride] * sx;
					var y = positions[index * stride + 1] * sy;
					var z = positions[index * stride + 2] * sz;
					var idx;
					if (checkDupes) {
						var str = x + ":" + y + ":" + z;
						idx = vertexCache.get(str);
						if (idx !== undefined) {
							return idx;
						}
						v1.setValue(x, y, z);
						idx = triMesh.findOrAddVertex(v1, false);
						vertexCache.set(str, idx);
					} else {
						v1.setValue(x, y, z);
						idx = triMesh.findOrAddVertex(v1, false);
					}
					return idx;
				};
				for (var _i = 0; _i < numTriangles; _i++) {
					i1 = addVertex(indices[base + _i * 3]);
					i2 = addVertex(indices[base + _i * 3 + 1]);
					i3 = addVertex(indices[base + _i * 3 + 2]);
					triMesh.addIndex(i1);
					triMesh.addIndex(i2);
					triMesh.addIndex(i3);
				}
				Ammo.destroy(v1);
			}
			var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, true);
			if (!scale) {
				var scaling = system._getNodeScaling(node);
				triMeshShape.setLocalScaling(scaling);
				Ammo.destroy(scaling);
			}
			var transform = system._getNodeTransform(node);
			shape.addChildShape(transform, triMeshShape);
			Ammo.destroy(transform);
		};
		_proto7.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo === 'undefined') return undefined;
			if (data.model || data.render) {
				var shape = new Ammo.btCompoundShape();
				var entityTransform = entity.getWorldTransform();
				var scale = entityTransform.getScale();
				if (data.render) {
					var meshes = data.render.meshes;
					for (var i = 0; i < meshes.length; i++) {
						if (data.convexHull) {
							this.createAmmoHull(meshes[i], tempGraphNode, shape, scale);
						} else {
							this.createAmmoMesh(meshes[i], tempGraphNode, shape, scale, data.checkVertexDuplicates);
						}
					}
				} else if (data.model) {
					var meshInstances = data.model.meshInstances;
					for (var _i2 = 0; _i2 < meshInstances.length; _i2++) {
						this.createAmmoMesh(meshInstances[_i2].mesh, meshInstances[_i2].node, shape, null, data.checkVertexDuplicates);
					}
					var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
					shape.setLocalScaling(vec);
					Ammo.destroy(vec);
				}
				return shape;
			}
			return undefined;
		};
		_proto7.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			var data = component.data;
			if (data.renderAsset || data.asset) {
				if (component.enabled && component.entity.enabled) {
					this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
					return;
				}
			}
			this.doRecreatePhysicalShape(component);
		};
		_proto7.loadAsset = function loadAsset(component, id, property) {
			var _this = this;
			var data = component.data;
			var assets = this.system.app.assets;
			var previousPropertyValue = data[property];
			var onAssetFullyReady = function onAssetFullyReady(asset) {
				if (data[property] !== previousPropertyValue) {
					return;
				}
				data[property] = asset.resource;
				_this.doRecreatePhysicalShape(component);
			};
			var loadAndHandleAsset = function loadAndHandleAsset(asset) {
				asset.ready(function (asset) {
					if (asset.data.containerAsset) {
						var containerAsset = assets.get(asset.data.containerAsset);
						if (containerAsset.loaded) {
							onAssetFullyReady(asset);
						} else {
							containerAsset.ready(function () {
								onAssetFullyReady(asset);
							});
							assets.load(containerAsset);
						}
					} else {
						onAssetFullyReady(asset);
					}
				});
				assets.load(asset);
			};
			var asset = assets.get(id);
			if (asset) {
				loadAndHandleAsset(asset);
			} else {
				assets.once("add:" + id, loadAndHandleAsset);
			}
		};
		_proto7.doRecreatePhysicalShape = function doRecreatePhysicalShape(component) {
			var entity = component.entity;
			var data = component.data;
			if (data.model || data.render) {
				this.destroyShape(data);
				data.shape = this.createPhysicalShape(entity, data);
				if (entity.rigidbody) {
					entity.rigidbody.disableSimulation();
					entity.rigidbody.createBody();
					if (entity.enabled && entity.rigidbody.enabled) {
						entity.rigidbody.enableSimulation();
					}
				} else {
					if (!entity.trigger) {
						entity.trigger = new Trigger(this.system.app, component, data);
					} else {
						entity.trigger.initialize(data);
					}
				}
			} else {
				this.beforeRemove(entity, component);
				this.remove(entity, data);
			}
		};
		_proto7.updateTransform = function updateTransform(component, position, rotation, scale) {
			if (component.shape) {
				var entityTransform = component.entity.getWorldTransform();
				var worldScale = entityTransform.getScale();
				var previousScale = component.shape.getLocalScaling();
				if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
					this.doRecreatePhysicalShape(component);
				}
			}
			_CollisionSystemImpl6.prototype.updateTransform.call(this, component, position, rotation, scale);
		};
		_proto7.destroyShape = function destroyShape(data) {
			if (!data.shape) {
				return;
			}
			var numShapes = data.shape.getNumChildShapes();
			for (var i = 0; i < numShapes; i++) {
				var shape = data.shape.getChildShape(i);
				Ammo.destroy(shape);
			}
			Ammo.destroy(data.shape);
			data.shape = null;
		};
		return CollisionMeshSystemImpl;
	}(CollisionSystemImpl);
	var CollisionCompoundSystemImpl = function (_CollisionSystemImpl7) {
		function CollisionCompoundSystemImpl() {
			return _CollisionSystemImpl7.apply(this, arguments) || this;
		}
		_inheritsLoose(CollisionCompoundSystemImpl, _CollisionSystemImpl7);
		var _proto8 = CollisionCompoundSystemImpl.prototype;
		_proto8.createPhysicalShape = function createPhysicalShape(entity, data) {
			if (typeof Ammo !== 'undefined') {
				return new Ammo.btCompoundShape();
			}
			return undefined;
		};
		_proto8._addEachDescendant = function _addEachDescendant(entity) {
			if (!entity.collision || entity.rigidbody) {
				return;
			}
			entity.collision._compoundParent = this;
			if (entity !== this.entity) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		};
		_proto8._updateEachDescendant = function _updateEachDescendant(entity) {
			if (!entity.collision) {
				return;
			}
			if (entity.collision._compoundParent !== this) {
				return;
			}
			entity.collision._compoundParent = null;
			if (entity !== this.entity && !entity.rigidbody) {
				entity.collision.system.recreatePhysicalShapes(entity.collision);
			}
		};
		_proto8._updateEachDescendantTransform = function _updateEachDescendantTransform(entity) {
			if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) {
				return;
			}
			this.collision.system.updateCompoundChildTransform(entity, false);
		};
		return CollisionCompoundSystemImpl;
	}(CollisionSystemImpl);
	var CollisionComponentSystem = function (_ComponentSystem) {
		function CollisionComponentSystem(app) {
			var _this2;
			_this2 = _ComponentSystem.call(this, app) || this;
			_this2.id = 'collision';
			_this2.ComponentType = CollisionComponent;
			_this2.DataType = CollisionComponentData;
			_this2.schema = _schema$g;
			_this2.implementations = {};
			_this2._triMeshCache = {};
			_this2.on('beforeremove', _this2.onBeforeRemove, _this2);
			_this2.on('remove', _this2.onRemove, _this2);
			return _this2;
		}
		_inheritsLoose(CollisionComponentSystem, _ComponentSystem);
		var _proto9 = CollisionComponentSystem.prototype;
		_proto9.initializeComponentData = function initializeComponentData(component, _data, properties) {
			properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'convexHull', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled', 'linearOffset', 'angularOffset', 'checkVertexDuplicates'];
			var data = {};
			for (var i = 0, len = properties.length; i < len; i++) {
				var property = properties[i];
				data[property] = _data[property];
			}
			var idx;
			if (_data.hasOwnProperty('asset')) {
				idx = properties.indexOf('model');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
				idx = properties.indexOf('render');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			} else if (_data.hasOwnProperty('model')) {
				idx = properties.indexOf('asset');
				if (idx !== -1) {
					properties.splice(idx, 1);
				}
			}
			if (!data.type) {
				data.type = component.data.type;
			}
			component.data.type = data.type;
			if (Array.isArray(data.halfExtents)) {
				data.halfExtents = new Vec3(data.halfExtents);
			}
			if (Array.isArray(data.linearOffset)) {
				data.linearOffset = new Vec3(data.linearOffset);
			}
			if (Array.isArray(data.angularOffset)) {
				var values = data.angularOffset;
				if (values.length === 3) {
					data.angularOffset = new Quat().setFromEulerAngles(values[0], values[1], values[2]);
				} else {
					data.angularOffset = new Quat(data.angularOffset);
				}
			}
			var impl = this._createImplementation(data.type);
			impl.beforeInitialize(component, data);
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			impl.afterInitialize(component, data);
		};
		_proto9._createImplementation = function _createImplementation(type) {
			if (this.implementations[type] === undefined) {
				var impl;
				switch (type) {
					case 'box':
						impl = new CollisionBoxSystemImpl(this);
						break;
					case 'sphere':
						impl = new CollisionSphereSystemImpl(this);
						break;
					case 'capsule':
						impl = new CollisionCapsuleSystemImpl(this);
						break;
					case 'cylinder':
						impl = new CollisionCylinderSystemImpl(this);
						break;
					case 'cone':
						impl = new CollisionConeSystemImpl(this);
						break;
					case 'mesh':
						impl = new CollisionMeshSystemImpl(this);
						break;
					case 'compound':
						impl = new CollisionCompoundSystemImpl(this);
						break;
				}
				this.implementations[type] = impl;
			}
			return this.implementations[type];
		};
		_proto9._getImplementation = function _getImplementation(entity) {
			return this.implementations[entity.collision.data.type];
		};
		_proto9.cloneComponent = function cloneComponent(entity, clone) {
			return this._getImplementation(entity).clone(entity, clone);
		};
		_proto9.onBeforeRemove = function onBeforeRemove(entity, component) {
			this.implementations[component.data.type].beforeRemove(entity, component);
			component.onBeforeRemove();
		};
		_proto9.onRemove = function onRemove(entity, data) {
			this.implementations[data.type].remove(entity, data);
		};
		_proto9.updateCompoundChildTransform = function updateCompoundChildTransform(entity, forceUpdate) {
			var parentComponent = entity.collision._compoundParent;
			if (parentComponent === entity.collision) return;
			if (entity.enabled && entity.collision.enabled && (entity._dirtyLocal || forceUpdate)) {
				var transform = this._getNodeTransform(entity, parentComponent.entity);
				var idx = parentComponent.getCompoundChildShapeIndex(entity.collision.shape);
				if (idx === null) {
					parentComponent.shape.addChildShape(transform, entity.collision.data.shape);
				} else {
					parentComponent.shape.updateChildTransform(idx, transform, true);
				}
				Ammo.destroy(transform);
			}
		};
		_proto9._removeCompoundChild = function _removeCompoundChild(collision, shape) {
			if (collision.shape.getNumChildShapes() === 0) {
				return;
			}
			if (collision.shape.removeChildShape) {
				collision.shape.removeChildShape(shape);
			} else {
				var ind = collision.getCompoundChildShapeIndex(shape);
				if (ind !== null) {
					collision.shape.removeChildShapeByIndex(ind);
				}
			}
		};
		_proto9.onTransformChanged = function onTransformChanged(component, position, rotation, scale) {
			this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
		};
		_proto9.changeType = function changeType(component, previousType, newType) {
			this.implementations[previousType].beforeRemove(component.entity, component);
			this.implementations[previousType].remove(component.entity, component.data);
			this._createImplementation(newType).reset(component, component.data);
		};
		_proto9.recreatePhysicalShapes = function recreatePhysicalShapes(component) {
			this.implementations[component.data.type].recreatePhysicalShapes(component);
		};
		_proto9._calculateNodeRelativeTransform = function _calculateNodeRelativeTransform(node, relative) {
			if (node === relative) {
				var scale = node.getWorldTransform().getScale();
				mat4.setScale(scale.x, scale.y, scale.z);
			} else {
				this._calculateNodeRelativeTransform(node.parent, relative);
				mat4.mul(node.getLocalTransform());
			}
		};
		_proto9._getNodeScaling = function _getNodeScaling(node) {
			var wtm = node.getWorldTransform();
			var scl = wtm.getScale();
			return new Ammo.btVector3(scl.x, scl.y, scl.z);
		};
		_proto9._getNodeTransform = function _getNodeTransform(node, relative) {
			var pos, rot;
			if (relative) {
				this._calculateNodeRelativeTransform(node, relative);
				pos = p1;
				rot = quat$1;
				mat4.getTranslation(pos);
				rot.setFromMat4(mat4);
			} else {
				pos = node.getPosition();
				rot = node.getRotation();
			}
			var ammoQuat = new Ammo.btQuaternion();
			var transform = new Ammo.btTransform();
			transform.setIdentity();
			var origin = transform.getOrigin();
			var component = node.collision;
			if (component && component._hasOffset) {
				var lo = component.data.linearOffset;
				var ao = component.data.angularOffset;
				var newOrigin = p2;
				quat$1.copy(rot).transformVector(lo, newOrigin);
				newOrigin.add(pos);
				quat$1.copy(rot).mul(ao);
				origin.setValue(newOrigin.x, newOrigin.y, newOrigin.z);
				ammoQuat.setValue(quat$1.x, quat$1.y, quat$1.z, quat$1.w);
			} else {
				origin.setValue(pos.x, pos.y, pos.z);
				ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			}
			transform.setRotation(ammoQuat);
			Ammo.destroy(ammoQuat);
			return transform;
		};
		_proto9.destroy = function destroy() {
			for (var key in this._triMeshCache) {
				Ammo.destroy(this._triMeshCache[key]);
			}
			this._triMeshCache = null;
			_ComponentSystem.prototype.destroy.call(this);
		};
		return CollisionComponentSystem;
	}(ComponentSystem);

	var _tempColor$2 = new Color();
	var _vertexFormatDeviceCache = new DeviceCache();
	var ImageRenderable = function () {
		function ImageRenderable(entity, mesh, material) {
			this._entity = entity;
			this._element = entity.element;
			this.model = new Model();
			this.node = new GraphNode();
			this.model.graph = this.node;
			this.mesh = mesh;
			this.meshInstance = new MeshInstance(this.mesh, material, this.node);
			this.meshInstance.name = "ImageElement: " + entity.name;
			this.meshInstance.castShadow = false;
			this.meshInstance.receiveShadow = false;
			this._meshDirty = false;
			this.model.meshInstances.push(this.meshInstance);
			this._entity.addChild(this.model.graph);
			this.model._entity = this._entity;
			this.unmaskMeshInstance = null;
		}
		var _proto = ImageRenderable.prototype;
		_proto.destroy = function destroy() {
			this.setMaterial(null);
			this._element.removeModelFromLayers(this.model);
			this.model.destroy();
			this.model = null;
			this.node = null;
			this.mesh = null;
			this.meshInstance = null;
			this._entity = null;
			this._element = null;
		};
		_proto.setMesh = function setMesh(mesh) {
			if (!this.meshInstance) return;
			this.mesh = mesh;
			this.meshInstance.mesh = mesh;
			this.meshInstance.visible = !!mesh;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.mesh = mesh;
			}
			this.forceUpdateAabb();
		};
		_proto.setMask = function setMask(mask) {
			if (!this.meshInstance) return;
			if (mask) {
				this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
				this.unmaskMeshInstance.name = "Unmask: " + this._entity.name;
				this.unmaskMeshInstance.castShadow = false;
				this.unmaskMeshInstance.receiveShadow = false;
				this.unmaskMeshInstance.pick = false;
				this.model.meshInstances.push(this.unmaskMeshInstance);
				for (var name in this.meshInstance.parameters) {
					this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
				}
			} else {
				var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
				if (idx >= 0) {
					this.model.meshInstances.splice(idx, 1);
				}
				this.unmaskMeshInstance = null;
			}
			if (this._entity.enabled && this._element.enabled) {
				this._element.removeModelFromLayers(this.model);
				this._element.addModelToLayers(this.model);
			}
		};
		_proto.setMaterial = function setMaterial(material) {
			if (!this.meshInstance) return;
			this.meshInstance.material = material;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.material = material;
			}
		};
		_proto.setParameter = function setParameter(name, value) {
			if (!this.meshInstance) return;
			this.meshInstance.setParameter(name, value);
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.setParameter(name, value);
			}
		};
		_proto.deleteParameter = function deleteParameter(name) {
			if (!this.meshInstance) return;
			this.meshInstance.deleteParameter(name);
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.deleteParameter(name);
			}
		};
		_proto.setUnmaskDrawOrder = function setUnmaskDrawOrder() {
			if (!this.meshInstance) return;
			var _getLastChild = function getLastChild(e) {
				var last;
				var c = e.children;
				var l = c.length;
				if (l) {
					for (var i = 0; i < l; i++) {
						if (c[i].element) {
							last = c[i];
						}
					}
					if (!last) return null;
					var child = _getLastChild(last);
					if (child) {
						return child;
					}
					return last;
				}
				return null;
			};
			if (this.unmaskMeshInstance) {
				var lastChild = _getLastChild(this._entity);
				if (lastChild && lastChild.element) {
					this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
				} else {
					this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
				}
			}
		};
		_proto.setDrawOrder = function setDrawOrder(drawOrder) {
			if (!this.meshInstance) {
				return;
			}
			this.meshInstance.drawOrder = drawOrder;
		};
		_proto.setCull = function setCull(cull) {
			if (!this.meshInstance) return;
			var element = this._element;
			var visibleFn = null;
			if (cull && element._isScreenSpace()) {
				visibleFn = function visibleFn(camera) {
					return element.isVisibleForCamera(camera);
				};
			}
			this.meshInstance.cull = cull;
			this.meshInstance.isVisibleFunc = visibleFn;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.cull = cull;
				this.unmaskMeshInstance.isVisibleFunc = visibleFn;
			}
		};
		_proto.setScreenSpace = function setScreenSpace(screenSpace) {
			if (!this.meshInstance) return;
			this.meshInstance.screenSpace = screenSpace;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.screenSpace = screenSpace;
			}
		};
		_proto.setLayer = function setLayer(layer) {
			if (!this.meshInstance) return;
			this.meshInstance.layer = layer;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance.layer = layer;
			}
		};
		_proto.forceUpdateAabb = function forceUpdateAabb(mask) {
			if (!this.meshInstance) return;
			this.meshInstance._aabbVer = -1;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance._aabbVer = -1;
			}
		};
		_proto.setAabbFunc = function setAabbFunc(fn) {
			if (!this.meshInstance) return;
			this.meshInstance._updateAabbFunc = fn;
			if (this.unmaskMeshInstance) {
				this.unmaskMeshInstance._updateAabbFunc = fn;
			}
		};
		return ImageRenderable;
	}();
	var ImageElement = function () {
		function ImageElement(element) {
			this._evtSetMeshes = null;
			this._element = element;
			this._entity = element.entity;
			this._system = element.system;
			this._textureAsset = null;
			this._texture = null;
			this._materialAsset = null;
			this._material = null;
			this._spriteAsset = null;
			this._sprite = null;
			this._spriteFrame = 0;
			this._pixelsPerUnit = null;
			this._targetAspectRatio = -1;
			this._rect = new Vec4(0, 0, 1, 1);
			this._mask = false;
			this._maskRef = 0;
			this._outerScale = new Vec2();
			this._outerScaleUniform = new Float32Array(2);
			this._innerOffset = new Vec4();
			this._innerOffsetUniform = new Float32Array(4);
			this._atlasRect = new Vec4();
			this._atlasRectUniform = new Float32Array(4);
			this._defaultMesh = this._createMesh();
			this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
			this._color = new Color(1, 1, 1, 1);
			this._colorUniform = new Float32Array([1, 1, 1]);
			this._updateRenderableEmissive();
			this._renderable.setParameter('material_opacity', 1);
			this._updateAabbFunc = this._updateAabb.bind(this);
			this._onScreenChange(this._element.screen);
			this._element.on('resize', this._onParentResizeOrPivotChange, this);
			this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);
			this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.on('set:screen', this._onScreenChange, this);
			this._element.on('set:draworder', this._onDrawOrderChange, this);
			this._element.on('screen:set:resolution', this._onResolutionChange, this);
		}
		var _proto2 = ImageElement.prototype;
		_proto2.destroy = function destroy() {
			this.textureAsset = null;
			this.spriteAsset = null;
			this.materialAsset = null;
			this._renderable.setMesh(this._defaultMesh);
			this._renderable.destroy();
			this._defaultMesh = null;
			this._element.off('resize', this._onParentResizeOrPivotChange, this);
			this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);
			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.off('set:screen', this._onScreenChange, this);
			this._element.off('set:draworder', this._onDrawOrderChange, this);
			this._element.off('screen:set:resolution', this._onResolutionChange, this);
		};
		_proto2._onResolutionChange = function _onResolutionChange(res) {};
		_proto2._onParentResizeOrPivotChange = function _onParentResizeOrPivotChange() {
			if (this._renderable.mesh) {
				this._updateMesh(this._renderable.mesh);
			}
		};
		_proto2._onScreenSpaceChange = function _onScreenSpaceChange(value) {
			this._updateMaterial(value);
		};
		_proto2._onScreenChange = function _onScreenChange(screen, previous) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		};
		_proto2._onDrawOrderChange = function _onDrawOrderChange(order) {
			this._renderable.setDrawOrder(order);
			if (this.mask && this._element.screen) {
				this._element.screen.screen.once('syncdraworder', function () {
					this._renderable.setUnmaskDrawOrder();
				}, this);
			}
		};
		_proto2._hasUserMaterial = function _hasUserMaterial() {
			return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
		};
		_proto2._use9Slicing = function _use9Slicing() {
			return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
		};
		_proto2._updateMaterial = function _updateMaterial(screenSpace) {
			var mask = !!this._mask;
			var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
			var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
			if (!this._hasUserMaterial()) {
				this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
			}
			if (this._renderable) {
				this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());
				this._renderable.setMaterial(this._material);
				this._renderable.setScreenSpace(screenSpace);
				this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
			}
		};
		_proto2._createMesh = function _createMesh() {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;
			var r = this._rect;
			var device = this._system.app.graphicsDevice;
			var vertexData = new Float32Array([w, 0, 0, 0, 0, 1, r.x + r.z, 1.0 - r.y, w, h, 0, 0, 0, 1, r.x + r.z, 1.0 - (r.y + r.w), 0, 0, 0, 0, 0, 1, r.x, 1.0 - r.y, 0, h, 0, 0, 0, 1, r.x, 1.0 - (r.y + r.w)]);
			var vertexFormat = _vertexFormatDeviceCache.get(device, function () {
				return new VertexFormat(device, [{
					semantic: SEMANTIC_POSITION,
					components: 3,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_NORMAL,
					components: 3,
					type: TYPE_FLOAT32
				}, {
					semantic: SEMANTIC_TEXCOORD0,
					components: 2,
					type: TYPE_FLOAT32
				}]);
			});
			var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, {
				data: vertexData.buffer
			});
			var mesh = new Mesh(device);
			mesh.vertexBuffer = vertexBuffer;
			mesh.primitive[0].type = PRIMITIVE_TRISTRIP;
			mesh.primitive[0].base = 0;
			mesh.primitive[0].count = 4;
			mesh.primitive[0].indexed = false;
			mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));
			this._updateMesh(mesh);
			return mesh;
		};
		_proto2._updateMesh = function _updateMesh(mesh) {
			var element = this._element;
			var w = element.calculatedWidth;
			var h = element.calculatedHeight;
			if (element.fitMode !== FITMODE_STRETCH && this._targetAspectRatio > 0) {
				var actualRatio = element.calculatedWidth / element.calculatedHeight;
				if (element.fitMode === FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === FITMODE_COVER && actualRatio < this._targetAspectRatio) {
					w = element.calculatedHeight * this._targetAspectRatio;
				} else {
					h = element.calculatedWidth / this._targetAspectRatio;
				}
			}
			var screenSpace = element._isScreenSpace();
			this._updateMaterial(screenSpace);
			if (this._renderable) this._renderable.forceUpdateAabb();
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
				var borderWidthScale = 2 / frameData.rect.z;
				var borderHeightScale = 2 / frameData.rect.w;
				this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
				var tex = this.sprite.atlas.texture;
				this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
				var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
				var scaleMulX = frameData.rect.z / ppu;
				var scaleMulY = frameData.rect.w / ppu;
				this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));
				var scaleX = scaleMulX;
				var scaleY = scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);
				if (this._renderable) {
					this._innerOffsetUniform[0] = this._innerOffset.x;
					this._innerOffsetUniform[1] = this._innerOffset.y;
					this._innerOffsetUniform[2] = this._innerOffset.z;
					this._innerOffsetUniform[3] = this._innerOffset.w;
					this._renderable.setParameter('innerOffset', this._innerOffsetUniform);
					this._atlasRectUniform[0] = this._atlasRect.x;
					this._atlasRectUniform[1] = this._atlasRect.y;
					this._atlasRectUniform[2] = this._atlasRect.z;
					this._atlasRectUniform[3] = this._atlasRect.w;
					this._renderable.setParameter('atlasRect', this._atlasRectUniform);
					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;
					this._renderable.setParameter('outerScale', this._outerScaleUniform);
					this._renderable.setAabbFunc(this._updateAabbFunc);
					this._renderable.node.setLocalScale(scaleX, scaleY, 1);
					this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
				}
			} else {
				var vb = mesh.vertexBuffer;
				var vertexDataF32 = new Float32Array(vb.lock());
				var hp = element.pivot.x;
				var vp = element.pivot.y;
				vertexDataF32[0] = w - hp * w;
				vertexDataF32[1] = 0 - vp * h;
				vertexDataF32[8] = w - hp * w;
				vertexDataF32[9] = h - vp * h;
				vertexDataF32[16] = 0 - hp * w;
				vertexDataF32[17] = 0 - vp * h;
				vertexDataF32[24] = 0 - hp * w;
				vertexDataF32[25] = h - vp * h;
				var atlasTextureWidth = 1;
				var atlasTextureHeight = 1;
				var rect = this._rect;
				if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
					var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
					if (frame) {
						rect = frame.rect;
						atlasTextureWidth = this._sprite.atlas.texture.width;
						atlasTextureHeight = this._sprite.atlas.texture.height;
					}
				}
				vertexDataF32[6] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
				vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
				vertexDataF32[15] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
				vertexDataF32[22] = rect.x / atlasTextureWidth;
				vertexDataF32[23] = 1.0 - rect.y / atlasTextureHeight;
				vertexDataF32[30] = rect.x / atlasTextureWidth;
				vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
				vb.unlock();
				var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
				var max = new Vec3(w - hp * w, h - vp * h, 0);
				mesh.aabb.setMinMax(min, max);
				if (this._renderable) {
					this._renderable.node.setLocalScale(1, 1, 1);
					this._renderable.node.setLocalPosition(0, 0, 0);
					this._renderable.setAabbFunc(null);
				}
			}
			this._meshDirty = false;
		};
		_proto2._updateSprite = function _updateSprite() {
			var nineSlice = false;
			var mesh = null;
			this._targetAspectRatio = -1;
			if (this._sprite && this._sprite.atlas) {
				mesh = this._sprite.meshes[this.spriteFrame];
				nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
				var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
				if ((frameData == null ? void 0 : frameData.rect.w) > 0) {
					this._targetAspectRatio = frameData.rect.z / frameData.rect.w;
				}
			}
			this.mesh = nineSlice ? mesh : this._defaultMesh;
			this.refreshMesh();
		};
		_proto2.refreshMesh = function refreshMesh() {
			if (this.mesh) {
				if (!this._element._beingInitialized) {
					this._updateMesh(this.mesh);
				} else {
					this._meshDirty = true;
				}
			}
		};
		_proto2._updateAabb = function _updateAabb(aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
			return aabb;
		};
		_proto2._toggleMask = function _toggleMask() {
			this._element._dirtifyMask();
			var screenSpace = this._element._isScreenSpace();
			this._updateMaterial(screenSpace);
			this._renderable.setMask(!!this._mask);
		};
		_proto2._onMaterialLoad = function _onMaterialLoad(asset) {
			this.material = asset.resource;
		};
		_proto2._onMaterialAdded = function _onMaterialAdded(asset) {
			this._system.app.assets.off("add:" + asset.id, this._onMaterialAdded, this);
			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		};
		_proto2._bindMaterialAsset = function _bindMaterialAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on('load', this._onMaterialLoad, this);
			asset.on('change', this._onMaterialChange, this);
			asset.on('remove', this._onMaterialRemove, this);
			if (asset.resource) {
				this._onMaterialLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};
		_proto2._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
			asset.off('load', this._onMaterialLoad, this);
			asset.off('change', this._onMaterialChange, this);
			asset.off('remove', this._onMaterialRemove, this);
		};
		_proto2._onMaterialChange = function _onMaterialChange() {};
		_proto2._onMaterialRemove = function _onMaterialRemove() {};
		_proto2._onTextureAdded = function _onTextureAdded(asset) {
			this._system.app.assets.off("add:" + asset.id, this._onTextureAdded, this);
			if (this._textureAsset === asset.id) {
				this._bindTextureAsset(asset);
			}
		};
		_proto2._bindTextureAsset = function _bindTextureAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on('load', this._onTextureLoad, this);
			asset.on('change', this._onTextureChange, this);
			asset.on('remove', this._onTextureRemove, this);
			if (asset.resource) {
				this._onTextureLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};
		_proto2._unbindTextureAsset = function _unbindTextureAsset(asset) {
			asset.off('load', this._onTextureLoad, this);
			asset.off('change', this._onTextureChange, this);
			asset.off('remove', this._onTextureRemove, this);
		};
		_proto2._onTextureLoad = function _onTextureLoad(asset) {
			this.texture = asset.resource;
		};
		_proto2._onTextureChange = function _onTextureChange(asset) {};
		_proto2._onTextureRemove = function _onTextureRemove(asset) {};
		_proto2._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
			this._system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		};
		_proto2._bindSpriteAsset = function _bindSpriteAsset(asset) {
			if (!this._entity.enabled) return;
			asset.on('load', this._onSpriteAssetLoad, this);
			asset.on('change', this._onSpriteAssetChange, this);
			asset.on('remove', this._onSpriteAssetRemove, this);
			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._system.app.assets.load(asset);
			}
		};
		_proto2._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
			asset.off('load', this._onSpriteAssetLoad, this);
			asset.off('change', this._onSpriteAssetChange, this);
			asset.off('remove', this._onSpriteAssetRemove, this);
			if (asset.data.textureAtlasAsset) {
				this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		};
		_proto2._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
			if (!asset || !asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;
					if (atlasAssetId) {
						var assets = this._system.app.assets;
						assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
						assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
					}
				} else {
					this.sprite = asset.resource;
				}
			}
		};
		_proto2._onSpriteAssetChange = function _onSpriteAssetChange(asset) {
			this._onSpriteAssetLoad(asset);
		};
		_proto2._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {};
		_proto2._bindSprite = function _bindSprite(sprite) {
			this._evtSetMeshes = sprite.on('set:meshes', this._onSpriteMeshesChange, this);
			sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.on('set:atlas', this._onAtlasTextureChange, this);
			if (sprite.atlas) {
				sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
			}
		};
		_proto2._unbindSprite = function _unbindSprite(sprite) {
			var _this$_evtSetMeshes;
			(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();
			this._evtSetMeshes = null;
			sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
			sprite.off('set:atlas', this._onAtlasTextureChange, this);
			if (sprite.atlas) {
				sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
			}
		};
		_proto2._onSpriteMeshesChange = function _onSpriteMeshesChange() {
			if (this._sprite) {
				this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
			}
			this._updateSprite();
		};
		_proto2._onSpritePpuChange = function _onSpritePpuChange() {
			if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
				this._updateSprite();
			}
		};
		_proto2._onAtlasTextureChange = function _onAtlasTextureChange() {
			if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
				this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
				this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
			} else {
				this._renderable.deleteParameter('texture_emissiveMap');
				this._renderable.deleteParameter('texture_opacityMap');
			}
		};
		_proto2._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
			var spriteAsset = this._spriteAsset;
			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
			}
		};
		_proto2.onEnable = function onEnable() {
			if (this._materialAsset) {
				var asset = this._system.app.assets.get(this._materialAsset);
				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}
			if (this._textureAsset) {
				var _asset = this._system.app.assets.get(this._textureAsset);
				if (_asset && _asset.resource !== this._texture) {
					this._bindTextureAsset(_asset);
				}
			}
			if (this._spriteAsset) {
				var _asset2 = this._system.app.assets.get(this._spriteAsset);
				if (_asset2 && _asset2.resource !== this._sprite) {
					this._bindSpriteAsset(_asset2);
				}
			}
			this._element.addModelToLayers(this._renderable.model);
		};
		_proto2.onDisable = function onDisable() {
			this._element.removeModelFromLayers(this._renderable.model);
		};
		_proto2._setStencil = function _setStencil(stencilParams) {
			this._renderable.meshInstance.stencilFront = stencilParams;
			this._renderable.meshInstance.stencilBack = stencilParams;
			var ref = 0;
			if (this._element.maskedBy) {
				ref = this._element.maskedBy.element._image._maskRef;
			}
			if (this._renderable.unmaskMeshInstance) {
				var sp = new StencilParameters({
					ref: ref + 1,
					func: FUNC_EQUAL,
					zpass: STENCILOP_DECREMENT
				});
				this._renderable.unmaskMeshInstance.stencilFront = sp;
				this._renderable.unmaskMeshInstance.stencilBack = sp;
			}
		};
		_proto2._updateRenderableEmissive = function _updateRenderableEmissive() {
			_tempColor$2.linear(this._color);
			this._colorUniform[0] = _tempColor$2.r;
			this._colorUniform[1] = _tempColor$2.g;
			this._colorUniform[2] = _tempColor$2.b;
			this._renderable.setParameter('material_emissive', this._colorUniform);
		};
		_proto2._removeMaterialAssetEvents = function _removeMaterialAssetEvents() {
			if (this._materialAsset) {
				var assets = this._system.app.assets;
				assets.off("add:" + this._materialAsset, this._onMaterialAdded, this);
				var asset = assets.get(this._materialAsset);
				if (asset) {
					asset.off('load', this._onMaterialLoad, this);
					asset.off('change', this._onMaterialChange, this);
					asset.off('remove', this._onMaterialRemove, this);
				}
			}
		};
		return _createClass(ImageElement, [{
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				var r = value.r,
					g = value.g,
					b = value.b;
				if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
					this._color.r = r;
					this._color.g = g;
					this._color.b = b;
					this._updateRenderableEmissive();
				}
				if (this._element) {
					this._element.fire('set:color', this._color);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				if (value !== this._color.a) {
					this._color.a = value;
					this._renderable.setParameter('material_opacity', value);
				}
				if (this._element) {
					this._element.fire('set:opacity', value);
				}
			}
		}, {
			key: "rect",
			get: function get() {
				return this._rect;
			},
			set: function set(value) {
				var x, y, z, w;
				if (value instanceof Vec4) {
					x = value.x;
					y = value.y;
					z = value.z;
					w = value.w;
				} else {
					x = value[0];
					y = value[1];
					z = value[2];
					w = value[3];
				}
				if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
					return;
				}
				this._rect.set(x, y, z, w);
				if (this._renderable.mesh) {
					if (!this._element._beingInitialized) {
						this._updateMesh(this._renderable.mesh);
					} else {
						this._meshDirty = true;
					}
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material === value) return;
				if (!value) {
					var screenSpace = this._element._isScreenSpace();
					if (this.mask) {
						value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
					} else {
						value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
					}
				}
				this._material = value;
				if (this._materialAsset) {
					var asset = this._system.app.assets.get(this._materialAsset);
					if (!asset || asset.resource !== value) {
						this._removeMaterialAssetEvents();
						this._materialAsset = null;
					}
				}
				if (value) {
					this._renderable.setMaterial(value);
					if (this._hasUserMaterial()) {
						this._renderable.deleteParameter('material_opacity');
						this._renderable.deleteParameter('material_emissive');
					} else {
						this._updateRenderableEmissive();
						this._renderable.setParameter('material_opacity', this._color.a);
					}
				}
			}
		}, {
			key: "materialAsset",
			get: function get() {
				return this._materialAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._materialAsset !== _id) {
					this._removeMaterialAssetEvents();
					this._materialAsset = _id;
					if (this._materialAsset) {
						var asset = assets.get(this._materialAsset);
						if (!asset) {
							this._materialAsset = null;
							this.material = null;
							this._materialAsset = _id;
							assets.on("add:" + this._materialAsset, this._onMaterialAdded, this);
						} else {
							this._bindMaterialAsset(asset);
						}
					} else {
						this._materialAsset = null;
						this.material = null;
						this._materialAsset = _id;
					}
				}
			}
		}, {
			key: "texture",
			get: function get() {
				return this._texture;
			},
			set: function set(value) {
				if (this._texture === value) return;
				if (this._textureAsset) {
					var textureAsset = this._system.app.assets.get(this._textureAsset);
					if (textureAsset && textureAsset.resource !== value) {
						this.textureAsset = null;
					}
				}
				this._texture = value;
				if (value) {
					if (this._spriteAsset) {
						this.spriteAsset = null;
					}
					this._renderable.setParameter('texture_emissiveMap', this._texture);
					this._renderable.setParameter('texture_opacityMap', this._texture);
					this._updateRenderableEmissive();
					this._renderable.setParameter('material_opacity', this._color.a);
					var newAspectRatio = this._texture.width / this._texture.height;
					if (newAspectRatio !== this._targetAspectRatio) {
						this._targetAspectRatio = newAspectRatio;
						if (this._element.fitMode !== FITMODE_STRETCH) {
							this.refreshMesh();
						}
					}
				} else {
					this._renderable.deleteParameter('texture_emissiveMap');
					this._renderable.deleteParameter('texture_opacityMap');
					this._targetAspectRatio = -1;
					if (this._element.fitMode !== FITMODE_STRETCH) {
						this.refreshMesh();
					}
				}
			}
		}, {
			key: "textureAsset",
			get: function get() {
				return this._textureAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._textureAsset !== _id) {
					if (this._textureAsset) {
						assets.off("add:" + this._textureAsset, this._onTextureAdded, this);
						var _prev = assets.get(this._textureAsset);
						if (_prev) {
							_prev.off('load', this._onTextureLoad, this);
							_prev.off('change', this._onTextureChange, this);
							_prev.off('remove', this._onTextureRemove, this);
						}
					}
					this._textureAsset = _id;
					if (this._textureAsset) {
						var asset = assets.get(this._textureAsset);
						if (!asset) {
							this.texture = null;
							assets.on("add:" + this._textureAsset, this._onTextureAdded, this);
						} else {
							this._bindTextureAsset(asset);
						}
					} else {
						this.texture = null;
					}
				}
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._spriteAsset;
			},
			set: function set(value) {
				var assets = this._system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._spriteAsset !== _id) {
					if (this._spriteAsset) {
						assets.off("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
						var _prev = assets.get(this._spriteAsset);
						if (_prev) {
							this._unbindSpriteAsset(_prev);
						}
					}
					this._spriteAsset = _id;
					if (this._spriteAsset) {
						var asset = assets.get(this._spriteAsset);
						if (!asset) {
							this.sprite = null;
							assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
						} else {
							this._bindSpriteAsset(asset);
						}
					} else {
						this.sprite = null;
					}
				}
				if (this._element) {
					this._element.fire('set:spriteAsset', _id);
				}
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._sprite;
			},
			set: function set(value) {
				if (this._sprite === value) return;
				if (this._sprite) {
					this._unbindSprite(this._sprite);
				}
				if (this._spriteAsset) {
					var spriteAsset = this._system.app.assets.get(this._spriteAsset);
					if (spriteAsset && spriteAsset.resource !== value) {
						this.spriteAsset = null;
					}
				}
				this._sprite = value;
				if (this._sprite) {
					this._bindSprite(this._sprite);
					if (this._textureAsset) {
						this.textureAsset = null;
					}
				}
				if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
					this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
					this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
				} else {
					this._renderable.deleteParameter('texture_emissiveMap');
					this._renderable.deleteParameter('texture_opacityMap');
				}
				if (this._sprite) {
					this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
				}
				this._updateSprite();
			}
		}, {
			key: "spriteFrame",
			get: function get() {
				return this._spriteFrame;
			},
			set: function set(value) {
				var oldValue = this._spriteFrame;
				if (this._sprite) {
					this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
				} else {
					this._spriteFrame = value;
				}
				if (this._spriteFrame !== oldValue) {
					this._updateSprite();
				}
				if (this._element) {
					this._element.fire('set:spriteFrame', value);
				}
			}
		}, {
			key: "mesh",
			get: function get() {
				return this._renderable.mesh;
			},
			set: function set(value) {
				this._renderable.setMesh(value);
				if (this._defaultMesh === value) {
					this._renderable.setAabbFunc(null);
				} else {
					this._renderable.setAabbFunc(this._updateAabbFunc);
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(value) {
				if (this._mask !== value) {
					this._mask = value;
					this._toggleMask();
				}
			}
		}, {
			key: "pixelsPerUnit",
			get: function get() {
				return this._pixelsPerUnit;
			},
			set: function set(value) {
				if (this._pixelsPerUnit === value) return;
				this._pixelsPerUnit = value;
				if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
					this._updateSprite();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._renderable.meshInstance) {
					return this._renderable.meshInstance.aabb;
				}
				return null;
			}
		}]);
	}();

	var LocalizedAsset = function (_EventHandler) {
		function LocalizedAsset(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._app = app;
			app.i18n.on('set:locale', _this._onSetLocale, _this);
			_this._autoLoad = false;
			_this._disableLocalization = false;
			_this._defaultAsset = null;
			_this._localizedAsset = null;
			return _this;
		}
		_inheritsLoose(LocalizedAsset, _EventHandler);
		var _proto = LocalizedAsset.prototype;
		_proto._bindDefaultAsset = function _bindDefaultAsset() {
			var asset = this._app.assets.get(this._defaultAsset);
			if (!asset) {
				this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
			} else {
				this._onDefaultAssetAdd(asset);
			}
		};
		_proto._unbindDefaultAsset = function _unbindDefaultAsset() {
			if (!this._defaultAsset) return;
			this._app.assets.off("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
			var asset = this._app.assets.get(this._defaultAsset);
			if (!asset) return;
			asset.off('add:localized', this._onLocaleAdd, this);
			asset.off('remove:localized', this._onLocaleRemove, this);
			asset.off('remove', this._onDefaultAssetRemove, this);
		};
		_proto._onDefaultAssetAdd = function _onDefaultAssetAdd(asset) {
			if (this._defaultAsset !== asset.id) return;
			asset.on('add:localized', this._onLocaleAdd, this);
			asset.on('remove:localized', this._onLocaleRemove, this);
			asset.once('remove', this._onDefaultAssetRemove, this);
		};
		_proto._onDefaultAssetRemove = function _onDefaultAssetRemove(asset) {
			if (this._defaultAsset !== asset.id) return;
			asset.off('add:localized', this._onLocaleAdd, this);
			asset.off('remove:localized', this._onLocaleAdd, this);
			this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
		};
		_proto._bindLocalizedAsset = function _bindLocalizedAsset() {
			if (!this._autoLoad) return;
			var asset = this._app.assets.get(this._localizedAsset);
			if (!asset) return;
			asset.on('load', this._onLocalizedAssetLoad, this);
			asset.on('change', this._onLocalizedAssetChange, this);
			asset.on('remove', this._onLocalizedAssetRemove, this);
			if (asset.resource) {
				this._onLocalizedAssetLoad(asset);
			} else {
				this._app.assets.load(asset);
			}
		};
		_proto._unbindLocalizedAsset = function _unbindLocalizedAsset() {
			var asset = this._app.assets.get(this._localizedAsset);
			if (!asset) return;
			asset.off('load', this._onLocalizedAssetLoad, this);
			asset.off('change', this._onLocalizedAssetChange, this);
			asset.off('remove', this._onLocalizedAssetRemove, this);
		};
		_proto._onLocalizedAssetAdd = function _onLocalizedAssetAdd(asset) {
			if (this._localizedAsset !== asset.id) return;
			this._bindLocalizedAsset();
		};
		_proto._onLocalizedAssetLoad = function _onLocalizedAssetLoad(asset) {
			this.fire('load', asset);
		};
		_proto._onLocalizedAssetChange = function _onLocalizedAssetChange(asset, name, newValue, oldValue) {
			this.fire('change', asset, name, newValue, oldValue);
		};
		_proto._onLocalizedAssetRemove = function _onLocalizedAssetRemove(asset) {
			if (this._localizedAsset === asset.id) {
				this.localizedAsset = this._defaultAsset;
			}
			this.fire('remove', asset);
		};
		_proto._onLocaleAdd = function _onLocaleAdd(locale, assetId) {
			if (this._app.i18n.locale !== locale) return;
			this._onSetLocale(locale);
		};
		_proto._onLocaleRemove = function _onLocaleRemove(locale, assetId) {
			if (this._app.i18n.locale !== locale) return;
			this._onSetLocale(locale);
		};
		_proto._onSetLocale = function _onSetLocale(locale) {
			if (!this._defaultAsset) {
				this.localizedAsset = null;
				return;
			}
			var asset = this._app.assets.get(this._defaultAsset);
			if (!asset || this._disableLocalization) {
				this.localizedAsset = this._defaultAsset;
				return;
			}
			var localizedAssetId = asset.getLocalizedAssetId(locale);
			if (!localizedAssetId) {
				this.localizedAsset = this._defaultAsset;
				return;
			}
			this.localizedAsset = localizedAssetId;
		};
		_proto.destroy = function destroy() {
			this.defaultAsset = null;
			this._app.i18n.off('set:locale', this._onSetLocale, this);
			this.off();
		};
		return _createClass(LocalizedAsset, [{
			key: "defaultAsset",
			get: function get() {
				return this._defaultAsset;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._defaultAsset === id) return;
				if (this._defaultAsset) {
					this._unbindDefaultAsset();
				}
				this._defaultAsset = id;
				if (this._defaultAsset) {
					this._bindDefaultAsset();
				}
				this._onSetLocale(this._app.i18n.locale);
			}
		}, {
			key: "localizedAsset",
			get: function get() {
				return this._localizedAsset;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._localizedAsset === id) {
					return;
				}
				if (this._localizedAsset) {
					this._app.assets.off("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this);
					this._unbindLocalizedAsset();
				}
				this._localizedAsset = id;
				if (this._localizedAsset) {
					var asset = this._app.assets.get(this._localizedAsset);
					if (!asset) {
						this._app.assets.once("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this);
					} else {
						this._bindLocalizedAsset();
					}
				}
			}
		}, {
			key: "autoLoad",
			get: function get() {
				return this._autoLoad;
			},
			set: function set(value) {
				if (this._autoLoad === value) return;
				this._autoLoad = value;
				if (this._autoLoad && this._localizedAsset) {
					this._unbindLocalizedAsset();
					this._bindLocalizedAsset();
				}
			}
		}, {
			key: "disableLocalization",
			get: function get() {
				return this._disableLocalization;
			},
			set: function set(value) {
				if (this._disableLocalization === value) return;
				this._disableLocalization = value;
				this._onSetLocale(this._app.i18n.locale);
			}
		}]);
	}(EventHandler);

	var FONT_MSDF = 'msdf';
	var FONT_BITMAP = 'bitmap';

	var EOF_TOKEN = 0;
	var ERROR_TOKEN = 1;
	var TEXT_TOKEN = 2;
	var OPEN_BRACKET_TOKEN = 3;
	var CLOSE_BRACKET_TOKEN = 4;
	var EQUALS_TOKEN = 5;
	var STRING_TOKEN = 6;
	var IDENTIFIER_TOKEN = 7;
	var WHITESPACE_TOKEN = 8;
	var WHITESPACE_CHARS = ' \t\n\r\v\f';
	var IDENTIFIER_REGEX = /[\w|/]/;
	var Scanner = function () {
		function Scanner(symbols) {
			this._symbols = symbols;
			this._index = 0;
			this._last = 0;
			this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
			this._buf = [];
			this._mode = 'text';
			this._error = null;
		}
		var _proto = Scanner.prototype;
		_proto.read = function read() {
			var token = this._read();
			while (token === WHITESPACE_TOKEN) {
				token = this._read();
			}
			if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
				this._last = this._index;
			}
			return token;
		};
		_proto.buf = function buf() {
			return this._buf;
		};
		_proto.last = function last() {
			return this._last;
		};
		_proto.error = function error() {
			return this._error;
		};
		_proto.debugPrint = function debugPrint() {
			var tokenStrings = ['EOF', 'ERROR', 'TEXT', 'OPEN_BRACKET', 'CLOSE_BRACKET', 'EQUALS', 'STRING', 'IDENTIFIER', 'WHITESPACE'];
			var token = this.read();
			var result = '';
			while (true) {
				result += (result.length > 0 ? '\n' : '') + tokenStrings[token] + " '" + this.buf().join('') + "'";
				if (token === EOF_TOKEN || token === ERROR_TOKEN) {
					break;
				}
				token = this.read();
			}
			return result;
		};
		_proto._read = function _read() {
			this._buf = [];
			if (this._eof()) {
				return EOF_TOKEN;
			}
			return this._mode === 'text' ? this._text() : this._tag();
		};
		_proto._text = function _text() {
			while (true) {
				switch (this._cur) {
					case null:
						return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;
					case '[':
						this._mode = 'tag';
						return this._buf.length > 0 ? TEXT_TOKEN : this._tag();
					case '\\':
						this._next();
						switch (this._cur) {
							case '[':
								this._store();
								break;
							default:
								this._output('\\');
								break;
						}
						break;
					default:
						this._store();
						break;
				}
			}
		};
		_proto._tag = function _tag() {
			switch (this._cur) {
				case null:
					this._error = 'unexpected end of input reading tag';
					return ERROR_TOKEN;
				case '[':
					this._store();
					return OPEN_BRACKET_TOKEN;
				case ']':
					this._store();
					this._mode = 'text';
					return CLOSE_BRACKET_TOKEN;
				case '=':
					this._store();
					return EQUALS_TOKEN;
				case ' ':
				case '\t':
				case '\n':
				case '\r':
				case '\v':
				case '\f':
					return this._whitespace();
				case '"':
					return this._string();
				default:
					if (!this._isIdentifierSymbol(this._cur)) {
						this._error = 'unrecognized character';
						return ERROR_TOKEN;
					}
					return this._identifier();
			}
		};
		_proto._whitespace = function _whitespace() {
			this._store();
			while (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
				this._store();
			}
			return WHITESPACE_TOKEN;
		};
		_proto._string = function _string() {
			this._next();
			while (true) {
				switch (this._cur) {
					case null:
						this._error = 'unexpected end of input reading string';
						return ERROR_TOKEN;
					case '"':
						this._next();
						return STRING_TOKEN;
					default:
						this._store();
						break;
				}
			}
		};
		_proto._identifier = function _identifier() {
			this._store();
			while (this._cur !== null && this._isIdentifierSymbol(this._cur)) {
				this._store();
			}
			return IDENTIFIER_TOKEN;
		};
		_proto._isIdentifierSymbol = function _isIdentifierSymbol(s) {
			return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
		};
		_proto._eof = function _eof() {
			return this._cur === null;
		};
		_proto._next = function _next() {
			if (!this._eof()) {
				this._index++;
				this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
			}
			return this._cur;
		};
		_proto._store = function _store() {
			this._buf.push(this._cur);
			return this._next();
		};
		_proto._output = function _output(c) {
			this._buf.push(c);
		};
		return Scanner;
	}();
	var Parser = function () {
		function Parser(symbols) {
			this._scanner = new Scanner(symbols);
			this._error = null;
		}
		var _proto2 = Parser.prototype;
		_proto2.parse = function parse(symbols, tags) {
			while (true) {
				var token = this._scanner.read();
				switch (token) {
					case EOF_TOKEN:
						return true;
					case ERROR_TOKEN:
						return false;
					case TEXT_TOKEN:
						Array.prototype.push.apply(symbols, this._scanner.buf());
						break;
					case OPEN_BRACKET_TOKEN:
						if (!this._parseTag(symbols, tags)) {
							return false;
						}
						break;
					default:
						return false;
				}
			}
		};
		_proto2.error = function error() {
			return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")";
		};
		_proto2._parseTag = function _parseTag(symbols, tags) {
			var token = this._scanner.read();
			if (token !== IDENTIFIER_TOKEN) {
				this._error = 'expected identifier';
				return false;
			}
			var name = this._scanner.buf().join('');
			if (name[0] === '/') {
				for (var index = tags.length - 1; index >= 0; --index) {
					if (name === "/" + tags[index].name && tags[index].end === null) {
						tags[index].end = symbols.length;
						token = this._scanner.read();
						if (token !== CLOSE_BRACKET_TOKEN) {
							this._error = 'expected close bracket';
							return false;
						}
						return true;
					}
				}
				this._error = 'failed to find matching tag';
				return false;
			}
			var tag = {
				name: name,
				value: null,
				attributes: {},
				start: symbols.length,
				end: null
			};
			token = this._scanner.read();
			if (token === EQUALS_TOKEN) {
				token = this._scanner.read();
				if (token !== STRING_TOKEN) {
					this._error = 'expected string';
					return false;
				}
				tag.value = this._scanner.buf().join('');
				token = this._scanner.read();
			}
			while (true) {
				switch (token) {
					case CLOSE_BRACKET_TOKEN:
						tags.push(tag);
						return true;
					case IDENTIFIER_TOKEN:
						{
							var identifier = this._scanner.buf().join('');
							token = this._scanner.read();
							if (token !== EQUALS_TOKEN) {
								this._error = 'expected equals';
								return false;
							}
							token = this._scanner.read();
							if (token !== STRING_TOKEN) {
								this._error = 'expected string';
								return false;
							}
							var value = this._scanner.buf().join('');
							tag.attributes[identifier] = value;
							break;
						}
					default:
						this._error = 'expected close bracket or identifier';
						return false;
				}
				token = this._scanner.read();
			}
		};
		return Parser;
	}();
	function merge(target, source) {
		for (var key in source) {
			if (!source.hasOwnProperty(key)) {
				continue;
			}
			var value = source[key];
			if (value instanceof Object) {
				if (!target.hasOwnProperty(key)) {
					target[key] = {};
				}
				merge(target[key], source[key]);
			} else {
				target[key] = value;
			}
		}
	}
	function combineTags(tags) {
		if (tags.length === 0) {
			return null;
		}
		var result = {};
		for (var index = 0; index < tags.length; ++index) {
			var tag = tags[index];
			var tmp = {};
			tmp[tag.name] = {
				value: tag.value,
				attributes: tag.attributes
			};
			merge(result, tmp);
		}
		return result;
	}
	function resolveMarkupTags(tags, numSymbols) {
		if (tags.length === 0) {
			return null;
		}
		var edges = {};
		for (var index = 0; index < tags.length; ++index) {
			var tag = tags[index];
			if (!edges.hasOwnProperty(tag.start)) {
				edges[tag.start] = {
					open: [tag],
					close: null
				};
			} else {
				if (edges[tag.start].open === null) {
					edges[tag.start].open = [tag];
				} else {
					edges[tag.start].open.push(tag);
				}
			}
			if (!edges.hasOwnProperty(tag.end)) {
				edges[tag.end] = {
					open: null,
					close: [tag]
				};
			} else {
				if (edges[tag.end].close === null) {
					edges[tag.end].close = [tag];
				} else {
					edges[tag.end].close.push(tag);
				}
			}
		}
		var tagStack = [];
		function removeTags(tags) {
			tagStack = tagStack.filter(function (tag) {
				return tags.find(function (t) {
					return t === tag;
				}) === undefined;
			});
		}
		function addTags(tags) {
			for (var _index = 0; _index < tags.length; ++_index) {
				tagStack.push(tags[_index]);
			}
		}
		var edgeKeys = Object.keys(edges).sort(function (a, b) {
			return a - b;
		});
		var resolvedTags = [];
		for (var _index2 = 0; _index2 < edgeKeys.length; ++_index2) {
			var edge = edges[edgeKeys[_index2]];
			if (edge.close !== null) {
				removeTags(edge.close);
			}
			if (edge.open !== null) {
				addTags(edge.open);
			}
			resolvedTags.push({
				start: edgeKeys[_index2],
				tags: combineTags(tagStack)
			});
		}
		var result = [];
		var prevTag = null;
		for (var _index3 = 0; _index3 < resolvedTags.length; ++_index3) {
			var resolvedTag = resolvedTags[_index3];
			while (result.length < resolvedTag.start) {
				result.push(prevTag ? prevTag.tags : null);
			}
			prevTag = resolvedTag;
		}
		while (result.length < numSymbols) {
			result.push(null);
		}
		return result;
	}
	function evaluateMarkup(symbols) {
		var parser = new Parser(symbols);
		var stripped_symbols = [];
		var tags = [];
		if (!parser.parse(stripped_symbols, tags)) {
			console.warn(parser.error());
			return {
				symbols: symbols,
				tags: null
			};
		}
		var invalidTag = tags.find(function (t) {
			return t.end === null;
		});
		if (invalidTag) {
			console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
			return {
				symbols: symbols,
				tags: null
			};
		}
		var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
		return {
			symbols: stripped_symbols,
			tags: resolved_tags
		};
	}
	var Markup = function () {
		function Markup() {}
		Markup.evaluate = function evaluate(symbols) {
			return evaluateMarkup(symbols);
		};
		return Markup;
	}();

	var MeshInfo = function MeshInfo() {
		this.count = 0;
		this.quad = 0;
		this.lines = {};
		this.positions = [];
		this.normals = [];
		this.uvs = [];
		this.colors = [];
		this.indices = [];
		this.outlines = [];
		this.shadows = [];
		this.meshInstance = null;
	};
	function createTextMesh(device, meshInfo) {
		var mesh = new Mesh(device);
		mesh.setPositions(meshInfo.positions);
		mesh.setNormals(meshInfo.normals);
		mesh.setColors32(meshInfo.colors);
		mesh.setUvs(0, meshInfo.uvs);
		mesh.setIndices(meshInfo.indices);
		mesh.setVertexStream(SEMANTIC_ATTR8, meshInfo.outlines, 3, undefined, TYPE_FLOAT32, false);
		mesh.setVertexStream(SEMANTIC_ATTR9, meshInfo.shadows, 3, undefined, TYPE_FLOAT32, false);
		mesh.update();
		return mesh;
	}
	var LINE_BREAK_CHAR = /^[\r\n]$/;
	var WHITESPACE_CHAR = /^[ \t]$/;
	var WORD_BOUNDARY_CHAR = /^[ \t\-]|\u200b$/;
	var ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
	var CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff\ua960-\ua97f]|[\uac00-\ud7ff]$/;
	var NO_LINE_BREAK_CJK_CHAR = /^[]$/;
	var CONTROL_CHARS = ["\u200B", "\u061C", "\u200E", "\u200F", "\u202A", "\u202B", "\u202C", "\u202D", "\u202E", "\u2066", "\u2067", "\u2068", "\u2069"];
	var CONTROL_GLYPH_DATA = {
		width: 0,
		height: 0,
		xadvance: 0,
		xoffset: 0,
		yoffset: 0
	};
	var colorTmp = new Color();
	var vec2Tmp = new Vec2();
	var _tempColor$1 = new Color();
	var TextElement = function () {
		function TextElement(element) {
			this._element = element;
			this._system = element.system;
			this._entity = element.entity;
			this._text = '';
			this._symbols = [];
			this._colorPalette = [];
			this._outlinePalette = [];
			this._shadowPalette = [];
			this._symbolColors = null;
			this._symbolOutlineParams = null;
			this._symbolShadowParams = null;
			this._i18nKey = null;
			this._fontAsset = new LocalizedAsset(this._system.app);
			this._fontAsset.disableLocalization = true;
			this._fontAsset.on('load', this._onFontLoad, this);
			this._fontAsset.on('change', this._onFontChange, this);
			this._fontAsset.on('remove', this._onFontRemove, this);
			this._font = null;
			this._color = new Color(1, 1, 1, 1);
			this._colorUniform = new Float32Array(3);
			this._spacing = 1;
			this._fontSize = 32;
			this._fontMinY = 0;
			this._fontMaxY = 0;
			this._originalFontSize = 32;
			this._maxFontSize = 32;
			this._minFontSize = 8;
			this._autoFitWidth = false;
			this._autoFitHeight = false;
			this._maxLines = -1;
			this._lineHeight = 32;
			this._scaledLineHeight = 32;
			this._wrapLines = false;
			this._drawOrder = 0;
			this._alignment = new Vec2(0.5, 0.5);
			this._autoWidth = true;
			this._autoHeight = true;
			this.width = 0;
			this.height = 0;
			this._node = new GraphNode();
			this._model = new Model();
			this._model.graph = this._node;
			this._entity.addChild(this._node);
			this._meshInfo = [];
			this._material = null;
			this._aabbDirty = true;
			this._aabb = new BoundingBox();
			this._noResize = false;
			this._currentMaterialType = null;
			this._maskedMaterialSrc = null;
			this._rtlReorder = false;
			this._unicodeConverter = false;
			this._rtl = false;
			this._outlineColor = new Color(0, 0, 0, 1);
			this._outlineColorUniform = new Float32Array(4);
			this._outlineThicknessScale = 0.2;
			this._outlineThickness = 0.0;
			this._shadowColor = new Color(0, 0, 0, 1);
			this._shadowColorUniform = new Float32Array(4);
			this._shadowOffsetScale = 0.005;
			this._shadowOffset = new Vec2(0, 0);
			this._shadowOffsetUniform = new Float32Array(2);
			this._enableMarkup = false;
			this._onScreenChange(this._element.screen);
			element.on('resize', this._onParentResize, this);
			element.on('set:screen', this._onScreenChange, this);
			element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
			element.on('set:draworder', this._onDrawOrderChange, this);
			element.on('set:pivot', this._onPivotChange, this);
			this._system.app.i18n.on('set:locale', this._onLocaleSet, this);
			this._system.app.i18n.on('data:add', this._onLocalizationData, this);
			this._system.app.i18n.on('data:remove', this._onLocalizationData, this);
			this._rangeStart = 0;
			this._rangeEnd = 0;
		}
		var _proto = TextElement.prototype;
		_proto.destroy = function destroy() {
			this._setMaterial(null);
			if (this._model) {
				this._element.removeModelFromLayers(this._model);
				this._model.destroy();
				this._model = null;
			}
			this._fontAsset.destroy();
			this.font = null;
			this._element.off('resize', this._onParentResize, this);
			this._element.off('set:screen', this._onScreenChange, this);
			this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
			this._element.off('set:draworder', this._onDrawOrderChange, this);
			this._element.off('set:pivot', this._onPivotChange, this);
			this._system.app.i18n.off('set:locale', this._onLocaleSet, this);
			this._system.app.i18n.off('data:add', this._onLocalizationData, this);
			this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
		};
		_proto._onParentResize = function _onParentResize(width, height) {
			if (this._noResize) return;
			if (this._font) this._updateText();
		};
		_proto._onScreenChange = function _onScreenChange(screen) {
			if (screen) {
				this._updateMaterial(screen.screen.screenSpace);
			} else {
				this._updateMaterial(false);
			}
		};
		_proto._onScreenSpaceChange = function _onScreenSpaceChange(value) {
			this._updateMaterial(value);
		};
		_proto._onDrawOrderChange = function _onDrawOrderChange(order) {
			this._drawOrder = order;
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					this._model.meshInstances[i].drawOrder = order;
				}
			}
		};
		_proto._onPivotChange = function _onPivotChange(pivot) {
			if (this._font) {
				this._updateText();
			}
		};
		_proto._onLocaleSet = function _onLocaleSet(locale) {
			if (!this._i18nKey) return;
			if (this.fontAsset) {
				var asset = this._system.app.assets.get(this.fontAsset);
				if (!asset || !asset.resource || asset.resource !== this._font) {
					this.font = null;
				}
			}
			this._resetLocalizedText();
		};
		_proto._onLocalizationData = function _onLocalizationData(locale, messages) {
			if (this._i18nKey && messages[this._i18nKey]) {
				this._resetLocalizedText();
			}
		};
		_proto._resetLocalizedText = function _resetLocalizedText() {
			this._setText(this._system.app.i18n.getText(this._i18nKey));
		};
		_proto._setText = function _setText(text) {
			if (this.unicodeConverter) {
				var unicodeConverterFunc = this._system.getUnicodeConverter();
				if (unicodeConverterFunc) {
					text = unicodeConverterFunc(text);
				} else {
					console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
				}
			}
			if (this._text !== text) {
				if (this._font) {
					this._updateText(text);
				}
				this._text = text;
			}
		};
		_proto._updateText = function _updateText(text) {
			var tags;
			if (text === undefined) text = this._text;
			this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);
			if (this._symbols.length === 0) {
				this._symbols = [' '];
			}
			if (this._enableMarkup) {
				var results = Markup.evaluate(this._symbols);
				this._symbols = results.symbols;
				tags = results.tags || [];
			}
			if (this._rtlReorder) {
				var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();
				if (rtlReorderFunc) {
					var _results = rtlReorderFunc(this._symbols);
					this._rtl = _results.rtl;
					this._symbols = _results.mapping.map(function (v) {
						return this._symbols[v];
					}, this);
					if (tags) {
						tags = _results.mapping.map(function (v) {
							return tags[v];
						});
					}
				} else {
					console.warn('Element created with rtlReorder option but no rtlReorder function registered');
				}
			} else {
				this._rtl = false;
			}
			var getColorThicknessHash = function getColorThicknessHash(color, thickness) {
				return color.toString(true).toLowerCase() + ":" + thickness.toFixed(2);
			};
			var getColorOffsetHash = function getColorOffsetHash(color, offset) {
				return color.toString(true).toLowerCase() + ":" + offset.x.toFixed(2) + ":" + offset.y.toFixed(2);
			};
			if (tags) {
				var paletteMap = {};
				var outlinePaletteMap = {};
				var shadowPaletteMap = {};
				this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];
				this._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)];
				this._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)];
				this._symbolColors = [];
				this._symbolOutlineParams = [];
				this._symbolShadowParams = [];
				paletteMap[this._color.toString(false).toLowerCase()] = 0;
				outlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;
				shadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;
				for (var i = 0, len = this._symbols.length; i < len; ++i) {
					var tag = tags[i];
					var color = 0;
					if (tag && tag.color && tag.color.value) {
						var c = tag.color.value;
						if (c.length === 7 && c[0] === '#') {
							var hex = c.substring(1).toLowerCase();
							if (paletteMap.hasOwnProperty(hex)) {
								color = paletteMap[hex];
							} else {
								if (/^[0-9a-f]{6}$/.test(hex)) {
									color = this._colorPalette.length / 3;
									paletteMap[hex] = color;
									this._colorPalette.push(parseInt(hex.substring(0, 2), 16));
									this._colorPalette.push(parseInt(hex.substring(2, 4), 16));
									this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
								}
							}
						}
					}
					this._symbolColors.push(color);
					var outline = 0;
					if (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {
						var _color = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;
						var thickness = Number(tag.outline.attributes.thickness);
						if (Number.isNaN(_color.r) || Number.isNaN(_color.g) || Number.isNaN(_color.b) || Number.isNaN(_color.a)) {
							_color = this._outlineColor;
						}
						if (Number.isNaN(thickness)) {
							thickness = this._outlineThickness;
						}
						var outlineHash = getColorThicknessHash(_color, thickness);
						if (outlinePaletteMap.hasOwnProperty(outlineHash)) {
							outline = outlinePaletteMap[outlineHash];
						} else {
							outline = this._outlinePalette.length / 5;
							outlinePaletteMap[outlineHash] = outline;
							this._outlinePalette.push(Math.round(_color.r * 255), Math.round(_color.g * 255), Math.round(_color.b * 255), Math.round(_color.a * 255), Math.round(thickness * 255));
						}
					}
					this._symbolOutlineParams.push(outline);
					var shadow = 0;
					if (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {
						var _color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;
						var off = Number(tag.shadow.attributes.offset);
						var offX = Number(tag.shadow.attributes.offsetX);
						var offY = Number(tag.shadow.attributes.offsetY);
						if (Number.isNaN(_color2.r) || Number.isNaN(_color2.g) || Number.isNaN(_color2.b) || Number.isNaN(_color2.a)) {
							_color2 = this._shadowColor;
						}
						var offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);
						var shadowHash = getColorOffsetHash(_color2, offset);
						if (shadowPaletteMap.hasOwnProperty(shadowHash)) {
							shadow = shadowPaletteMap[shadowHash];
						} else {
							shadow = this._shadowPalette.length / 6;
							shadowPaletteMap[shadowHash] = shadow;
							this._shadowPalette.push(Math.round(_color2.r * 255), Math.round(_color2.g * 255), Math.round(_color2.b * 255), Math.round(_color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));
						}
					}
					this._symbolShadowParams.push(shadow);
				}
			} else {
				this._colorPalette = [];
				this._symbolColors = null;
				this._symbolOutlineParams = null;
				this._symbolShadowParams = null;
			}
			this._updateMaterialEmissive();
			this._updateMaterialOutline();
			this._updateMaterialShadow();
			var charactersPerTexture = this._calculateCharsPerTexture();
			var removedModel = false;
			var element = this._element;
			var screenSpace = element._isScreenSpace();
			var screenCulled = element._isScreenCulled();
			var visibleFn = function visibleFn(camera) {
				return element.isVisibleForCamera(camera);
			};
			for (var _i = 0, _len = this._meshInfo.length; _i < _len; _i++) {
				var l = charactersPerTexture[_i] || 0;
				var meshInfo = this._meshInfo[_i];
				if (meshInfo.count !== l) {
					if (!removedModel) {
						element.removeModelFromLayers(this._model);
						removedModel = true;
					}
					meshInfo.count = l;
					meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
					meshInfo.indices.length = l * 3 * 2;
					meshInfo.uvs.length = l * 2 * 4;
					meshInfo.colors.length = l * 4 * 4;
					meshInfo.outlines.length = l * 4 * 3;
					meshInfo.shadows.length = l * 4 * 3;
					if (meshInfo.meshInstance) {
						this._removeMeshInstance(meshInfo.meshInstance);
					}
					if (l === 0) {
						meshInfo.meshInstance = null;
						continue;
					}
					for (var v = 0; v < l; v++) {
						meshInfo.indices[v * 3 * 2 + 0] = v * 4;
						meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
						meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
						meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
						meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
						meshInfo.normals[v * 4 * 3 + 0] = 0;
						meshInfo.normals[v * 4 * 3 + 1] = 0;
						meshInfo.normals[v * 4 * 3 + 2] = -1;
						meshInfo.normals[v * 4 * 3 + 3] = 0;
						meshInfo.normals[v * 4 * 3 + 4] = 0;
						meshInfo.normals[v * 4 * 3 + 5] = -1;
						meshInfo.normals[v * 4 * 3 + 6] = 0;
						meshInfo.normals[v * 4 * 3 + 7] = 0;
						meshInfo.normals[v * 4 * 3 + 8] = -1;
						meshInfo.normals[v * 4 * 3 + 9] = 0;
						meshInfo.normals[v * 4 * 3 + 10] = 0;
						meshInfo.normals[v * 4 * 3 + 11] = -1;
					}
					var mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);
					var mi = new MeshInstance(mesh, this._material, this._node);
					mi.name = "Text Element: " + this._entity.name;
					mi.castShadow = false;
					mi.receiveShadow = false;
					mi.cull = !screenSpace;
					mi.screenSpace = screenSpace;
					mi.drawOrder = this._drawOrder;
					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					}
					this._setTextureParams(mi, this._font.textures[_i]);
					mi.setParameter('material_emissive', this._colorUniform);
					mi.setParameter('material_opacity', this._color.a);
					mi.setParameter('font_sdfIntensity', this._font.intensity);
					mi.setParameter('font_pxrange', this._getPxRange(this._font));
					mi.setParameter('font_textureWidth', this._font.data.info.maps[_i].width);
					mi.setParameter('outline_color', this._outlineColorUniform);
					mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
					mi.setParameter('shadow_color', this._shadowColorUniform);
					if (this._symbolShadowParams) {
						this._shadowOffsetUniform[0] = 0;
						this._shadowOffsetUniform[1] = 0;
					} else {
						var ratio = -this._font.data.info.maps[_i].width / this._font.data.info.maps[_i].height;
						this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
						this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
					}
					mi.setParameter('shadow_offset', this._shadowOffsetUniform);
					meshInfo.meshInstance = mi;
					this._model.meshInstances.push(mi);
				}
			}
			if (this._element.maskedBy) {
				this._element._setMaskedBy(this._element.maskedBy);
			}
			if (removedModel && this._element.enabled && this._entity.enabled) {
				this._element.addModelToLayers(this._model);
			}
			this._updateMeshes();
			this._rangeStart = 0;
			this._rangeEnd = this._symbols.length;
			this._updateRenderRange();
		};
		_proto._removeMeshInstance = function _removeMeshInstance(meshInstance) {
			meshInstance.destroy();
			var idx = this._model.meshInstances.indexOf(meshInstance);
			if (idx !== -1) {
				this._model.meshInstances.splice(idx, 1);
			}
		};
		_proto._setMaterial = function _setMaterial(material) {
			this._material = material;
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.material = material;
				}
			}
		};
		_proto._updateMaterial = function _updateMaterial(screenSpace) {
			var element = this._element;
			var screenCulled = element._isScreenCulled();
			var visibleFn = function visibleFn(camera) {
				return element.isVisibleForCamera(camera);
			};
			var msdf = this._font && this._font.type === FONT_MSDF;
			this._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);
			if (this._model) {
				for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
					var mi = this._model.meshInstances[i];
					mi.cull = !screenSpace;
					mi.material = this._material;
					mi.screenSpace = screenSpace;
					if (screenCulled) {
						mi.cull = true;
						mi.isVisibleFunc = visibleFn;
					} else {
						mi.isVisibleFunc = null;
					}
				}
			}
		};
		_proto._updateMaterialEmissive = function _updateMaterialEmissive() {
			if (this._symbolColors) {
				this._colorUniform[0] = 1;
				this._colorUniform[1] = 1;
				this._colorUniform[2] = 1;
			} else {
				_tempColor$1.linear(this._color);
				this._colorUniform[0] = _tempColor$1.r;
				this._colorUniform[1] = _tempColor$1.g;
				this._colorUniform[2] = _tempColor$1.b;
			}
		};
		_proto._updateMaterialOutline = function _updateMaterialOutline() {
			if (this._symbolOutlineParams) {
				this._outlineColorUniform[0] = 0;
				this._outlineColorUniform[1] = 0;
				this._outlineColorUniform[2] = 0;
				this._outlineColorUniform[3] = 1;
			} else {
				_tempColor$1.linear(this._outlineColor);
				this._outlineColorUniform[0] = _tempColor$1.r;
				this._outlineColorUniform[1] = _tempColor$1.g;
				this._outlineColorUniform[2] = _tempColor$1.b;
				this._outlineColorUniform[3] = _tempColor$1.a;
			}
		};
		_proto._updateMaterialShadow = function _updateMaterialShadow() {
			if (this._symbolOutlineParams) {
				this._shadowColorUniform[0] = 0;
				this._shadowColorUniform[1] = 0;
				this._shadowColorUniform[2] = 0;
				this._shadowColorUniform[3] = 0;
			} else {
				_tempColor$1.linear(this._shadowColor);
				this._shadowColorUniform[0] = _tempColor$1.r;
				this._shadowColorUniform[1] = _tempColor$1.g;
				this._shadowColorUniform[2] = _tempColor$1.b;
				this._shadowColorUniform[3] = _tempColor$1.a;
			}
		};
		_proto._isWordBoundary = function _isWordBoundary(_char) {
			return WORD_BOUNDARY_CHAR.test(_char);
		};
		_proto._isValidNextChar = function _isValidNextChar(nextchar) {
			return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
		};
		_proto._isNextCJKBoundary = function _isNextCJKBoundary(_char2, nextchar) {
			return CJK_CHAR.test(_char2) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
		};
		_proto._isNextCJKWholeWord = function _isNextCJKWholeWord(nextchar) {
			return CJK_CHAR.test(nextchar);
		};
		_proto._updateMeshes = function _updateMeshes() {
			var json = this._font.data;
			var self = this;
			var minFont = Math.min(this._minFontSize, this._maxFontSize);
			var maxFont = this._maxFontSize;
			var autoFit = this._shouldAutoFit();
			if (autoFit) {
				this._fontSize = this._maxFontSize;
			}
			var MAGIC = 32;
			var l = this._symbols.length;
			var _x = 0;
			var _y = 0;
			var _z = 0;
			var _xMinusTrailingWhitespace = 0;
			var lines = 1;
			var wordStartX = 0;
			var wordStartIndex = 0;
			var lineStartIndex = 0;
			var numWordsThisLine = 0;
			var numCharsThisLine = 0;
			var numBreaksThisLine = 0;
			var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
			var maxLineWidth = this._element.calculatedWidth;
			if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
				maxLineWidth = Number.POSITIVE_INFINITY;
			}
			var fontMinY = 0;
			var fontMaxY = 0;
			var _char3, data, quad, nextchar;
			function breakLine(symbols, lineBreakIndex, lineBreakX) {
				self._lineWidths.push(Math.abs(lineBreakX));
				var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
				var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
				var chars = symbols.slice(sliceStart, sliceEnd);
				if (numBreaksThisLine) {
					var i = chars.length;
					while (i-- && numBreaksThisLine > 0) {
						if (LINE_BREAK_CHAR.test(chars[i])) {
							chars.splice(i, 1);
							numBreaksThisLine--;
						}
					}
				}
				self._lineContents.push(chars.join(''));
				_x = 0;
				_y -= self._scaledLineHeight;
				lines++;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				wordStartX = 0;
				lineStartIndex = lineBreakIndex;
			}
			var retryUpdateMeshes = true;
			while (retryUpdateMeshes) {
				retryUpdateMeshes = false;
				if (autoFit) {
					this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
				} else {
					this._scaledLineHeight = this._lineHeight;
				}
				this.width = 0;
				this.height = 0;
				this._lineWidths = [];
				this._lineContents = [];
				_x = 0;
				_y = 0;
				_z = 0;
				_xMinusTrailingWhitespace = 0;
				lines = 1;
				wordStartX = 0;
				wordStartIndex = 0;
				lineStartIndex = 0;
				numWordsThisLine = 0;
				numCharsThisLine = 0;
				numBreaksThisLine = 0;
				var scale = this._fontSize / MAGIC;
				fontMinY = this._fontMinY * scale;
				fontMaxY = this._fontMaxY * scale;
				for (var i = 0; i < this._meshInfo.length; i++) {
					this._meshInfo[i].quad = 0;
					this._meshInfo[i].lines = {};
				}
				var color_r = 255;
				var color_g = 255;
				var color_b = 255;
				var outline_color_rg = 255 + 255 * 256;
				var outline_color_ba = 255 + 255 * 256;
				var outline_thickness = 0;
				var shadow_color_rg = 255 + 255 * 256;
				var shadow_color_ba = 255 + 255 * 256;
				var shadow_offset_xy = 127 + 127 * 256;
				for (var _i2 = 0; _i2 < l; _i2++) {
					_char3 = this._symbols[_i2];
					nextchar = _i2 + 1 >= l ? null : this._symbols[_i2 + 1];
					var isLineBreak = LINE_BREAK_CHAR.test(_char3);
					if (isLineBreak) {
						numBreaksThisLine++;
						if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
							breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
							wordStartIndex = _i2 + 1;
							lineStartIndex = _i2 + 1;
						}
						continue;
					}
					var x = 0;
					var y = 0;
					var advance = 0;
					var quadsize = 1;
					var dataScale = void 0,
						size = void 0;
					data = json.chars[_char3];
					if (!data) {
						if (CONTROL_CHARS.indexOf(_char3) !== -1) {
							data = CONTROL_GLYPH_DATA;
						} else {
							if (json.chars[' ']) {
								data = json.chars[' '];
							} else {
								for (var key in json.chars) {
									data = json.chars[key];
									break;
								}
							}
						}
					}
					if (data) {
						var kerning = 0;
						if (numCharsThisLine > 0) {
							var kernTable = this._font.data.kerning;
							if (kernTable) {
								var kernLeft = kernTable[string.getCodePoint(this._symbols[_i2 - 1]) || 0];
								if (kernLeft) {
									kerning = kernLeft[string.getCodePoint(this._symbols[_i2]) || 0] || 0;
								}
							}
						}
						dataScale = data.scale || 1;
						size = (data.width + data.height) / 2;
						quadsize = scale * size / dataScale;
						advance = (data.xadvance + kerning) * scale;
						x = (data.xoffset - kerning) * scale;
						y = data.yoffset * scale;
					} else {
						console.error("Couldn't substitute missing character: '" + _char3 + "'");
					}
					var isWhitespace = WHITESPACE_CHAR.test(_char3);
					var meshInfoId = data && data.map || 0;
					var ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;
					var meshInfo = this._meshInfo[meshInfoId];
					var candidateLineWidth = _x + this._spacing * advance;
					if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
						if (this._maxLines < 0 || lines < this._maxLines) {
							if (numWordsThisLine === 0) {
								wordStartIndex = _i2;
								breakLine(this._symbols, _i2, _xMinusTrailingWhitespace);
							} else {
								var backtrack = Math.max(_i2 - wordStartIndex, 0);
								if (this._meshInfo.length <= 1) {
									meshInfo.lines[lines - 1] -= backtrack;
									meshInfo.quad -= backtrack;
								} else {
									var backtrackStart = wordStartIndex;
									var backtrackEnd = _i2;
									for (var j = backtrackStart; j < backtrackEnd; j++) {
										var backChar = this._symbols[j];
										var backCharData = json.chars[backChar];
										var backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
										backMeshInfo.lines[lines - 1] -= 1;
										backMeshInfo.quad -= 1;
									}
								}
								_i2 -= backtrack + 1;
								breakLine(this._symbols, wordStartIndex, wordStartX);
								continue;
							}
						}
					}
					quad = meshInfo.quad;
					meshInfo.lines[lines - 1] = quad;
					var left = _x - x;
					var right = left + quadsize;
					var bottom = _y - y;
					var top = bottom + quadsize;
					if (this._rtl) {
						var shift = quadsize - x - this._spacing * advance - x;
						left -= shift;
						right -= shift;
					}
					meshInfo.positions[quad * 4 * 3 + 0] = left;
					meshInfo.positions[quad * 4 * 3 + 1] = bottom;
					meshInfo.positions[quad * 4 * 3 + 2] = _z;
					meshInfo.positions[quad * 4 * 3 + 3] = right;
					meshInfo.positions[quad * 4 * 3 + 4] = bottom;
					meshInfo.positions[quad * 4 * 3 + 5] = _z;
					meshInfo.positions[quad * 4 * 3 + 6] = right;
					meshInfo.positions[quad * 4 * 3 + 7] = top;
					meshInfo.positions[quad * 4 * 3 + 8] = _z;
					meshInfo.positions[quad * 4 * 3 + 9] = left;
					meshInfo.positions[quad * 4 * 3 + 10] = top;
					meshInfo.positions[quad * 4 * 3 + 11] = _z;
					this.width = Math.max(this.width, candidateLineWidth);
					var fontSize = void 0;
					if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
						fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
						fontSize = math.clamp(fontSize, minFont, maxFont);
						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}
					this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));
					if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
						fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);
						if (fontSize !== this._element.fontSize) {
							this._fontSize = fontSize;
							retryUpdateMeshes = true;
							break;
						}
					}
					_x += this._spacing * advance;
					if (!isWhitespace) {
						_xMinusTrailingWhitespace = _x;
					}
					if (this._isWordBoundary(_char3) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(_char3, nextchar) || this._isNextCJKWholeWord(nextchar))) {
						numWordsThisLine++;
						wordStartX = _xMinusTrailingWhitespace;
						wordStartIndex = _i2 + 1;
					}
					numCharsThisLine++;
					var uv = this._getUv(_char3);
					meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
					meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
					meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
					meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
					meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
					meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];
					if (this._symbolColors) {
						var colorIdx = this._symbolColors[_i2] * 3;
						color_r = this._colorPalette[colorIdx];
						color_g = this._colorPalette[colorIdx + 1];
						color_b = this._colorPalette[colorIdx + 2];
					}
					meshInfo.colors[quad * 4 * 4 + 0] = color_r;
					meshInfo.colors[quad * 4 * 4 + 1] = color_g;
					meshInfo.colors[quad * 4 * 4 + 2] = color_b;
					meshInfo.colors[quad * 4 * 4 + 3] = 255;
					meshInfo.colors[quad * 4 * 4 + 4] = color_r;
					meshInfo.colors[quad * 4 * 4 + 5] = color_g;
					meshInfo.colors[quad * 4 * 4 + 6] = color_b;
					meshInfo.colors[quad * 4 * 4 + 7] = 255;
					meshInfo.colors[quad * 4 * 4 + 8] = color_r;
					meshInfo.colors[quad * 4 * 4 + 9] = color_g;
					meshInfo.colors[quad * 4 * 4 + 10] = color_b;
					meshInfo.colors[quad * 4 * 4 + 11] = 255;
					meshInfo.colors[quad * 4 * 4 + 12] = color_r;
					meshInfo.colors[quad * 4 * 4 + 13] = color_g;
					meshInfo.colors[quad * 4 * 4 + 14] = color_b;
					meshInfo.colors[quad * 4 * 4 + 15] = 255;
					if (this._symbolOutlineParams) {
						var outlineIdx = this._symbolOutlineParams[_i2] * 5;
						outline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;
						outline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;
						outline_thickness = this._outlinePalette[outlineIdx + 4];
					}
					meshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;
					meshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;
					meshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;
					meshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;
					meshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;
					meshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;
					if (this._symbolShadowParams) {
						var shadowIdx = this._symbolShadowParams[_i2] * 6;
						shadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;
						shadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;
						shadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;
					}
					meshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;
					meshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;
					meshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;
					meshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;
					meshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;
					meshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;
					meshInfo.quad++;
				}
				if (retryUpdateMeshes) {
					continue;
				}
				if (lineStartIndex < l) {
					breakLine(this._symbols, l, _x);
				}
			}
			this._noResize = true;
			this.autoWidth = this._autoWidth;
			this.autoHeight = this._autoHeight;
			this._noResize = false;
			var hp = this._element.pivot.x;
			var vp = this._element.pivot.y;
			var ha = this._alignment.x;
			var va = this._alignment.y;
			for (var _i3 = 0; _i3 < this._meshInfo.length; _i3++) {
				if (this._meshInfo[_i3].count === 0) continue;
				var prevQuad = 0;
				for (var line in this._meshInfo[_i3].lines) {
					var index = this._meshInfo[_i3].lines[line];
					var lw = this._lineWidths[parseInt(line, 10)];
					var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
					var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);
					for (var _quad = prevQuad; _quad <= index; _quad++) {
						this._meshInfo[_i3].positions[_quad * 4 * 3] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 3] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 6] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 9] += hoffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 1] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 4] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 7] += voffset;
						this._meshInfo[_i3].positions[_quad * 4 * 3 + 10] += voffset;
					}
					if (this._rtl) {
						for (var _quad2 = prevQuad; _quad2 <= index; _quad2++) {
							var idx = _quad2 * 4 * 3;
							for (var vert = 0; vert < 4; ++vert) {
								this._meshInfo[_i3].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[_i3].positions[idx + vert * 3] + hoffset * 2;
							}
							var tmp0 = this._meshInfo[_i3].positions[idx + 3];
							var tmp1 = this._meshInfo[_i3].positions[idx + 6];
							this._meshInfo[_i3].positions[idx + 3] = this._meshInfo[_i3].positions[idx + 0];
							this._meshInfo[_i3].positions[idx + 6] = this._meshInfo[_i3].positions[idx + 9];
							this._meshInfo[_i3].positions[idx + 0] = tmp0;
							this._meshInfo[_i3].positions[idx + 9] = tmp1;
						}
					}
					prevQuad = index + 1;
				}
				var numVertices = this._meshInfo[_i3].count * 4;
				var vertMax = this._meshInfo[_i3].quad * 4;
				var it = new VertexIterator(this._meshInfo[_i3].meshInstance.mesh.vertexBuffer);
				for (var v = 0; v < numVertices; v++) {
					if (v >= vertMax) {
						it.element[SEMANTIC_POSITION].set(0, 0, 0);
						it.element[SEMANTIC_TEXCOORD0].set(0, 0);
						it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
						it.element[SEMANTIC_ATTR8].set(0, 0, 0, 0);
						it.element[SEMANTIC_ATTR9].set(0, 0, 0, 0);
					} else {
						it.element[SEMANTIC_POSITION].set(this._meshInfo[_i3].positions[v * 3 + 0], this._meshInfo[_i3].positions[v * 3 + 1], this._meshInfo[_i3].positions[v * 3 + 2]);
						it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[_i3].uvs[v * 2 + 0], this._meshInfo[_i3].uvs[v * 2 + 1]);
						it.element[SEMANTIC_COLOR].set(this._meshInfo[_i3].colors[v * 4 + 0], this._meshInfo[_i3].colors[v * 4 + 1], this._meshInfo[_i3].colors[v * 4 + 2], this._meshInfo[_i3].colors[v * 4 + 3]);
						it.element[SEMANTIC_ATTR8].set(this._meshInfo[_i3].outlines[v * 3 + 0], this._meshInfo[_i3].outlines[v * 3 + 1], this._meshInfo[_i3].outlines[v * 3 + 2]);
						it.element[SEMANTIC_ATTR9].set(this._meshInfo[_i3].shadows[v * 3 + 0], this._meshInfo[_i3].shadows[v * 3 + 1], this._meshInfo[_i3].shadows[v * 3 + 2]);
					}
					it.next();
				}
				it.end();
				this._meshInfo[_i3].meshInstance.mesh.aabb.compute(this._meshInfo[_i3].positions);
				this._meshInfo[_i3].meshInstance._aabbVer = -1;
			}
			this._aabbDirty = true;
		};
		_proto._onFontRender = function _onFontRender() {
			this.font = this._font;
		};
		_proto._onFontLoad = function _onFontLoad(asset) {
			if (this.font !== asset.resource) {
				this.font = asset.resource;
			}
		};
		_proto._onFontChange = function _onFontChange(asset, name, _new, _old) {
			if (name === 'data') {
				this._font.data = _new;
				var maps = this._font.data.info.maps.length;
				for (var i = 0; i < maps; i++) {
					if (!this._meshInfo[i]) continue;
					var mi = this._meshInfo[i].meshInstance;
					if (mi) {
						mi.setParameter('font_sdfIntensity', this._font.intensity);
						mi.setParameter('font_pxrange', this._getPxRange(this._font));
						mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
					}
				}
			}
		};
		_proto._onFontRemove = function _onFontRemove(asset) {};
		_proto._setTextureParams = function _setTextureParams(mi, texture) {
			if (this._font) {
				if (this._font.type === FONT_MSDF) {
					mi.deleteParameter('texture_emissiveMap');
					mi.deleteParameter('texture_opacityMap');
					mi.setParameter('texture_msdfMap', texture);
				} else if (this._font.type === FONT_BITMAP) {
					mi.deleteParameter('texture_msdfMap');
					mi.setParameter('texture_emissiveMap', texture);
					mi.setParameter('texture_opacityMap', texture);
				}
			}
		};
		_proto._getPxRange = function _getPxRange(font) {
			var keys = Object.keys(this._font.data.chars);
			for (var i = 0; i < keys.length; i++) {
				var _char4 = this._font.data.chars[keys[i]];
				if (_char4.range) {
					return (_char4.scale || 1) * _char4.range;
				}
			}
			return 2;
		};
		_proto._getUv = function _getUv(_char5) {
			var data = this._font.data;
			if (!data.chars[_char5]) {
				var space = ' ';
				if (data.chars[space]) {
					return this._getUv(space);
				}
				return [0, 0, 0, 0];
			}
			var map = data.chars[_char5].map;
			var width = data.info.maps[map].width;
			var height = data.info.maps[map].height;
			var x = data.chars[_char5].x;
			var y = data.chars[_char5].y;
			var x1 = x;
			var y1 = y;
			var x2 = x + data.chars[_char5].width;
			var y2 = y - data.chars[_char5].height;
			var edge = 1 - data.chars[_char5].height / height;
			return [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];
		};
		_proto.onEnable = function onEnable() {
			this._fontAsset.autoLoad = true;
			if (this._model) {
				this._element.addModelToLayers(this._model);
			}
		};
		_proto.onDisable = function onDisable() {
			this._fontAsset.autoLoad = false;
			if (this._model) {
				this._element.removeModelFromLayers(this._model);
			}
		};
		_proto._setStencil = function _setStencil(stencilParams) {
			if (this._model) {
				var instances = this._model.meshInstances;
				for (var i = 0; i < instances.length; i++) {
					instances[i].stencilFront = stencilParams;
					instances[i].stencilBack = stencilParams;
				}
			}
		};
		_proto._shouldAutoFitWidth = function _shouldAutoFitWidth() {
			return this._autoFitWidth && !this._autoWidth;
		};
		_proto._shouldAutoFitHeight = function _shouldAutoFitHeight() {
			return this._autoFitHeight && !this._autoHeight;
		};
		_proto._shouldAutoFit = function _shouldAutoFit() {
			return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
		};
		_proto._calculateCharsPerTexture = function _calculateCharsPerTexture(symbolIndex) {
			var charactersPerTexture = {};
			if (symbolIndex === undefined) {
				symbolIndex = this._symbols.length;
			}
			for (var i = 0, len = symbolIndex; i < len; i++) {
				var _char6 = this._symbols[i];
				var info = this._font.data.chars[_char6];
				if (!info) {
					info = this._font.data.chars[' '];
					if (!info) {
						info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
					}
				}
				var map = info.map;
				if (!charactersPerTexture[map]) {
					charactersPerTexture[map] = 1;
				} else {
					charactersPerTexture[map]++;
				}
			}
			return charactersPerTexture;
		};
		_proto._updateRenderRange = function _updateRenderRange() {
			var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
			var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
			for (var i = 0, len = this._meshInfo.length; i < len; i++) {
				var start = startChars[i] || 0;
				var end = endChars[i] || 0;
				var instance = this._meshInfo[i].meshInstance;
				if (instance) {
					var mesh = instance.mesh;
					if (mesh) {
						mesh.primitive[0].base = start * 3 * 2;
						mesh.primitive[0].count = (end - start) * 3 * 2;
					}
				}
			}
		};
		return _createClass(TextElement, [{
			key: "text",
			get: function get() {
				return this._text;
			},
			set: function set(value) {
				this._i18nKey = null;
				var str = value != null && value.toString() || '';
				this._setText(str);
			}
		}, {
			key: "key",
			get: function get() {
				return this._i18nKey;
			},
			set: function set(value) {
				var str = value !== null ? value.toString() : null;
				if (this._i18nKey === str) {
					return;
				}
				this._i18nKey = str;
				if (str) {
					this._fontAsset.disableLocalization = false;
					this._resetLocalizedText();
				} else {
					this._fontAsset.disableLocalization = true;
				}
			}
		}, {
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				var r = value.r;
				var g = value.g;
				var b = value.b;
				if (this._color.r === r && this._color.g === g && this._color.b === b) {
					return;
				}
				this._color.r = r;
				this._color.g = g;
				this._color.b = b;
				if (!this._model) {
					return;
				}
				if (this._symbolColors) {
					if (this._font) {
						this._updateText();
					}
				} else {
					_tempColor$1.linear(this._color);
					this._colorUniform[0] = _tempColor$1.r;
					this._colorUniform[1] = _tempColor$1.g;
					this._colorUniform[2] = _tempColor$1.b;
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter('material_emissive', this._colorUniform);
					}
				}
				if (this._element) {
					this._element.fire('set:color', this._color);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				if (this._color.a !== value) {
					this._color.a = value;
					if (this._model) {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var mi = this._model.meshInstances[i];
							mi.setParameter('material_opacity', value);
						}
					}
				}
				if (this._element) {
					this._element.fire('set:opacity', value);
				}
			}
		}, {
			key: "lineHeight",
			get: function get() {
				return this._lineHeight;
			},
			set: function set(value) {
				var _prev = this._lineHeight;
				this._lineHeight = value;
				this._scaledLineHeight = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "wrapLines",
			get: function get() {
				return this._wrapLines;
			},
			set: function set(value) {
				var _prev = this._wrapLines;
				this._wrapLines = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "lines",
			get: function get() {
				return this._lineContents;
			}
		}, {
			key: "spacing",
			get: function get() {
				return this._spacing;
			},
			set: function set(value) {
				var _prev = this._spacing;
				this._spacing = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "fontSize",
			get: function get() {
				return this._fontSize;
			},
			set: function set(value) {
				var _prev = this._fontSize;
				this._fontSize = value;
				this._originalFontSize = value;
				if (_prev !== value && this._font) {
					this._updateText();
				}
			}
		}, {
			key: "fontAsset",
			get: function get() {
				return this._fontAsset.localizedAsset;
			},
			set: function set(value) {
				this._fontAsset.defaultAsset = value;
			}
		}, {
			key: "font",
			get: function get() {
				return this._font;
			},
			set: function set(value) {
				var previousFontType;
				if (this._font) {
					previousFontType = this._font.type;
					if (this._font.off) this._font.off('render', this._onFontRender, this);
				}
				this._font = value;
				this._fontMinY = 0;
				this._fontMaxY = 0;
				if (!value) return;
				var json = this._font.data;
				for (var charId in json.chars) {
					var data = json.chars[charId];
					if (data.bounds) {
						this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
						this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
					}
				}
				if (this._font.on) this._font.on('render', this._onFontRender, this);
				if (this._fontAsset.localizedAsset) {
					var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);
					if (asset.resource !== this._font) {
						this._fontAsset.defaultAsset = null;
					}
				}
				if (value.type !== previousFontType) {
					var screenSpace = this._element._isScreenSpace();
					this._updateMaterial(screenSpace);
				}
				for (var i = 0, len = this._font.textures.length; i < len; i++) {
					if (!this._meshInfo[i]) {
						this._meshInfo[i] = new MeshInfo();
					} else {
						var mi = this._meshInfo[i].meshInstance;
						if (mi) {
							mi.setParameter('font_sdfIntensity', this._font.intensity);
							mi.setParameter('font_pxrange', this._getPxRange(this._font));
							mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
							this._setTextureParams(mi, this._font.textures[i]);
						}
					}
				}
				var removedModel = false;
				for (var _i4 = this._font.textures.length; _i4 < this._meshInfo.length; _i4++) {
					if (this._meshInfo[_i4].meshInstance) {
						if (!removedModel) {
							this._element.removeModelFromLayers(this._model);
							removedModel = true;
						}
						this._removeMeshInstance(this._meshInfo[_i4].meshInstance);
					}
				}
				if (this._meshInfo.length > this._font.textures.length) {
					this._meshInfo.length = this._font.textures.length;
				}
				this._updateText();
			}
		}, {
			key: "alignment",
			get: function get() {
				return this._alignment;
			},
			set: function set(value) {
				if (value instanceof Vec2) {
					this._alignment.set(value.x, value.y);
				} else {
					this._alignment.set(value[0], value[1]);
				}
				if (this._font) {
					this._updateText();
				}
			}
		}, {
			key: "autoWidth",
			get: function get() {
				return this._autoWidth;
			},
			set: function set(value) {
				var old = this._autoWidth;
				this._autoWidth = value;
				if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
					this._element.width = this.width;
				}
				if (old !== value) {
					var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
					if (newFontSize !== this._fontSize) {
						this._fontSize = newFontSize;
						if (this._font) {
							this._updateText();
						}
					}
				}
			}
		}, {
			key: "autoHeight",
			get: function get() {
				return this._autoHeight;
			},
			set: function set(value) {
				var old = this._autoHeight;
				this._autoHeight = value;
				if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
					this._element.height = this.height;
				}
				if (old !== value) {
					var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
					if (newFontSize !== this._fontSize) {
						this._fontSize = newFontSize;
						if (this._font) {
							this._updateText();
						}
					}
				}
			}
		}, {
			key: "rtlReorder",
			get: function get() {
				return this._rtlReorder;
			},
			set: function set(value) {
				if (this._rtlReorder !== value) {
					this._rtlReorder = value;
					if (this._font) {
						this._updateText();
					}
				}
			}
		}, {
			key: "unicodeConverter",
			get: function get() {
				return this._unicodeConverter;
			},
			set: function set(value) {
				if (this._unicodeConverter !== value) {
					this._unicodeConverter = value;
					this._setText(this._text);
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._aabbDirty) {
					var initialized = false;
					for (var i = 0; i < this._meshInfo.length; i++) {
						if (!this._meshInfo[i].meshInstance) continue;
						if (!initialized) {
							this._aabb.copy(this._meshInfo[i].meshInstance.aabb);
							initialized = true;
						} else {
							this._aabb.add(this._meshInfo[i].meshInstance.aabb);
						}
					}
					this._aabbDirty = false;
				}
				return this._aabb;
			}
		}, {
			key: "outlineColor",
			get: function get() {
				return this._outlineColor;
			},
			set: function set(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];
				if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
					return;
				}
				this._outlineColor.r = r;
				this._outlineColor.g = g;
				this._outlineColor.b = b;
				this._outlineColor.a = a;
				if (!this._model) {
					return;
				}
				if (this._symbolOutlineParams) {
					if (this._font) {
						this._updateText();
					}
				} else {
					_tempColor$1.linear(this._outlineColor);
					this._outlineColorUniform[0] = _tempColor$1.r;
					this._outlineColorUniform[1] = _tempColor$1.g;
					this._outlineColorUniform[2] = _tempColor$1.b;
					this._outlineColorUniform[3] = _tempColor$1.a;
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter('outline_color', this._outlineColorUniform);
					}
				}
				if (this._element) {
					this._element.fire('set:outline', this._color);
				}
			}
		}, {
			key: "outlineThickness",
			get: function get() {
				return this._outlineThickness;
			},
			set: function set(value) {
				var _prev = this._outlineThickness;
				this._outlineThickness = value;
				if (_prev !== value && this._font) {
					if (!this._model) {
						return;
					}
					if (this._symbolOutlineParams) {
						if (this._font) {
							this._updateText();
						}
					} else {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var mi = this._model.meshInstances[i];
							mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
						}
					}
				}
			}
		}, {
			key: "shadowColor",
			get: function get() {
				return this._shadowColor;
			},
			set: function set(value) {
				var r = value instanceof Color ? value.r : value[0];
				var g = value instanceof Color ? value.g : value[1];
				var b = value instanceof Color ? value.b : value[2];
				var a = value instanceof Color ? value.a : value[3];
				if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
					return;
				}
				this._shadowColor.r = r;
				this._shadowColor.g = g;
				this._shadowColor.b = b;
				this._shadowColor.a = a;
				if (!this._model) {
					return;
				}
				if (this._symbolShadowParams) {
					if (this._font) {
						this._updateText();
					}
				} else {
					_tempColor$1.linear(this._shadowColor);
					this._shadowColorUniform[0] = _tempColor$1.r;
					this._shadowColorUniform[1] = _tempColor$1.g;
					this._shadowColorUniform[2] = _tempColor$1.b;
					this._shadowColorUniform[3] = _tempColor$1.a;
					for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
						var mi = this._model.meshInstances[i];
						mi.setParameter('shadow_color', this._shadowColorUniform);
					}
				}
			}
		}, {
			key: "shadowOffset",
			get: function get() {
				return this._shadowOffset;
			},
			set: function set(value) {
				var x = value instanceof Vec2 ? value.x : value[0],
					y = value instanceof Vec2 ? value.y : value[1];
				if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
					return;
				}
				this._shadowOffset.set(x, y);
				if (this._font && this._model) {
					if (this._symbolShadowParams) {
						this._updateText();
					} else {
						for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
							var ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
							this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
							this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
							var mi = this._model.meshInstances[i];
							mi.setParameter('shadow_offset', this._shadowOffsetUniform);
						}
					}
				}
			}
		}, {
			key: "minFontSize",
			get: function get() {
				return this._minFontSize;
			},
			set: function set(value) {
				if (this._minFontSize === value) return;
				this._minFontSize = value;
				if (this.font && this._shouldAutoFit()) {
					this._updateText();
				}
			}
		}, {
			key: "maxFontSize",
			get: function get() {
				return this._maxFontSize;
			},
			set: function set(value) {
				if (this._maxFontSize === value) return;
				this._maxFontSize = value;
				if (this.font && this._shouldAutoFit()) {
					this._updateText();
				}
			}
		}, {
			key: "autoFitWidth",
			get: function get() {
				return this._autoFitWidth;
			},
			set: function set(value) {
				if (this._autoFitWidth === value) return;
				this._autoFitWidth = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (this.font) {
					this._updateText();
				}
			}
		}, {
			key: "autoFitHeight",
			get: function get() {
				return this._autoFitHeight;
			},
			set: function set(value) {
				if (this._autoFitHeight === value) return;
				this._autoFitHeight = value;
				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
				if (this.font) {
					this._updateText();
				}
			}
		}, {
			key: "maxLines",
			get: function get() {
				return this._maxLines;
			},
			set: function set(value) {
				if (this._maxLines === value) return;
				if (value === null && this._maxLines === -1) return;
				this._maxLines = value === null ? -1 : value;
				if (this.font && this._wrapLines) {
					this._updateText();
				}
			}
		}, {
			key: "enableMarkup",
			get: function get() {
				return this._enableMarkup;
			},
			set: function set(value) {
				value = !!value;
				if (this._enableMarkup === value) return;
				this._enableMarkup = value;
				if (this.font) {
					this._updateText();
				}
				var screenSpace = this._element._isScreenSpace();
				this._updateMaterial(screenSpace);
			}
		}, {
			key: "symbols",
			get: function get() {
				return this._symbols;
			}
		}, {
			key: "symbolColors",
			get: function get() {
				if (this._symbolColors === null) {
					return null;
				}
				return this._symbolColors.map(function (c) {
					return this._colorPalette.slice(c * 3, c * 3 + 3);
				}, this);
			}
		}, {
			key: "symbolOutlineParams",
			get: function get() {
				if (this._symbolOutlineParams === null) {
					return null;
				}
				return this._symbolOutlineParams.map(function (paramId) {
					return this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);
				}, this);
			}
		}, {
			key: "symbolShadowParams",
			get: function get() {
				if (this._symbolShadowParams === null) {
					return null;
				}
				return this._symbolShadowParams.map(function (paramId) {
					return this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);
				}, this);
			}
		}, {
			key: "rtl",
			get: function get() {
				return this._rtl;
			}
		}, {
			key: "rangeStart",
			get: function get() {
				return this._rangeStart;
			},
			set: function set(rangeStart) {
				rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));
				if (rangeStart !== this._rangeStart) {
					this._rangeStart = rangeStart;
					this._updateRenderRange();
				}
			}
		}, {
			key: "rangeEnd",
			get: function get() {
				return this._rangeEnd;
			},
			set: function set(rangeEnd) {
				rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));
				if (rangeEnd !== this._rangeEnd) {
					this._rangeEnd = rangeEnd;
					this._updateRenderRange();
				}
			}
		}]);
	}();

	var position = new Vec3();
	var invParentWtm = new Mat4();
	var vecA$2 = new Vec3();
	var vecB$2 = new Vec3();
	var matA = new Mat4();
	var matB = new Mat4();
	var matC = new Mat4();
	var matD = new Mat4();
	var ElementComponent = function (_Component) {
		function ElementComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._beingInitialized = false;
			_this._anchor = new Vec4();
			_this._localAnchor = new Vec4();
			_this._pivot = new Vec2();
			_this._width = _this._calculatedWidth = 32;
			_this._height = _this._calculatedHeight = 32;
			_this._margin = new Vec4(0, 0, -32, -32);
			_this._modelTransform = new Mat4();
			_this._screenToWorld = new Mat4();
			_this._anchorTransform = new Mat4();
			_this._anchorDirty = true;
			_this._parentWorldTransform = new Mat4();
			_this._screenTransform = new Mat4();
			_this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
			_this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
			_this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
			_this._cornersDirty = true;
			_this._canvasCornersDirty = true;
			_this._worldCornersDirty = true;
			_this.entity.on('insert', _this._onInsert, _this);
			_this._patch();
			_this.screen = null;
			_this._type = ELEMENTTYPE_GROUP;
			_this._image = null;
			_this._text = null;
			_this._group = null;
			_this._drawOrder = 0;
			_this._fitMode = FITMODE_STRETCH;
			_this._useInput = false;
			_this._layers = [LAYERID_UI];
			_this._addedModels = [];
			_this._batchGroupId = -1;
			_this._offsetReadAt = 0;
			_this._maskOffset = 0.5;
			_this._maskedBy = null;
			return _this;
		}
		_inheritsLoose(ElementComponent, _Component);
		var _proto = ElementComponent.prototype;
		_proto._setValue = function _setValue(name, value) {
			if (this._text) {
				if (this._text[name] !== value) {
					this._dirtyBatch();
				}
				this._text[name] = value;
			} else if (this._image) {
				if (this._image[name] !== value) {
					this._dirtyBatch();
				}
				this._image[name] = value;
			}
		};
		_proto._patch = function _patch() {
			this.entity._sync = this._sync;
			this.entity.setPosition = this._setPosition;
			this.entity.setLocalPosition = this._setLocalPosition;
		};
		_proto._unpatch = function _unpatch() {
			this.entity._sync = Entity.prototype._sync;
			this.entity.setPosition = Entity.prototype.setPosition;
			this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
		};
		_proto._setPosition = function _setPosition(x, y, z) {
			if (!this.element.screen) {
				Entity.prototype.setPosition.call(this, x, y, z);
				return;
			}
			if (x instanceof Vec3) {
				position.copy(x);
			} else {
				position.set(x, y, z);
			}
			this.getWorldTransform();
			invParentWtm.copy(this.element._screenToWorld).invert();
			invParentWtm.transformPoint(position, this.localPosition);
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto._setLocalPosition = function _setLocalPosition(x, y, z) {
			if (x instanceof Vec3) {
				this.localPosition.copy(x);
			} else {
				this.localPosition.set(x, y, z);
			}
			var element = this.element;
			var p = this.localPosition;
			var pvt = element._pivot;
			element._margin.x = p.x - element._calculatedWidth * pvt.x;
			element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
			element._margin.y = p.y - element._calculatedHeight * pvt.y;
			element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
			if (!this._dirtyLocal) {
				this._dirtifyLocal();
			}
		};
		_proto._sync = function _sync() {
			var element = this.element;
			var screen = element.screen;
			if (screen) {
				if (element._anchorDirty) {
					var resx = 0;
					var resy = 0;
					var px = 0;
					var py = 1;
					if (this._parent && this._parent.element) {
						resx = this._parent.element.calculatedWidth;
						resy = this._parent.element.calculatedHeight;
						px = this._parent.element.pivot.x;
						py = this._parent.element.pivot.y;
					} else {
						var resolution = screen.screen.resolution;
						resx = resolution.x / screen.screen.scale;
						resy = resolution.y / screen.screen.scale;
					}
					element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);
					element._anchorDirty = false;
					element._calculateLocalAnchors();
				}
				if (element._sizeDirty) {
					element._calculateSize(false, false);
				}
			}
			if (this._dirtyLocal) {
				this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
				var p = this.localPosition;
				var pvt = element._pivot;
				element._margin.x = p.x - element._calculatedWidth * pvt.x;
				element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
				element._margin.y = p.y - element._calculatedHeight * pvt.y;
				element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
				this._dirtyLocal = false;
			}
			if (!screen) {
				if (this._dirtyWorld) {
					element._cornersDirty = true;
					element._canvasCornersDirty = true;
					element._worldCornersDirty = true;
				}
				Entity.prototype._sync.call(this);
				return;
			}
			if (this._dirtyWorld) {
				if (this._parent === null) {
					this.worldTransform.copy(this.localTransform);
				} else {
					if (this._parent.element) {
						element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
					} else {
						element._screenToWorld.copy(element._anchorTransform);
					}
					element._modelTransform.mul2(element._screenToWorld, this.localTransform);
					if (screen) {
						element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);
						if (!screen.screen.screenSpace) {
							element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
						}
						this.worldTransform.mul2(element._screenToWorld, this.localTransform);
						var parentWorldTransform = element._parentWorldTransform;
						parentWorldTransform.setIdentity();
						var parent = this._parent;
						if (parent && parent.element && parent !== screen) {
							matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
							parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
						}
						var depthOffset = vecA$2;
						depthOffset.set(0, 0, this.localPosition.z);
						var pivotOffset = vecB$2;
						pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
						matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
						matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
						matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);
						element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);
						element._cornersDirty = true;
						element._canvasCornersDirty = true;
						element._worldCornersDirty = true;
					} else {
						this.worldTransform.copy(element._modelTransform);
					}
				}
				this._dirtyWorld = false;
			}
		};
		_proto._onInsert = function _onInsert(parent) {
			var result = this._parseUpToScreen();
			this.entity._dirtifyWorld();
			this._updateScreen(result.screen);
			this._dirtifyMask();
		};
		_proto._dirtifyMask = function _dirtifyMask() {
			var current = this.entity;
			while (current) {
				var next = current.parent;
				if ((next === null || next.screen) && current.element) {
					if (!this.system._prerender || !this.system._prerender.length) {
						this.system._prerender = [];
						this.system.app.once('prerender', this._onPrerender, this);
					}
					var i = this.system._prerender.indexOf(this.entity);
					if (i >= 0) {
						this.system._prerender.splice(i, 1);
					}
					var j = this.system._prerender.indexOf(current);
					if (j < 0) {
						this.system._prerender.push(current);
					}
				}
				current = next;
			}
		};
		_proto._onPrerender = function _onPrerender() {
			for (var i = 0; i < this.system._prerender.length; i++) {
				var mask = this.system._prerender[i];
				if (mask.element) {
					var depth = 1;
					mask.element.syncMask(depth);
				}
			}
			this.system._prerender.length = 0;
		};
		_proto._bindScreen = function _bindScreen(screen) {
			screen._bindElement(this);
		};
		_proto._unbindScreen = function _unbindScreen(screen) {
			screen._unbindElement(this);
		};
		_proto._updateScreen = function _updateScreen(screen) {
			if (this.screen && this.screen !== screen) {
				this._unbindScreen(this.screen.screen);
			}
			var previousScreen = this.screen;
			this.screen = screen;
			if (this.screen) {
				this._bindScreen(this.screen.screen);
			}
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
			this.fire('set:screen', this.screen, previousScreen);
			this._anchorDirty = true;
			var children = this.entity.children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i].element) {
					children[i].element._updateScreen(screen);
				}
			}
			if (this.screen) {
				this.screen.screen.syncDrawOrder();
			}
		};
		_proto.syncMask = function syncMask(depth) {
			var result = this._parseUpToScreen();
			this._updateMask(result.mask, depth);
		};
		_proto._setMaskedBy = function _setMaskedBy(mask) {
			var renderableElement = this._image || this._text;
			if (mask) {
				var ref = mask.element._image._maskRef;
				renderableElement == null || renderableElement._setStencil(new StencilParameters({
					ref: ref,
					func: FUNC_EQUAL
				}));
				this._maskedBy = mask;
			} else {
				renderableElement == null || renderableElement._setStencil(null);
				this._maskedBy = null;
			}
		};
		_proto._updateMask = function _updateMask(currentMask, depth) {
			if (currentMask) {
				this._setMaskedBy(currentMask);
				if (this.mask) {
					var ref = currentMask.element._image._maskRef;
					var sp = new StencilParameters({
						ref: ref,
						func: FUNC_EQUAL,
						zpass: STENCILOP_INCREMENT
					});
					this._image._setStencil(sp);
					this._image._maskRef = depth;
					depth++;
					currentMask = this.entity;
				}
				var children = this.entity.children;
				for (var i = 0, l = children.length; i < l; i++) {
					var _children$i$element;
					(_children$i$element = children[i].element) == null || _children$i$element._updateMask(currentMask, depth);
				}
				if (this.mask) depth--;
			} else {
				this._setMaskedBy(null);
				if (this.mask) {
					var _sp = new StencilParameters({
						ref: depth,
						func: FUNC_ALWAYS,
						zpass: STENCILOP_REPLACE
					});
					this._image._setStencil(_sp);
					this._image._maskRef = depth;
					depth++;
					currentMask = this.entity;
				}
				var _children = this.entity.children;
				for (var _i = 0, _l = _children.length; _i < _l; _i++) {
					var _children$_i$element;
					(_children$_i$element = _children[_i].element) == null || _children$_i$element._updateMask(currentMask, depth);
				}
				if (this.mask) {
					depth--;
				}
			}
		};
		_proto._parseUpToScreen = function _parseUpToScreen() {
			var result = {
				screen: null,
				mask: null
			};
			var parent = this.entity._parent;
			while (parent && !parent.screen) {
				if (parent.element && parent.element.mask) {
					if (!result.mask) result.mask = parent;
				}
				parent = parent.parent;
			}
			if (parent && parent.screen) {
				result.screen = parent;
			}
			return result;
		};
		_proto._onScreenResize = function _onScreenResize(res) {
			this._anchorDirty = true;
			this._cornersDirty = true;
			this._worldCornersDirty = true;
			this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
			this.fire('screen:set:resolution', res);
		};
		_proto._onScreenSpaceChange = function _onScreenSpaceChange() {
			this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
		};
		_proto._onScreenRemove = function _onScreenRemove() {
			if (this.screen) {
				if (this.screen._destroying) {
					this.screen = null;
				} else {
					this._updateScreen(null);
				}
			}
		};
		_proto._calculateLocalAnchors = function _calculateLocalAnchors() {
			var resx = 1000;
			var resy = 1000;
			var parent = this.entity._parent;
			if (parent && parent.element) {
				resx = parent.element.calculatedWidth;
				resy = parent.element.calculatedHeight;
			} else if (this.screen) {
				var res = this.screen.screen.resolution;
				var scale = this.screen.screen.scale;
				resx = res.x / scale;
				resy = res.y / scale;
			}
			this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
		};
		_proto.getOffsetPosition = function getOffsetPosition(x, y) {
			var p = this.entity.getLocalPosition().clone();
			p.x += x;
			p.y += y;
			this._screenToWorld.transformPoint(p, p);
			return p;
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._image) {
				layer.addMeshInstances(this._image._renderable.model.meshInstances);
			} else if (this._text) {
				layer.addMeshInstances(this._text._model.meshInstances);
			}
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._image) {
				layer.removeMeshInstances(this._image._renderable.model.meshInstances);
			} else if (this._text) {
				layer.removeMeshInstances(this._text._model.meshInstances);
			}
		};
		_proto.onEnable = function onEnable() {
			var scene = this.system.app.scene;
			var layers = scene.layers;
			if (this._image) {
				this._image.onEnable();
			}
			if (this._text) {
				this._text.onEnable();
			}
			if (this._group) {
				this._group.onEnable();
			}
			if (this.useInput && this.system.app.elementInput) {
				this.system.app.elementInput.addElement(this);
			}
			this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
				this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
			}
			if (this._batchGroupId >= 0) {
				var _this$system$app$batc;
				(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}
			this.fire('enableelement');
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang;
			var scene = this.system.app.scene;
			var layers = scene.layers;
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = null;
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = null;
			}
			if (this._image) this._image.onDisable();
			if (this._text) this._text.onDisable();
			if (this._group) this._group.onDisable();
			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}
			if (this._batchGroupId >= 0) {
				var _this$system$app$batc2;
				(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
			}
			this.fire('disableelement');
		};
		_proto.onRemove = function onRemove() {
			this.entity.off('insert', this._onInsert, this);
			this._unpatch();
			if (this._image) {
				this._image.destroy();
			}
			if (this._text) {
				this._text.destroy();
			}
			if (this.system.app.elementInput && this.useInput) {
				this.system.app.elementInput.removeElement(this);
			}
			if (this.screen && this.screen.screen) {
				this._unbindScreen(this.screen.screen);
				this.screen.screen.syncDrawOrder();
			}
			this.off();
		};
		_proto._calculateSize = function _calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
			if (!this.entity._parent && !this.screen) {
				return;
			}
			this._calculateLocalAnchors();
			var newWidth = this._absRight - this._absLeft;
			var newHeight = this._absTop - this._absBottom;
			if (propagateCalculatedWidth) {
				this._setWidth(newWidth);
			} else {
				this._setCalculatedWidth(newWidth, false);
			}
			if (propagateCalculatedHeight) {
				this._setHeight(newHeight);
			} else {
				this._setCalculatedHeight(newHeight, false);
			}
			var p = this.entity.getLocalPosition();
			p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
			p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
			this.entity.setLocalPosition(p);
			this._sizeDirty = false;
		};
		_proto._setWidth = function _setWidth(w) {
			this._width = w;
			this._setCalculatedWidth(w, false);
			this.fire('set:width', this._width);
		};
		_proto._setHeight = function _setHeight(h) {
			this._height = h;
			this._setCalculatedHeight(h, false);
			this.fire('set:height', this._height);
		};
		_proto._setCalculatedWidth = function _setCalculatedWidth(value, updateMargins) {
			if (Math.abs(value - this._calculatedWidth) <= 1e-4) {
				return;
			}
			this._calculatedWidth = value;
			this.entity._dirtifyLocal();
			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.x = p.x - this._calculatedWidth * pvt.x;
				this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
			}
			this._flagChildrenAsDirty();
			this.fire('set:calculatedWidth', this._calculatedWidth);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		};
		_proto._setCalculatedHeight = function _setCalculatedHeight(value, updateMargins) {
			if (Math.abs(value - this._calculatedHeight) <= 1e-4) {
				return;
			}
			this._calculatedHeight = value;
			this.entity._dirtifyLocal();
			if (updateMargins) {
				var p = this.entity.getLocalPosition();
				var pvt = this._pivot;
				this._margin.y = p.y - this._calculatedHeight * pvt.y;
				this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
			}
			this._flagChildrenAsDirty();
			this.fire('set:calculatedHeight', this._calculatedHeight);
			this.fire('resize', this._calculatedWidth, this._calculatedHeight);
		};
		_proto._flagChildrenAsDirty = function _flagChildrenAsDirty() {
			var c = this.entity._children;
			for (var i = 0, l = c.length; i < l; i++) {
				if (c[i].element) {
					c[i].element._anchorDirty = true;
					c[i].element._sizeDirty = true;
				}
			}
		};
		_proto.addModelToLayers = function addModelToLayers(model) {
			this._addedModels.push(model);
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances(model.meshInstances);
			}
		};
		_proto.removeModelFromLayers = function removeModelFromLayers(model) {
			var idx = this._addedModels.indexOf(model);
			if (idx >= 0) {
				this._addedModels.splice(idx, 1);
			}
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) {
					continue;
				}
				layer.removeMeshInstances(model.meshInstances);
			}
		};
		_proto.getMaskOffset = function getMaskOffset() {
			var frame = this.system.app.frame;
			if (this._offsetReadAt !== frame) {
				this._maskOffset = 0.5;
				this._offsetReadAt = frame;
			}
			var mo = this._maskOffset;
			this._maskOffset -= 0.001;
			return mo;
		};
		_proto.isVisibleForCamera = function isVisibleForCamera(camera) {
			var clipL, clipR, clipT, clipB;
			if (this.maskedBy) {
				var corners = this.maskedBy.element.screenCorners;
				clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
				clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
				clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
				clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
			} else {
				var sw = this.system.app.graphicsDevice.width;
				var sh = this.system.app.graphicsDevice.height;
				var cameraWidth = camera._rect.z * sw;
				var cameraHeight = camera._rect.w * sh;
				clipL = camera._rect.x * sw;
				clipR = clipL + cameraWidth;
				clipT = (1 - camera._rect.y) * sh;
				clipB = clipT - cameraHeight;
			}
			var hitCorners = this.screenCorners;
			var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
			var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
			var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
			var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));
			if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
				return false;
			}
			return true;
		};
		_proto._isScreenSpace = function _isScreenSpace() {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.screenSpace;
			}
			return false;
		};
		_proto._isScreenCulled = function _isScreenCulled() {
			if (this.screen && this.screen.screen) {
				return this.screen.screen.cull;
			}
			return false;
		};
		_proto._dirtyBatch = function _dirtyBatch() {
			if (this.batchGroupId !== -1) {
				var _this$system$app$batc3;
				(_this$system$app$batc3 = this.system.app.batcher) == null || _this$system$app$batc3.markGroupDirty(this.batchGroupId);
			}
		};
		return _createClass(ElementComponent, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this.data.enabled;
			},
			set: function set(value) {
				var data = this.data;
				var oldValue = data.enabled;
				data.enabled = value;
				this.fire('set', 'enabled', oldValue, value);
			}
		}, {
			key: "_absLeft",
			get: function get() {
				return this._localAnchor.x + this._margin.x;
			}
		}, {
			key: "_absRight",
			get: function get() {
				return this._localAnchor.z - this._margin.z;
			}
		}, {
			key: "_absTop",
			get: function get() {
				return this._localAnchor.w - this._margin.w;
			}
		}, {
			key: "_absBottom",
			get: function get() {
				return this._localAnchor.y + this._margin.y;
			}
		}, {
			key: "_hasSplitAnchorsX",
			get: function get() {
				return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
			}
		}, {
			key: "_hasSplitAnchorsY",
			get: function get() {
				return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._image) {
					return this._image.aabb;
				}
				if (this._text) {
					return this._text.aabb;
				}
				return null;
			}
		}, {
			key: "anchor",
			get: function get() {
				return this._anchor;
			},
			set: function set(value) {
				if (value instanceof Vec4) {
					this._anchor.copy(value);
				} else {
					var _this$_anchor;
					(_this$_anchor = this._anchor).set.apply(_this$_anchor, value);
				}
				if (!this.entity._parent && !this.screen) {
					this._calculateLocalAnchors();
				} else {
					this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
				}
				this._anchorDirty = true;
				if (!this.entity._dirtyLocal) {
					this.entity._dirtifyLocal();
				}
				this.fire('set:anchor', this._anchor);
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) {
					return;
				}
				if (this.entity.enabled && this._batchGroupId >= 0) {
					var _this$system$app$batc4;
					(_this$system$app$batc4 = this.system.app.batcher) == null || _this$system$app$batc4.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
					var _this$system$app$batc5;
					(_this$system$app$batc5 = this.system.app.batcher) == null || _this$system$app$batc5.insert(BatchGroup.ELEMENT, value, this.entity);
				}
				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
					if (this._image && this._image._renderable.model) {
						this.addModelToLayers(this._image._renderable.model);
					} else if (this._text && this._text._model) {
						this.addModelToLayers(this._text._model);
					}
				}
				this._batchGroupId = value;
			}
		}, {
			key: "bottom",
			get: function get() {
				return this._margin.y;
			},
			set: function set(value) {
				this._margin.y = value;
				var p = this.entity.getLocalPosition();
				var wt = this._absTop;
				var wb = this._localAnchor.y + value;
				this._setHeight(wt - wb);
				p.y = value + this._calculatedHeight * this._pivot.y;
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "calculatedWidth",
			get: function get() {
				return this._calculatedWidth;
			},
			set: function set(value) {
				this._setCalculatedWidth(value, true);
			}
		}, {
			key: "calculatedHeight",
			get: function get() {
				return this._calculatedHeight;
			},
			set: function set(value) {
				this._setCalculatedHeight(value, true);
			}
		}, {
			key: "canvasCorners",
			get: function get() {
				if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) {
					return this._canvasCorners;
				}
				var device = this.system.app.graphicsDevice;
				var screenCorners = this.screenCorners;
				var sx = device.canvas.clientWidth / device.width;
				var sy = device.canvas.clientHeight / device.height;
				for (var i = 0; i < 4; i++) {
					this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
				}
				this._canvasCornersDirty = false;
				return this._canvasCorners;
			}
		}, {
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(value) {
				var priority = 0;
				if (this.screen) {
					priority = this.screen.screen.priority;
				}
				if (value > 0xFFFFFF) {
					value = 0xFFFFFF;
				}
				this._drawOrder = (priority << 24) + value;
				this.fire('set:draworder', this._drawOrder);
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			},
			set: function set(value) {
				this._height = value;
				if (!this._hasSplitAnchorsY) {
					this._setCalculatedHeight(value, true);
				}
				this.fire('set:height', this._height);
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				if (this._addedModels.length) {
					for (var i = 0; i < this._layers.length; i++) {
						var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
						if (layer) {
							for (var j = 0; j < this._addedModels.length; j++) {
								layer.removeMeshInstances(this._addedModels[j].meshInstances);
							}
						}
					}
				}
				this._layers = value;
				if (!this.enabled || !this.entity.enabled || !this._addedModels.length) {
					return;
				}
				for (var _i2 = 0; _i2 < this._layers.length; _i2++) {
					var _layer = this.system.app.scene.layers.getLayerById(this._layers[_i2]);
					if (_layer) {
						for (var _j = 0; _j < this._addedModels.length; _j++) {
							_layer.addMeshInstances(this._addedModels[_j].meshInstances);
						}
					}
				}
			}
		}, {
			key: "left",
			get: function get() {
				return this._margin.x;
			},
			set: function set(value) {
				this._margin.x = value;
				var p = this.entity.getLocalPosition();
				var wr = this._absRight;
				var wl = this._localAnchor.x + value;
				this._setWidth(wr - wl);
				p.x = value + this._calculatedWidth * this._pivot.x;
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "margin",
			get: function get() {
				return this._margin;
			},
			set: function set(value) {
				this._margin.copy(value);
				this._calculateSize(true, true);
				this.fire('set:margin', this._margin);
			}
		}, {
			key: "maskedBy",
			get: function get() {
				return this._maskedBy;
			}
		}, {
			key: "pivot",
			get: function get() {
				return this._pivot;
			},
			set: function set(value) {
				var pivot = this.pivot,
					margin = this.margin;
				var prevX = pivot.x;
				var prevY = pivot.y;
				if (value instanceof Vec2) {
					pivot.copy(value);
				} else {
					pivot.set.apply(pivot, value);
				}
				var mx = margin.x + margin.z;
				var dx = pivot.x - prevX;
				margin.x += mx * dx;
				margin.z -= mx * dx;
				var my = margin.y + margin.w;
				var dy = pivot.y - prevY;
				margin.y += my * dy;
				margin.w -= my * dy;
				this._anchorDirty = true;
				this._cornersDirty = true;
				this._worldCornersDirty = true;
				this._calculateSize(false, false);
				this._flagChildrenAsDirty();
				this.fire('set:pivot', pivot);
			}
		}, {
			key: "right",
			get: function get() {
				return this._margin.z;
			},
			set: function set(value) {
				this._margin.z = value;
				var p = this.entity.getLocalPosition();
				var wl = this._absLeft;
				var wr = this._localAnchor.z - value;
				this._setWidth(wr - wl);
				p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "screenCorners",
			get: function get() {
				if (!this._cornersDirty || !this.screen) {
					return this._screenCorners;
				}
				var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
				this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
				this._screenCorners[1].set(this._absRight, this._absBottom, 0);
				this._screenCorners[2].set(this._absRight, this._absTop, 0);
				this._screenCorners[3].set(this._absLeft, this._absTop, 0);
				var screenSpace = this.screen.screen.screenSpace;
				for (var i = 0; i < 4; i++) {
					this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
					if (screenSpace) {
						this._screenCorners[i].mulScalar(this.screen.screen.scale);
					}
					if (parentBottomLeft) {
						this._screenCorners[i].add(parentBottomLeft);
					}
				}
				this._cornersDirty = false;
				this._canvasCornersDirty = true;
				this._worldCornersDirty = true;
				return this._screenCorners;
			}
		}, {
			key: "textWidth",
			get: function get() {
				return this._text ? this._text.width : 0;
			}
		}, {
			key: "textHeight",
			get: function get() {
				return this._text ? this._text.height : 0;
			}
		}, {
			key: "top",
			get: function get() {
				return this._margin.w;
			},
			set: function set(value) {
				this._margin.w = value;
				var p = this.entity.getLocalPosition();
				var wb = this._absBottom;
				var wt = this._localAnchor.w - value;
				this._setHeight(wt - wb);
				p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
				this.entity.setLocalPosition(p);
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (value !== this._type) {
					this._type = value;
					if (this._image) {
						this._image.destroy();
						this._image = null;
					}
					if (this._text) {
						this._text.destroy();
						this._text = null;
					}
					if (value === ELEMENTTYPE_IMAGE) {
						this._image = new ImageElement(this);
					} else if (value === ELEMENTTYPE_TEXT) {
						this._text = new TextElement(this);
					}
				}
			}
		}, {
			key: "useInput",
			get: function get() {
				return this._useInput;
			},
			set: function set(value) {
				if (this._useInput === value) {
					return;
				}
				this._useInput = value;
				if (this.system.app.elementInput) {
					if (value) {
						if (this.enabled && this.entity.enabled) {
							this.system.app.elementInput.addElement(this);
						}
					} else {
						this.system.app.elementInput.removeElement(this);
					}
				} else {
					if (this._useInput === true) ;
				}
				this.fire('set:useInput', value);
			}
		}, {
			key: "fitMode",
			get: function get() {
				return this._fitMode;
			},
			set: function set(value) {
				this._fitMode = value;
				this._calculateSize(true, true);
				if (this._image) {
					this._image.refreshMesh();
				}
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				this._width = value;
				if (!this._hasSplitAnchorsX) {
					this._setCalculatedWidth(value, true);
				}
				this.fire('set:width', this._width);
			}
		}, {
			key: "worldCorners",
			get: function get() {
				if (!this._worldCornersDirty) {
					return this._worldCorners;
				}
				if (this.screen) {
					var screenCorners = this.screenCorners;
					if (!this.screen.screen.screenSpace) {
						matA.copy(this.screen.screen._screenMatrix);
						matA.data[13] = -matA.data[13];
						matA.mul2(this.screen.getWorldTransform(), matA);
						for (var i = 0; i < 4; i++) {
							matA.transformPoint(screenCorners[i], this._worldCorners[i]);
						}
					}
				} else {
					var localPos = this.entity.getLocalPosition();
					matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
					matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
					matC.setTranslate(localPos.x, localPos.y, localPos.z);
					var entity = this.entity.parent ? this.entity.parent : this.entity;
					matD.copy(entity.getWorldTransform());
					matD.mul(matC).mul(matB).mul(matA);
					vecA$2.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[0]);
					vecA$2.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[1]);
					vecA$2.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[2]);
					vecA$2.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
					matD.transformPoint(vecA$2, this._worldCorners[3]);
				}
				this._worldCornersDirty = false;
				return this._worldCorners;
			}
		}, {
			key: "fontSize",
			get: function get() {
				if (this._text) {
					return this._text.fontSize;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('fontSize', arg);
			}
		}, {
			key: "minFontSize",
			get: function get() {
				if (this._text) {
					return this._text.minFontSize;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('minFontSize', arg);
			}
		}, {
			key: "maxFontSize",
			get: function get() {
				if (this._text) {
					return this._text.maxFontSize;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('maxFontSize', arg);
			}
		}, {
			key: "maxLines",
			get: function get() {
				if (this._text) {
					return this._text.maxLines;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('maxLines', arg);
			}
		}, {
			key: "autoFitWidth",
			get: function get() {
				if (this._text) {
					return this._text.autoFitWidth;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('autoFitWidth', arg);
			}
		}, {
			key: "autoFitHeight",
			get: function get() {
				if (this._text) {
					return this._text.autoFitHeight;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('autoFitHeight', arg);
			}
		}, {
			key: "color",
			get: function get() {
				if (this._text) {
					return this._text.color;
				}
				if (this._image) {
					return this._image.color;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('color', arg);
			}
		}, {
			key: "font",
			get: function get() {
				if (this._text) {
					return this._text.font;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('font', arg);
			}
		}, {
			key: "fontAsset",
			get: function get() {
				if (this._text && typeof this._text.fontAsset === 'number') {
					return this._text.fontAsset;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('fontAsset', arg);
			}
		}, {
			key: "spacing",
			get: function get() {
				if (this._text) {
					return this._text.spacing;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('spacing', arg);
			}
		}, {
			key: "lineHeight",
			get: function get() {
				if (this._text) {
					return this._text.lineHeight;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('lineHeight', arg);
			}
		}, {
			key: "wrapLines",
			get: function get() {
				if (this._text) {
					return this._text.wrapLines;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('wrapLines', arg);
			}
		}, {
			key: "lines",
			get: function get() {
				if (this._text) {
					return this._text.lines;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('lines', arg);
			}
		}, {
			key: "alignment",
			get: function get() {
				if (this._text) {
					return this._text.alignment;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('alignment', arg);
			}
		}, {
			key: "autoWidth",
			get: function get() {
				if (this._text) {
					return this._text.autoWidth;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('autoWidth', arg);
			}
		}, {
			key: "autoHeight",
			get: function get() {
				if (this._text) {
					return this._text.autoHeight;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('autoHeight', arg);
			}
		}, {
			key: "rtlReorder",
			get: function get() {
				if (this._text) {
					return this._text.rtlReorder;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('rtlReorder', arg);
			}
		}, {
			key: "unicodeConverter",
			get: function get() {
				if (this._text) {
					return this._text.unicodeConverter;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('unicodeConverter', arg);
			}
		}, {
			key: "text",
			get: function get() {
				if (this._text) {
					return this._text.text;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('text', arg);
			}
		}, {
			key: "key",
			get: function get() {
				if (this._text) {
					return this._text.key;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('key', arg);
			}
		}, {
			key: "texture",
			get: function get() {
				if (this._image) {
					return this._image.texture;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('texture', arg);
			}
		}, {
			key: "textureAsset",
			get: function get() {
				if (this._image) {
					return this._image.textureAsset;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('textureAsset', arg);
			}
		}, {
			key: "material",
			get: function get() {
				if (this._image) {
					return this._image.material;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('material', arg);
			}
		}, {
			key: "materialAsset",
			get: function get() {
				if (this._image) {
					return this._image.materialAsset;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('materialAsset', arg);
			}
		}, {
			key: "sprite",
			get: function get() {
				if (this._image) {
					return this._image.sprite;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('sprite', arg);
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				if (this._image) {
					return this._image.spriteAsset;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('spriteAsset', arg);
			}
		}, {
			key: "spriteFrame",
			get: function get() {
				if (this._image) {
					return this._image.spriteFrame;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('spriteFrame', arg);
			}
		}, {
			key: "pixelsPerUnit",
			get: function get() {
				if (this._image) {
					return this._image.pixelsPerUnit;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('pixelsPerUnit', arg);
			}
		}, {
			key: "opacity",
			get: function get() {
				if (this._text) {
					return this._text.opacity;
				}
				if (this._image) {
					return this._image.opacity;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('opacity', arg);
			}
		}, {
			key: "rect",
			get: function get() {
				if (this._image) {
					return this._image.rect;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('rect', arg);
			}
		}, {
			key: "mask",
			get: function get() {
				if (this._image) {
					return this._image.mask;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('mask', arg);
			}
		}, {
			key: "outlineColor",
			get: function get() {
				if (this._text) {
					return this._text.outlineColor;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('outlineColor', arg);
			}
		}, {
			key: "outlineThickness",
			get: function get() {
				if (this._text) {
					return this._text.outlineThickness;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('outlineThickness', arg);
			}
		}, {
			key: "shadowColor",
			get: function get() {
				if (this._text) {
					return this._text.shadowColor;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('shadowColor', arg);
			}
		}, {
			key: "shadowOffset",
			get: function get() {
				if (this._text) {
					return this._text.shadowOffset;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('shadowOffset', arg);
			}
		}, {
			key: "enableMarkup",
			get: function get() {
				if (this._text) {
					return this._text.enableMarkup;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('enableMarkup', arg);
			}
		}, {
			key: "rangeStart",
			get: function get() {
				if (this._text) {
					return this._text.rangeStart;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('rangeStart', arg);
			}
		}, {
			key: "rangeEnd",
			get: function get() {
				if (this._text) {
					return this._text.rangeEnd;
				}
				return null;
			},
			set: function set(arg) {
				this._setValue('rangeEnd', arg);
			}
		}]);
	}(Component);
	ElementComponent.EVENT_MOUSEDOWN = 'mousedown';
	ElementComponent.EVENT_MOUSEUP = 'mouseup';
	ElementComponent.EVENT_MOUSEENTER = 'mouseenter';
	ElementComponent.EVENT_MOUSELEAVE = 'mouseleave';
	ElementComponent.EVENT_MOUSEMOVE = 'mousemove';
	ElementComponent.EVENT_MOUSEWHEEL = 'mousewheel';
	ElementComponent.EVENT_CLICK = 'click';
	ElementComponent.EVENT_TOUCHSTART = 'touchstart';
	ElementComponent.EVENT_TOUCHEND = 'touchend';
	ElementComponent.EVENT_TOUCHMOVE = 'touchmove';
	ElementComponent.EVENT_TOUCHCANCEL = 'touchcancel';

	var ElementComponentData = function ElementComponentData() {
		this.enabled = true;
	};

	var _schema$f = ['enabled'];
	var ElementComponentSystem = function (_ComponentSystem) {
		function ElementComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'element';
			_this.ComponentType = ElementComponent;
			_this.DataType = ElementComponentData;
			_this.schema = _schema$f;
			_this._unicodeConverter = null;
			_this._rtlReorder = null;
			_this._defaultTexture = new Texture(app.graphicsDevice, {
				width: 1,
				height: 1,
				format: PIXELFORMAT_RGBA8,
				name: 'element-system'
			});
			var pixels = _this._defaultTexture.lock();
			var pixelData = new Uint8Array(4);
			pixelData[0] = 255.0;
			pixelData[1] = 255.0;
			pixelData[2] = 255.0;
			pixelData[3] = 255.0;
			pixels.set(pixelData);
			_this._defaultTexture.unlock();
			_this.defaultImageMaterial = null;
			_this.defaultImage9SlicedMaterial = null;
			_this.defaultImage9TiledMaterial = null;
			_this.defaultImageMaskMaterial = null;
			_this.defaultImage9SlicedMaskMaterial = null;
			_this.defaultImage9TiledMaskMaterial = null;
			_this.defaultScreenSpaceImageMaterial = null;
			_this.defaultScreenSpaceImage9SlicedMaterial = null;
			_this.defaultScreenSpaceImage9TiledMaterial = null;
			_this.defaultScreenSpaceImageMask9SlicedMaterial = null;
			_this.defaultScreenSpaceImageMask9TiledMaterial = null;
			_this.defaultScreenSpaceImageMaskMaterial = null;
			_this._defaultTextMaterials = {};
			_this.defaultImageMaterials = [];
			_this.on('beforeremove', _this.onRemoveComponent, _this);
			return _this;
		}
		_inheritsLoose(ElementComponentSystem, _ComponentSystem);
		var _proto = ElementComponentSystem.prototype;
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this._defaultTexture.destroy();
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component._beingInitialized = true;
			if (data.anchor !== undefined) {
				if (data.anchor instanceof Vec4) {
					component.anchor.copy(data.anchor);
				} else {
					component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
				}
			}
			if (data.pivot !== undefined) {
				if (data.pivot instanceof Vec2) {
					component.pivot.copy(data.pivot);
				} else {
					component.pivot.set(data.pivot[0], data.pivot[1]);
				}
			}
			var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
			var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
			var _marginChange = false;
			var color;
			if (data.margin !== undefined) {
				if (data.margin instanceof Vec4) {
					component.margin.copy(data.margin);
				} else {
					component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
				}
				_marginChange = true;
			}
			if (data.left !== undefined) {
				component._margin.x = data.left;
				_marginChange = true;
			}
			if (data.bottom !== undefined) {
				component._margin.y = data.bottom;
				_marginChange = true;
			}
			if (data.right !== undefined) {
				component._margin.z = data.right;
				_marginChange = true;
			}
			if (data.top !== undefined) {
				component._margin.w = data.top;
				_marginChange = true;
			}
			if (_marginChange) {
				component.margin = component._margin;
			}
			var shouldForceSetAnchor = false;
			if (data.width !== undefined && !splitHorAnchors) {
				component.width = data.width;
			} else if (splitHorAnchors) {
				shouldForceSetAnchor = true;
			}
			if (data.height !== undefined && !splitVerAnchors) {
				component.height = data.height;
			} else if (splitVerAnchors) {
				shouldForceSetAnchor = true;
			}
			if (shouldForceSetAnchor) {
				component.anchor = component.anchor;
			}
			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}
			if (data.useInput !== undefined) {
				component.useInput = data.useInput;
			}
			if (data.fitMode !== undefined) {
				component.fitMode = data.fitMode;
			}
			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}
			if (data.type !== undefined) {
				component.type = data.type;
			}
			if (component.type === ELEMENTTYPE_IMAGE) {
				if (data.rect !== undefined) {
					component.rect = data.rect;
				}
				if (data.color !== undefined) {
					color = data.color;
					if (!(color instanceof Color)) {
						color = new Color(data.color[0], data.color[1], data.color[2]);
					}
					component.color = color;
				}
				if (data.opacity !== undefined) component.opacity = data.opacity;
				if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
				if (data.texture) component.texture = data.texture;
				if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
				if (data.sprite) component.sprite = data.sprite;
				if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
				if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
				if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
				if (data.material) component.material = data.material;
				if (data.mask !== undefined) {
					component.mask = data.mask;
				}
			} else if (component.type === ELEMENTTYPE_TEXT) {
				if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
				if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
				if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
				if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;
				if (data.text !== null && data.text !== undefined) {
					component.text = data.text;
				} else if (data.key !== null && data.key !== undefined) {
					component.key = data.key;
				}
				if (data.color !== undefined) {
					color = data.color;
					if (!(color instanceof Color)) {
						color = new Color(color[0], color[1], color[2]);
					}
					component.color = color;
				}
				if (data.opacity !== undefined) {
					component.opacity = data.opacity;
				}
				if (data.spacing !== undefined) component.spacing = data.spacing;
				if (data.fontSize !== undefined) {
					component.fontSize = data.fontSize;
					if (!data.lineHeight) component.lineHeight = data.fontSize;
				}
				if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
				if (data.maxLines !== undefined) component.maxLines = data.maxLines;
				if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
				if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
				if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
				if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
				if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
				if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
				if (data.font !== undefined) component.font = data.font;
				if (data.alignment !== undefined) component.alignment = data.alignment;
				if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
				if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
				if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
				if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
				if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
			}
			var result = component._parseUpToScreen();
			if (result.screen) {
				component._updateScreen(result.screen);
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
			component._beingInitialized = false;
			if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
				component._image._updateMesh(component._image.mesh);
			}
		};
		_proto.onRemoveComponent = function onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.element;
			var data = {
				enabled: source.enabled,
				width: source.width,
				height: source.height,
				anchor: source.anchor.clone(),
				pivot: source.pivot.clone(),
				margin: source.margin.clone(),
				alignment: source.alignment && source.alignment.clone() || source.alignment,
				autoWidth: source.autoWidth,
				autoHeight: source.autoHeight,
				type: source.type,
				rect: source.rect && source.rect.clone() || source.rect,
				rtlReorder: source.rtlReorder,
				unicodeConverter: source.unicodeConverter,
				materialAsset: source.materialAsset,
				material: source.material,
				color: source.color && source.color.clone() || source.color,
				opacity: source.opacity,
				textureAsset: source.textureAsset,
				texture: source.texture,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				spriteFrame: source.spriteFrame,
				pixelsPerUnit: source.pixelsPerUnit,
				spacing: source.spacing,
				lineHeight: source.lineHeight,
				wrapLines: source.wrapLines,
				layers: source.layers,
				fontSize: source.fontSize,
				minFontSize: source.minFontSize,
				maxFontSize: source.maxFontSize,
				autoFitWidth: source.autoFitWidth,
				autoFitHeight: source.autoFitHeight,
				maxLines: source.maxLines,
				fontAsset: source.fontAsset,
				font: source.font,
				useInput: source.useInput,
				fitMode: source.fitMode,
				batchGroupId: source.batchGroupId,
				mask: source.mask,
				outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
				outlineThickness: source.outlineThickness,
				shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
				shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
				enableMarkup: source.enableMarkup
			};
			if (source.key !== undefined && source.key !== null) {
				data.key = source.key;
			} else {
				data.text = source.text;
			}
			return this.addComponent(clone, data);
		};
		_proto.getTextElementMaterial = function getTextElementMaterial(screenSpace, msdf, textAttibutes) {
			var hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);
			var material = this._defaultTextMaterials[hash];
			if (material) {
				return material;
			}
			var name = 'TextMaterial';
			material = new StandardMaterial();
			if (msdf) {
				material.msdfMap = this._defaultTexture;
				material.msdfTextAttribute = textAttibutes;
				material.emissive.set(1, 1, 1);
			} else {
				name = "Bitmap" + name;
				material.emissive.set(1, 1, 1);
				material.emissiveMap = this._defaultTexture;
				material.opacityMap = this._defaultTexture;
				material.opacityMapChannel = 'a';
			}
			if (screenSpace) {
				name = "ScreenSpace" + name;
				material.depthTest = false;
			}
			material.name = "default" + name;
			material.useLighting = false;
			material.useTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.diffuse.set(0, 0, 0);
			material.opacity = 0.5;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			material.emissiveVertexColor = true;
			material.update();
			this._defaultTextMaterials[hash] = material;
			return material;
		};
		_proto._createBaseImageMaterial = function _createBaseImageMaterial() {
			var material = new StandardMaterial();
			material.diffuse.set(0, 0, 0);
			material.emissive.set(1, 1, 1);
			material.emissiveMap = this._defaultTexture;
			material.opacityMap = this._defaultTexture;
			material.opacityMapChannel = 'a';
			material.useLighting = false;
			material.useTonemap = false;
			material.useFog = false;
			material.useSkybox = false;
			material.blendType = BLEND_PREMULTIPLIED;
			material.depthWrite = false;
			return material;
		};
		_proto.getImageElementMaterial = function getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
			if (screenSpace) {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
							this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMask9SlicedMaterial.name = 'defaultScreenSpaceImageMask9SlicedMaterial';
							this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
						}
						return this.defaultScreenSpaceImageMask9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
							this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
							this.defaultScreenSpaceImageMask9TiledMaterial.name = 'defaultScreenSpaceImageMask9TiledMaterial';
							this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMask9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
						}
						return this.defaultScreenSpaceImageMask9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaskMaterial) {
							this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaskMaterial.name = 'defaultScreenSpaceImageMaskMaterial';
							this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
							this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
							this.defaultScreenSpaceImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
						}
						return this.defaultScreenSpaceImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultScreenSpaceImage9SlicedMaterial) {
							this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9SlicedMaterial.name = 'defaultScreenSpaceImage9SlicedMaterial';
							this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
							this.defaultScreenSpaceImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
						}
						return this.defaultScreenSpaceImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultScreenSpaceImage9TiledMaterial) {
							this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImage9TiledMaterial.name = 'defaultScreenSpaceImage9TiledMaterial';
							this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
							this.defaultScreenSpaceImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
						}
						return this.defaultScreenSpaceImage9TiledMaterial;
					} else {
						if (!this.defaultScreenSpaceImageMaterial) {
							this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
							this.defaultScreenSpaceImageMaterial.name = 'defaultScreenSpaceImageMaterial';
							this.defaultScreenSpaceImageMaterial.depthTest = false;
							this.defaultScreenSpaceImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
						}
						return this.defaultScreenSpaceImageMaterial;
					}
				}
			} else {
				if (mask) {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaskMaterial) {
							this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaskMaterial.name = 'defaultImage9SlicedMaskMaterial';
							this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
							this.defaultImage9SlicedMaskMaterial.redWrite = false;
							this.defaultImage9SlicedMaskMaterial.greenWrite = false;
							this.defaultImage9SlicedMaskMaterial.blueWrite = false;
							this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
							this.defaultImage9SlicedMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
						}
						return this.defaultImage9SlicedMaskMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaskMaterial) {
							this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaskMaterial.name = 'defaultImage9TiledMaskMaterial';
							this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaskMaterial.alphaTest = 1;
							this.defaultImage9TiledMaskMaterial.redWrite = false;
							this.defaultImage9TiledMaskMaterial.greenWrite = false;
							this.defaultImage9TiledMaskMaterial.blueWrite = false;
							this.defaultImage9TiledMaskMaterial.alphaWrite = false;
							this.defaultImage9TiledMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
						}
						return this.defaultImage9TiledMaskMaterial;
					} else {
						if (!this.defaultImageMaskMaterial) {
							this.defaultImageMaskMaterial = this._createBaseImageMaterial();
							this.defaultImageMaskMaterial.name = 'defaultImageMaskMaterial';
							this.defaultImageMaskMaterial.alphaTest = 1;
							this.defaultImageMaskMaterial.redWrite = false;
							this.defaultImageMaskMaterial.greenWrite = false;
							this.defaultImageMaskMaterial.blueWrite = false;
							this.defaultImageMaskMaterial.alphaWrite = false;
							this.defaultImageMaskMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
						}
						return this.defaultImageMaskMaterial;
					}
				} else {
					if (nineSliced) {
						if (!this.defaultImage9SlicedMaterial) {
							this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
							this.defaultImage9SlicedMaterial.name = 'defaultImage9SlicedMaterial';
							this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
							this.defaultImage9SlicedMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
						}
						return this.defaultImage9SlicedMaterial;
					} else if (nineSliceTiled) {
						if (!this.defaultImage9TiledMaterial) {
							this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
							this.defaultImage9TiledMaterial.name = 'defaultImage9TiledMaterial';
							this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
							this.defaultImage9TiledMaterial.update();
							this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
						}
						return this.defaultImage9TiledMaterial;
					} else {
						if (!this.defaultImageMaterial) {
							this.defaultImageMaterial = this._createBaseImageMaterial();
							this.defaultImageMaterial.name = 'defaultImageMaterial';
							this.defaultImageMaterial.update();
							this.defaultImageMaterials.push(this.defaultImageMaterial);
						}
						return this.defaultImageMaterial;
					}
				}
			}
		};
		_proto.registerUnicodeConverter = function registerUnicodeConverter(func) {
			this._unicodeConverter = func;
		};
		_proto.registerRtlReorder = function registerRtlReorder(func) {
			this._rtlReorder = func;
		};
		_proto.getUnicodeConverter = function getUnicodeConverter() {
			return this._unicodeConverter;
		};
		_proto.getRtlReorder = function getRtlReorder() {
			return this._rtlReorder;
		};
		return ElementComponentSystem;
	}(ComponentSystem);

	var MOTION_FREE = 'free';
	var MOTION_LIMITED = 'limited';
	var MOTION_LOCKED = 'locked';

	var properties$1 = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];
	var JointComponent = function (_Component) {
		function JointComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._constraint = null;
			_this._entityA = null;
			_this._entityB = null;
			_this._breakForce = 3.4e+38;
			_this._enableCollision = true;
			_this._linearMotionX = MOTION_LOCKED;
			_this._linearLimitsX = new Vec2(0, 0);
			_this._linearSpringX = false;
			_this._linearStiffnessX = 0;
			_this._linearDampingX = 1;
			_this._linearEquilibriumX = 0;
			_this._linearMotionY = MOTION_LOCKED;
			_this._linearLimitsY = new Vec2(0, 0);
			_this._linearSpringY = false;
			_this._linearStiffnessY = 0;
			_this._linearDampingY = 1;
			_this._linearEquilibriumY = 0;
			_this._linearMotionZ = MOTION_LOCKED;
			_this._linearLimitsZ = new Vec2(0, 0);
			_this._linearSpringZ = false;
			_this._linearStiffnessZ = 0;
			_this._linearDampingZ = 1;
			_this._linearEquilibriumZ = 0;
			_this._angularMotionX = MOTION_LOCKED;
			_this._angularLimitsX = new Vec2(0, 0);
			_this._angularSpringX = false;
			_this._angularStiffnessX = 0;
			_this._angularDampingX = 1;
			_this._angularEquilibriumX = 0;
			_this._angularMotionY = MOTION_LOCKED;
			_this._angularLimitsY = new Vec2(0, 0);
			_this._angularSpringY = false;
			_this._angularStiffnessY = 0;
			_this._angularDampingY = 1;
			_this._angularEquilibriumY = 0;
			_this._angularMotionZ = MOTION_LOCKED;
			_this._angularLimitsZ = new Vec2(0, 0);
			_this._angularSpringZ = false;
			_this._angularEquilibriumZ = 0;
			_this._angularDampingZ = 1;
			_this._angularStiffnessZ = 0;
			_this.on('set_enabled', _this._onSetEnabled, _this);
			return _this;
		}
		_inheritsLoose(JointComponent, _Component);
		var _proto = JointComponent.prototype;
		_proto._convertTransform = function _convertTransform(pcTransform, ammoTransform) {
			var pos = pcTransform.getTranslation();
			var rot = new Quat();
			rot.setFromMat4(pcTransform);
			var ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
			var ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
			ammoTransform.setOrigin(ammoVec);
			ammoTransform.setRotation(ammoQuat);
			Ammo.destroy(ammoVec);
			Ammo.destroy(ammoQuat);
		};
		_proto._updateAngularLimits = function _updateAngularLimits() {
			var constraint = this._constraint;
			if (constraint) {
				var lx, ly, lz, ux, uy, uz;
				if (this._angularMotionX === MOTION_LIMITED) {
					lx = this._angularLimitsX.x * math.DEG_TO_RAD;
					ux = this._angularLimitsX.y * math.DEG_TO_RAD;
				} else if (this._angularMotionX === MOTION_FREE) {
					lx = 1;
					ux = 0;
				} else {
					lx = ux = 0;
				}
				if (this._angularMotionY === MOTION_LIMITED) {
					ly = this._angularLimitsY.x * math.DEG_TO_RAD;
					uy = this._angularLimitsY.y * math.DEG_TO_RAD;
				} else if (this._angularMotionY === MOTION_FREE) {
					ly = 1;
					uy = 0;
				} else {
					ly = uy = 0;
				}
				if (this._angularMotionZ === MOTION_LIMITED) {
					lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
					uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
				} else if (this._angularMotionZ === MOTION_FREE) {
					lz = 1;
					uz = 0;
				} else {
					lz = uz = 0;
				}
				var limits = new Ammo.btVector3(lx, ly, lz);
				constraint.setAngularLowerLimit(limits);
				limits.setValue(ux, uy, uz);
				constraint.setAngularUpperLimit(limits);
				Ammo.destroy(limits);
			}
		};
		_proto._updateLinearLimits = function _updateLinearLimits() {
			var constraint = this._constraint;
			if (constraint) {
				var lx, ly, lz, ux, uy, uz;
				if (this._linearMotionX === MOTION_LIMITED) {
					lx = this._linearLimitsX.x;
					ux = this._linearLimitsX.y;
				} else if (this._linearMotionX === MOTION_FREE) {
					lx = 1;
					ux = 0;
				} else {
					lx = ux = 0;
				}
				if (this._linearMotionY === MOTION_LIMITED) {
					ly = this._linearLimitsY.x;
					uy = this._linearLimitsY.y;
				} else if (this._linearMotionY === MOTION_FREE) {
					ly = 1;
					uy = 0;
				} else {
					ly = uy = 0;
				}
				if (this._linearMotionZ === MOTION_LIMITED) {
					lz = this._linearLimitsZ.x;
					uz = this._linearLimitsZ.y;
				} else if (this._linearMotionZ === MOTION_FREE) {
					lz = 1;
					uz = 0;
				} else {
					lz = uz = 0;
				}
				var limits = new Ammo.btVector3(lx, ly, lz);
				constraint.setLinearLowerLimit(limits);
				limits.setValue(ux, uy, uz);
				constraint.setLinearUpperLimit(limits);
				Ammo.destroy(limits);
			}
		};
		_proto._createConstraint = function _createConstraint() {
			if (this._entityA && this._entityA.rigidbody) {
				this._destroyConstraint();
				var mat = new Mat4();
				var bodyA = this._entityA.rigidbody.body;
				bodyA.activate();
				var jointWtm = this.entity.getWorldTransform();
				var entityAWtm = this._entityA.getWorldTransform();
				var invEntityAWtm = entityAWtm.clone().invert();
				mat.mul2(invEntityAWtm, jointWtm);
				var frameA = new Ammo.btTransform();
				this._convertTransform(mat, frameA);
				if (this._entityB && this._entityB.rigidbody) {
					var bodyB = this._entityB.rigidbody.body;
					bodyB.activate();
					var entityBWtm = this._entityB.getWorldTransform();
					var invEntityBWtm = entityBWtm.clone().invert();
					mat.mul2(invEntityBWtm, jointWtm);
					var frameB = new Ammo.btTransform();
					this._convertTransform(mat, frameB);
					this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
					Ammo.destroy(frameB);
				} else {
					this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
				}
				Ammo.destroy(frameA);
				var axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];
				for (var i = 0; i < 6; i++) {
					var type = i < 3 ? '_linear' : '_angular';
					this._constraint.enableSpring(i, this[type + "Spring" + axis[i]]);
					this._constraint.setDamping(i, this[type + "Damping" + axis[i]]);
					this._constraint.setEquilibriumPoint(i, this[type + "Equilibrium" + axis[i]]);
					this._constraint.setStiffness(i, this[type + "Stiffness" + axis[i]]);
				}
				this._constraint.setBreakingImpulseThreshold(this._breakForce);
				this._updateLinearLimits();
				this._updateAngularLimits();
				var app = this.system.app;
				var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
				dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
			}
		};
		_proto._destroyConstraint = function _destroyConstraint() {
			if (this._constraint) {
				var app = this.system.app;
				var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
				dynamicsWorld.removeConstraint(this._constraint);
				Ammo.destroy(this._constraint);
				this._constraint = null;
			}
		};
		_proto.initFromData = function initFromData(data) {
			for (var _i = 0, _properties = properties$1; _i < _properties.length; _i++) {
				var prop = _properties[_i];
				if (data.hasOwnProperty(prop)) {
					if (data[prop] instanceof Vec2) {
						this["_" + prop].copy(data[prop]);
					} else {
						this["_" + prop] = data[prop];
					}
				}
			}
			this._createConstraint();
		};
		_proto.onEnable = function onEnable() {
			this._createConstraint();
		};
		_proto.onDisable = function onDisable() {
			this._destroyConstraint();
		};
		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {};
		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
		};
		return _createClass(JointComponent, [{
			key: "entityA",
			get: function get() {
				return this._entityA;
			},
			set: function set(body) {
				this._destroyConstraint();
				this._entityA = body;
				this._createConstraint();
			}
		}, {
			key: "entityB",
			get: function get() {
				return this._entityB;
			},
			set: function set(body) {
				this._destroyConstraint();
				this._entityB = body;
				this._createConstraint();
			}
		}, {
			key: "breakForce",
			get: function get() {
				return this._breakForce;
			},
			set: function set(force) {
				if (this._constraint && this._breakForce !== force) {
					this._constraint.setBreakingImpulseThreshold(force);
					this._breakForce = force;
				}
			}
		}, {
			key: "enableCollision",
			get: function get() {
				return this._enableCollision;
			},
			set: function set(enableCollision) {
				this._destroyConstraint();
				this._enableCollision = enableCollision;
				this._createConstraint();
			}
		}, {
			key: "angularLimitsX",
			get: function get() {
				return this._angularLimitsX;
			},
			set: function set(limits) {
				if (!this._angularLimitsX.equals(limits)) {
					this._angularLimitsX.copy(limits);
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionX",
			get: function get() {
				return this._angularMotionX;
			},
			set: function set(value) {
				if (this._angularMotionX !== value) {
					this._angularMotionX = value;
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularLimitsY",
			get: function get() {
				return this._angularLimitsY;
			},
			set: function set(limits) {
				if (!this._angularLimitsY.equals(limits)) {
					this._angularLimitsY.copy(limits);
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionY",
			get: function get() {
				return this._angularMotionY;
			},
			set: function set(value) {
				if (this._angularMotionY !== value) {
					this._angularMotionY = value;
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularLimitsZ",
			get: function get() {
				return this._angularLimitsZ;
			},
			set: function set(limits) {
				if (!this._angularLimitsZ.equals(limits)) {
					this._angularLimitsZ.copy(limits);
					this._updateAngularLimits();
				}
			}
		}, {
			key: "angularMotionZ",
			get: function get() {
				return this._angularMotionZ;
			},
			set: function set(value) {
				if (this._angularMotionZ !== value) {
					this._angularMotionZ = value;
					this._updateAngularLimits();
				}
			}
		}, {
			key: "linearLimitsX",
			get: function get() {
				return this._linearLimitsX;
			},
			set: function set(limits) {
				if (!this._linearLimitsX.equals(limits)) {
					this._linearLimitsX.copy(limits);
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionX",
			get: function get() {
				return this._linearMotionX;
			},
			set: function set(value) {
				if (this._linearMotionX !== value) {
					this._linearMotionX = value;
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearLimitsY",
			get: function get() {
				return this._linearLimitsY;
			},
			set: function set(limits) {
				if (!this._linearLimitsY.equals(limits)) {
					this._linearLimitsY.copy(limits);
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionY",
			get: function get() {
				return this._linearMotionY;
			},
			set: function set(value) {
				if (this._linearMotionY !== value) {
					this._linearMotionY = value;
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearLimitsZ",
			get: function get() {
				return this._linearLimitsZ;
			},
			set: function set(limits) {
				if (!this._linearLimitsZ.equals(limits)) {
					this._linearLimitsZ.copy(limits);
					this._updateLinearLimits();
				}
			}
		}, {
			key: "linearMotionZ",
			get: function get() {
				return this._linearMotionZ;
			},
			set: function set(value) {
				if (this._linearMotionZ !== value) {
					this._linearMotionZ = value;
					this._updateLinearLimits();
				}
			}
		}]);
	}(Component);
	var functionMap = {
		Damping: 'setDamping',
		Equilibrium: 'setEquilibriumPoint',
		Spring: 'enableSpring',
		Stiffness: 'setStiffness'
	};
	['linear', 'angular'].forEach(function (type) {
		['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(function (name) {
			['X', 'Y', 'Z'].forEach(function (axis) {
				var prop = type + name + axis;
				var propInternal = "_" + prop;
				var index = type === 'linear' ? 0 : 3;
				if (axis === 'Y') index += 1;
				if (axis === 'Z') index += 2;
				Object.defineProperty(JointComponent.prototype, prop, {
					get: function get() {
						return this[propInternal];
					},
					set: function set(value) {
						if (this[propInternal] !== value) {
							this[propInternal] = value;
							this._constraint[functionMap[name]](index, value);
						}
					}
				});
			});
		});
	});

	var JointComponentData = function JointComponentData() {
		this.enabled = true;
	};

	var _schema$e = ['enabled'];
	var JointComponentSystem = function (_ComponentSystem) {
		function JointComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'joint';
			_this.app = app;
			_this.ComponentType = JointComponent;
			_this.DataType = JointComponentData;
			_this.schema = _schema$e;
			return _this;
		}
		_inheritsLoose(JointComponentSystem, _ComponentSystem);
		var _proto = JointComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component.initFromData(data);
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$e);
		};
		return JointComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(JointComponent.prototype, _schema$e);

	var LayoutChildComponent = function (_Component) {
		function LayoutChildComponent() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Component.call.apply(_Component, [this].concat(args)) || this;
			_this._minWidth = 0;
			_this._minHeight = 0;
			_this._maxWidth = null;
			_this._maxHeight = null;
			_this._fitWidthProportion = 0;
			_this._fitHeightProportion = 0;
			_this._excludeFromLayout = false;
			return _this;
		}
		_inheritsLoose(LayoutChildComponent, _Component);
		return _createClass(LayoutChildComponent, [{
			key: "minWidth",
			get: function get() {
				return this._minWidth;
			},
			set: function set(value) {
				if (value !== this._minWidth) {
					this._minWidth = value;
					this.fire('resize');
				}
			}
		}, {
			key: "minHeight",
			get: function get() {
				return this._minHeight;
			},
			set: function set(value) {
				if (value !== this._minHeight) {
					this._minHeight = value;
					this.fire('resize');
				}
			}
		}, {
			key: "maxWidth",
			get: function get() {
				return this._maxWidth;
			},
			set: function set(value) {
				if (value !== this._maxWidth) {
					this._maxWidth = value;
					this.fire('resize');
				}
			}
		}, {
			key: "maxHeight",
			get: function get() {
				return this._maxHeight;
			},
			set: function set(value) {
				if (value !== this._maxHeight) {
					this._maxHeight = value;
					this.fire('resize');
				}
			}
		}, {
			key: "fitWidthProportion",
			get: function get() {
				return this._fitWidthProportion;
			},
			set: function set(value) {
				if (value !== this._fitWidthProportion) {
					this._fitWidthProportion = value;
					this.fire('resize');
				}
			}
		}, {
			key: "fitHeightProportion",
			get: function get() {
				return this._fitHeightProportion;
			},
			set: function set(value) {
				if (value !== this._fitHeightProportion) {
					this._fitHeightProportion = value;
					this.fire('resize');
				}
			}
		}, {
			key: "excludeFromLayout",
			get: function get() {
				return this._excludeFromLayout;
			},
			set: function set(value) {
				if (value !== this._excludeFromLayout) {
					this._excludeFromLayout = value;
					this.fire('resize');
				}
			}
		}]);
	}(Component);

	var LayoutChildComponentData = function LayoutChildComponentData() {
		this.enabled = true;
	};

	var _schema$d = ['enabled'];
	var LayoutChildComponentSystem = function (_ComponentSystem) {
		function LayoutChildComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'layoutchild';
			_this.ComponentType = LayoutChildComponent;
			_this.DataType = LayoutChildComponentData;
			_this.schema = _schema$d;
			return _this;
		}
		_inheritsLoose(LayoutChildComponentSystem, _ComponentSystem);
		var _proto = LayoutChildComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.minWidth !== undefined) component.minWidth = data.minWidth;
			if (data.minHeight !== undefined) component.minHeight = data.minHeight;
			if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
			if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
			if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
			if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
			if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var layoutChild = entity.layoutchild;
			return this.addComponent(clone, {
				enabled: layoutChild.enabled,
				minWidth: layoutChild.minWidth,
				minHeight: layoutChild.minHeight,
				maxWidth: layoutChild.maxWidth,
				maxHeight: layoutChild.maxHeight,
				fitWidthProportion: layoutChild.fitWidthProportion,
				fitHeightProportion: layoutChild.fitHeightProportion,
				excludeFromLayout: layoutChild.excludeFromLayout
			});
		};
		return LayoutChildComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(LayoutChildComponent.prototype, _schema$d);

	var FITTING_NONE = 0;
	var FITTING_STRETCH = 1;
	var FITTING_SHRINK = 2;
	var FITTING_BOTH = 3;

	var AXIS_MAPPINGS = {};
	AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
		axis: 'x',
		size: 'width',
		calculatedSize: 'calculatedWidth',
		minSize: 'minWidth',
		maxSize: 'maxWidth',
		fitting: 'widthFitting',
		fittingProportion: 'fitWidthProportion'
	};
	AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
		axis: 'y',
		size: 'height',
		calculatedSize: 'calculatedHeight',
		minSize: 'minHeight',
		maxSize: 'maxHeight',
		fitting: 'heightFitting',
		fittingProportion: 'fitHeightProportion'
	};
	var OPPOSITE_ORIENTATION = {};
	OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
	OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
	var PROPERTY_DEFAULTS = {
		minWidth: 0,
		minHeight: 0,
		maxWidth: Number.POSITIVE_INFINITY,
		maxHeight: Number.POSITIVE_INFINITY,
		width: null,
		height: null,
		fitWidthProportion: 0,
		fitHeightProportion: 0
	};
	var FITTING_ACTION = {
		NONE: 'NONE',
		APPLY_STRETCHING: 'APPLY_STRETCHING',
		APPLY_SHRINKING: 'APPLY_SHRINKING'
	};
	var availableSpace = new Vec2();
	function createCalculator(orientation) {
		var options;
		var a = AXIS_MAPPINGS[orientation];
		var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];
		function minExtentA(element, size) {
			return -size[a.size] * element.pivot[a.axis];
		}
		function minExtentB(element, size) {
			return -size[b.size] * element.pivot[b.axis];
		}
		function maxExtentA(element, size) {
			return size[a.size] * (1 - element.pivot[a.axis]);
		}
		function calculateAll(allElements, layoutOptions) {
			allElements = allElements.filter(shouldIncludeInLayout);
			options = layoutOptions;
			availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
			availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
			resetAnchors(allElements);
			var lines = reverseLinesIfRequired(splitLines(allElements));
			var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
			var positions = calculateBasePositions(lines, sizes);
			applyAlignmentAndPadding(lines, sizes, positions);
			applySizesAndPositions(lines, sizes, positions);
			return createLayoutInfo(lines);
		}
		function shouldIncludeInLayout(element) {
			var layoutChildComponent = element.entity.layoutchild;
			return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
		}
		function resetAnchors(allElements) {
			for (var i = 0; i < allElements.length; ++i) {
				var element = allElements[i];
				var anchor = element.anchor;
				if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
					element.anchor = Vec4.ZERO;
				}
			}
		}
		function splitLines(allElements) {
			if (!options.wrap) {
				return [allElements];
			}
			var lines = [[]];
			var sizes = getElementSizeProperties(allElements);
			var runningSize = 0;
			var allowOverrun = options[a.fitting] === FITTING_SHRINK;
			for (var i = 0; i < allElements.length; ++i) {
				if (lines[lines.length - 1].length > 0) {
					runningSize += options.spacing[a.axis];
				}
				var idealElementSize = sizes[i][a.size];
				runningSize += idealElementSize;
				if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
					runningSize = idealElementSize;
					lines.push([]);
				}
				lines[lines.length - 1].push(allElements[i]);
				if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
					runningSize = 0;
					lines.push([]);
				}
			}
			return lines;
		}
		function reverseLinesIfRequired(lines) {
			var reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
			var reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;
			if (reverseAxisA) {
				for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
					if (reverseAxisA) {
						lines[lineIndex].reverse();
					}
				}
			}
			if (reverseAxisB) {
				lines.reverse();
			}
			return lines;
		}
		function calculateSizesOnAxisA(lines) {
			var sizesAllLines = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = getElementSizeProperties(line);
				var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
				var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);
				if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
					stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
					shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
				}
				sizesAllLines.push(sizesThisLine);
			}
			return sizesAllLines;
		}
		function calculateSizesOnAxisB(lines, sizesAllLines) {
			var largestElementsForEachLine = [];
			var largestSizesForEachLine = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				line.largestElement = null;
				line.largestSize = {
					width: Number.NEGATIVE_INFINITY,
					height: Number.NEGATIVE_INFINITY
				};
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var sizesThisElement = sizesAllLines[lineIndex][elementIndex];
					if (sizesThisElement[b.size] > line.largestSize[b.size]) {
						line.largestElement = line[elementIndex];
						line.largestSize = sizesThisElement;
					}
				}
				largestElementsForEachLine.push(line.largestElement);
				largestSizesForEachLine.push(line.largestSize);
			}
			var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
			var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);
			if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
				stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
				shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
			}
			for (var _lineIndex = 0; _lineIndex < lines.length; ++_lineIndex) {
				var _line = lines[_lineIndex];
				for (var _elementIndex = 0; _elementIndex < _line.length; ++_elementIndex) {
					var sizesForThisElement = sizesAllLines[_lineIndex][_elementIndex];
					var currentSize = sizesForThisElement[b.size];
					var availableSize = lines.length === 1 ? availableSpace[b.axis] : _line.largestSize[b.size];
					var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);
					if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
						sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
					} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
						sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
					}
				}
			}
			return sizesAllLines;
		}
		function determineFittingAction(fittingMode, currentSize, availableSize) {
			switch (fittingMode) {
				case FITTING_NONE:
					return FITTING_ACTION.NONE;
				case FITTING_STRETCH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					}
					return FITTING_ACTION.NONE;
				case FITTING_SHRINK:
					if (currentSize >= availableSize) {
						return FITTING_ACTION.APPLY_SHRINKING;
					}
					return FITTING_ACTION.NONE;
				case FITTING_BOTH:
					if (currentSize < availableSize) {
						return FITTING_ACTION.APPLY_STRETCHING;
					}
					return FITTING_ACTION.APPLY_SHRINKING;
				default:
					throw new Error("Unrecognized fitting mode: " + fittingMode);
			}
		}
		function calculateTotalSpace(sizes, axis) {
			var totalSizes = sumValues(sizes, axis.size);
			var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
			return totalSizes + totalSpacing;
		}
		function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
			var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;
			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = ascendingMaxSizeOrder[i];
				var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
				var maxSize = sizesThisLine[index][axis.maxSize];
				var actualSize = Math.min(targetSize, maxSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualIncrease = Math.max(targetSize - actualSize, 0);
				var appliedIncrease = targetIncrease - actualIncrease;
				remainingUndershoot -= appliedIncrease;
			}
		}
		function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
			var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
			var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
			var inverseFittingProportions = invertNormalizedValues(fittingProportions);
			var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
			var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];
			for (var i = 0; i < sizesThisLine.length; ++i) {
				var index = descendingMinSizeOrder[i];
				var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
				var targetSize = sizesThisLine[index][axis.size] - targetReduction;
				var minSize = sizesThisLine[index][axis.minSize];
				var actualSize = Math.max(targetSize, minSize);
				sizesThisLine[index][axis.size] = actualSize;
				var actualReduction = Math.max(actualSize - targetSize, 0);
				var appliedReduction = targetReduction - actualReduction;
				remainingOvershoot -= appliedReduction;
			}
		}
		function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
			var proportion = fittingProportions[index];
			var sumOfRemainingProportions = fittingProportionSums[index];
			if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
				return remainingAdjustment;
			}
			return remainingAdjustment * proportion / sumOfRemainingProportions;
		}
		function calculateBasePositions(lines, sizes) {
			var cursor = {};
			cursor[a.axis] = 0;
			cursor[b.axis] = 0;
			lines[a.size] = Number.NEGATIVE_INFINITY;
			var positionsAllLines = [];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				if (line.length === 0) {
					positionsAllLines.push([]);
					continue;
				}
				var positionsThisLine = [];
				var sizesThisLine = sizes[lineIndex];
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					var sizesThisElement = sizesThisLine[elementIndex];
					cursor[b.axis] -= minExtentB(element, sizesThisElement);
					cursor[a.axis] -= minExtentA(element, sizesThisElement);
					positionsThisLine[elementIndex] = {};
					positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
					positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
					cursor[b.axis] += minExtentB(element, sizesThisElement);
					cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
				}
				line[a.size] = cursor[a.axis] - options.spacing[a.axis];
				line[b.size] = line.largestSize[b.size];
				lines[a.size] = Math.max(lines[a.size], line[a.size]);
				cursor[a.axis] = 0;
				cursor[b.axis] += line[b.size] + options.spacing[b.axis];
				positionsAllLines.push(positionsThisLine);
			}
			lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
			return positionsAllLines;
		}
		function applyAlignmentAndPadding(lines, sizes, positions) {
			var alignmentA = options.alignment[a.axis];
			var alignmentB = options.alignment[b.axis];
			var paddingA = options.padding[a.axis];
			var paddingB = options.padding[b.axis];
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];
				var axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
				var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
					positionsThisLine[elementIndex][a.axis] += axisAOffset;
					positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
				}
			}
		}
		function applySizesAndPositions(lines, sizes, positions) {
			for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
				var line = lines[lineIndex];
				var sizesThisLine = sizes[lineIndex];
				var positionsThisLine = positions[lineIndex];
				for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
					var element = line[elementIndex];
					element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
					element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];
					if (options.orientation === ORIENTATION_HORIZONTAL) {
						element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
					} else {
						element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
					}
				}
			}
		}
		function createLayoutInfo(lines) {
			var layoutWidth = lines.width;
			var layoutHeight = lines.height;
			var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
			var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
			return {
				bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
			};
		}
		function getElementSizeProperties(elements) {
			var sizeProperties = [];
			for (var i = 0; i < elements.length; ++i) {
				var element = elements[i];
				var minWidth = Math.max(getProperty(element, 'minWidth'), 0);
				var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
				var maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
				var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
				var width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
				var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
				var fitWidthProportion = getProperty(element, 'fitWidthProportion');
				var fitHeightProportion = getProperty(element, 'fitHeightProportion');
				sizeProperties.push({
					minWidth: minWidth,
					minHeight: minHeight,
					maxWidth: maxWidth,
					maxHeight: maxHeight,
					width: width,
					height: height,
					fitWidthProportion: fitWidthProportion,
					fitHeightProportion: fitHeightProportion
				});
			}
			return sizeProperties;
		}
		function getProperty(element, propertyName) {
			var layoutChildComponent = element.entity.layoutchild;
			if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
				return layoutChildComponent[propertyName];
			} else if (element[propertyName] !== undefined) {
				return element[propertyName];
			}
			return PROPERTY_DEFAULTS[propertyName];
		}
		function clamp(value, min, max) {
			return Math.min(Math.max(value, min), max);
		}
		function sumValues(items, propertyName) {
			return items.reduce(function (accumulator, current) {
				return accumulator + current[propertyName];
			}, 0);
		}
		function getNormalizedValues(items, propertyName) {
			var sum = sumValues(items, propertyName);
			var normalizedValues = [];
			var numItems = items.length;
			if (sum === 0) {
				for (var i = 0; i < numItems; ++i) {
					normalizedValues.push(1 / numItems);
				}
			} else {
				for (var _i = 0; _i < numItems; ++_i) {
					normalizedValues.push(items[_i][propertyName] / sum);
				}
			}
			return normalizedValues;
		}
		function invertNormalizedValues(values) {
			if (values.length === 1) {
				return [1];
			}
			var invertedValues = [];
			var numValues = values.length;
			for (var i = 0; i < numValues; ++i) {
				invertedValues.push((1 - values[i]) / (numValues - 1));
			}
			return invertedValues;
		}
		function getTraversalOrder(items, orderBy, descending) {
			items.forEach(assignIndex);
			return items.slice().sort(function (itemA, itemB) {
				return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
			}).map(getIndex);
		}
		function assignIndex(item, index) {
			item.index = index;
		}
		function getIndex(item) {
			return item.index;
		}
		function createSumArray(values, order) {
			var sumArray = [];
			sumArray[order[values.length - 1]] = values[order[values.length - 1]];
			for (var i = values.length - 2; i >= 0; --i) {
				sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
			}
			return sumArray;
		}
		return calculateAll;
	}
	var CALCULATE_FNS = {};
	CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
	CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);
	var LayoutCalculator = function () {
		function LayoutCalculator() {}
		var _proto = LayoutCalculator.prototype;
		_proto.calculateLayout = function calculateLayout(elements, options) {
			var calculateFn = CALCULATE_FNS[options.orientation];
			if (!calculateFn) {
				throw new Error("Unrecognized orientation value: " + options.orientation);
			} else {
				return calculateFn(elements, options);
			}
		};
		return LayoutCalculator;
	}();

	function getElement(entity) {
		return entity.element;
	}
	function isEnabledAndHasEnabledElement(entity) {
		return entity.enabled && entity.element && entity.element.enabled;
	}
	var LayoutGroupComponent = function (_Component) {
		function LayoutGroupComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._orientation = ORIENTATION_HORIZONTAL;
			_this._reverseX = false;
			_this._reverseY = true;
			_this._alignment = new Vec2(0, 1);
			_this._padding = new Vec4();
			_this._spacing = new Vec2();
			_this._widthFitting = FITTING_NONE;
			_this._heightFitting = FITTING_NONE;
			_this._wrap = false;
			_this._layoutCalculator = new LayoutCalculator();
			_this._listenForReflowEvents(_this.entity, 'on');
			_this.entity.children.forEach(function (child) {
				_this._listenForReflowEvents(child, 'on');
			});
			_this.entity.on('childinsert', _this._onChildInsert, _this);
			_this.entity.on('childremove', _this._onChildRemove, _this);
			system.app.systems.element.on('add', _this._onElementOrLayoutComponentAdd, _this);
			system.app.systems.element.on('beforeremove', _this._onElementOrLayoutComponentRemove, _this);
			system.app.systems.layoutchild.on('add', _this._onElementOrLayoutComponentAdd, _this);
			system.app.systems.layoutchild.on('beforeremove', _this._onElementOrLayoutComponentRemove, _this);
			return _this;
		}
		_inheritsLoose(LayoutGroupComponent, _Component);
		var _proto = LayoutGroupComponent.prototype;
		_proto._isSelfOrChild = function _isSelfOrChild(entity) {
			return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
		};
		_proto._listenForReflowEvents = function _listenForReflowEvents(target, onOff) {
			if (target.element) {
				target.element[onOff]('enableelement', this._scheduleReflow, this);
				target.element[onOff]('disableelement', this._scheduleReflow, this);
				target.element[onOff]('resize', this._scheduleReflow, this);
				target.element[onOff]('set:pivot', this._scheduleReflow, this);
			}
			if (target.layoutchild) {
				target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
				target.layoutchild[onOff]('resize', this._scheduleReflow, this);
			}
		};
		_proto._onElementOrLayoutComponentAdd = function _onElementOrLayoutComponentAdd(entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'on');
				this._scheduleReflow();
			}
		};
		_proto._onElementOrLayoutComponentRemove = function _onElementOrLayoutComponentRemove(entity) {
			if (this._isSelfOrChild(entity)) {
				this._listenForReflowEvents(entity, 'off');
				this._scheduleReflow();
			}
		};
		_proto._onChildInsert = function _onChildInsert(child) {
			this._listenForReflowEvents(child, 'on');
			this._scheduleReflow();
		};
		_proto._onChildRemove = function _onChildRemove(child) {
			this._listenForReflowEvents(child, 'off');
			this._scheduleReflow();
		};
		_proto._scheduleReflow = function _scheduleReflow() {
			if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
				this.system.scheduleReflow(this);
			}
		};
		_proto.reflow = function reflow() {
			var container = getElement(this.entity);
			var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);
			if (!container || elements.length === 0) {
				return;
			}
			var containerWidth = Math.max(container.calculatedWidth, 0);
			var containerHeight = Math.max(container.calculatedHeight, 0);
			var options = {
				orientation: this._orientation,
				reverseX: this._reverseX,
				reverseY: this._reverseY,
				alignment: this._alignment,
				padding: this._padding,
				spacing: this._spacing,
				widthFitting: this._widthFitting,
				heightFitting: this._heightFitting,
				wrap: this._wrap,
				containerSize: new Vec2(containerWidth, containerHeight)
			};
			this._isPerformingReflow = true;
			var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);
			this._isPerformingReflow = false;
			this.fire('reflow', layoutInfo);
		};
		_proto.onEnable = function onEnable() {
			this._scheduleReflow();
		};
		_proto.onRemove = function onRemove() {
			var _this2 = this;
			this.entity.off('childinsert', this._onChildInsert, this);
			this.entity.off('childremove', this._onChildRemove, this);
			this._listenForReflowEvents(this.entity, 'off');
			this.entity.children.forEach(function (child) {
				_this2._listenForReflowEvents(child, 'off');
			});
			this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
			this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
			this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
		};
		return _createClass(LayoutGroupComponent, [{
			key: "orientation",
			get: function get() {
				return this._orientation;
			},
			set: function set(value) {
				if (value !== this._orientation) {
					this._orientation = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "reverseX",
			get: function get() {
				return this._reverseX;
			},
			set: function set(value) {
				if (value !== this._reverseX) {
					this._reverseX = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "reverseY",
			get: function get() {
				return this._reverseY;
			},
			set: function set(value) {
				if (value !== this._reverseY) {
					this._reverseY = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "alignment",
			get: function get() {
				return this._alignment;
			},
			set: function set(value) {
				if (!value.equals(this._alignment)) {
					this._alignment.copy(value);
					this._scheduleReflow();
				}
			}
		}, {
			key: "padding",
			get: function get() {
				return this._padding;
			},
			set: function set(value) {
				if (!value.equals(this._padding)) {
					this._padding.copy(value);
					this._scheduleReflow();
				}
			}
		}, {
			key: "spacing",
			get: function get() {
				return this._spacing;
			},
			set: function set(value) {
				if (!value.equals(this._spacing)) {
					this._spacing.copy(value);
					this._scheduleReflow();
				}
			}
		}, {
			key: "widthFitting",
			get: function get() {
				return this._widthFitting;
			},
			set: function set(value) {
				if (value !== this._widthFitting) {
					this._widthFitting = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "heightFitting",
			get: function get() {
				return this._heightFitting;
			},
			set: function set(value) {
				if (value !== this._heightFitting) {
					this._heightFitting = value;
					this._scheduleReflow();
				}
			}
		}, {
			key: "wrap",
			get: function get() {
				return this._wrap;
			},
			set: function set(value) {
				if (value !== this._wrap) {
					this._wrap = value;
					this._scheduleReflow();
				}
			}
		}]);
	}(Component);

	var LayoutGroupComponentData = function LayoutGroupComponentData() {
		this.enabled = true;
	};

	var _schema$c = ['enabled'];
	var MAX_ITERATIONS = 100;
	var LayoutGroupComponentSystem = function (_ComponentSystem) {
		function LayoutGroupComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'layoutgroup';
			_this.ComponentType = LayoutGroupComponent;
			_this.DataType = LayoutGroupComponentData;
			_this.schema = _schema$c;
			_this._reflowQueue = [];
			_this.on('beforeremove', _this._onRemoveComponent, _this);
			_this.app.systems.on('postUpdate', _this._onPostUpdate, _this);
			return _this;
		}
		_inheritsLoose(LayoutGroupComponentSystem, _ComponentSystem);
		var _proto = LayoutGroupComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) component.enabled = data.enabled;
			if (data.orientation !== undefined) component.orientation = data.orientation;
			if (data.reverseX !== undefined) component.reverseX = data.reverseX;
			if (data.reverseY !== undefined) component.reverseY = data.reverseY;
			if (data.alignment !== undefined) {
				component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
			}
			if (data.padding !== undefined) {
				component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
			}
			if (data.spacing !== undefined) {
				component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
			}
			if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
			if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
			if (data.wrap !== undefined) component.wrap = data.wrap;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var layoutGroup = entity.layoutgroup;
			return this.addComponent(clone, {
				enabled: layoutGroup.enabled,
				orientation: layoutGroup.orientation,
				reverseX: layoutGroup.reverseX,
				reverseY: layoutGroup.reverseY,
				alignment: layoutGroup.alignment,
				padding: layoutGroup.padding,
				spacing: layoutGroup.spacing,
				widthFitting: layoutGroup.widthFitting,
				heightFitting: layoutGroup.heightFitting,
				wrap: layoutGroup.wrap
			});
		};
		_proto.scheduleReflow = function scheduleReflow(component) {
			if (this._reflowQueue.indexOf(component) === -1) {
				this._reflowQueue.push(component);
			}
		};
		_proto._onPostUpdate = function _onPostUpdate() {
			this._processReflowQueue();
		};
		_proto._processReflowQueue = function _processReflowQueue() {
			if (this._reflowQueue.length === 0) {
				return;
			}
			var iterationCount = 0;
			while (this._reflowQueue.length > 0) {
				var queue = this._reflowQueue.slice();
				this._reflowQueue.length = 0;
				queue.sort(function (componentA, componentB) {
					return componentA.entity.graphDepth - componentB.entity.graphDepth;
				});
				for (var i = 0; i < queue.length; ++i) {
					queue[i].reflow();
				}
				if (++iterationCount >= MAX_ITERATIONS) {
					console.warn('Max reflow iterations limit reached, bailing.');
					break;
				}
			}
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('postUpdate', this._onPostUpdate, this);
		};
		return LayoutGroupComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(LayoutGroupComponent.prototype, _schema$c);

	var PrimitivesCache = function () {
		function PrimitivesCache() {
			this.map = new Map();
		}
		var _proto = PrimitivesCache.prototype;
		_proto.destroy = function destroy(device) {
			this.map.forEach(function (primData) {
				return primData.mesh.destroy();
			});
		};
		return PrimitivesCache;
	}();
	var _primitivesCache = new DeviceCache();
	var getShapePrimitive = function getShapePrimitive(device, type) {
		var cache = _primitivesCache.get(device, function () {
			return new PrimitivesCache();
		});
		var primData = cache.map.get(type);
		if (!primData) {
			var mesh, area;
			switch (type) {
				case 'box':
					mesh = Mesh.fromGeometry(device, new BoxGeometry());
					area = {
						x: 2,
						y: 2,
						z: 2,
						uv: 2.0 / 3
					};
					break;
				case 'capsule':
					mesh = Mesh.fromGeometry(device, new CapsuleGeometry({
						radius: 0.5,
						height: 2
					}));
					area = {
						x: Math.PI * 2,
						y: Math.PI,
						z: Math.PI * 2,
						uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
					};
					break;
				case 'cone':
					mesh = Mesh.fromGeometry(device, new ConeGeometry({
						baseRadius: 0.5,
						peakRadius: 0,
						height: 1
					}));
					area = {
						x: 2.54,
						y: 2.54,
						z: 2.54,
						uv: 1.0 / 3 + 1.0 / 3 / 3
					};
					break;
				case 'cylinder':
					mesh = Mesh.fromGeometry(device, new CylinderGeometry({
						radius: 0.5,
						height: 1
					}));
					area = {
						x: Math.PI,
						y: 0.79 * 2,
						z: Math.PI,
						uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
					};
					break;
				case 'plane':
					mesh = Mesh.fromGeometry(device, new PlaneGeometry({
						halfExtents: new Vec2(0.5, 0.5),
						widthSegments: 1,
						lengthSegments: 1
					}));
					area = {
						x: 0,
						y: 1,
						z: 0,
						uv: 1
					};
					break;
				case 'sphere':
					mesh = Mesh.fromGeometry(device, new SphereGeometry({
						radius: 0.5
					}));
					area = {
						x: Math.PI,
						y: Math.PI,
						z: Math.PI,
						uv: 1
					};
					break;
				case 'torus':
					mesh = Mesh.fromGeometry(device, new TorusGeometry({
						tubeRadius: 0.2,
						ringRadius: 0.3
					}));
					area = {
						x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
						y: 0.4,
						z: 0.4,
						uv: 1
					};
					break;
				default:
					throw new Error("Invalid primitive type: " + type);
			}
			mesh.incRefCount();
			primData = {
				mesh: mesh,
				area: area
			};
			cache.map.set(type, primData);
		}
		return primData;
	};

	var ModelComponent = function (_Component) {
		function ModelComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._type = 'asset';
			_this._asset = null;
			_this._model = null;
			_this._mapping = {};
			_this._castShadows = true;
			_this._receiveShadows = true;
			_this._materialAsset = null;
			_this._material = void 0;
			_this._castShadowsLightmap = true;
			_this._lightmapped = false;
			_this._lightmapSizeMultiplier = 1;
			_this.isStatic = false;
			_this._layers = [LAYERID_WORLD];
			_this._batchGroupId = -1;
			_this._customAabb = null;
			_this._area = null;
			_this._materialEvents = null;
			_this._clonedModel = false;
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._material = system.defaultMaterial;
			entity.on('remove', _this.onRemoveChild, _this);
			entity.on('removehierarchy', _this.onRemoveChild, _this);
			entity.on('insert', _this.onInsertChild, _this);
			entity.on('inserthierarchy', _this.onInsertChild, _this);
			return _this;
		}
		_inheritsLoose(ModelComponent, _Component);
		var _proto = ModelComponent.prototype;
		_proto.addModelToLayers = function addModelToLayers() {
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.addMeshInstances(this.meshInstances);
				}
			}
		};
		_proto.removeModelFromLayers = function removeModelFromLayers() {
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances(this.meshInstances);
			}
		};
		_proto.onRemoveChild = function onRemoveChild() {
			if (this._model) {
				this.removeModelFromLayers();
			}
		};
		_proto.onInsertChild = function onInsertChild() {
			if (this._model && this.enabled && this.entity.enabled) {
				this.addModelToLayers();
			}
		};
		_proto.onRemove = function onRemove() {
			this.asset = null;
			this.model = null;
			this.materialAsset = null;
			this._unsetMaterialEvents();
			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addModelToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this.meshInstances);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this.meshInstances);
		};
		_proto._setMaterialEvent = function _setMaterialEvent(index, event, id, handler) {
			var evt = event + ":" + id;
			this.system.app.assets.on(evt, handler, this);
			if (!this._materialEvents) {
				this._materialEvents = [];
			}
			if (!this._materialEvents[index]) {
				this._materialEvents[index] = {};
			}
			this._materialEvents[index][evt] = {
				id: id,
				handler: handler
			};
		};
		_proto._unsetMaterialEvents = function _unsetMaterialEvents() {
			var assets = this.system.app.assets;
			var events = this._materialEvents;
			if (!events) {
				return;
			}
			for (var i = 0, len = events.length; i < len; i++) {
				if (!events[i]) continue;
				var evt = events[i];
				for (var key in evt) {
					assets.off(key, evt[key].handler, this);
				}
			}
			this._materialEvents = null;
		};
		_proto._getAssetByIdOrPath = function _getAssetByIdOrPath(idOrPath) {
			var asset = null;
			var isPath = isNaN(parseInt(idOrPath, 10));
			if (!isPath) {
				asset = this.system.app.assets.get(idOrPath);
			} else if (this.asset) {
				var url = this._getMaterialAssetUrl(idOrPath);
				if (url) {
					asset = this.system.app.assets.getByUrl(url);
				}
			}
			return asset;
		};
		_proto._getMaterialAssetUrl = function _getMaterialAssetUrl(path) {
			if (!this.asset) return null;
			var modelAsset = this.system.app.assets.get(this.asset);
			return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
		};
		_proto._loadAndSetMeshInstanceMaterial = function _loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
			var assets = this.system.app.assets;
			if (!materialAsset) {
				return;
			}
			if (materialAsset.resource) {
				meshInstance.material = materialAsset.resource;
				this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
					meshInstance.material = this.system.defaultMaterial;
				});
			} else {
				this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
					meshInstance.material = asset.resource;
					this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
						meshInstance.material = this.system.defaultMaterial;
					});
				});
				if (this.enabled && this.entity.enabled) {
					assets.load(materialAsset);
				}
			}
		};
		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			var layers = scene == null ? void 0 : scene.layers;
			this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
				this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
			}
			var isAsset = this._type === 'asset';
			var asset;
			if (this._model) {
				this.addModelToLayers();
			} else if (isAsset && this._asset) {
				asset = app.assets.get(this._asset);
				if (asset && asset.resource !== this._model) {
					this._bindModelAsset(asset);
				}
			}
			if (this._materialAsset) {
				asset = app.assets.get(this._materialAsset);
				if (asset && asset.resource !== this._material) {
					this._bindMaterialAsset(asset);
				}
			}
			if (isAsset) {
				if (this._mapping) {
					for (var index in this._mapping) {
						if (this._mapping[index]) {
							asset = this._getAssetByIdOrPath(this._mapping[index]);
							if (asset && !asset.resource) {
								app.assets.load(asset);
							}
						}
					}
				}
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher;
				(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang;
			var app = this.system.app;
			var scene = app.scene;
			var layers = scene.layers;
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = null;
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = null;
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher2;
				(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
			}
			if (this._model) {
				this.removeModelFromLayers();
			}
		};
		_proto.hide = function hide() {
			if (this._model) {
				var instances = this._model.meshInstances;
				for (var i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = false;
				}
			}
		};
		_proto.show = function show() {
			if (this._model) {
				var instances = this._model.meshInstances;
				for (var i = 0, l = instances.length; i < l; i++) {
					instances[i].visible = true;
				}
			}
		};
		_proto._bindMaterialAsset = function _bindMaterialAsset(asset) {
			asset.on('load', this._onMaterialAssetLoad, this);
			asset.on('unload', this._onMaterialAssetUnload, this);
			asset.on('remove', this._onMaterialAssetRemove, this);
			asset.on('change', this._onMaterialAssetChange, this);
			if (asset.resource) {
				this._onMaterialAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindMaterialAsset = function _unbindMaterialAsset(asset) {
			asset.off('load', this._onMaterialAssetLoad, this);
			asset.off('unload', this._onMaterialAssetUnload, this);
			asset.off('remove', this._onMaterialAssetRemove, this);
			asset.off('change', this._onMaterialAssetChange, this);
		};
		_proto._onMaterialAssetAdd = function _onMaterialAssetAdd(asset) {
			this.system.app.assets.off("add:" + asset.id, this._onMaterialAssetAdd, this);
			if (this._materialAsset === asset.id) {
				this._bindMaterialAsset(asset);
			}
		};
		_proto._onMaterialAssetLoad = function _onMaterialAssetLoad(asset) {
			this._setMaterial(asset.resource);
		};
		_proto._onMaterialAssetUnload = function _onMaterialAssetUnload(asset) {
			this._setMaterial(this.system.defaultMaterial);
		};
		_proto._onMaterialAssetRemove = function _onMaterialAssetRemove(asset) {
			this._onMaterialAssetUnload(asset);
		};
		_proto._onMaterialAssetChange = function _onMaterialAssetChange(asset) {};
		_proto._bindModelAsset = function _bindModelAsset(asset) {
			this._unbindModelAsset(asset);
			asset.on('load', this._onModelAssetLoad, this);
			asset.on('unload', this._onModelAssetUnload, this);
			asset.on('change', this._onModelAssetChange, this);
			asset.on('remove', this._onModelAssetRemove, this);
			if (asset.resource) {
				this._onModelAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindModelAsset = function _unbindModelAsset(asset) {
			asset.off('load', this._onModelAssetLoad, this);
			asset.off('unload', this._onModelAssetUnload, this);
			asset.off('change', this._onModelAssetChange, this);
			asset.off('remove', this._onModelAssetRemove, this);
		};
		_proto._onModelAssetAdded = function _onModelAssetAdded(asset) {
			this.system.app.assets.off("add:" + asset.id, this._onModelAssetAdded, this);
			if (asset.id === this._asset) {
				this._bindModelAsset(asset);
			}
		};
		_proto._onModelAssetLoad = function _onModelAssetLoad(asset) {
			this.model = asset.resource.clone();
			this._clonedModel = true;
		};
		_proto._onModelAssetUnload = function _onModelAssetUnload(asset) {
			this.model = null;
		};
		_proto._onModelAssetChange = function _onModelAssetChange(asset, attr, _new, _old) {
			if (attr === 'data') {
				this.mapping = this._mapping;
			}
		};
		_proto._onModelAssetRemove = function _onModelAssetRemove(asset) {
			this.model = null;
		};
		_proto._setMaterial = function _setMaterial(material) {
			if (this._material === material) {
				return;
			}
			this._material = material;
			var model = this._model;
			if (model && this._type !== 'asset') {
				var meshInstances = model.meshInstances;
				for (var i = 0, len = meshInstances.length; i < len; i++) {
					meshInstances[i].material = material;
				}
			}
		};
		return _createClass(ModelComponent, [{
			key: "meshInstances",
			get: function get() {
				if (!this._model) {
					return null;
				}
				return this._model.meshInstances;
			},
			set: function set(value) {
				if (!this._model) {
					return;
				}
				this._model.meshInstances = value;
			}
		}, {
			key: "customAabb",
			get: function get() {
				return this._customAabb;
			},
			set: function set(value) {
				this._customAabb = value;
				if (this._model) {
					var mi = this._model.meshInstances;
					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].setCustomAabb(this._customAabb);
						}
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) return;
				this._area = null;
				this._type = value;
				if (value === 'asset') {
					if (this._asset !== null) {
						this._bindModelAsset(this._asset);
					} else {
						this.model = null;
					}
				} else {
					var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
					this._area = primData.area;
					var mesh = primData.mesh;
					var node = new GraphNode();
					var model = new Model();
					model.graph = node;
					model.meshInstances = [new MeshInstance(mesh, this._material, node)];
					this.model = model;
					this._asset = null;
				}
			}
		}, {
			key: "asset",
			get: function get() {
				return this._asset;
			},
			set: function set(value) {
				var assets = this.system.app.assets;
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				if (this._asset !== _id) {
					if (this._asset) {
						assets.off("add:" + this._asset, this._onModelAssetAdded, this);
						var _prev = assets.get(this._asset);
						if (_prev) {
							this._unbindModelAsset(_prev);
						}
					}
					this._asset = _id;
					if (this._asset) {
						var asset = assets.get(this._asset);
						if (!asset) {
							this.model = null;
							assets.on("add:" + this._asset, this._onModelAssetAdded, this);
						} else {
							this._bindModelAsset(asset);
						}
					} else {
						this.model = null;
					}
				}
			}
		}, {
			key: "model",
			get: function get() {
				return this._model;
			},
			set: function set(value) {
				if (this._model === value) {
					return;
				}
				if (value && value._immutable) {
					return;
				}
				if (this._model) {
					this._model._immutable = false;
					this.removeModelFromLayers();
					this._model.getGraph().destroy();
					delete this._model._entity;
					if (this._clonedModel) {
						this._model.destroy();
						this._clonedModel = false;
					}
				}
				this._model = value;
				if (this._model) {
					this._model._immutable = true;
					var meshInstances = this._model.meshInstances;
					for (var i = 0; i < meshInstances.length; i++) {
						meshInstances[i].castShadow = this._castShadows;
						meshInstances[i].receiveShadow = this._receiveShadows;
						meshInstances[i].setCustomAabb(this._customAabb);
					}
					this.lightmapped = this._lightmapped;
					this.entity.addChild(this._model.graph);
					if (this.enabled && this.entity.enabled) {
						this.addModelToLayers();
					}
					this._model._entity = this.entity;
					if (this.entity.animation) {
						this.entity.animation.setModel(this._model);
					}
					if (this.entity.anim) {
						this.entity.anim.rebind();
					}
					if (this.type === 'asset') {
						this.mapping = this._mapping;
					} else {
						this._unsetMaterialEvents();
					}
				}
			}
		}, {
			key: "lightmapped",
			get: function get() {
				return this._lightmapped;
			},
			set: function set(value) {
				if (value !== this._lightmapped) {
					this._lightmapped = value;
					if (this._model) {
						var mi = this._model.meshInstances;
						for (var i = 0; i < mi.length; i++) {
							mi[i].setLightmapped(value);
						}
					}
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows;
			},
			set: function set(value) {
				if (this._castShadows === value) return;
				var model = this._model;
				if (model) {
					var layers = this.layers;
					var scene = this.system.app.scene;
					if (this._castShadows && !value) {
						for (var i = 0; i < layers.length; i++) {
							var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
							if (!layer) continue;
							layer.removeShadowCasters(model.meshInstances);
						}
					}
					var meshInstances = model.meshInstances;
					for (var _i = 0; _i < meshInstances.length; _i++) {
						meshInstances[_i].castShadow = value;
					}
					if (!this._castShadows && value) {
						for (var _i2 = 0; _i2 < layers.length; _i2++) {
							var _layer = scene.layers.getLayerById(layers[_i2]);
							if (!_layer) continue;
							_layer.addShadowCasters(model.meshInstances);
						}
					}
				}
				this._castShadows = value;
			}
		}, {
			key: "receiveShadows",
			get: function get() {
				return this._receiveShadows;
			},
			set: function set(value) {
				if (this._receiveShadows === value) return;
				this._receiveShadows = value;
				if (this._model) {
					var meshInstances = this._model.meshInstances;
					for (var i = 0, len = meshInstances.length; i < len; i++) {
						meshInstances[i].receiveShadow = value;
					}
				}
			}
		}, {
			key: "castShadowsLightmap",
			get: function get() {
				return this._castShadowsLightmap;
			},
			set: function set(value) {
				this._castShadowsLightmap = value;
			}
		}, {
			key: "lightmapSizeMultiplier",
			get: function get() {
				return this._lightmapSizeMultiplier;
			},
			set: function set(value) {
				this._lightmapSizeMultiplier = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				var layers = this.system.app.scene.layers;
				if (this.meshInstances) {
					for (var i = 0; i < this._layers.length; i++) {
						var layer = layers.getLayerById(this._layers[i]);
						if (!layer) continue;
						layer.removeMeshInstances(this.meshInstances);
					}
				}
				this._layers.length = 0;
				for (var _i3 = 0; _i3 < value.length; _i3++) {
					this._layers[_i3] = value[_i3];
				}
				if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;
				for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
					var _layer2 = layers.getLayerById(this._layers[_i4]);
					if (!_layer2) continue;
					_layer2.addMeshInstances(this.meshInstances);
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) return;
				if (this.entity.enabled && this._batchGroupId >= 0) {
					var _this$system$app$batc;
					(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
					var _this$system$app$batc2;
					(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.MODEL, value, this.entity);
				}
				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
					this.addModelToLayers();
				}
				this._batchGroupId = value;
			}
		}, {
			key: "materialAsset",
			get: function get() {
				return this._materialAsset;
			},
			set: function set(value) {
				var _id = value;
				if (value instanceof Asset) {
					_id = value.id;
				}
				var assets = this.system.app.assets;
				if (_id !== this._materialAsset) {
					if (this._materialAsset) {
						assets.off("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
						var _prev = assets.get(this._materialAsset);
						if (_prev) {
							this._unbindMaterialAsset(_prev);
						}
					}
					this._materialAsset = _id;
					if (this._materialAsset) {
						var asset = assets.get(this._materialAsset);
						if (!asset) {
							this._setMaterial(this.system.defaultMaterial);
							assets.on("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
						} else {
							this._bindMaterialAsset(asset);
						}
					} else {
						this._setMaterial(this.system.defaultMaterial);
					}
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material === value) {
					return;
				}
				this.materialAsset = null;
				this._setMaterial(value);
			}
		}, {
			key: "mapping",
			get: function get() {
				return this._mapping;
			},
			set: function set(value) {
				if (this._type !== 'asset') {
					return;
				}
				this._unsetMaterialEvents();
				if (!value) {
					value = {};
				}
				this._mapping = value;
				if (!this._model) return;
				var meshInstances = this._model.meshInstances;
				var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
				var assetMapping = modelAsset ? modelAsset.data.mapping : null;
				var asset = null;
				for (var i = 0, len = meshInstances.length; i < len; i++) {
					if (value[i] !== undefined) {
						if (value[i]) {
							asset = this.system.app.assets.get(value[i]);
							this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
						} else {
							meshInstances[i].material = this.system.defaultMaterial;
						}
					} else if (assetMapping) {
						if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
							if (assetMapping[i].material !== undefined) {
								asset = this.system.app.assets.get(assetMapping[i].material);
							} else if (assetMapping[i].path !== undefined) {
								var url = this._getMaterialAssetUrl(assetMapping[i].path);
								if (url) {
									asset = this.system.app.assets.getByUrl(url);
								}
							}
							this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
						} else {
							meshInstances[i].material = this.system.defaultMaterial;
						}
					}
				}
			}
		}]);
	}(Component);

	var ModelComponentData = function ModelComponentData() {
		this.enabled = true;
	};

	var _schema$b = ['enabled'];
	var ModelComponentSystem = function (_ComponentSystem) {
		function ModelComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'model';
			_this.ComponentType = ModelComponent;
			_this.DataType = ModelComponentData;
			_this.schema = _schema$b;
			_this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
			_this.on('beforeremove', _this.onRemove, _this);
			return _this;
		}
		_inheritsLoose(ModelComponentSystem, _ComponentSystem);
		var _proto = ModelComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			properties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];
			if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
				_data.batchGroupId = -1;
			}
			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}
			for (var i = 0; i < properties.length; i++) {
				if (_data.hasOwnProperty(properties[i])) {
					component[properties[i]] = _data[properties[i]];
				}
			}
			if (_data.aabbCenter && _data.aabbHalfExtents) {
				component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, _data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {
				type: entity.model.type,
				asset: entity.model.asset,
				castShadows: entity.model.castShadows,
				receiveShadows: entity.model.receiveShadows,
				castShadowsLightmap: entity.model.castShadowsLightmap,
				lightmapped: entity.model.lightmapped,
				lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
				isStatic: entity.model.isStatic,
				enabled: entity.model.enabled,
				layers: entity.model.layers,
				batchGroupId: entity.model.batchGroupId,
				mapping: extend({}, entity.model.mapping)
			};
			var materialAsset = entity.model.materialAsset;
			if (!(materialAsset instanceof Asset) && materialAsset != null) {
				materialAsset = this.app.assets.get(materialAsset);
			}
			var material = entity.model.material;
			if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
				data.materialAsset = materialAsset;
			}
			var component = this.addComponent(clone, data);
			if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
				component.model = entity.model.model.clone();
				component._clonedModel = true;
			}
			if (!data.materialAsset) {
				component.material = material;
			}
			if (entity.model.model) {
				var meshInstances = entity.model.model.meshInstances;
				var meshInstancesClone = component.model.meshInstances;
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstancesClone[i].mask = meshInstances[i].mask;
					meshInstancesClone[i].material = meshInstances[i].material;
					meshInstancesClone[i].layer = meshInstances[i].layer;
					meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
				}
			}
			if (entity.model.customAabb) {
				component.customAabb = entity.model.customAabb.clone();
			}
			return component;
		};
		_proto.onRemove = function onRemove(entity, component) {
			component.onRemove();
		};
		return ModelComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ModelComponent.prototype, _schema$b);

	var SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];
	var COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];
	var GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];
	var ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];
	var depthLayer;
	var ParticleSystemComponent = function (_Component) {
		function ParticleSystemComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._requestedDepth = false;
			_this._drawOrder = 0;
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._evtSetMeshes = null;
			_this.on('set_colorMapAsset', _this.onSetColorMapAsset, _this);
			_this.on('set_normalMapAsset', _this.onSetNormalMapAsset, _this);
			_this.on('set_meshAsset', _this.onSetMeshAsset, _this);
			_this.on('set_mesh', _this.onSetMesh, _this);
			_this.on('set_renderAsset', _this.onSetRenderAsset, _this);
			_this.on('set_loop', _this.onSetLoop, _this);
			_this.on('set_blendType', _this.onSetBlendType, _this);
			_this.on('set_depthSoftening', _this.onSetDepthSoftening, _this);
			_this.on('set_layers', _this.onSetLayers, _this);
			SIMPLE_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetSimpleProperty, _this);
			});
			COMPLEX_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetComplexProperty, _this);
			});
			GRAPH_PROPERTIES.forEach(function (prop) {
				_this.on("set_" + prop, _this.onSetGraphProperty, _this);
			});
			return _this;
		}
		_inheritsLoose(ParticleSystemComponent, _Component);
		var _proto = ParticleSystemComponent.prototype;
		_proto._setValue = function _setValue(name, value) {
			var data = this.data;
			var oldValue = data[name];
			data[name] = value;
			this.fire('set', name, oldValue, value);
		};
		_proto.addMeshInstanceToLayers = function addMeshInstanceToLayers() {
			if (!this.emitter) return;
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.addMeshInstances([this.emitter.meshInstance]);
				this.emitter._layer = layer;
			}
		};
		_proto.removeMeshInstanceFromLayers = function removeMeshInstanceFromLayers() {
			if (!this.emitter) return;
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this.emitter.meshInstance]);
			}
		};
		_proto.onSetLayers = function onSetLayers(name, oldValue, newValue) {
			if (!this.emitter) return;
			for (var i = 0; i < oldValue.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this.emitter.meshInstance]);
			}
			if (!this.enabled || !this.entity.enabled) return;
			for (var _i = 0; _i < newValue.length; _i++) {
				var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);
				if (!_layer) continue;
				_layer.addMeshInstances([this.emitter.meshInstance]);
			}
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addMeshInstanceToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			if (!this.emitter) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances([this.emitter.meshInstance]);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			if (!this.emitter) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances([this.emitter.meshInstance]);
		};
		_proto._bindColorMapAsset = function _bindColorMapAsset(asset) {
			asset.on('load', this._onColorMapAssetLoad, this);
			asset.on('unload', this._onColorMapAssetUnload, this);
			asset.on('remove', this._onColorMapAssetRemove, this);
			asset.on('change', this._onColorMapAssetChange, this);
			if (asset.resource) {
				this._onColorMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindColorMapAsset = function _unbindColorMapAsset(asset) {
			asset.off('load', this._onColorMapAssetLoad, this);
			asset.off('unload', this._onColorMapAssetUnload, this);
			asset.off('remove', this._onColorMapAssetRemove, this);
			asset.off('change', this._onColorMapAssetChange, this);
		};
		_proto._onColorMapAssetLoad = function _onColorMapAssetLoad(asset) {
			this.colorMap = asset.resource;
		};
		_proto._onColorMapAssetUnload = function _onColorMapAssetUnload(asset) {
			this.colorMap = null;
		};
		_proto._onColorMapAssetRemove = function _onColorMapAssetRemove(asset) {
			this._onColorMapAssetUnload(asset);
		};
		_proto._onColorMapAssetChange = function _onColorMapAssetChange(asset) {};
		_proto.onSetColorMapAsset = function onSetColorMapAsset(name, oldValue, newValue) {
			var _this2 = this;
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindColorMapAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.colorMapAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset = assets.get(newValue);
				if (_asset) {
					this._bindColorMapAsset(_asset);
				} else {
					assets.once("add:" + newValue, function (asset) {
						_this2._bindColorMapAsset(asset);
					});
				}
			} else {
				this.colorMap = null;
			}
		};
		_proto._bindNormalMapAsset = function _bindNormalMapAsset(asset) {
			asset.on('load', this._onNormalMapAssetLoad, this);
			asset.on('unload', this._onNormalMapAssetUnload, this);
			asset.on('remove', this._onNormalMapAssetRemove, this);
			asset.on('change', this._onNormalMapAssetChange, this);
			if (asset.resource) {
				this._onNormalMapAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindNormalMapAsset = function _unbindNormalMapAsset(asset) {
			asset.off('load', this._onNormalMapAssetLoad, this);
			asset.off('unload', this._onNormalMapAssetUnload, this);
			asset.off('remove', this._onNormalMapAssetRemove, this);
			asset.off('change', this._onNormalMapAssetChange, this);
		};
		_proto._onNormalMapAssetLoad = function _onNormalMapAssetLoad(asset) {
			this.normalMap = asset.resource;
		};
		_proto._onNormalMapAssetUnload = function _onNormalMapAssetUnload(asset) {
			this.normalMap = null;
		};
		_proto._onNormalMapAssetRemove = function _onNormalMapAssetRemove(asset) {
			this._onNormalMapAssetUnload(asset);
		};
		_proto._onNormalMapAssetChange = function _onNormalMapAssetChange(asset) {};
		_proto.onSetNormalMapAsset = function onSetNormalMapAsset(name, oldValue, newValue) {
			var _this3 = this;
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindNormalMapAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.normalMapAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset2 = assets.get(newValue);
				if (_asset2) {
					this._bindNormalMapAsset(_asset2);
				} else {
					assets.once("add:" + newValue, function (asset) {
						_this3._bindNormalMapAsset(asset);
					});
				}
			} else {
				this.normalMap = null;
			}
		};
		_proto._bindMeshAsset = function _bindMeshAsset(asset) {
			asset.on('load', this._onMeshAssetLoad, this);
			asset.on('unload', this._onMeshAssetUnload, this);
			asset.on('remove', this._onMeshAssetRemove, this);
			asset.on('change', this._onMeshAssetChange, this);
			if (asset.resource) {
				this._onMeshAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindMeshAsset = function _unbindMeshAsset(asset) {
			asset.off('load', this._onMeshAssetLoad, this);
			asset.off('unload', this._onMeshAssetUnload, this);
			asset.off('remove', this._onMeshAssetRemove, this);
			asset.off('change', this._onMeshAssetChange, this);
		};
		_proto._onMeshAssetLoad = function _onMeshAssetLoad(asset) {
			this._onMeshChanged(asset.resource);
		};
		_proto._onMeshAssetUnload = function _onMeshAssetUnload(asset) {
			this.mesh = null;
		};
		_proto._onMeshAssetRemove = function _onMeshAssetRemove(asset) {
			this._onMeshAssetUnload(asset);
		};
		_proto._onMeshAssetChange = function _onMeshAssetChange(asset) {};
		_proto.onSetMeshAsset = function onSetMeshAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindMeshAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.meshAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset3 = assets.get(newValue);
				if (_asset3) {
					this._bindMeshAsset(_asset3);
				}
			} else {
				this._onMeshChanged(null);
			}
		};
		_proto.onSetMesh = function onSetMesh(name, oldValue, newValue) {
			if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
				this.meshAsset = newValue;
			} else {
				this._onMeshChanged(newValue);
			}
		};
		_proto._onMeshChanged = function _onMeshChanged(mesh) {
			if (mesh && !(mesh instanceof Mesh)) {
				if (mesh.meshInstances[0]) {
					mesh = mesh.meshInstances[0].mesh;
				} else {
					mesh = null;
				}
			}
			this.data.mesh = mesh;
			if (this.emitter) {
				this.emitter.mesh = mesh;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		};
		_proto.onSetRenderAsset = function onSetRenderAsset(name, oldValue, newValue) {
			var assets = this.system.app.assets;
			if (oldValue) {
				var asset = assets.get(oldValue);
				if (asset) {
					this._unbindRenderAsset(asset);
				}
			}
			if (newValue) {
				if (newValue instanceof Asset) {
					this.data.renderAsset = newValue.id;
					newValue = newValue.id;
				}
				var _asset4 = assets.get(newValue);
				if (_asset4) {
					this._bindRenderAsset(_asset4);
				}
			} else {
				this._onRenderChanged(null);
			}
		};
		_proto._bindRenderAsset = function _bindRenderAsset(asset) {
			asset.on('load', this._onRenderAssetLoad, this);
			asset.on('unload', this._onRenderAssetUnload, this);
			asset.on('remove', this._onRenderAssetRemove, this);
			if (asset.resource) {
				this._onRenderAssetLoad(asset);
			} else {
				if (!this.enabled || !this.entity.enabled) return;
				this.system.app.assets.load(asset);
			}
		};
		_proto._unbindRenderAsset = function _unbindRenderAsset(asset) {
			var _this$_evtSetMeshes;
			asset.off('load', this._onRenderAssetLoad, this);
			asset.off('unload', this._onRenderAssetUnload, this);
			asset.off('remove', this._onRenderAssetRemove, this);
			(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();
			this._evtSetMeshes = null;
		};
		_proto._onRenderAssetLoad = function _onRenderAssetLoad(asset) {
			this._onRenderChanged(asset.resource);
		};
		_proto._onRenderAssetUnload = function _onRenderAssetUnload(asset) {
			this._onRenderChanged(null);
		};
		_proto._onRenderAssetRemove = function _onRenderAssetRemove(asset) {
			this._onRenderAssetUnload(asset);
		};
		_proto._onRenderChanged = function _onRenderChanged(render) {
			var _this$_evtSetMeshes2;
			if (!render) {
				this._onMeshChanged(null);
				return;
			}
			(_this$_evtSetMeshes2 = this._evtSetMeshes) == null || _this$_evtSetMeshes2.off();
			this._evtSetMeshes = render.on('set:meshes', this._onRenderSetMeshes, this);
			if (render.meshes) {
				this._onRenderSetMeshes(render.meshes);
			}
		};
		_proto._onRenderSetMeshes = function _onRenderSetMeshes(meshes) {
			this._onMeshChanged(meshes && meshes[0]);
		};
		_proto.onSetLoop = function onSetLoop(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetTime();
			}
		};
		_proto.onSetBlendType = function onSetBlendType(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.material.blendType = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
			}
		};
		_proto._requestDepth = function _requestDepth() {
			if (this._requestedDepth) return;
			if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer) {
				depthLayer.incrementCounter();
				this._requestedDepth = true;
			}
		};
		_proto._releaseDepth = function _releaseDepth() {
			if (!this._requestedDepth) return;
			if (depthLayer) {
				depthLayer.decrementCounter();
				this._requestedDepth = false;
			}
		};
		_proto.onSetDepthSoftening = function onSetDepthSoftening(name, oldValue, newValue) {
			if (oldValue !== newValue) {
				if (newValue) {
					if (this.enabled && this.entity.enabled) this._requestDepth();
					if (this.emitter) this.emitter[name] = newValue;
				} else {
					if (this.enabled && this.entity.enabled) this._releaseDepth();
					if (this.emitter) this.emitter[name] = newValue;
				}
				if (this.emitter) {
					this.reset();
					this.emitter.resetMaterial();
					this.rebuild();
				}
			}
		};
		_proto.onSetSimpleProperty = function onSetSimpleProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
			}
		};
		_proto.onSetComplexProperty = function onSetComplexProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.resetMaterial();
				this.rebuild();
				this.reset();
			}
		};
		_proto.onSetGraphProperty = function onSetGraphProperty(name, oldValue, newValue) {
			if (this.emitter) {
				this.emitter[name] = newValue;
				this.emitter.rebuildGraphs();
				this.emitter.resetMaterial();
			}
		};
		_proto.onEnable = function onEnable() {
			var scene = this.system.app.scene;
			var layers = scene.layers;
			var data = this.data;
			for (var i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
				var asset = data[ASSET_PROPERTIES[i]];
				if (asset) {
					if (!(asset instanceof Asset)) {
						var id = parseInt(asset, 10);
						if (id >= 0) {
							asset = this.system.app.assets.get(asset);
						} else {
							continue;
						}
					}
					if (asset && !asset.resource) {
						this.system.app.assets.load(asset);
					}
				}
			}
			if (this.system.app.graphicsDevice.disableParticleSystem) {
				return;
			}
			if (!this.emitter) {
				var mesh = data.mesh;
				if (!(mesh instanceof Mesh)) {
					mesh = null;
				}
				this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
					numParticles: data.numParticles,
					emitterExtents: data.emitterExtents,
					emitterExtentsInner: data.emitterExtentsInner,
					emitterRadius: data.emitterRadius,
					emitterRadiusInner: data.emitterRadiusInner,
					emitterShape: data.emitterShape,
					initialVelocity: data.initialVelocity,
					wrap: data.wrap,
					localSpace: data.localSpace,
					screenSpace: data.screenSpace,
					wrapBounds: data.wrapBounds,
					lifetime: data.lifetime,
					rate: data.rate,
					rate2: data.rate2,
					orientation: data.orientation,
					particleNormal: data.particleNormal,
					animTilesX: data.animTilesX,
					animTilesY: data.animTilesY,
					animStartFrame: data.animStartFrame,
					animNumFrames: data.animNumFrames,
					animNumAnimations: data.animNumAnimations,
					animIndex: data.animIndex,
					randomizeAnimIndex: data.randomizeAnimIndex,
					animSpeed: data.animSpeed,
					animLoop: data.animLoop,
					startAngle: data.startAngle,
					startAngle2: data.startAngle2,
					scaleGraph: data.scaleGraph,
					scaleGraph2: data.scaleGraph2,
					colorGraph: data.colorGraph,
					colorGraph2: data.colorGraph2,
					alphaGraph: data.alphaGraph,
					alphaGraph2: data.alphaGraph2,
					localVelocityGraph: data.localVelocityGraph,
					localVelocityGraph2: data.localVelocityGraph2,
					velocityGraph: data.velocityGraph,
					velocityGraph2: data.velocityGraph2,
					rotationSpeedGraph: data.rotationSpeedGraph,
					rotationSpeedGraph2: data.rotationSpeedGraph2,
					radialSpeedGraph: data.radialSpeedGraph,
					radialSpeedGraph2: data.radialSpeedGraph2,
					colorMap: data.colorMap,
					normalMap: data.normalMap,
					loop: data.loop,
					preWarm: data.preWarm,
					sort: data.sort,
					stretch: data.stretch,
					alignToMotion: data.alignToMotion,
					lighting: data.lighting,
					halfLambert: data.halfLambert,
					intensity: data.intensity,
					depthSoftening: data.depthSoftening,
					scene: this.system.app.scene,
					mesh: mesh,
					depthWrite: data.depthWrite,
					noFog: data.noFog,
					node: this.entity,
					blendType: data.blendType
				});
				this.emitter.meshInstance.node = this.entity;
				this.emitter.drawOrder = this.drawOrder;
				if (!data.autoPlay) {
					this.pause();
					this.emitter.meshInstance.visible = false;
				}
			}
			if (this.emitter.colorMap) {
				this.addMeshInstanceToLayers();
			}
			this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
				this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled && data.depthSoftening) {
				this._requestDepth();
			}
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang;
			var scene = this.system.app.scene;
			var layers = scene.layers;
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = null;
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = null;
			}
			if (this.emitter) {
				this.removeMeshInstanceFromLayers();
				if (this.data.depthSoftening) this._releaseDepth();
				this.emitter.camera = null;
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove() {
			if (this.enabled) {
				this.enabled = false;
			}
			if (this.emitter) {
				this.emitter.destroy();
				this.emitter = null;
			}
			for (var i = 0; i < ASSET_PROPERTIES.length; i++) {
				var prop = ASSET_PROPERTIES[i];
				if (this.data[prop]) {
					this[prop] = null;
				}
			}
			this.off();
		};
		_proto.reset = function reset() {
			if (this.emitter) {
				this.emitter.reset();
			}
		};
		_proto.stop = function stop() {
			if (this.emitter) {
				this.emitter.loop = false;
				this.emitter.resetTime();
				this.emitter.addTime(0, true);
			}
		};
		_proto.pause = function pause() {
			this.data.paused = true;
		};
		_proto.unpause = function unpause() {
			this.data.paused = false;
		};
		_proto.play = function play() {
			this.data.paused = false;
			if (this.emitter) {
				this.emitter.meshInstance.visible = true;
				this.emitter.loop = this.data.loop;
				this.emitter.resetTime();
			}
		};
		_proto.isPlaying = function isPlaying() {
			if (this.data.paused) {
				return false;
			}
			if (this.emitter && this.emitter.loop) {
				return true;
			}
			return Date.now() <= this.emitter.endTime;
		};
		_proto.setInTools = function setInTools() {
			var emitter = this.emitter;
			if (emitter && !emitter.inTools) {
				emitter.inTools = true;
				this.rebuild();
			}
		};
		_proto.rebuild = function rebuild() {
			var enabled = this.enabled;
			this.enabled = false;
			if (this.emitter) {
				this.emitter.rebuild();
			}
			this.enabled = enabled;
		};
		return _createClass(ParticleSystemComponent, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this.data.enabled;
			},
			set: function set(arg) {
				this._setValue('enabled', arg);
			}
		}, {
			key: "autoPlay",
			get: function get() {
				return this.data.autoPlay;
			},
			set: function set(arg) {
				this._setValue('autoPlay', arg);
			}
		}, {
			key: "numParticles",
			get: function get() {
				return this.data.numParticles;
			},
			set: function set(arg) {
				this._setValue('numParticles', arg);
			}
		}, {
			key: "lifetime",
			get: function get() {
				return this.data.lifetime;
			},
			set: function set(arg) {
				this._setValue('lifetime', arg);
			}
		}, {
			key: "rate",
			get: function get() {
				return this.data.rate;
			},
			set: function set(arg) {
				this._setValue('rate', arg);
			}
		}, {
			key: "rate2",
			get: function get() {
				return this.data.rate2;
			},
			set: function set(arg) {
				this._setValue('rate2', arg);
			}
		}, {
			key: "startAngle",
			get: function get() {
				return this.data.startAngle;
			},
			set: function set(arg) {
				this._setValue('startAngle', arg);
			}
		}, {
			key: "startAngle2",
			get: function get() {
				return this.data.startAngle2;
			},
			set: function set(arg) {
				this._setValue('startAngle2', arg);
			}
		}, {
			key: "loop",
			get: function get() {
				return this.data.loop;
			},
			set: function set(arg) {
				this._setValue('loop', arg);
			}
		}, {
			key: "preWarm",
			get: function get() {
				return this.data.preWarm;
			},
			set: function set(arg) {
				this._setValue('preWarm', arg);
			}
		}, {
			key: "lighting",
			get: function get() {
				return this.data.lighting;
			},
			set: function set(arg) {
				this._setValue('lighting', arg);
			}
		}, {
			key: "halfLambert",
			get: function get() {
				return this.data.halfLambert;
			},
			set: function set(arg) {
				this._setValue('halfLambert', arg);
			}
		}, {
			key: "intensity",
			get: function get() {
				return this.data.intensity;
			},
			set: function set(arg) {
				this._setValue('intensity', arg);
			}
		}, {
			key: "depthWrite",
			get: function get() {
				return this.data.depthWrite;
			},
			set: function set(arg) {
				this._setValue('depthWrite', arg);
			}
		}, {
			key: "noFog",
			get: function get() {
				return this.data.noFog;
			},
			set: function set(arg) {
				this._setValue('noFog', arg);
			}
		}, {
			key: "depthSoftening",
			get: function get() {
				return this.data.depthSoftening;
			},
			set: function set(arg) {
				this._setValue('depthSoftening', arg);
			}
		}, {
			key: "sort",
			get: function get() {
				return this.data.sort;
			},
			set: function set(arg) {
				this._setValue('sort', arg);
			}
		}, {
			key: "blendType",
			get: function get() {
				return this.data.blendType;
			},
			set: function set(arg) {
				this._setValue('blendType', arg);
			}
		}, {
			key: "stretch",
			get: function get() {
				return this.data.stretch;
			},
			set: function set(arg) {
				this._setValue('stretch', arg);
			}
		}, {
			key: "alignToMotion",
			get: function get() {
				return this.data.alignToMotion;
			},
			set: function set(arg) {
				this._setValue('alignToMotion', arg);
			}
		}, {
			key: "emitterShape",
			get: function get() {
				return this.data.emitterShape;
			},
			set: function set(arg) {
				this._setValue('emitterShape', arg);
			}
		}, {
			key: "emitterExtents",
			get: function get() {
				return this.data.emitterExtents;
			},
			set: function set(arg) {
				this._setValue('emitterExtents', arg);
			}
		}, {
			key: "emitterExtentsInner",
			get: function get() {
				return this.data.emitterExtentsInner;
			},
			set: function set(arg) {
				this._setValue('emitterExtentsInner', arg);
			}
		}, {
			key: "emitterRadius",
			get: function get() {
				return this.data.emitterRadius;
			},
			set: function set(arg) {
				this._setValue('emitterRadius', arg);
			}
		}, {
			key: "emitterRadiusInner",
			get: function get() {
				return this.data.emitterRadiusInner;
			},
			set: function set(arg) {
				this._setValue('emitterRadiusInner', arg);
			}
		}, {
			key: "initialVelocity",
			get: function get() {
				return this.data.initialVelocity;
			},
			set: function set(arg) {
				this._setValue('initialVelocity', arg);
			}
		}, {
			key: "wrap",
			get: function get() {
				return this.data.wrap;
			},
			set: function set(arg) {
				this._setValue('wrap', arg);
			}
		}, {
			key: "wrapBounds",
			get: function get() {
				return this.data.wrapBounds;
			},
			set: function set(arg) {
				this._setValue('wrapBounds', arg);
			}
		}, {
			key: "localSpace",
			get: function get() {
				return this.data.localSpace;
			},
			set: function set(arg) {
				this._setValue('localSpace', arg);
			}
		}, {
			key: "screenSpace",
			get: function get() {
				return this.data.screenSpace;
			},
			set: function set(arg) {
				this._setValue('screenSpace', arg);
			}
		}, {
			key: "colorMapAsset",
			get: function get() {
				return this.data.colorMapAsset;
			},
			set: function set(arg) {
				this._setValue('colorMapAsset', arg);
			}
		}, {
			key: "normalMapAsset",
			get: function get() {
				return this.data.normalMapAsset;
			},
			set: function set(arg) {
				this._setValue('normalMapAsset', arg);
			}
		}, {
			key: "mesh",
			get: function get() {
				return this.data.mesh;
			},
			set: function set(arg) {
				this._setValue('mesh', arg);
			}
		}, {
			key: "meshAsset",
			get: function get() {
				return this.data.meshAsset;
			},
			set: function set(arg) {
				this._setValue('meshAsset', arg);
			}
		}, {
			key: "renderAsset",
			get: function get() {
				return this.data.renderAsset;
			},
			set: function set(arg) {
				this._setValue('renderAsset', arg);
			}
		}, {
			key: "orientation",
			get: function get() {
				return this.data.orientation;
			},
			set: function set(arg) {
				this._setValue('orientation', arg);
			}
		}, {
			key: "particleNormal",
			get: function get() {
				return this.data.particleNormal;
			},
			set: function set(arg) {
				this._setValue('particleNormal', arg);
			}
		}, {
			key: "localVelocityGraph",
			get: function get() {
				return this.data.localVelocityGraph;
			},
			set: function set(arg) {
				this._setValue('localVelocityGraph', arg);
			}
		}, {
			key: "localVelocityGraph2",
			get: function get() {
				return this.data.localVelocityGraph2;
			},
			set: function set(arg) {
				this._setValue('localVelocityGraph2', arg);
			}
		}, {
			key: "velocityGraph",
			get: function get() {
				return this.data.velocityGraph;
			},
			set: function set(arg) {
				this._setValue('velocityGraph', arg);
			}
		}, {
			key: "velocityGraph2",
			get: function get() {
				return this.data.velocityGraph2;
			},
			set: function set(arg) {
				this._setValue('velocityGraph2', arg);
			}
		}, {
			key: "rotationSpeedGraph",
			get: function get() {
				return this.data.rotationSpeedGraph;
			},
			set: function set(arg) {
				this._setValue('rotationSpeedGraph', arg);
			}
		}, {
			key: "rotationSpeedGraph2",
			get: function get() {
				return this.data.rotationSpeedGraph2;
			},
			set: function set(arg) {
				this._setValue('rotationSpeedGraph2', arg);
			}
		}, {
			key: "radialSpeedGraph",
			get: function get() {
				return this.data.radialSpeedGraph;
			},
			set: function set(arg) {
				this._setValue('radialSpeedGraph', arg);
			}
		}, {
			key: "radialSpeedGraph2",
			get: function get() {
				return this.data.radialSpeedGraph2;
			},
			set: function set(arg) {
				this._setValue('radialSpeedGraph2', arg);
			}
		}, {
			key: "scaleGraph",
			get: function get() {
				return this.data.scaleGraph;
			},
			set: function set(arg) {
				this._setValue('scaleGraph', arg);
			}
		}, {
			key: "scaleGraph2",
			get: function get() {
				return this.data.scaleGraph2;
			},
			set: function set(arg) {
				this._setValue('scaleGraph2', arg);
			}
		}, {
			key: "colorGraph",
			get: function get() {
				return this.data.colorGraph;
			},
			set: function set(arg) {
				this._setValue('colorGraph', arg);
			}
		}, {
			key: "colorGraph2",
			get: function get() {
				return this.data.colorGraph2;
			},
			set: function set(arg) {
				this._setValue('colorGraph2', arg);
			}
		}, {
			key: "alphaGraph",
			get: function get() {
				return this.data.alphaGraph;
			},
			set: function set(arg) {
				this._setValue('alphaGraph', arg);
			}
		}, {
			key: "alphaGraph2",
			get: function get() {
				return this.data.alphaGraph2;
			},
			set: function set(arg) {
				this._setValue('alphaGraph2', arg);
			}
		}, {
			key: "colorMap",
			get: function get() {
				return this.data.colorMap;
			},
			set: function set(arg) {
				this._setValue('colorMap', arg);
			}
		}, {
			key: "normalMap",
			get: function get() {
				return this.data.normalMap;
			},
			set: function set(arg) {
				this._setValue('normalMap', arg);
			}
		}, {
			key: "animTilesX",
			get: function get() {
				return this.data.animTilesX;
			},
			set: function set(arg) {
				this._setValue('animTilesX', arg);
			}
		}, {
			key: "animTilesY",
			get: function get() {
				return this.data.animTilesY;
			},
			set: function set(arg) {
				this._setValue('animTilesY', arg);
			}
		}, {
			key: "animStartFrame",
			get: function get() {
				return this.data.animStartFrame;
			},
			set: function set(arg) {
				this._setValue('animStartFrame', arg);
			}
		}, {
			key: "animNumFrames",
			get: function get() {
				return this.data.animNumFrames;
			},
			set: function set(arg) {
				this._setValue('animNumFrames', arg);
			}
		}, {
			key: "animNumAnimations",
			get: function get() {
				return this.data.animNumAnimations;
			},
			set: function set(arg) {
				this._setValue('animNumAnimations', arg);
			}
		}, {
			key: "animIndex",
			get: function get() {
				return this.data.animIndex;
			},
			set: function set(arg) {
				this._setValue('animIndex', arg);
			}
		}, {
			key: "randomizeAnimIndex",
			get: function get() {
				return this.data.randomizeAnimIndex;
			},
			set: function set(arg) {
				this._setValue('randomizeAnimIndex', arg);
			}
		}, {
			key: "animSpeed",
			get: function get() {
				return this.data.animSpeed;
			},
			set: function set(arg) {
				this._setValue('animSpeed', arg);
			}
		}, {
			key: "animLoop",
			get: function get() {
				return this.data.animLoop;
			},
			set: function set(arg) {
				this._setValue('animLoop', arg);
			}
		}, {
			key: "layers",
			get: function get() {
				return this.data.layers;
			},
			set: function set(arg) {
				this._setValue('layers', arg);
			}
		}, {
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(drawOrder) {
				this._drawOrder = drawOrder;
				if (this.emitter) {
					this.emitter.drawOrder = drawOrder;
				}
			}
		}]);
	}(Component);

	var ParticleSystemComponentData = function ParticleSystemComponentData() {
		this.numParticles = 1;
		this.rate = 1;
		this.rate2 = null;
		this.startAngle = 0;
		this.startAngle2 = null;
		this.lifetime = 50;
		this.emitterExtents = new Vec3();
		this.emitterExtentsInner = new Vec3();
		this.emitterRadius = 0;
		this.emitterRadiusInner = 0;
		this.emitterShape = EMITTERSHAPE_BOX;
		this.initialVelocity = 0;
		this.wrap = false;
		this.wrapBounds = new Vec3();
		this.localSpace = false;
		this.screenSpace = false;
		this.colorMap = null;
		this.colorMapAsset = null;
		this.normalMap = null;
		this.normalMapAsset = null;
		this.loop = true;
		this.preWarm = false;
		this.sort = 0;
		this.mode = PARTICLEMODE_GPU;
		this.scene = null;
		this.lighting = false;
		this.halfLambert = false;
		this.intensity = 1;
		this.stretch = 0.0;
		this.alignToMotion = false;
		this.depthSoftening = 0;
		this.renderAsset = null;
		this.meshAsset = null;
		this.mesh = null;
		this.depthWrite = false;
		this.noFog = false;
		this.orientation = PARTICLEORIENTATION_SCREEN;
		this.particleNormal = new Vec3(0, 1, 0);
		this.animTilesX = 1;
		this.animTilesY = 1;
		this.animStartFrame = 0;
		this.animNumFrames = 1;
		this.animNumAnimations = 1;
		this.animIndex = 0;
		this.randomizeAnimIndex = false;
		this.animSpeed = 1;
		this.animLoop = true;
		this.scaleGraph = null;
		this.scaleGraph2 = null;
		this.colorGraph = null;
		this.colorGraph2 = null;
		this.alphaGraph = null;
		this.alphaGraph2 = null;
		this.localVelocityGraph = null;
		this.localVelocityGraph2 = null;
		this.velocityGraph = null;
		this.velocityGraph2 = null;
		this.rotationSpeedGraph = null;
		this.rotationSpeedGraph2 = null;
		this.radialSpeedGraph = null;
		this.radialSpeedGraph2 = null;
		this.blendType = BLEND_NORMAL;
		this.enabled = true;
		this.paused = false;
		this.autoPlay = true;
		this.layers = [LAYERID_WORLD];
	};

	var _schema$a = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];
	var ParticleSystemComponentSystem = function (_ComponentSystem) {
		function ParticleSystemComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'particlesystem';
			_this.ComponentType = ParticleSystemComponent;
			_this.DataType = ParticleSystemComponentData;
			_this.schema = _schema$a;
			_this.propertyTypes = {
				emitterExtents: 'vec3',
				emitterExtentsInner: 'vec3',
				particleNormal: 'vec3',
				wrapBounds: 'vec3',
				localVelocityGraph: 'curveset',
				localVelocityGraph2: 'curveset',
				velocityGraph: 'curveset',
				velocityGraph2: 'curveset',
				colorGraph: 'curveset',
				colorGraph2: 'curveset',
				alphaGraph: 'curve',
				alphaGraph2: 'curve',
				rotationSpeedGraph: 'curve',
				rotationSpeedGraph2: 'curve',
				radialSpeedGraph: 'curve',
				radialSpeedGraph2: 'curve',
				scaleGraph: 'curve',
				scaleGraph2: 'curve'
			};
			_this.on('beforeremove', _this.onBeforeRemove, _this);
			_this.app.systems.on('update', _this.onUpdate, _this);
			return _this;
		}
		_inheritsLoose(ParticleSystemComponentSystem, _ComponentSystem);
		var _proto = ParticleSystemComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			var data = {};
			properties = [];
			var types = this.propertyTypes;
			if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
				_data.meshAsset = _data.mesh;
				delete _data.mesh;
			}
			for (var prop in _data) {
				if (_data.hasOwnProperty(prop)) {
					properties.push(prop);
					data[prop] = _data[prop];
				}
				if (types[prop] === 'vec3') {
					if (Array.isArray(data[prop])) {
						data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
					}
				} else if (types[prop] === 'curve') {
					if (!(data[prop] instanceof Curve)) {
						var t = data[prop].type;
						data[prop] = new Curve(data[prop].keys);
						data[prop].type = t;
					}
				} else if (types[prop] === 'curveset') {
					if (!(data[prop] instanceof CurveSet)) {
						var _t = data[prop].type;
						data[prop] = new CurveSet(data[prop].keys);
						data[prop].type = _t;
					}
				}
				if (data.layers && Array.isArray(data.layers)) {
					data.layers = data.layers.slice(0);
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.particlesystem.data;
			var schema = this.schema;
			var data = {};
			for (var i = 0, len = schema.length; i < len; i++) {
				var prop = schema[i];
				var sourceProp = source[prop];
				if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
					sourceProp = sourceProp.clone();
					data[prop] = sourceProp;
				} else if (prop === 'layers') {
					data.layers = source.layers.slice(0);
				} else {
					if (sourceProp !== null && sourceProp !== undefined) {
						data[prop] = sourceProp;
					}
				}
			}
			return this.addComponent(clone, data);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			var numSteps;
			var stats = this.app.stats.particles;
			var composition = this.app.scene.layers;
			for (var i = 0; i < composition.layerList.length; i++) {
				composition.layerList[i].requiresLightCube = false;
			}
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					var entity = component.entity;
					var data = component.data;
					if (data.enabled && entity.enabled) {
						var emitter = entity.particlesystem.emitter;
						if (!(emitter != null && emitter.meshInstance.visible)) continue;
						if (emitter.lighting) {
							var layers = data.layers;
							for (var _i = 0; _i < layers.length; _i++) {
								var layer = composition.getLayerById(layers[_i]);
								if (layer) {
									layer.requiresLightCube = true;
								}
							}
						}
						if (!data.paused) {
							emitter.simTime += dt;
							if (emitter.simTime > emitter.fixedTimeStep) {
								numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
								emitter.simTime -= numSteps * emitter.fixedTimeStep;
							}
							if (numSteps) {
								numSteps = Math.min(numSteps, emitter.maxSubSteps);
								for (var _i2 = 0; _i2 < numSteps; _i2++) {
									emitter.addTime(emitter.fixedTimeStep, false);
								}
								stats._updatesPerFrame += numSteps;
								stats._frameTime += emitter._addTimeTime;
								emitter._addTimeTime = 0;
							}
							emitter.finishFrame();
						}
					}
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onBeforeRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return ParticleSystemComponentSystem;
	}(ComponentSystem);

	var SkinInstanceCachedObject = function (_RefCountedObject) {
		function SkinInstanceCachedObject(skin, skinInstance) {
			var _this;
			_this = _RefCountedObject.call(this) || this;
			_this.skin = skin;
			_this.skinInstance = skinInstance;
			return _this;
		}
		_inheritsLoose(SkinInstanceCachedObject, _RefCountedObject);
		return SkinInstanceCachedObject;
	}(RefCountedObject);
	var SkinInstanceCache = function () {
		function SkinInstanceCache() {}
		SkinInstanceCache.createCachedSkinInstance = function createCachedSkinInstance(skin, rootBone, entity) {
			var skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);
			if (!skinInst) {
				skinInst = new SkinInstance(skin);
				skinInst.resolve(rootBone, entity);
				SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
			}
			return skinInst;
		};
		SkinInstanceCache.getCachedSkinInstance = function getCachedSkinInstance(skin, rootBone) {
			var skinInstance = null;
			var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
			if (cachedObjArray) {
				var cachedObj = cachedObjArray.find(function (element) {
					return element.skin === skin;
				});
				if (cachedObj) {
					cachedObj.incRefCount();
					skinInstance = cachedObj.skinInstance;
				}
			}
			return skinInstance;
		};
		SkinInstanceCache.addCachedSkinInstance = function addCachedSkinInstance(skin, rootBone, skinInstance) {
			var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
			if (!cachedObjArray) {
				cachedObjArray = [];
				SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
			}
			var cachedObj = cachedObjArray.find(function (element) {
				return element.skin === skin;
			});
			if (!cachedObj) {
				cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
				cachedObjArray.push(cachedObj);
			}
			cachedObj.incRefCount();
		};
		SkinInstanceCache.removeCachedSkinInstance = function removeCachedSkinInstance(skinInstance) {
			if (skinInstance) {
				var rootBone = skinInstance.rootBone;
				if (rootBone) {
					var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
					if (cachedObjArray) {
						var cachedObjIndex = cachedObjArray.findIndex(function (element) {
							return element.skinInstance === skinInstance;
						});
						if (cachedObjIndex >= 0) {
							var cachedObj = cachedObjArray[cachedObjIndex];
							cachedObj.decRefCount();
							if (cachedObj.refCount === 0) {
								cachedObjArray.splice(cachedObjIndex, 1);
								if (!cachedObjArray.length) {
									SkinInstanceCache._skinInstanceCache.delete(rootBone);
								}
								if (skinInstance) {
									skinInstance.destroy();
									cachedObj.skinInstance = null;
								}
							}
						}
					}
				}
			}
		};
		return SkinInstanceCache;
	}();
	SkinInstanceCache._skinInstanceCache = new Map();

	var AssetReference = function () {
		function AssetReference(propertyName, parent, registry, callbacks, scope) {
			this._evtLoadById = null;
			this._evtUnloadById = null;
			this._evtAddById = null;
			this._evtRemoveById = null;
			this._evtLoadByUrl = null;
			this._evtAddByUrl = null;
			this._evtRemoveByUrl = null;
			this.propertyName = propertyName;
			this.parent = parent;
			this._scope = scope;
			this._registry = registry;
			this.id = null;
			this.url = null;
			this.asset = null;
			this._onAssetLoad = callbacks.load;
			this._onAssetAdd = callbacks.add;
			this._onAssetRemove = callbacks.remove;
			this._onAssetUnload = callbacks.unload;
		}
		var _proto = AssetReference.prototype;
		_proto._bind = function _bind() {
			if (this.id) {
				if (this._onAssetLoad) this._evtLoadById = this._registry.on("load:" + this.id, this._onLoad, this);
				if (this._onAssetAdd) this._evtAddById = this._registry.once("add:" + this.id, this._onAdd, this);
				if (this._onAssetRemove) this._evtRemoveById = this._registry.on("remove:" + this.id, this._onRemove, this);
				if (this._onAssetUnload) this._evtUnloadById = this._registry.on("unload:" + this.id, this._onUnload, this);
			}
			if (this.url) {
				if (this._onAssetLoad) this._evtLoadByUrl = this._registry.on("load:url:" + this.url, this._onLoad, this);
				if (this._onAssetAdd) this._evtAddByUrl = this._registry.once("add:url:" + this.url, this._onAdd, this);
				if (this._onAssetRemove) this._evtRemoveByUrl = this._registry.on("remove:url:" + this.url, this._onRemove, this);
			}
		};
		_proto._unbind = function _unbind() {
			if (this.id) {
				var _this$_evtLoadById, _this$_evtAddById, _this$_evtRemoveById, _this$_evtUnloadById;
				(_this$_evtLoadById = this._evtLoadById) == null || _this$_evtLoadById.off();
				this._evtLoadById = null;
				(_this$_evtAddById = this._evtAddById) == null || _this$_evtAddById.off();
				this._evtAddById = null;
				(_this$_evtRemoveById = this._evtRemoveById) == null || _this$_evtRemoveById.off();
				this._evtRemoveById = null;
				(_this$_evtUnloadById = this._evtUnloadById) == null || _this$_evtUnloadById.off();
				this._evtUnloadById = null;
			}
			if (this.url) {
				var _this$_evtLoadByUrl, _this$_evtAddByUrl, _this$_evtRemoveByUrl;
				(_this$_evtLoadByUrl = this._evtLoadByUrl) == null || _this$_evtLoadByUrl.off();
				this._evtLoadByUrl = null;
				(_this$_evtAddByUrl = this._evtAddByUrl) == null || _this$_evtAddByUrl.off();
				this._evtAddByUrl = null;
				(_this$_evtRemoveByUrl = this._evtRemoveByUrl) == null || _this$_evtRemoveByUrl.off();
				this._evtRemoveByUrl = null;
			}
		};
		_proto._onLoad = function _onLoad(asset) {
			this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
		};
		_proto._onAdd = function _onAdd(asset) {
			this.asset = asset;
			this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
		};
		_proto._onRemove = function _onRemove(asset) {
			this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
			this.asset = null;
		};
		_proto._onUnload = function _onUnload(asset) {
			this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
		};
		return _createClass(AssetReference, [{
			key: "id",
			get: function get() {
				return this._id;
			},
			set: function set(value) {
				if (this.url) throw Error('Can\'t set id and url');
				this._unbind();
				this._id = value;
				this.asset = this._registry.get(this._id);
				this._bind();
			}
		}, {
			key: "url",
			get: function get() {
				return this._url;
			},
			set: function set(value) {
				if (this.id) throw Error('Can\'t set id and url');
				this._unbind();
				this._url = value;
				this.asset = this._registry.getByUrl(this._url);
				this._bind();
			}
		}]);
	}();

	var RenderComponent = function (_Component) {
		function RenderComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._type = 'asset';
			_this._castShadows = true;
			_this._receiveShadows = true;
			_this._castShadowsLightmap = true;
			_this._lightmapped = false;
			_this._lightmapSizeMultiplier = 1;
			_this.isStatic = false;
			_this._batchGroupId = -1;
			_this._layers = [LAYERID_WORLD];
			_this._renderStyle = RENDERSTYLE_SOLID;
			_this._meshInstances = [];
			_this._customAabb = null;
			_this._area = null;
			_this._assetReference = void 0;
			_this._materialReferences = [];
			_this._material = void 0;
			_this._rootBone = null;
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._evtSetMeshes = null;
			_this._assetReference = new AssetReference('asset', _this, system.app.assets, {
				add: _this._onRenderAssetAdded,
				load: _this._onRenderAssetLoad,
				remove: _this._onRenderAssetRemove,
				unload: _this._onRenderAssetUnload
			}, _this);
			_this._material = system.defaultMaterial;
			entity.on('remove', _this.onRemoveChild, _this);
			entity.on('removehierarchy', _this.onRemoveChild, _this);
			entity.on('insert', _this.onInsertChild, _this);
			entity.on('inserthierarchy', _this.onInsertChild, _this);
			return _this;
		}
		_inheritsLoose(RenderComponent, _Component);
		var _proto = RenderComponent.prototype;
		_proto.assignAsset = function assignAsset(asset) {
			var id = asset instanceof Asset ? asset.id : asset;
			this._assetReference.id = id;
		};
		_proto.destroyMeshInstances = function destroyMeshInstances() {
			var meshInstances = this._meshInstances;
			if (meshInstances) {
				this.removeFromLayers();
				this._clearSkinInstances();
				for (var i = 0; i < meshInstances.length; i++) {
					meshInstances[i].destroy();
				}
				this._meshInstances.length = 0;
			}
		};
		_proto.addToLayers = function addToLayers() {
			var layers = this.system.app.scene.layers;
			for (var i = 0; i < this._layers.length; i++) {
				var layer = layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.addMeshInstances(this._meshInstances);
				}
			}
		};
		_proto.removeFromLayers = function removeFromLayers() {
			if (this._meshInstances && this._meshInstances.length) {
				var layers = this.system.app.scene.layers;
				for (var i = 0; i < this._layers.length; i++) {
					var layer = layers.getLayerById(this._layers[i]);
					if (layer) {
						layer.removeMeshInstances(this._meshInstances);
					}
				}
			}
		};
		_proto.onRemoveChild = function onRemoveChild() {
			this.removeFromLayers();
		};
		_proto.onInsertChild = function onInsertChild() {
			if (this._meshInstances && this.enabled && this.entity.enabled) {
				this.addToLayers();
			}
		};
		_proto.onRemove = function onRemove() {
			this.destroyMeshInstances();
			this.asset = null;
			this.materialAsset = null;
			this._assetReference.id = null;
			for (var i = 0; i < this._materialReferences.length; i++) {
				this._materialReferences[i].id = null;
			}
			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addMeshInstances(this._meshInstances);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances(this._meshInstances);
		};
		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			var layers = scene.layers;
			if (this._rootBone) {
				this._cloneSkinInstances();
			}
			this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
				this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
			}
			var isAsset = this._type === 'asset';
			if (this._meshInstances && this._meshInstances.length) {
				this.addToLayers();
			} else if (isAsset && this.asset) {
				this._onRenderAssetAdded();
			}
			for (var i = 0; i < this._materialReferences.length; i++) {
				if (this._materialReferences[i].asset) {
					this.system.app.assets.load(this._materialReferences[i].asset);
				}
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher;
				(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang;
			var app = this.system.app;
			var scene = app.scene;
			var layers = scene.layers;
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = null;
			if (this._rootBone) {
				this._clearSkinInstances();
			}
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = null;
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher2;
				(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
			}
			this.removeFromLayers();
		};
		_proto.hide = function hide() {
			if (this._meshInstances) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].visible = false;
				}
			}
		};
		_proto.show = function show() {
			if (this._meshInstances) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					this._meshInstances[i].visible = true;
				}
			}
		};
		_proto._onRenderAssetAdded = function _onRenderAssetAdded() {
			if (!this._assetReference.asset) return;
			if (this._assetReference.asset.resource) {
				this._onRenderAssetLoad();
			} else if (this.enabled && this.entity.enabled) {
				this.system.app.assets.load(this._assetReference.asset);
			}
		};
		_proto._onRenderAssetLoad = function _onRenderAssetLoad() {
			this.destroyMeshInstances();
			if (this._assetReference.asset) {
				var _this$_evtSetMeshes;
				var render = this._assetReference.asset.resource;
				(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();
				this._evtSetMeshes = render.on('set:meshes', this._onSetMeshes, this);
				if (render.meshes) {
					this._onSetMeshes(render.meshes);
				}
			}
		};
		_proto._onSetMeshes = function _onSetMeshes(meshes) {
			this._cloneMeshes(meshes);
		};
		_proto._clearSkinInstances = function _clearSkinInstances() {
			for (var i = 0; i < this._meshInstances.length; i++) {
				var meshInstance = this._meshInstances[i];
				SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
				meshInstance.skinInstance = null;
			}
		};
		_proto._cloneSkinInstances = function _cloneSkinInstances() {
			if (this._meshInstances.length && this._rootBone instanceof GraphNode) {
				for (var i = 0; i < this._meshInstances.length; i++) {
					var meshInstance = this._meshInstances[i];
					var mesh = meshInstance.mesh;
					if (mesh.skin && !meshInstance.skinInstance) {
						meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone, this.entity);
					}
				}
			}
		};
		_proto._cloneMeshes = function _cloneMeshes(meshes) {
			if (meshes && meshes.length) {
				var meshInstances = [];
				for (var i = 0; i < meshes.length; i++) {
					var mesh = meshes[i];
					var material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
					var meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
					meshInstances.push(meshInst);
					if (mesh.morph) {
						meshInst.morphInstance = new MorphInstance(mesh.morph);
					}
				}
				this.meshInstances = meshInstances;
				this._cloneSkinInstances();
			}
		};
		_proto._onRenderAssetUnload = function _onRenderAssetUnload() {
			if (this._type === 'asset') {
				this.destroyMeshInstances();
			}
		};
		_proto._onRenderAssetRemove = function _onRenderAssetRemove() {
			var _this$_evtSetMeshes2;
			(_this$_evtSetMeshes2 = this._evtSetMeshes) == null || _this$_evtSetMeshes2.off();
			this._evtSetMeshes = null;
			this._onRenderAssetUnload();
		};
		_proto._onMaterialAdded = function _onMaterialAdded(index, component, asset) {
			if (asset.resource) {
				this._onMaterialLoad(index, component, asset);
			} else {
				if (this.enabled && this.entity.enabled) {
					this.system.app.assets.load(asset);
				}
			}
		};
		_proto._updateMainMaterial = function _updateMainMaterial(index, material) {
			if (index === 0) {
				this.material = material;
			}
		};
		_proto._onMaterialLoad = function _onMaterialLoad(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = asset.resource;
			}
			this._updateMainMaterial(index, asset.resource);
		};
		_proto._onMaterialRemove = function _onMaterialRemove(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = this.system.defaultMaterial;
			}
			this._updateMainMaterial(index, this.system.defaultMaterial);
		};
		_proto._onMaterialUnload = function _onMaterialUnload(index, component, asset) {
			if (this._meshInstances[index]) {
				this._meshInstances[index].material = this.system.defaultMaterial;
			}
			this._updateMainMaterial(index, this.system.defaultMaterial);
		};
		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
			if (oldRender.rootBone) {
				this.rootBone = duplicatedIdsMap[oldRender.rootBone.getGuid()];
			}
		};
		return _createClass(RenderComponent, [{
			key: "renderStyle",
			get: function get() {
				return this._renderStyle;
			},
			set: function set(renderStyle) {
				if (this._renderStyle !== renderStyle) {
					this._renderStyle = renderStyle;
					MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
				}
			}
		}, {
			key: "customAabb",
			get: function get() {
				return this._customAabb;
			},
			set: function set(value) {
				this._customAabb = value;
				var mi = this._meshInstances;
				if (mi) {
					for (var i = 0; i < mi.length; i++) {
						mi[i].setCustomAabb(this._customAabb);
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type !== value) {
					this._area = null;
					this._type = value;
					this.destroyMeshInstances();
					if (value !== 'asset') {
						var material = this._material;
						if (!material || material === this.system.defaultMaterial) {
							material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
						}
						var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
						this._area = primData.area;
						this.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];
					}
				}
			}
		}, {
			key: "meshInstances",
			get: function get() {
				return this._meshInstances;
			},
			set: function set(value) {
				this.destroyMeshInstances();
				this._meshInstances = value;
				if (this._meshInstances) {
					var mi = this._meshInstances;
					for (var i = 0; i < mi.length; i++) {
						if (!mi[i].node) {
							mi[i].node = this.entity;
						}
						mi[i].castShadow = this._castShadows;
						mi[i].receiveShadow = this._receiveShadows;
						mi[i].renderStyle = this._renderStyle;
						mi[i].setLightmapped(this._lightmapped);
						mi[i].setCustomAabb(this._customAabb);
					}
					if (this.enabled && this.entity.enabled) {
						this.addToLayers();
					}
				}
			}
		}, {
			key: "lightmapped",
			get: function get() {
				return this._lightmapped;
			},
			set: function set(value) {
				if (value !== this._lightmapped) {
					this._lightmapped = value;
					var mi = this._meshInstances;
					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].setLightmapped(value);
						}
					}
				}
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this._castShadows;
			},
			set: function set(value) {
				if (this._castShadows !== value) {
					var mi = this._meshInstances;
					if (mi) {
						var layers = this.layers;
						var scene = this.system.app.scene;
						if (this._castShadows && !value) {
							for (var i = 0; i < layers.length; i++) {
								var layer = scene.layers.getLayerById(this.layers[i]);
								if (layer) {
									layer.removeShadowCasters(mi);
								}
							}
						}
						for (var _i = 0; _i < mi.length; _i++) {
							mi[_i].castShadow = value;
						}
						if (!this._castShadows && value) {
							for (var _i2 = 0; _i2 < layers.length; _i2++) {
								var _layer = scene.layers.getLayerById(layers[_i2]);
								if (_layer) {
									_layer.addShadowCasters(mi);
								}
							}
						}
					}
					this._castShadows = value;
				}
			}
		}, {
			key: "receiveShadows",
			get: function get() {
				return this._receiveShadows;
			},
			set: function set(value) {
				if (this._receiveShadows !== value) {
					this._receiveShadows = value;
					var mi = this._meshInstances;
					if (mi) {
						for (var i = 0; i < mi.length; i++) {
							mi[i].receiveShadow = value;
						}
					}
				}
			}
		}, {
			key: "castShadowsLightmap",
			get: function get() {
				return this._castShadowsLightmap;
			},
			set: function set(value) {
				this._castShadowsLightmap = value;
			}
		}, {
			key: "lightmapSizeMultiplier",
			get: function get() {
				return this._lightmapSizeMultiplier;
			},
			set: function set(value) {
				this._lightmapSizeMultiplier = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				var layers = this.system.app.scene.layers;
				var layer;
				if (this._meshInstances) {
					for (var i = 0; i < this._layers.length; i++) {
						layer = layers.getLayerById(this._layers[i]);
						if (layer) {
							layer.removeMeshInstances(this._meshInstances);
						}
					}
				}
				this._layers.length = 0;
				for (var _i3 = 0; _i3 < value.length; _i3++) {
					this._layers[_i3] = value[_i3];
				}
				if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;
				for (var _i4 = 0; _i4 < this._layers.length; _i4++) {
					layer = layers.getLayerById(this._layers[_i4]);
					if (layer) {
						layer.addMeshInstances(this._meshInstances);
					}
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId !== value) {
					if (this.entity.enabled && this._batchGroupId >= 0) {
						var _this$system$app$batc;
						(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
					}
					if (this.entity.enabled && value >= 0) {
						var _this$system$app$batc2;
						(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.RENDER, value, this.entity);
					}
					if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
						this.addToLayers();
					}
					this._batchGroupId = value;
				}
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				if (this._material !== value) {
					this._material = value;
					if (this._meshInstances && this._type !== 'asset') {
						for (var i = 0; i < this._meshInstances.length; i++) {
							this._meshInstances[i].material = value;
						}
					}
				}
			}
		}, {
			key: "materialAssets",
			get: function get() {
				return this._materialReferences.map(function (ref) {
					return ref.id;
				});
			},
			set: function set(value) {
				if (value === void 0) {
					value = [];
				}
				if (this._materialReferences.length > value.length) {
					for (var i = value.length; i < this._materialReferences.length; i++) {
						this._materialReferences[i].id = null;
					}
					this._materialReferences.length = value.length;
				}
				for (var _i5 = 0; _i5 < value.length; _i5++) {
					if (!this._materialReferences[_i5]) {
						this._materialReferences.push(new AssetReference(_i5, this, this.system.app.assets, {
							add: this._onMaterialAdded,
							load: this._onMaterialLoad,
							remove: this._onMaterialRemove,
							unload: this._onMaterialUnload
						}, this));
					}
					if (value[_i5]) {
						var id = value[_i5] instanceof Asset ? value[_i5].id : value[_i5];
						if (this._materialReferences[_i5].id !== id) {
							this._materialReferences[_i5].id = id;
						}
						if (this._materialReferences[_i5].asset) {
							this._onMaterialAdded(_i5, this, this._materialReferences[_i5].asset);
						}
					} else {
						this._materialReferences[_i5].id = null;
						if (this._meshInstances[_i5]) {
							this._meshInstances[_i5].material = this.system.defaultMaterial;
						}
					}
				}
			}
		}, {
			key: "asset",
			get: function get() {
				return this._assetReference.id;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._assetReference.id === id) return;
				if (this._assetReference.asset && this._assetReference.asset.resource) {
					this._onRenderAssetRemove();
				}
				this._assetReference.id = id;
				if (this._assetReference.asset) {
					this._onRenderAssetAdded();
				}
			}
		}, {
			key: "rootBone",
			get: function get() {
				return this._rootBone;
			},
			set: function set(value) {
				if (this._rootBone !== value) {
					var isString = typeof value === 'string';
					if (this._rootBone && isString && this._rootBone.getGuid() === value) {
						return;
					}
					if (this._rootBone) {
						this._clearSkinInstances();
					}
					if (value instanceof GraphNode) {
						this._rootBone = value;
					} else if (isString) {
						this._rootBone = this.system.app.getEntityFromIndex(value) || null;
						if (!this._rootBone) ;
					} else {
						this._rootBone = null;
					}
					if (this._rootBone) {
						this._cloneSkinInstances();
					}
				}
			}
		}]);
	}(Component);

	var RenderComponentData = function RenderComponentData() {
		this.enabled = true;
	};

	var _schema$9 = ['enabled'];
	var _properties$1 = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId', 'rootBone'];
	var RenderComponentSystem = function (_ComponentSystem) {
		function RenderComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'render';
			_this.ComponentType = RenderComponent;
			_this.DataType = RenderComponentData;
			_this.schema = _schema$9;
			_this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
			_this.on('beforeremove', _this.onRemove, _this);
			return _this;
		}
		_inheritsLoose(RenderComponentSystem, _ComponentSystem);
		var _proto = RenderComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
				_data.batchGroupId = -1;
			}
			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}
			for (var i = 0; i < _properties$1.length; i++) {
				if (_data.hasOwnProperty(_properties$1[i])) {
					component[_properties$1[i]] = _data[_properties$1[i]];
				}
			}
			if (_data.aabbCenter && _data.aabbHalfExtents) {
				component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, _data, _schema$9);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {};
			for (var i = 0; i < _properties$1.length; i++) {
				data[_properties$1[i]] = entity.render[_properties$1[i]];
			}
			data.enabled = entity.render.enabled;
			delete data.meshInstances;
			var component = this.addComponent(clone, data);
			var srcMeshInstances = entity.render.meshInstances;
			var meshes = srcMeshInstances.map(function (mi) {
				return mi.mesh;
			});
			component._onSetMeshes(meshes);
			for (var m = 0; m < srcMeshInstances.length; m++) {
				component.meshInstances[m].material = srcMeshInstances[m].material;
			}
			if (entity.render.customAabb) {
				component.customAabb = entity.render.customAabb.clone();
			}
			return component;
		};
		_proto.onRemove = function onRemove(entity, component) {
			component.onRemove();
		};
		return RenderComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(RenderComponent.prototype, _schema$9);

	var ObjectPool = function () {
		function ObjectPool(constructorFunc, size) {
			this._constructor = void 0;
			this._pool = [];
			this._count = 0;
			this._constructor = constructorFunc;
			this._resize(size);
		}
		var _proto = ObjectPool.prototype;
		_proto._resize = function _resize(size) {
			if (size > this._pool.length) {
				for (var i = this._pool.length; i < size; i++) {
					this._pool[i] = new this._constructor();
				}
			}
		};
		_proto.allocate = function allocate() {
			if (this._count >= this._pool.length) {
				this._resize(this._pool.length * 2);
			}
			return this._pool[this._count++];
		};
		_proto.freeAll = function freeAll() {
			this._count = 0;
		};
		return ObjectPool;
	}();

	var _ammoTransform;
	var _ammoVec1, _ammoVec2, _ammoQuat;
	var _quat1 = new Quat();
	var _quat2 = new Quat();
	var _vec3 = new Vec3();
	var RigidBodyComponent = function (_Component) {
		function RigidBodyComponent() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Component.call.apply(_Component, [this].concat(args)) || this;
			_this._angularDamping = 0;
			_this._angularFactor = new Vec3(1, 1, 1);
			_this._angularVelocity = new Vec3();
			_this._body = null;
			_this._friction = 0.5;
			_this._group = BODYGROUP_STATIC;
			_this._linearDamping = 0;
			_this._linearFactor = new Vec3(1, 1, 1);
			_this._linearVelocity = new Vec3();
			_this._mask = BODYMASK_NOT_STATIC;
			_this._mass = 1;
			_this._restitution = 0;
			_this._rollingFriction = 0;
			_this._simulationEnabled = false;
			_this._type = BODYTYPE_STATIC;
			return _this;
		}
		_inheritsLoose(RigidBodyComponent, _Component);
		RigidBodyComponent.onLibraryLoaded = function onLibraryLoaded() {
			if (typeof Ammo !== 'undefined') {
				_ammoTransform = new Ammo.btTransform();
				_ammoVec1 = new Ammo.btVector3();
				_ammoVec2 = new Ammo.btVector3();
				_ammoQuat = new Ammo.btQuaternion();
			}
		};
		RigidBodyComponent.onAppDestroy = function onAppDestroy() {
			Ammo.destroy(_ammoTransform);
			Ammo.destroy(_ammoVec1);
			Ammo.destroy(_ammoVec2);
			Ammo.destroy(_ammoQuat);
			_ammoTransform = null;
			_ammoVec1 = null;
			_ammoVec2 = null;
			_ammoQuat = null;
		};
		var _proto = RigidBodyComponent.prototype;
		_proto.createBody = function createBody() {
			var entity = this.entity;
			var shape;
			if (entity.collision) {
				shape = entity.collision.shape;
				if (entity.trigger) {
					entity.trigger.destroy();
					delete entity.trigger;
				}
			}
			if (shape) {
				if (this._body) {
					this.system.removeBody(this._body);
					this.system.destroyBody(this._body);
					this._body = null;
				}
				var mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;
				this._getEntityTransform(_ammoTransform);
				var body = this.system.createBody(mass, shape, _ammoTransform);
				body.setRestitution(this._restitution);
				body.setFriction(this._friction);
				body.setRollingFriction(this._rollingFriction);
				body.setDamping(this._linearDamping, this._angularDamping);
				if (this._type === BODYTYPE_DYNAMIC) {
					var linearFactor = this._linearFactor;
					_ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
					body.setLinearFactor(_ammoVec1);
					var angularFactor = this._angularFactor;
					_ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
					body.setAngularFactor(_ammoVec1);
				} else if (this._type === BODYTYPE_KINEMATIC) {
					body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
					body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
				}
				body.entity = entity;
				this.body = body;
				if (this.enabled && entity.enabled) {
					this.enableSimulation();
				}
			}
		};
		_proto.isActive = function isActive() {
			return this._body ? this._body.isActive() : false;
		};
		_proto.activate = function activate() {
			if (this._body) {
				this._body.activate();
			}
		};
		_proto.enableSimulation = function enableSimulation() {
			var entity = this.entity;
			if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
				var body = this._body;
				if (body) {
					this.system.addBody(body, this._group, this._mask);
					switch (this._type) {
						case BODYTYPE_DYNAMIC:
							this.system._dynamic.push(this);
							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;
						case BODYTYPE_KINEMATIC:
							this.system._kinematic.push(this);
							body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
							break;
						case BODYTYPE_STATIC:
							body.forceActivationState(BODYSTATE_ACTIVE_TAG);
							this.syncEntityToBody();
							break;
					}
					if (entity.collision.type === 'compound') {
						this.system._compounds.push(entity.collision);
					}
					body.activate();
					this._simulationEnabled = true;
				}
			}
		};
		_proto.disableSimulation = function disableSimulation() {
			var body = this._body;
			if (body && this._simulationEnabled) {
				var system = this.system;
				var idx = system._compounds.indexOf(this.entity.collision);
				if (idx > -1) {
					system._compounds.splice(idx, 1);
				}
				idx = system._dynamic.indexOf(this);
				if (idx > -1) {
					system._dynamic.splice(idx, 1);
				}
				idx = system._kinematic.indexOf(this);
				if (idx > -1) {
					system._kinematic.splice(idx, 1);
				}
				system.removeBody(body);
				body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
				this._simulationEnabled = false;
			}
		};
		_proto.applyForce = function applyForce(x, y, z, px, py, pz) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				if (y instanceof Vec3) {
					_ammoVec2.setValue(y.x, y.y, y.z);
				} else if (px !== undefined) {
					_ammoVec2.setValue(px, py, pz);
				} else {
					_ammoVec2.setValue(0, 0, 0);
				}
				body.applyForce(_ammoVec1, _ammoVec2);
			}
		};
		_proto.applyTorque = function applyTorque(x, y, z) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				body.applyTorque(_ammoVec1);
			}
		};
		_proto.applyImpulse = function applyImpulse(x, y, z, px, py, pz) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				if (y instanceof Vec3) {
					_ammoVec2.setValue(y.x, y.y, y.z);
				} else if (px !== undefined) {
					_ammoVec2.setValue(px, py, pz);
				} else {
					_ammoVec2.setValue(0, 0, 0);
				}
				body.applyImpulse(_ammoVec1, _ammoVec2);
			}
		};
		_proto.applyTorqueImpulse = function applyTorqueImpulse(x, y, z) {
			var body = this._body;
			if (body) {
				body.activate();
				if (x instanceof Vec3) {
					_ammoVec1.setValue(x.x, x.y, x.z);
				} else {
					_ammoVec1.setValue(x, y, z);
				}
				body.applyTorqueImpulse(_ammoVec1);
			}
		};
		_proto.isStatic = function isStatic() {
			return this._type === BODYTYPE_STATIC;
		};
		_proto.isStaticOrKinematic = function isStaticOrKinematic() {
			return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
		};
		_proto.isKinematic = function isKinematic() {
			return this._type === BODYTYPE_KINEMATIC;
		};
		_proto._getEntityTransform = function _getEntityTransform(transform) {
			var entity = this.entity;
			var component = entity.collision;
			if (component) {
				var bodyPos = component.getShapePosition();
				var bodyRot = component.getShapeRotation();
				_ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
				_ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
			} else {
				var pos = entity.getPosition();
				var rot = entity.getRotation();
				_ammoVec1.setValue(pos.x, pos.y, pos.z);
				_ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
			}
			transform.setOrigin(_ammoVec1);
			transform.setRotation(_ammoQuat);
		};
		_proto.syncEntityToBody = function syncEntityToBody() {
			var body = this._body;
			if (body) {
				this._getEntityTransform(_ammoTransform);
				body.setWorldTransform(_ammoTransform);
				if (this._type === BODYTYPE_KINEMATIC) {
					var motionState = body.getMotionState();
					if (motionState) {
						motionState.setWorldTransform(_ammoTransform);
					}
				}
				body.activate();
			}
		};
		_proto._updateDynamic = function _updateDynamic() {
			var body = this._body;
			if (body.isActive()) {
				var motionState = body.getMotionState();
				if (motionState) {
					var entity = this.entity;
					motionState.getWorldTransform(_ammoTransform);
					var p = _ammoTransform.getOrigin();
					var q = _ammoTransform.getRotation();
					var component = entity.collision;
					if (component && component._hasOffset) {
						var lo = component.data.linearOffset;
						var ao = component.data.angularOffset;
						var invertedAo = _quat2.copy(ao).invert();
						var entityRot = _quat1.set(q.x(), q.y(), q.z(), q.w()).mul(invertedAo);
						entityRot.transformVector(lo, _vec3);
						entity.setPosition(p.x() - _vec3.x, p.y() - _vec3.y, p.z() - _vec3.z);
						entity.setRotation(entityRot);
					} else {
						entity.setPosition(p.x(), p.y(), p.z());
						entity.setRotation(q.x(), q.y(), q.z(), q.w());
					}
				}
			}
		};
		_proto._updateKinematic = function _updateKinematic() {
			var motionState = this._body.getMotionState();
			if (motionState) {
				this._getEntityTransform(_ammoTransform);
				motionState.setWorldTransform(_ammoTransform);
			}
		};
		_proto.teleport = function teleport(x, y, z, rx, ry, rz) {
			if (x instanceof Vec3) {
				this.entity.setPosition(x);
			} else {
				this.entity.setPosition(x, y, z);
			}
			if (y instanceof Quat) {
				this.entity.setRotation(y);
			} else if (y instanceof Vec3) {
				this.entity.setEulerAngles(y);
			} else if (rx !== undefined) {
				this.entity.setEulerAngles(rx, ry, rz);
			}
			this.syncEntityToBody();
		};
		_proto.onEnable = function onEnable() {
			if (!this._body) {
				this.createBody();
			}
			this.enableSimulation();
		};
		_proto.onDisable = function onDisable() {
			this.disableSimulation();
		};
		return _createClass(RigidBodyComponent, [{
			key: "angularDamping",
			get: function get() {
				return this._angularDamping;
			},
			set: function set(damping) {
				if (this._angularDamping !== damping) {
					this._angularDamping = damping;
					if (this._body) {
						this._body.setDamping(this._linearDamping, damping);
					}
				}
			}
		}, {
			key: "angularFactor",
			get: function get() {
				return this._angularFactor;
			},
			set: function set(factor) {
				if (!this._angularFactor.equals(factor)) {
					this._angularFactor.copy(factor);
					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						_ammoVec1.setValue(factor.x, factor.y, factor.z);
						this._body.setAngularFactor(_ammoVec1);
					}
				}
			}
		}, {
			key: "angularVelocity",
			get: function get() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					var velocity = this._body.getAngularVelocity();
					this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}
				return this._angularVelocity;
			},
			set: function set(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					this._body.activate();
					_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
					this._body.setAngularVelocity(_ammoVec1);
					this._angularVelocity.copy(velocity);
				}
			}
		}, {
			key: "body",
			get: function get() {
				return this._body;
			},
			set: function set(body) {
				if (this._body !== body) {
					this._body = body;
					if (body && this._simulationEnabled) {
						body.activate();
					}
				}
			}
		}, {
			key: "friction",
			get: function get() {
				return this._friction;
			},
			set: function set(friction) {
				if (this._friction !== friction) {
					this._friction = friction;
					if (this._body) {
						this._body.setFriction(friction);
					}
				}
			}
		}, {
			key: "group",
			get: function get() {
				return this._group;
			},
			set: function set(group) {
				if (this._group !== group) {
					this._group = group;
					if (this.enabled && this.entity.enabled) {
						this.disableSimulation();
						this.enableSimulation();
					}
				}
			}
		}, {
			key: "linearDamping",
			get: function get() {
				return this._linearDamping;
			},
			set: function set(damping) {
				if (this._linearDamping !== damping) {
					this._linearDamping = damping;
					if (this._body) {
						this._body.setDamping(damping, this._angularDamping);
					}
				}
			}
		}, {
			key: "linearFactor",
			get: function get() {
				return this._linearFactor;
			},
			set: function set(factor) {
				if (!this._linearFactor.equals(factor)) {
					this._linearFactor.copy(factor);
					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						_ammoVec1.setValue(factor.x, factor.y, factor.z);
						this._body.setLinearFactor(_ammoVec1);
					}
				}
			}
		}, {
			key: "linearVelocity",
			get: function get() {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					var velocity = this._body.getLinearVelocity();
					this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
				}
				return this._linearVelocity;
			},
			set: function set(velocity) {
				if (this._body && this._type === BODYTYPE_DYNAMIC) {
					this._body.activate();
					_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
					this._body.setLinearVelocity(_ammoVec1);
					this._linearVelocity.copy(velocity);
				}
			}
		}, {
			key: "mask",
			get: function get() {
				return this._mask;
			},
			set: function set(mask) {
				if (this._mask !== mask) {
					this._mask = mask;
					if (this.enabled && this.entity.enabled) {
						this.disableSimulation();
						this.enableSimulation();
					}
				}
			}
		}, {
			key: "mass",
			get: function get() {
				return this._mass;
			},
			set: function set(mass) {
				if (this._mass !== mass) {
					this._mass = mass;
					if (this._body && this._type === BODYTYPE_DYNAMIC) {
						var enabled = this.enabled && this.entity.enabled;
						if (enabled) {
							this.disableSimulation();
						}
						this._body.getCollisionShape().calculateLocalInertia(mass, _ammoVec1);
						this._body.setMassProps(mass, _ammoVec1);
						this._body.updateInertiaTensor();
						if (enabled) {
							this.enableSimulation();
						}
					}
				}
			}
		}, {
			key: "restitution",
			get: function get() {
				return this._restitution;
			},
			set: function set(restitution) {
				if (this._restitution !== restitution) {
					this._restitution = restitution;
					if (this._body) {
						this._body.setRestitution(restitution);
					}
				}
			}
		}, {
			key: "rollingFriction",
			get: function get() {
				return this._rollingFriction;
			},
			set: function set(friction) {
				if (this._rollingFriction !== friction) {
					this._rollingFriction = friction;
					if (this._body) {
						this._body.setRollingFriction(friction);
					}
				}
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(type) {
				if (this._type !== type) {
					this._type = type;
					this.disableSimulation();
					switch (type) {
						case BODYTYPE_DYNAMIC:
							this._group = BODYGROUP_DYNAMIC;
							this._mask = BODYMASK_ALL;
							break;
						case BODYTYPE_KINEMATIC:
							this._group = BODYGROUP_KINEMATIC;
							this._mask = BODYMASK_ALL;
							break;
						case BODYTYPE_STATIC:
						default:
							this._group = BODYGROUP_STATIC;
							this._mask = BODYMASK_NOT_STATIC;
							break;
					}
					this.createBody();
				}
			}
		}]);
	}(Component);
	RigidBodyComponent.EVENT_CONTACT = 'contact';
	RigidBodyComponent.EVENT_COLLISIONSTART = 'collisionstart';
	RigidBodyComponent.EVENT_COLLISIONEND = 'collisionend';
	RigidBodyComponent.EVENT_TRIGGERENTER = 'triggerenter';
	RigidBodyComponent.EVENT_TRIGGERLEAVE = 'triggerleave';
	RigidBodyComponent.order = -1;

	var RigidBodyComponentData = function RigidBodyComponentData() {
		this.enabled = true;
	};

	var ammoRayStart, ammoRayEnd;
	var RaycastResult = function RaycastResult(entity, point, normal, hitFraction) {
		this.entity = void 0;
		this.point = void 0;
		this.normal = void 0;
		this.hitFraction = void 0;
		this.entity = entity;
		this.point = point;
		this.normal = normal;
		this.hitFraction = hitFraction;
	};
	var SingleContactResult = function SingleContactResult(a, b, contactPoint) {
		this.a = void 0;
		this.b = void 0;
		this.impulse = void 0;
		this.localPointA = void 0;
		this.localPointB = void 0;
		this.pointA = void 0;
		this.pointB = void 0;
		this.normal = void 0;
		if (arguments.length !== 0) {
			this.a = a;
			this.b = b;
			this.impulse = contactPoint.impulse;
			this.localPointA = contactPoint.localPoint;
			this.localPointB = contactPoint.localPointOther;
			this.pointA = contactPoint.point;
			this.pointB = contactPoint.pointOther;
			this.normal = contactPoint.normal;
		} else {
			this.a = null;
			this.b = null;
			this.impulse = 0;
			this.localPointA = new Vec3();
			this.localPointB = new Vec3();
			this.pointA = new Vec3();
			this.pointB = new Vec3();
			this.normal = new Vec3();
		}
	};
	var ContactPoint = function ContactPoint(localPoint, localPointOther, point, pointOther, normal, impulse) {
		if (localPoint === void 0) {
			localPoint = new Vec3();
		}
		if (localPointOther === void 0) {
			localPointOther = new Vec3();
		}
		if (point === void 0) {
			point = new Vec3();
		}
		if (pointOther === void 0) {
			pointOther = new Vec3();
		}
		if (normal === void 0) {
			normal = new Vec3();
		}
		if (impulse === void 0) {
			impulse = 0;
		}
		this.localPoint = void 0;
		this.localPointOther = void 0;
		this.point = void 0;
		this.pointOther = void 0;
		this.normal = void 0;
		this.impulse = void 0;
		this.localPoint = localPoint;
		this.localPointOther = localPointOther;
		this.point = point;
		this.pointOther = pointOther;
		this.normal = normal;
		this.impulse = impulse;
	};
	var ContactResult = function ContactResult(other, contacts) {
		this.other = void 0;
		this.contacts = void 0;
		this.other = other;
		this.contacts = contacts;
	};
	var _schema$8 = ['enabled'];
	var RigidBodyComponentSystem = function (_ComponentSystem) {
		function RigidBodyComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.maxSubSteps = 10;
			_this.fixedTimeStep = 1 / 60;
			_this.gravity = new Vec3(0, -9.81, 0);
			_this._gravityFloat32 = new Float32Array(3);
			_this._dynamic = [];
			_this._kinematic = [];
			_this._triggers = [];
			_this._compounds = [];
			_this.id = 'rigidbody';
			_this._stats = app.stats.frame;
			_this.ComponentType = RigidBodyComponent;
			_this.DataType = RigidBodyComponentData;
			_this.contactPointPool = null;
			_this.contactResultPool = null;
			_this.singleContactResultPool = null;
			_this.schema = _schema$8;
			_this.collisions = {};
			_this.frameCollisions = {};
			_this.on('beforeremove', _this.onBeforeRemove, _this);
			return _this;
		}
		_inheritsLoose(RigidBodyComponentSystem, _ComponentSystem);
		var _proto = RigidBodyComponentSystem.prototype;
		_proto.onLibraryLoaded = function onLibraryLoaded() {
			if (typeof Ammo !== 'undefined') {
				this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
				this.overlappingPairCache = new Ammo.btDbvtBroadphase();
				this.solver = new Ammo.btSequentialImpulseConstraintSolver();
				this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);
				if (this.dynamicsWorld.setInternalTickCallback) {
					var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
					this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
				}
				ammoRayStart = new Ammo.btVector3();
				ammoRayEnd = new Ammo.btVector3();
				RigidBodyComponent.onLibraryLoaded();
				this.contactPointPool = new ObjectPool(ContactPoint, 1);
				this.contactResultPool = new ObjectPool(ContactResult, 1);
				this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
				this.app.systems.on('update', this.onUpdate, this);
			} else {
				this.app.systems.off('update', this.onUpdate, this);
			}
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			var props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];
			for (var _i = 0, _props = props; _i < _props.length; _i++) {
				var property = _props[_i];
				if (data.hasOwnProperty(property)) {
					var value = data[property];
					if (Array.isArray(value)) {
						component[property] = new Vec3(value[0], value[1], value[2]);
					} else {
						component[property] = value;
					}
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var rigidbody = entity.rigidbody;
			var data = {
				enabled: rigidbody.enabled,
				mass: rigidbody.mass,
				linearDamping: rigidbody.linearDamping,
				angularDamping: rigidbody.angularDamping,
				linearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],
				angularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],
				friction: rigidbody.friction,
				rollingFriction: rigidbody.rollingFriction,
				restitution: rigidbody.restitution,
				type: rigidbody.type,
				group: rigidbody.group,
				mask: rigidbody.mask
			};
			return this.addComponent(clone, data);
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			if (component.enabled) {
				component.enabled = false;
			}
			if (component.body) {
				this.destroyBody(component.body);
				component.body = null;
			}
		};
		_proto.addBody = function addBody(body, group, mask) {
			if (group !== undefined && mask !== undefined) {
				this.dynamicsWorld.addRigidBody(body, group, mask);
			} else {
				this.dynamicsWorld.addRigidBody(body);
			}
		};
		_proto.removeBody = function removeBody(body) {
			this.dynamicsWorld.removeRigidBody(body);
		};
		_proto.createBody = function createBody(mass, shape, transform) {
			var localInertia = new Ammo.btVector3(0, 0, 0);
			if (mass !== 0) {
				shape.calculateLocalInertia(mass, localInertia);
			}
			var motionState = new Ammo.btDefaultMotionState(transform);
			var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
			var body = new Ammo.btRigidBody(bodyInfo);
			Ammo.destroy(bodyInfo);
			Ammo.destroy(localInertia);
			return body;
		};
		_proto.destroyBody = function destroyBody(body) {
			var motionState = body.getMotionState();
			if (motionState) {
				Ammo.destroy(motionState);
			}
			Ammo.destroy(body);
		};
		_proto.raycastFirst = function raycastFirst(start, end, options) {
			if (options === void 0) {
				options = {};
			}
			if (options.filterTags || options.filterCallback) {
				options.sort = true;
				return this.raycastAll(start, end, options)[0] || null;
			}
			var result = null;
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
			if (typeof options.filterCollisionGroup === 'number') {
				rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
			}
			if (typeof options.filterCollisionMask === 'number') {
				rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
			}
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
			if (rayCallback.hasHit()) {
				var collisionObj = rayCallback.get_m_collisionObject();
				var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
				if (body) {
					var point = rayCallback.get_m_hitPointWorld();
					var normal = rayCallback.get_m_hitNormalWorld();
					result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), rayCallback.get_m_closestHitFraction());
				}
			}
			Ammo.destroy(rayCallback);
			return result;
		};
		_proto.raycastAll = function raycastAll(start, end, options) {
			if (options === void 0) {
				options = {};
			}
			var results = [];
			ammoRayStart.setValue(start.x, start.y, start.z);
			ammoRayEnd.setValue(end.x, end.y, end.z);
			var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
			if (typeof options.filterCollisionGroup === 'number') {
				rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
			}
			if (typeof options.filterCollisionMask === 'number') {
				rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
			}
			this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
			if (rayCallback.hasHit()) {
				var collisionObjs = rayCallback.get_m_collisionObjects();
				var points = rayCallback.get_m_hitPointWorld();
				var normals = rayCallback.get_m_hitNormalWorld();
				var hitFractions = rayCallback.get_m_hitFractions();
				var numHits = collisionObjs.size();
				for (var i = 0; i < numHits; i++) {
					var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);
					if (body && body.entity) {
						var _body$entity$tags;
						if (options.filterTags && !(_body$entity$tags = body.entity.tags).has.apply(_body$entity$tags, options.filterTags) || options.filterCallback && !options.filterCallback(body.entity)) {
							continue;
						}
						var point = points.at(i);
						var normal = normals.at(i);
						var result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), hitFractions.at(i));
						results.push(result);
					}
				}
				if (options.sort) {
					results.sort(function (a, b) {
						return a.hitFraction - b.hitFraction;
					});
				}
			}
			Ammo.destroy(rayCallback);
			return results;
		};
		_proto._storeCollision = function _storeCollision(entity, other) {
			var isNewCollision = false;
			var guid = entity.getGuid();
			this.collisions[guid] = this.collisions[guid] || {
				others: [],
				entity: entity
			};
			if (this.collisions[guid].others.indexOf(other) < 0) {
				this.collisions[guid].others.push(other);
				isNewCollision = true;
			}
			this.frameCollisions[guid] = this.frameCollisions[guid] || {
				others: [],
				entity: entity
			};
			this.frameCollisions[guid].others.push(other);
			return isNewCollision;
		};
		_proto._createContactPointFromAmmo = function _createContactPointFromAmmo(contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			contact.impulse = contactPoint.getAppliedImpulse();
			return contact;
		};
		_proto._createReverseContactPointFromAmmo = function _createReverseContactPointFromAmmo(contactPoint) {
			var localPointA = contactPoint.get_m_localPointA();
			var localPointB = contactPoint.get_m_localPointB();
			var positionWorldOnA = contactPoint.getPositionWorldOnA();
			var positionWorldOnB = contactPoint.getPositionWorldOnB();
			var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
			var contact = this.contactPointPool.allocate();
			contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
			contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
			contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
			contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
			contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
			contact.impulse = contactPoint.getAppliedImpulse();
			return contact;
		};
		_proto._createSingleContactResult = function _createSingleContactResult(a, b, contactPoint) {
			var result = this.singleContactResultPool.allocate();
			result.a = a;
			result.b = b;
			result.localPointA = contactPoint.localPoint;
			result.localPointB = contactPoint.localPointOther;
			result.pointA = contactPoint.point;
			result.pointB = contactPoint.pointOther;
			result.normal = contactPoint.normal;
			result.impulse = contactPoint.impulse;
			return result;
		};
		_proto._createContactResult = function _createContactResult(other, contacts) {
			var result = this.contactResultPool.allocate();
			result.other = other;
			result.contacts = contacts;
			return result;
		};
		_proto._cleanOldCollisions = function _cleanOldCollisions() {
			for (var guid in this.collisions) {
				if (this.collisions.hasOwnProperty(guid)) {
					var frameCollision = this.frameCollisions[guid];
					var collision = this.collisions[guid];
					var entity = collision.entity;
					var entityCollision = entity.collision;
					var entityRigidbody = entity.rigidbody;
					var others = collision.others;
					var length = others.length;
					var i = length;
					while (i--) {
						var other = others[i];
						if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
							others.splice(i, 1);
							if (entity.trigger) {
								if (entityCollision) {
									entityCollision.fire('triggerleave', other);
								}
								if (other.rigidbody) {
									other.rigidbody.fire('triggerleave', entity);
								}
							} else if (!other.trigger) {
								if (entityRigidbody) {
									entityRigidbody.fire('collisionend', other);
								}
								if (entityCollision) {
									entityCollision.fire('collisionend', other);
								}
							}
						}
					}
					if (others.length === 0) {
						delete this.collisions[guid];
					}
				}
			}
		};
		_proto._hasContactEvent = function _hasContactEvent(entity) {
			var c = entity.collision;
			if (c && (c.hasEvent('collisionstart') || c.hasEvent('collisionend') || c.hasEvent('contact'))) {
				return true;
			}
			var r = entity.rigidbody;
			return r && (r.hasEvent('collisionstart') || r.hasEvent('collisionend') || r.hasEvent('contact'));
		};
		_proto._checkForCollisions = function _checkForCollisions(world, timeStep) {
			var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
			var dispatcher = dynamicsWorld.getDispatcher();
			var numManifolds = dispatcher.getNumManifolds();
			this.frameCollisions = {};
			for (var i = 0; i < numManifolds; i++) {
				var manifold = dispatcher.getManifoldByIndexInternal(i);
				var body0 = manifold.getBody0();
				var body1 = manifold.getBody1();
				var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
				var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
				var e0 = wb0.entity;
				var e1 = wb1.entity;
				if (!e0 || !e1) {
					continue;
				}
				var flags0 = wb0.getCollisionFlags();
				var flags1 = wb1.getCollisionFlags();
				var numContacts = manifold.getNumContacts();
				var forwardContacts = [];
				var reverseContacts = [];
				var newCollision = void 0;
				if (numContacts > 0) {
					if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
						var e0Events = e0.collision && (e0.collision.hasEvent('triggerenter') || e0.collision.hasEvent('triggerleave'));
						var e1Events = e1.collision && (e1.collision.hasEvent('triggerenter') || e1.collision.hasEvent('triggerleave'));
						var e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent('triggerenter') || e0.rigidbody.hasEvent('triggerleave'));
						var e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent('triggerenter') || e1.rigidbody.hasEvent('triggerleave'));
						if (e0Events) {
							newCollision = this._storeCollision(e0, e1);
							if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
								e0.collision.fire('triggerenter', e1);
							}
						}
						if (e1Events) {
							newCollision = this._storeCollision(e1, e0);
							if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
								e1.collision.fire('triggerenter', e0);
							}
						}
						if (e0BodyEvents) {
							if (!newCollision) {
								newCollision = this._storeCollision(e1, e0);
							}
							if (newCollision) {
								e0.rigidbody.fire('triggerenter', e1);
							}
						}
						if (e1BodyEvents) {
							if (!newCollision) {
								newCollision = this._storeCollision(e0, e1);
							}
							if (newCollision) {
								e1.rigidbody.fire('triggerenter', e0);
							}
						}
					} else {
						var _e0Events = this._hasContactEvent(e0);
						var _e1Events = this._hasContactEvent(e1);
						var globalEvents = this.hasEvent('contact');
						if (globalEvents || _e0Events || _e1Events) {
							for (var j = 0; j < numContacts; j++) {
								var btContactPoint = manifold.getContactPoint(j);
								var contactPoint = this._createContactPointFromAmmo(btContactPoint);
								if (_e0Events || _e1Events) {
									forwardContacts.push(contactPoint);
									var reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
									reverseContacts.push(reverseContactPoint);
								}
								if (globalEvents) {
									var result = this._createSingleContactResult(e0, e1, contactPoint);
									this.fire('contact', result);
								}
							}
							if (_e0Events) {
								var forwardResult = this._createContactResult(e1, forwardContacts);
								newCollision = this._storeCollision(e0, e1);
								if (e0.collision) {
									e0.collision.fire('contact', forwardResult);
									if (newCollision) {
										e0.collision.fire('collisionstart', forwardResult);
									}
								}
								if (e0.rigidbody) {
									e0.rigidbody.fire('contact', forwardResult);
									if (newCollision) {
										e0.rigidbody.fire('collisionstart', forwardResult);
									}
								}
							}
							if (_e1Events) {
								var reverseResult = this._createContactResult(e0, reverseContacts);
								newCollision = this._storeCollision(e1, e0);
								if (e1.collision) {
									e1.collision.fire('contact', reverseResult);
									if (newCollision) {
										e1.collision.fire('collisionstart', reverseResult);
									}
								}
								if (e1.rigidbody) {
									e1.rigidbody.fire('contact', reverseResult);
									if (newCollision) {
										e1.rigidbody.fire('collisionstart', reverseResult);
									}
								}
							}
						}
					}
				}
			}
			this._cleanOldCollisions();
			this.contactPointPool.freeAll();
			this.contactResultPool.freeAll();
			this.singleContactResultPool.freeAll();
		};
		_proto.onUpdate = function onUpdate(dt) {
			var i, len;
			this._gravityFloat32[0] = this.gravity.x;
			this._gravityFloat32[1] = this.gravity.y;
			this._gravityFloat32[2] = this.gravity.z;
			var gravity = this.dynamicsWorld.getGravity();
			if (gravity.x() !== this._gravityFloat32[0] || gravity.y() !== this._gravityFloat32[1] || gravity.z() !== this._gravityFloat32[2]) {
				gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
				this.dynamicsWorld.setGravity(gravity);
			}
			var triggers = this._triggers;
			for (i = 0, len = triggers.length; i < len; i++) {
				triggers[i].updateTransform();
			}
			var compounds = this._compounds;
			for (i = 0, len = compounds.length; i < len; i++) {
				compounds[i]._updateCompound();
			}
			var kinematic = this._kinematic;
			for (i = 0, len = kinematic.length; i < len; i++) {
				kinematic[i]._updateKinematic();
			}
			this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
			var dynamic = this._dynamic;
			for (i = 0, len = dynamic.length; i < len; i++) {
				dynamic[i]._updateDynamic();
			}
			if (!this.dynamicsWorld.setInternalTickCallback) {
				this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
			}
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
			if (typeof Ammo !== 'undefined') {
				Ammo.destroy(this.dynamicsWorld);
				Ammo.destroy(this.solver);
				Ammo.destroy(this.overlappingPairCache);
				Ammo.destroy(this.dispatcher);
				Ammo.destroy(this.collisionConfiguration);
				Ammo.destroy(ammoRayStart);
				Ammo.destroy(ammoRayEnd);
				this.dynamicsWorld = null;
				this.solver = null;
				this.overlappingPairCache = null;
				this.dispatcher = null;
				this.collisionConfiguration = null;
				ammoRayStart = null;
				ammoRayEnd = null;
				RigidBodyComponent.onAppDestroy();
			}
		};
		return RigidBodyComponentSystem;
	}(ComponentSystem);
	RigidBodyComponentSystem.EVENT_CONTACT = 'contact';
	Component._buildAccessors(RigidBodyComponent.prototype, _schema$8);

	var SCALEMODE_NONE = 'none';
	var SCALEMODE_BLEND = 'blend';

	var _transform = new Mat4();
	var ScreenComponent = function (_Component) {
		function ScreenComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._resolution = new Vec2(640, 320);
			_this._referenceResolution = new Vec2(640, 320);
			_this._scaleMode = SCALEMODE_NONE;
			_this.scale = 1;
			_this._scaleBlend = 0.5;
			_this._priority = 0;
			_this._screenSpace = false;
			_this.cull = _this._screenSpace;
			_this._screenMatrix = new Mat4();
			_this._elements = new Set();
			system.app.graphicsDevice.on('resizecanvas', _this._onResize, _this);
			return _this;
		}
		_inheritsLoose(ScreenComponent, _Component);
		var _proto = ScreenComponent.prototype;
		_proto.syncDrawOrder = function syncDrawOrder() {
			this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
		};
		_proto._recurseDrawOrderSync = function _recurseDrawOrderSync(e, i) {
			if (!(e instanceof Entity)) {
				return i;
			}
			if (e.element) {
				var prevDrawOrder = e.element.drawOrder;
				e.element.drawOrder = i++;
				if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
					var _this$system$app$batc;
					(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.markGroupDirty(e.element._batchGroupId);
				}
			}
			if (e.particlesystem) {
				e.particlesystem.drawOrder = i++;
			}
			var children = e.children;
			for (var j = 0; j < children.length; j++) {
				i = this._recurseDrawOrderSync(children[j], i);
			}
			return i;
		};
		_proto._processDrawOrderSync = function _processDrawOrderSync() {
			var i = 1;
			this._recurseDrawOrderSync(this.entity, i);
			this.fire('syncdraworder');
		};
		_proto._calcProjectionMatrix = function _calcProjectionMatrix() {
			var w = this._resolution.x / this.scale;
			var h = this._resolution.y / this.scale;
			var left = 0;
			var right = w;
			var bottom = -h;
			var top = 0;
			var near = 1;
			var far = -1;
			this._screenMatrix.setOrtho(left, right, bottom, top, near, far);
			if (!this._screenSpace) {
				_transform.setScale(0.5 * w, 0.5 * h, 1);
				this._screenMatrix.mul2(_transform, this._screenMatrix);
			}
		};
		_proto._updateScale = function _updateScale() {
			this.scale = this._calcScale(this._resolution, this.referenceResolution);
		};
		_proto._calcScale = function _calcScale(resolution, referenceResolution) {
			var lx = Math.log2((resolution.x || 1) / referenceResolution.x);
			var ly = Math.log2((resolution.y || 1) / referenceResolution.y);
			return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
		};
		_proto._onResize = function _onResize(width, height) {
			if (this._screenSpace) {
				this._resolution.set(width, height);
				this.resolution = this._resolution;
			}
		};
		_proto._bindElement = function _bindElement(element) {
			this._elements.add(element);
		};
		_proto._unbindElement = function _unbindElement(element) {
			this._elements.delete(element);
		};
		_proto.onRemove = function onRemove() {
			this.system.app.graphicsDevice.off('resizecanvas', this._onResize, this);
			this.fire('remove');
			this._elements.forEach(function (element) {
				return element._onScreenRemove();
			});
			this._elements.clear();
			this.off();
		};
		return _createClass(ScreenComponent, [{
			key: "resolution",
			get: function get() {
				return this._resolution;
			},
			set: function set(value) {
				var _this2 = this;
				if (!this._screenSpace) {
					this._resolution.set(value.x, value.y);
				} else {
					this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) {
					this.entity._dirtifyLocal();
				}
				this.fire('set:resolution', this._resolution);
				this._elements.forEach(function (element) {
					return element._onScreenResize(_this2._resolution);
				});
			}
		}, {
			key: "referenceResolution",
			get: function get() {
				if (this._scaleMode === SCALEMODE_NONE) {
					return this._resolution;
				}
				return this._referenceResolution;
			},
			set: function set(value) {
				var _this3 = this;
				this._referenceResolution.set(value.x, value.y);
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) {
					this.entity._dirtifyLocal();
				}
				this.fire('set:referenceresolution', this._resolution);
				this._elements.forEach(function (element) {
					return element._onScreenResize(_this3._resolution);
				});
			}
		}, {
			key: "screenSpace",
			get: function get() {
				return this._screenSpace;
			},
			set: function set(value) {
				this._screenSpace = value;
				if (this._screenSpace) {
					this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
				}
				this.resolution = this._resolution;
				if (!this.entity._dirtyLocal) {
					this.entity._dirtifyLocal();
				}
				this.fire('set:screenspace', this._screenSpace);
				this._elements.forEach(function (element) {
					return element._onScreenSpaceChange();
				});
			}
		}, {
			key: "scaleMode",
			get: function get() {
				return this._scaleMode;
			},
			set: function set(value) {
				if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
					value = SCALEMODE_NONE;
				}
				if (!this._screenSpace && value !== SCALEMODE_NONE) {
					value = SCALEMODE_NONE;
				}
				this._scaleMode = value;
				this.resolution = this._resolution;
				this.fire('set:scalemode', this._scaleMode);
			}
		}, {
			key: "scaleBlend",
			get: function get() {
				return this._scaleBlend;
			},
			set: function set(value) {
				var _this4 = this;
				this._scaleBlend = value;
				this._updateScale();
				this._calcProjectionMatrix();
				if (!this.entity._dirtyLocal) {
					this.entity._dirtifyLocal();
				}
				this.fire('set:scaleblend', this._scaleBlend);
				this._elements.forEach(function (element) {
					return element._onScreenResize(_this4._resolution);
				});
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			},
			set: function set(value) {
				if (value > 0xFF) {
					value = 0xFF;
				}
				if (this._priority === value) {
					return;
				}
				this._priority = value;
				this.syncDrawOrder();
			}
		}]);
	}(Component);

	var ScreenComponentData = function ScreenComponentData() {
		this.enabled = true;
	};

	var _schema$7 = ['enabled'];
	var ScreenComponentSystem = function (_ComponentSystem) {
		function ScreenComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'screen';
			_this.ComponentType = ScreenComponent;
			_this.DataType = ScreenComponentData;
			_this.schema = _schema$7;
			_this.windowResolution = new Vec2();
			_this._drawOrderSyncQueue = new IndexedList();
			_this.app.graphicsDevice.on('resizecanvas', _this._onResize, _this);
			_this.app.systems.on('update', _this._onUpdate, _this);
			_this.on('beforeremove', _this.onRemoveComponent, _this);
			return _this;
		}
		_inheritsLoose(ScreenComponentSystem, _ComponentSystem);
		var _proto = ScreenComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.priority !== undefined) component.priority = data.priority;
			if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
			component.cull = component.screenSpace;
			if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
			if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;
			if (data.resolution !== undefined) {
				if (data.resolution instanceof Vec2) {
					component._resolution.copy(data.resolution);
				} else {
					component._resolution.set(data.resolution[0], data.resolution[1]);
				}
				component.resolution = component._resolution;
			}
			if (data.referenceResolution !== undefined) {
				if (data.referenceResolution instanceof Vec2) {
					component._referenceResolution.copy(data.referenceResolution);
				} else {
					component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
				}
				component.referenceResolution = component._referenceResolution;
			}
			component.syncDrawOrder();
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$7);
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.graphicsDevice.off('resizecanvas', this._onResize, this);
			this.app.systems.off('update', this._onUpdate, this);
		};
		_proto._onUpdate = function _onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
			}
		};
		_proto._onResize = function _onResize(width, height) {
			this.windowResolution.x = width;
			this.windowResolution.y = height;
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var screen = entity.screen;
			return this.addComponent(clone, {
				enabled: screen.enabled,
				screenSpace: screen.screenSpace,
				scaleMode: screen.scaleMode,
				resolution: screen.resolution.clone(),
				referenceResolution: screen.referenceResolution.clone()
			});
		};
		_proto.onRemoveComponent = function onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.processDrawOrderSyncQueue = function processDrawOrderSyncQueue() {
			var list = this._drawOrderSyncQueue.list();
			for (var i = 0; i < list.length; i++) {
				var item = list[i];
				item.callback.call(item.scope);
			}
			this._drawOrderSyncQueue.clear();
		};
		_proto.queueDrawOrderSync = function queueDrawOrderSync(id, fn, scope) {
			if (!this._drawOrderSyncQueue.list().length) {
				this.app.once('prerender', this.processDrawOrderSyncQueue, this);
			}
			if (!this._drawOrderSyncQueue.has(id)) {
				this._drawOrderSyncQueue.push(id, {
					callback: fn,
					scope: scope
				});
			}
		};
		return ScreenComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ScreenComponent.prototype, _schema$7);

	var _inputScreenPosition = new Vec2();
	var _inputWorldPosition = new Vec3();
	var _ray = new Ray();
	var _plane = new Plane();
	var _normal = new Vec3();
	var _point = new Vec3();
	var _entityRotation = new Quat();
	var OPPOSITE_AXIS = {
		x: 'y',
		y: 'x'
	};
	var ElementDragHelper = function (_EventHandler) {
		function ElementDragHelper(element, axis) {
			var _this;
			_this = _EventHandler.call(this) || this;
			if (!element || !(element instanceof ElementComponent)) {
				throw new Error('Element was null or not an ElementComponent');
			}
			if (axis && axis !== 'x' && axis !== 'y') {
				throw new Error("Unrecognized axis: " + axis);
			}
			_this._element = element;
			_this._app = element.system.app;
			_this._axis = axis || null;
			_this._enabled = true;
			_this._dragScale = new Vec3();
			_this._dragStartMousePosition = new Vec3();
			_this._dragStartHandlePosition = new Vec3();
			_this._deltaMousePosition = new Vec3();
			_this._deltaHandlePosition = new Vec3();
			_this._isDragging = false;
			_this._toggleLifecycleListeners('on');
			return _this;
		}
		_inheritsLoose(ElementDragHelper, _EventHandler);
		var _proto = ElementDragHelper.prototype;
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);
			this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
			this._element[onOrOff]('selectstart', this._onMouseDownOrTouchStart, this);
		};
		_proto._toggleDragListeners = function _toggleDragListeners(onOrOff) {
			var isOn = onOrOff === 'on';
			if (this._hasDragListeners && isOn) {
				return;
			}
			if (this._app.mouse) {
				this._element[onOrOff]('mousemove', this._onMove, this);
				this._element[onOrOff]('mouseup', this._onMouseUpOrTouchEnd, this);
			}
			if (platform.touch) {
				this._element[onOrOff]('touchmove', this._onMove, this);
				this._element[onOrOff]('touchend', this._onMouseUpOrTouchEnd, this);
				this._element[onOrOff]('touchcancel', this._onMouseUpOrTouchEnd, this);
			}
			this._element[onOrOff]('selectmove', this._onMove, this);
			this._element[onOrOff]('selectend', this._onMouseUpOrTouchEnd, this);
			this._hasDragListeners = isOn;
		};
		_proto._onMouseDownOrTouchStart = function _onMouseDownOrTouchStart(event) {
			if (this._element && !this._isDragging && this.enabled) {
				this._dragCamera = event.camera;
				this._calculateDragScale();
				var currentMousePosition = this._screenToLocal(event);
				if (currentMousePosition) {
					this._toggleDragListeners('on');
					this._isDragging = true;
					this._dragStartMousePosition.copy(currentMousePosition);
					this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());
					this.fire('drag:start');
				}
			}
		};
		_proto._onMouseUpOrTouchEnd = function _onMouseUpOrTouchEnd() {
			if (this._isDragging) {
				this._isDragging = false;
				this._toggleDragListeners('off');
				this.fire('drag:end');
			}
		};
		_proto._screenToLocal = function _screenToLocal(event) {
			if (event.inputSource) {
				_ray.set(event.inputSource.getOrigin(), event.inputSource.getDirection());
			} else {
				this._determineInputPosition(event);
				this._chooseRayOriginAndDirection();
			}
			_normal.copy(this._element.entity.forward).mulScalar(-1);
			_plane.setFromPointNormal(this._element.entity.getPosition(), _normal);
			if (_plane.intersectsRay(_ray, _point)) {
				_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(_point, _point);
				_point.mul(this._dragScale);
				return _point;
			}
			return null;
		};
		_proto._determineInputPosition = function _determineInputPosition(event) {
			var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;
			if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
				_inputScreenPosition.x = event.x * devicePixelRatio;
				_inputScreenPosition.y = event.y * devicePixelRatio;
			} else if (event.changedTouches) {
				_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
				_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
			} else {
				console.warn('Could not determine position from input event');
			}
		};
		_proto._chooseRayOriginAndDirection = function _chooseRayOriginAndDirection() {
			if (this._element.screen && this._element.screen.screen.screenSpace) {
				_ray.origin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
				_ray.direction.copy(Vec3.FORWARD);
			} else {
				_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
				_ray.origin.copy(this._dragCamera.entity.getPosition());
				_ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();
			}
		};
		_proto._calculateDragScale = function _calculateDragScale() {
			var current = this._element.entity.parent;
			var screen = this._element.screen && this._element.screen.screen;
			var isWithin2DScreen = screen && screen.screenSpace;
			var screenScale = isWithin2DScreen ? screen.scale : 1;
			var dragScale = this._dragScale;
			dragScale.set(screenScale, screenScale, screenScale);
			while (current) {
				dragScale.mul(current.getLocalScale());
				current = current.parent;
				if (isWithin2DScreen && current.screen) {
					break;
				}
			}
			dragScale.x = 1 / dragScale.x;
			dragScale.y = 1 / dragScale.y;
			dragScale.z = 0;
		};
		_proto._onMove = function _onMove(event) {
			var element = this._element,
				deltaMousePosition = this._deltaMousePosition,
				deltaHandlePosition = this._deltaHandlePosition,
				axis = this._axis;
			if (element && this._isDragging && this.enabled && element.enabled && element.entity.enabled) {
				var currentMousePosition = this._screenToLocal(event);
				if (currentMousePosition) {
					deltaMousePosition.sub2(currentMousePosition, this._dragStartMousePosition);
					deltaHandlePosition.add2(this._dragStartHandlePosition, deltaMousePosition);
					if (axis) {
						var currentPosition = element.entity.getLocalPosition();
						var constrainedAxis = OPPOSITE_AXIS[axis];
						deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
					}
					element.entity.setLocalPosition(deltaHandlePosition);
					this.fire('drag:move', deltaHandlePosition);
				}
			}
		};
		_proto.destroy = function destroy() {
			this._toggleLifecycleListeners('off');
			this._toggleDragListeners('off');
		};
		return _createClass(ElementDragHelper, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				this._enabled = value;
			}
		}, {
			key: "isDragging",
			get: function get() {
				return this._isDragging;
			}
		}]);
	}(EventHandler);
	ElementDragHelper.EVENT_DRAGSTART = 'drag:start';
	ElementDragHelper.EVENT_DRAGEND = 'drag:end';
	ElementDragHelper.EVENT_DRAGMOVE = 'drag:move';

	var SCROLL_MODE_CLAMP = 0;
	var SCROLL_MODE_BOUNCE = 1;
	var SCROLL_MODE_INFINITE = 2;
	var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
	var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

	var _tempScrollValue = new Vec2();
	var ScrollViewComponent = function (_Component) {
		function ScrollViewComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._viewportReference = new EntityReference(_this, 'viewportEntity', {
				'element#gain': _this._onViewportElementGain,
				'element#resize': _this._onSetContentOrViewportSize
			});
			_this._contentReference = new EntityReference(_this, 'contentEntity', {
				'element#gain': _this._onContentElementGain,
				'element#lose': _this._onContentElementLose,
				'element#resize': _this._onSetContentOrViewportSize
			});
			_this._scrollbarUpdateFlags = {};
			_this._scrollbarReferences = {};
			_this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(_this, 'horizontalScrollbarEntity', {
				'scrollbar#set:value': _this._onSetHorizontalScrollbarValue,
				'scrollbar#gain': _this._onHorizontalScrollbarGain
			});
			_this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(_this, 'verticalScrollbarEntity', {
				'scrollbar#set:value': _this._onSetVerticalScrollbarValue,
				'scrollbar#gain': _this._onVerticalScrollbarGain
			});
			_this._prevContentSizes = {};
			_this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
			_this._prevContentSizes[ORIENTATION_VERTICAL] = null;
			_this._scroll = new Vec2();
			_this._velocity = new Vec3();
			_this._dragStartPosition = new Vec3();
			_this._disabledContentInput = false;
			_this._disabledContentInputEntities = [];
			_this._toggleLifecycleListeners('on', system);
			_this._toggleElementListeners('on');
			return _this;
		}
		_inheritsLoose(ScrollViewComponent, _Component);
		var _proto = ScrollViewComponent.prototype;
		_proto._setValue = function _setValue(name, value) {
			var data = this.data;
			var oldValue = data[name];
			data[name] = value;
			this.fire('set', name, oldValue, value);
		};
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff, system) {
			this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
			this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
			system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
			system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
		};
		_proto._toggleElementListeners = function _toggleElementListeners(onOrOff) {
			if (this.entity.element) {
				if (onOrOff === 'on' && this._hasElementListeners) {
					return;
				}
				this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);
				this.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);
				this._hasElementListeners = onOrOff === 'on';
			}
		};
		_proto._onElementComponentAdd = function _onElementComponentAdd(entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('on');
			}
		};
		_proto._onElementComponentRemove = function _onElementComponentRemove(entity) {
			if (this.entity === entity) {
				this._toggleElementListeners('off');
			}
		};
		_proto._onViewportElementGain = function _onViewportElementGain() {
			this._syncAll();
		};
		_proto._onContentElementGain = function _onContentElementGain() {
			this._destroyDragHelper();
			this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);
			this._contentDragHelper.on('drag:start', this._onContentDragStart, this);
			this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);
			this._contentDragHelper.on('drag:move', this._onContentDragMove, this);
			this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
			this._prevContentSizes[ORIENTATION_VERTICAL] = null;
			this._syncAll();
		};
		_proto._onContentElementLose = function _onContentElementLose() {
			this._destroyDragHelper();
		};
		_proto._onContentDragStart = function _onContentDragStart() {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
			}
		};
		_proto._onContentDragEnd = function _onContentDragEnd() {
			this._prevContentDragPosition = null;
			this._enableContentInput();
		};
		_proto._onContentDragMove = function _onContentDragMove(position) {
			if (this._contentReference.entity && this.enabled && this.entity.enabled) {
				this._wasDragged = true;
				this._setScrollFromContentPosition(position);
				this._setVelocityFromContentPositionDelta(position);
				if (!this._disabledContentInput) {
					var dx = position.x - this._dragStartPosition.x;
					var dy = position.y - this._dragStartPosition.y;
					if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
						this._disableContentInput();
					}
				}
			}
		};
		_proto._onSetContentOrViewportSize = function _onSetContentOrViewportSize() {
			this._syncAll();
		};
		_proto._onSetHorizontalScrollbarValue = function _onSetHorizontalScrollbarValue(scrollValueX) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(scrollValueX, null);
			}
		};
		_proto._onSetVerticalScrollbarValue = function _onSetVerticalScrollbarValue(scrollValueY) {
			if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
				this._onSetScroll(null, scrollValueY);
			}
		};
		_proto._onSetHorizontalScrollingEnabled = function _onSetHorizontalScrollingEnabled() {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
		};
		_proto._onSetVerticalScrollingEnabled = function _onSetVerticalScrollingEnabled() {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		};
		_proto._onHorizontalScrollbarGain = function _onHorizontalScrollbarGain() {
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
		};
		_proto._onVerticalScrollbarGain = function _onVerticalScrollbarGain() {
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
			this._syncScrollbarPosition(ORIENTATION_VERTICAL);
		};
		_proto._onSetScroll = function _onSetScroll(x, y, resetVelocity) {
			if (resetVelocity !== false) {
				this._velocity.set(0, 0, 0);
			}
			var xChanged = this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
			var yChanged = this._updateAxis(y, 'y', ORIENTATION_VERTICAL);
			if (xChanged || yChanged) {
				this.fire('set:scroll', this._scroll);
			}
		};
		_proto._updateAxis = function _updateAxis(scrollValue, axis, orientation) {
			var hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;
			if (hasChanged || this._isDragging() || scrollValue === 0) {
				this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
				this._syncContentPosition(orientation);
				this._syncScrollbarPosition(orientation);
			}
			return hasChanged;
		};
		_proto._determineNewScrollValue = function _determineNewScrollValue(scrollValue, axis, orientation) {
			if (!this._getScrollingEnabled(orientation)) {
				return this._scroll[axis];
			}
			switch (this.scrollMode) {
				case SCROLL_MODE_CLAMP:
					return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));
				case SCROLL_MODE_BOUNCE:
					this._setVelocityFromOvershoot(scrollValue, axis, orientation);
					return scrollValue;
				case SCROLL_MODE_INFINITE:
					return scrollValue;
				default:
					console.warn("Unhandled scroll mode:" + this.scrollMode);
					return scrollValue;
			}
		};
		_proto._syncAll = function _syncAll() {
			this._syncContentPosition(ORIENTATION_HORIZONTAL);
			this._syncContentPosition(ORIENTATION_VERTICAL);
			this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
			this._syncScrollbarPosition(ORIENTATION_VERTICAL);
			this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
			this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
		};
		_proto._syncContentPosition = function _syncContentPosition(orientation) {
			var axis = this._getAxis(orientation);
			var sign = this._getSign(orientation);
			var contentEntity = this._contentReference.entity;
			if (contentEntity) {
				var prevContentSize = this._prevContentSizes[orientation];
				var currContentSize = this._getContentSize(orientation);
				if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
					var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);
					var currMaxOffset = this._getMaxOffset(orientation, currContentSize);
					if (currMaxOffset === 0) {
						this._scroll[axis] = 1;
					} else {
						this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
					}
				}
				var offset = this._scroll[axis] * this._getMaxOffset(orientation);
				var contentPosition = contentEntity.getLocalPosition();
				contentPosition[axis] = offset * sign;
				contentEntity.setLocalPosition(contentPosition);
				this._prevContentSizes[orientation] = currContentSize;
			}
		};
		_proto._syncScrollbarPosition = function _syncScrollbarPosition(orientation) {
			var axis = this._getAxis(orientation);
			var scrollbarEntity = this._scrollbarReferences[orientation].entity;
			if (scrollbarEntity && scrollbarEntity.scrollbar) {
				this._scrollbarUpdateFlags[orientation] = true;
				scrollbarEntity.scrollbar.value = this._scroll[axis];
				scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
				this._scrollbarUpdateFlags[orientation] = false;
			}
		};
		_proto._syncScrollbarEnabledState = function _syncScrollbarEnabledState(orientation) {
			var entity = this._scrollbarReferences[orientation].entity;
			if (entity) {
				var isScrollingEnabled = this._getScrollingEnabled(orientation);
				var requestedVisibility = this._getScrollbarVisibility(orientation);
				switch (requestedVisibility) {
					case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
						entity.enabled = isScrollingEnabled;
						return;
					case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
						entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
						return;
					default:
						console.warn("Unhandled scrollbar visibility:" + requestedVisibility);
						entity.enabled = isScrollingEnabled;
				}
			}
		};
		_proto._contentIsLargerThanViewport = function _contentIsLargerThanViewport(orientation) {
			return this._getContentSize(orientation) > this._getViewportSize(orientation);
		};
		_proto._contentPositionToScrollValue = function _contentPositionToScrollValue(contentPosition) {
			var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);
			var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);
			if (maxOffsetH === 0) {
				_tempScrollValue.x = 0;
			} else {
				_tempScrollValue.x = contentPosition.x / maxOffsetH;
			}
			if (maxOffsetV === 0) {
				_tempScrollValue.y = 0;
			} else {
				_tempScrollValue.y = contentPosition.y / -maxOffsetV;
			}
			return _tempScrollValue;
		};
		_proto._getMaxOffset = function _getMaxOffset(orientation, contentSize) {
			contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;
			var viewportSize = this._getViewportSize(orientation);
			if (contentSize < viewportSize) {
				return -this._getViewportSize(orientation);
			}
			return viewportSize - contentSize;
		};
		_proto._getMaxScrollValue = function _getMaxScrollValue(orientation) {
			return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
		};
		_proto._getScrollbarHandleSize = function _getScrollbarHandleSize(axis, orientation) {
			var viewportSize = this._getViewportSize(orientation);
			var contentSize = this._getContentSize(orientation);
			if (Math.abs(contentSize) < 0.001) {
				return 1;
			}
			var handleSize = Math.min(viewportSize / contentSize, 1);
			var overshoot = this._toOvershoot(this._scroll[axis], orientation);
			if (overshoot === 0) {
				return handleSize;
			}
			return handleSize / (1 + Math.abs(overshoot));
		};
		_proto._getViewportSize = function _getViewportSize(orientation) {
			return this._getSize(orientation, this._viewportReference);
		};
		_proto._getContentSize = function _getContentSize(orientation) {
			return this._getSize(orientation, this._contentReference);
		};
		_proto._getSize = function _getSize(orientation, entityReference) {
			if (entityReference.entity && entityReference.entity.element) {
				return entityReference.entity.element[this._getCalculatedDimension(orientation)];
			}
			return 0;
		};
		_proto._getScrollingEnabled = function _getScrollingEnabled(orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontal;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.vertical;
			}
			return undefined;
		};
		_proto._getScrollbarVisibility = function _getScrollbarVisibility(orientation) {
			if (orientation === ORIENTATION_HORIZONTAL) {
				return this.horizontalScrollbarVisibility;
			} else if (orientation === ORIENTATION_VERTICAL) {
				return this.verticalScrollbarVisibility;
			}
			return undefined;
		};
		_proto._getSign = function _getSign(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		};
		_proto._getAxis = function _getAxis(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		};
		_proto._getCalculatedDimension = function _getCalculatedDimension(orientation) {
			return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
		};
		_proto._destroyDragHelper = function _destroyDragHelper() {
			if (this._contentDragHelper) {
				this._contentDragHelper.destroy();
			}
		};
		_proto.onUpdate = function onUpdate() {
			if (this._contentReference.entity) {
				this._updateVelocity();
				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
			}
		};
		_proto._updateVelocity = function _updateVelocity() {
			if (!this._isDragging()) {
				if (this.scrollMode === SCROLL_MODE_BOUNCE) {
					if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
						this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
					}
					if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
						this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
					}
				}
				if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
					var position = this._contentReference.entity.getLocalPosition();
					position.x += this._velocity.x;
					position.y += this._velocity.y;
					this._contentReference.entity.setLocalPosition(position);
					this._setScrollFromContentPosition(position);
				}
				this._velocity.x *= 1 - this.friction;
				this._velocity.y *= 1 - this.friction;
			}
		};
		_proto._hasOvershoot = function _hasOvershoot(axis, orientation) {
			return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
		};
		_proto._toOvershoot = function _toOvershoot(scrollValue, orientation) {
			var maxScrollValue = this._getMaxScrollValue(orientation);
			if (scrollValue < 0) {
				return scrollValue;
			} else if (scrollValue > maxScrollValue) {
				return scrollValue - maxScrollValue;
			}
			return 0;
		};
		_proto._setVelocityFromOvershoot = function _setVelocityFromOvershoot(scrollValue, axis, orientation) {
			var overshootValue = this._toOvershoot(scrollValue, orientation);
			var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);
			if (Math.abs(overshootPixels) > 0) {
				this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
			}
		};
		_proto._setVelocityFromContentPositionDelta = function _setVelocityFromContentPositionDelta(position) {
			if (this._prevContentDragPosition) {
				this._velocity.sub2(position, this._prevContentDragPosition);
				this._prevContentDragPosition.copy(position);
			} else {
				this._velocity.set(0, 0, 0);
				this._prevContentDragPosition = position.clone();
			}
		};
		_proto._setScrollFromContentPosition = function _setScrollFromContentPosition(position) {
			var scrollValue = this._contentPositionToScrollValue(position);
			if (this._isDragging()) {
				scrollValue = this._applyScrollValueTension(scrollValue);
			}
			this._onSetScroll(scrollValue.x, scrollValue.y, false);
		};
		_proto._applyScrollValueTension = function _applyScrollValueTension(scrollValue) {
			var factor = 1;
			var max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);
			var overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);
			if (overshoot > 0) {
				scrollValue.x = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.x = -factor * Math.log10(1 - overshoot);
			}
			max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
			overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);
			if (overshoot > 0) {
				scrollValue.y = max + factor * Math.log10(1 + overshoot);
			} else if (overshoot < 0) {
				scrollValue.y = -factor * Math.log10(1 - overshoot);
			}
			return scrollValue;
		};
		_proto._isDragging = function _isDragging() {
			return this._contentDragHelper && this._contentDragHelper.isDragging;
		};
		_proto._setScrollbarComponentsEnabled = function _setScrollbarComponentsEnabled(enabled) {
			if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
			}
			if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
				this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
			}
		};
		_proto._setContentDraggingEnabled = function _setContentDraggingEnabled(enabled) {
			if (this._contentDragHelper) {
				this._contentDragHelper.enabled = enabled;
			}
		};
		_proto._onMouseWheel = function _onMouseWheel(event) {
			if (this.useMouseWheel) {
				var wheelEvent = event.event;
				var normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;
				var normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;
				var scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
				var scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
				this.scroll = new Vec2(scrollX, scrollY);
			}
		};
		_proto._enableContentInput = function _enableContentInput() {
			while (this._disabledContentInputEntities.length) {
				var e = this._disabledContentInputEntities.pop();
				if (e.element) {
					e.element.useInput = true;
				}
			}
			this._disabledContentInput = false;
		};
		_proto._disableContentInput = function _disableContentInput() {
			var _this2 = this;
			var _disableInput2 = function _disableInput(e) {
				if (e.element && e.element.useInput) {
					_this2._disabledContentInputEntities.push(e);
					e.element.useInput = false;
				}
				var children = e.children;
				for (var i = 0, l = children.length; i < l; i++) {
					_disableInput2(children[i]);
				}
			};
			var contentEntity = this._contentReference.entity;
			if (contentEntity) {
				var children = contentEntity.children;
				for (var i = 0, l = children.length; i < l; i++) {
					_disableInput2(children[i]);
				}
			}
			this._disabledContentInput = true;
		};
		_proto.onEnable = function onEnable() {
			this._viewportReference.onParentComponentEnable();
			this._contentReference.onParentComponentEnable();
			this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();
			this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();
			this._setScrollbarComponentsEnabled(true);
			this._setContentDraggingEnabled(true);
			this._syncAll();
		};
		_proto.onDisable = function onDisable() {
			this._setScrollbarComponentsEnabled(false);
			this._setContentDraggingEnabled(false);
		};
		_proto.onRemove = function onRemove() {
			this._toggleLifecycleListeners('off', this.system);
			this._toggleElementListeners('off');
			this._destroyDragHelper();
		};
		return _createClass(ScrollViewComponent, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this.data.enabled;
			},
			set: function set(arg) {
				this._setValue('enabled', arg);
			}
		}, {
			key: "horizontal",
			get: function get() {
				return this.data.horizontal;
			},
			set: function set(arg) {
				this._setValue('horizontal', arg);
			}
		}, {
			key: "vertical",
			get: function get() {
				return this.data.vertical;
			},
			set: function set(arg) {
				this._setValue('vertical', arg);
			}
		}, {
			key: "scrollMode",
			get: function get() {
				return this.data.scrollMode;
			},
			set: function set(arg) {
				this._setValue('scrollMode', arg);
			}
		}, {
			key: "bounceAmount",
			get: function get() {
				return this.data.bounceAmount;
			},
			set: function set(arg) {
				this._setValue('bounceAmount', arg);
			}
		}, {
			key: "friction",
			get: function get() {
				return this.data.friction;
			},
			set: function set(arg) {
				this._setValue('friction', arg);
			}
		}, {
			key: "dragThreshold",
			get: function get() {
				return this.data.dragThreshold;
			},
			set: function set(arg) {
				this._setValue('dragThreshold', arg);
			}
		}, {
			key: "useMouseWheel",
			get: function get() {
				return this.data.useMouseWheel;
			},
			set: function set(arg) {
				this._setValue('useMouseWheel', arg);
			}
		}, {
			key: "mouseWheelSensitivity",
			get: function get() {
				return this.data.mouseWheelSensitivity;
			},
			set: function set(arg) {
				this._setValue('mouseWheelSensitivity', arg);
			}
		}, {
			key: "horizontalScrollbarVisibility",
			get: function get() {
				return this.data.horizontalScrollbarVisibility;
			},
			set: function set(arg) {
				this._setValue('horizontalScrollbarVisibility', arg);
			}
		}, {
			key: "verticalScrollbarVisibility",
			get: function get() {
				return this.data.verticalScrollbarVisibility;
			},
			set: function set(arg) {
				this._setValue('verticalScrollbarVisibility', arg);
			}
		}, {
			key: "viewportEntity",
			get: function get() {
				return this.data.viewportEntity;
			},
			set: function set(arg) {
				this._setValue('viewportEntity', arg);
			}
		}, {
			key: "contentEntity",
			get: function get() {
				return this.data.contentEntity;
			},
			set: function set(arg) {
				this._setValue('contentEntity', arg);
			}
		}, {
			key: "horizontalScrollbarEntity",
			get: function get() {
				return this.data.horizontalScrollbarEntity;
			},
			set: function set(arg) {
				this._setValue('horizontalScrollbarEntity', arg);
			}
		}, {
			key: "verticalScrollbarEntity",
			get: function get() {
				return this.data.verticalScrollbarEntity;
			},
			set: function set(arg) {
				this._setValue('verticalScrollbarEntity', arg);
			}
		}, {
			key: "scroll",
			get: function get() {
				return this._scroll;
			},
			set: function set(value) {
				this._onSetScroll(value.x, value.y);
			}
		}]);
	}(Component);
	ScrollViewComponent.EVENT_SETSCROLL = 'set:scroll';

	var DEFAULT_DRAG_THRESHOLD$1 = 10;
	var ScrollViewComponentData = function ScrollViewComponentData() {
		this.enabled = true;
		this.horizontal = void 0;
		this.vertical = void 0;
		this.scrollMode = void 0;
		this.bounceAmount = void 0;
		this.friction = void 0;
		this.dragThreshold = DEFAULT_DRAG_THRESHOLD$1;
		this.useMouseWheel = true;
		this.mouseWheelSensitivity = new Vec2(1, 1);
		this.horizontalScrollbarVisibility = void 0;
		this.verticalScrollbarVisibility = void 0;
		this.viewportEntity = void 0;
		this.contentEntity = void 0;
		this.horizontalScrollbarEntity = void 0;
		this.verticalScrollbarEntity = void 0;
	};

	var _schema$6 = [{
		name: 'enabled',
		type: 'boolean'
	}, {
		name: 'horizontal',
		type: 'boolean'
	}, {
		name: 'vertical',
		type: 'boolean'
	}, {
		name: 'scrollMode',
		type: 'number'
	}, {
		name: 'bounceAmount',
		type: 'number'
	}, {
		name: 'friction',
		type: 'number'
	}, {
		name: 'dragThreshold',
		type: 'number'
	}, {
		name: 'useMouseWheel',
		type: 'boolean'
	}, {
		name: 'mouseWheelSensitivity',
		type: 'vec2'
	}, {
		name: 'horizontalScrollbarVisibility',
		type: 'number'
	}, {
		name: 'verticalScrollbarVisibility',
		type: 'number'
	}, {
		name: 'viewportEntity',
		type: 'entity'
	}, {
		name: 'contentEntity',
		type: 'entity'
	}, {
		name: 'horizontalScrollbarEntity',
		type: 'entity'
	}, {
		name: 'verticalScrollbarEntity',
		type: 'entity'
	}];
	var DEFAULT_DRAG_THRESHOLD = 10;
	var ScrollViewComponentSystem = function (_ComponentSystem) {
		function ScrollViewComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'scrollview';
			_this.ComponentType = ScrollViewComponent;
			_this.DataType = ScrollViewComponentData;
			_this.schema = _schema$6;
			_this.on('beforeremove', _this._onRemoveComponent, _this);
			_this.app.systems.on('update', _this.onUpdate, _this);
			return _this;
		}
		_inheritsLoose(ScrollViewComponentSystem, _ComponentSystem);
		var _proto = ScrollViewComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.dragThreshold === undefined) {
				data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
			}
			if (data.useMouseWheel === undefined) {
				data.useMouseWheel = true;
			}
			if (data.mouseWheelSensitivity === undefined) {
				data.mouseWheelSensitivity = new Vec2(1, 1);
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$6);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				var entity = components[id].entity;
				var component = entity.scrollview;
				if (component.enabled && entity.enabled) {
					component.onUpdate();
				}
			}
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return ScrollViewComponentSystem;
	}(ComponentSystem);

	var ScrollbarComponent = function (_Component) {
		function ScrollbarComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._handleReference = new EntityReference(_this, 'handleEntity', {
				'element#gain': _this._onHandleElementGain,
				'element#lose': _this._onHandleElementLose,
				'element#set:anchor': _this._onSetHandleAlignment,
				'element#set:margin': _this._onSetHandleAlignment,
				'element#set:pivot': _this._onSetHandleAlignment
			});
			_this._toggleLifecycleListeners('on');
			return _this;
		}
		_inheritsLoose(ScrollbarComponent, _Component);
		var _proto = ScrollbarComponent.prototype;
		_proto._setValue = function _setValue(name, value) {
			var data = this.data;
			var oldValue = data[name];
			data[name] = value;
			this.fire('set', name, oldValue, value);
		};
		_proto._toggleLifecycleListeners = function _toggleLifecycleListeners(onOrOff) {
			this[onOrOff]('set_value', this._onSetValue, this);
			this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
			this[onOrOff]('set_orientation', this._onSetOrientation, this);
		};
		_proto._onHandleElementGain = function _onHandleElementGain() {
			this._destroyDragHelper();
			this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());
			this._handleDragHelper.on('drag:move', this._onHandleDrag, this);
			this._updateHandlePositionAndSize();
		};
		_proto._onHandleElementLose = function _onHandleElementLose() {
			this._destroyDragHelper();
		};
		_proto._onHandleDrag = function _onHandleDrag(position) {
			if (this._handleReference.entity && this.enabled && this.entity.enabled) {
				this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
			}
		};
		_proto._onSetValue = function _onSetValue(name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.value = math.clamp(newValue, 0, 1);
				this._updateHandlePositionAndSize();
				this.fire('set:value', this.data.value);
			}
		};
		_proto._onSetHandleSize = function _onSetHandleSize(name, oldValue, newValue) {
			if (Math.abs(newValue - oldValue) > 1e-5) {
				this.data.handleSize = math.clamp(newValue, 0, 1);
				this._updateHandlePositionAndSize();
			}
		};
		_proto._onSetHandleAlignment = function _onSetHandleAlignment() {
			this._updateHandlePositionAndSize();
		};
		_proto._onSetOrientation = function _onSetOrientation(name, oldValue, newValue) {
			if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
				this._handleReference.entity.element[this._getOppositeDimension()] = 0;
			}
		};
		_proto._updateHandlePositionAndSize = function _updateHandlePositionAndSize() {
			var handleEntity = this._handleReference.entity;
			var handleElement = handleEntity && handleEntity.element;
			if (handleEntity) {
				var position = handleEntity.getLocalPosition();
				position[this._getAxis()] = this._getHandlePosition();
				this._handleReference.entity.setLocalPosition(position);
			}
			if (handleElement) {
				handleElement[this._getDimension()] = this._getHandleLength();
			}
		};
		_proto._handlePositionToScrollValue = function _handlePositionToScrollValue(handlePosition) {
			return handlePosition * this._getSign() / this._getUsableTrackLength();
		};
		_proto._scrollValueToHandlePosition = function _scrollValueToHandlePosition(value) {
			return value * this._getSign() * this._getUsableTrackLength();
		};
		_proto._getUsableTrackLength = function _getUsableTrackLength() {
			return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
		};
		_proto._getTrackLength = function _getTrackLength() {
			if (this.entity.element) {
				return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
			}
			return 0;
		};
		_proto._getHandleLength = function _getHandleLength() {
			return this._getTrackLength() * this.handleSize;
		};
		_proto._getHandlePosition = function _getHandlePosition() {
			return this._scrollValueToHandlePosition(this.value);
		};
		_proto._getSign = function _getSign() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
		};
		_proto._getAxis = function _getAxis() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
		};
		_proto._getDimension = function _getDimension() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
		};
		_proto._getOppositeDimension = function _getOppositeDimension() {
			return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
		};
		_proto._destroyDragHelper = function _destroyDragHelper() {
			if (this._handleDragHelper) {
				this._handleDragHelper.destroy();
			}
		};
		_proto._setHandleDraggingEnabled = function _setHandleDraggingEnabled(enabled) {
			if (this._handleDragHelper) {
				this._handleDragHelper.enabled = enabled;
			}
		};
		_proto.onEnable = function onEnable() {
			this._handleReference.onParentComponentEnable();
			this._setHandleDraggingEnabled(true);
		};
		_proto.onDisable = function onDisable() {
			this._setHandleDraggingEnabled(false);
		};
		_proto.onRemove = function onRemove() {
			this._destroyDragHelper();
			this._toggleLifecycleListeners('off');
		};
		return _createClass(ScrollbarComponent, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this.data.enabled;
			},
			set: function set(arg) {
				this._setValue('enabled', arg);
			}
		}, {
			key: "orientation",
			get: function get() {
				return this.data.orientation;
			},
			set: function set(arg) {
				this._setValue('orientation', arg);
			}
		}, {
			key: "value",
			get: function get() {
				return this.data.value;
			},
			set: function set(arg) {
				this._setValue('value', arg);
			}
		}, {
			key: "handleSize",
			get: function get() {
				return this.data.handleSize;
			},
			set: function set(arg) {
				this._setValue('handleSize', arg);
			}
		}, {
			key: "handleEntity",
			get: function get() {
				return this.data.handleEntity;
			},
			set: function set(arg) {
				this._setValue('handleEntity', arg);
			}
		}]);
	}(Component);
	ScrollbarComponent.EVENT_SETVALUE = 'set:value';

	var ScrollbarComponentData = function ScrollbarComponentData() {
		this.enabled = true;
		this.orientation = ORIENTATION_HORIZONTAL;
		this.value = 0;
		this.handleSize = void 0;
		this.handleEntity = void 0;
	};

	var _schema$5 = [{
		name: 'enabled',
		type: 'boolean'
	}, {
		name: 'orientation',
		type: 'number'
	}, {
		name: 'value',
		type: 'number'
	}, {
		name: 'handleSize',
		type: 'number'
	}, {
		name: 'handleEntity',
		type: 'entity'
	}];
	var ScrollbarComponentSystem = function (_ComponentSystem) {
		function ScrollbarComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'scrollbar';
			_this.ComponentType = ScrollbarComponent;
			_this.DataType = ScrollbarComponentData;
			_this.schema = _schema$5;
			_this.on('beforeremove', _this._onRemoveComponent, _this);
			return _this;
		}
		_inheritsLoose(ScrollbarComponentSystem, _ComponentSystem);
		var _proto = ScrollbarComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$5);
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		return ScrollbarComponentSystem;
	}(ComponentSystem);

	var instanceOptions = {
		volume: 0,
		pitch: 0,
		loop: false,
		startTime: 0,
		duration: 0,
		position: new Vec3(),
		maxDistance: 0,
		refDistance: 0,
		rollOffFactor: 0,
		distanceModel: 0,
		onPlay: null,
		onPause: null,
		onResume: null,
		onStop: null,
		onEnd: null
	};
	var SoundSlot = function (_EventHandler) {
		function SoundSlot(component, name, options) {
			var _this;
			if (name === void 0) {
				name = 'Untitled';
			}
			if (options === void 0) {
				options = {};
			}
			_this = _EventHandler.call(this) || this;
			_this.name = void 0;
			_this.instances = [];
			_this._component = component;
			_this._assets = component.system.app.assets;
			_this._manager = component.system.manager;
			_this.name = name;
			_this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
			_this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
			_this._loop = !!(options.loop !== undefined ? options.loop : false);
			_this._duration = options.duration > 0 ? options.duration : null;
			_this._startTime = Math.max(0, Number(options.startTime) || 0);
			_this._overlap = !!options.overlap;
			_this._autoPlay = !!options.autoPlay;
			_this._firstNode = null;
			_this._lastNode = null;
			_this._asset = options.asset;
			if (_this._asset instanceof Asset) {
				_this._asset = _this._asset.id;
			}
			_this._onInstancePlayHandler = _this._onInstancePlay.bind(_this);
			_this._onInstancePauseHandler = _this._onInstancePause.bind(_this);
			_this._onInstanceResumeHandler = _this._onInstanceResume.bind(_this);
			_this._onInstanceStopHandler = _this._onInstanceStop.bind(_this);
			_this._onInstanceEndHandler = _this._onInstanceEnd.bind(_this);
			return _this;
		}
		_inheritsLoose(SoundSlot, _EventHandler);
		var _proto = SoundSlot.prototype;
		_proto.play = function play() {
			if (!this.overlap) {
				this.stop();
			}
			if (!this.isLoaded && !this._hasAsset()) {
				return undefined;
			}
			var instance = this._createInstance();
			this.instances.push(instance);
			if (!this.isLoaded) {
				var onLoad = function onLoad(sound) {
					var playWhenLoaded = instance._playWhenLoaded;
					instance.sound = sound;
					if (playWhenLoaded) {
						instance.play();
					}
				};
				this.off('load', onLoad);
				this.once('load', onLoad);
				this.load();
			} else {
				instance.play();
			}
			return instance;
		};
		_proto.pause = function pause() {
			var paused = false;
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].pause()) {
					paused = true;
				}
			}
			return paused;
		};
		_proto.resume = function resume() {
			var resumed = false;
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				if (instances[i].resume()) {
					resumed = true;
				}
			}
			return resumed;
		};
		_proto.stop = function stop() {
			var stopped = false;
			var instances = this.instances;
			var i = instances.length;
			while (i--) {
				instances[i].stop();
				stopped = true;
			}
			instances.length = 0;
			return stopped;
		};
		_proto.load = function load() {
			if (!this._hasAsset()) {
				return;
			}
			var asset = this._assets.get(this._asset);
			if (!asset) {
				this._assets.off("add:" + this._asset, this._onAssetAdd, this);
				this._assets.once("add:" + this._asset, this._onAssetAdd, this);
				return;
			}
			asset.off('remove', this._onAssetRemoved, this);
			asset.on('remove', this._onAssetRemoved, this);
			if (!asset.resource) {
				asset.off('load', this._onAssetLoad, this);
				asset.once('load', this._onAssetLoad, this);
				this._assets.load(asset);
				return;
			}
			this.fire('load', asset.resource);
		};
		_proto.setExternalNodes = function setExternalNodes(firstNode, lastNode) {
			if (!firstNode) {
				console.error('The firstNode must have a valid AudioNode');
				return;
			}
			if (!lastNode) {
				lastNode = firstNode;
			}
			this._firstNode = firstNode;
			this._lastNode = lastNode;
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].setExternalNodes(firstNode, lastNode);
				}
			}
		};
		_proto.clearExternalNodes = function clearExternalNodes() {
			this._firstNode = null;
			this._lastNode = null;
			if (!this._overlap) {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].clearExternalNodes();
				}
			}
		};
		_proto.getExternalNodes = function getExternalNodes() {
			return [this._firstNode, this._lastNode];
		};
		_proto._hasAsset = function _hasAsset() {
			return this._asset != null;
		};
		_proto._createInstance = function _createInstance() {
			var instance = null;
			var component = this._component;
			var sound = null;
			if (this._hasAsset()) {
				var asset = this._assets.get(this._asset);
				if (asset) {
					sound = asset.resource;
				}
			}
			var data = instanceOptions;
			data.volume = this._volume * component.volume;
			data.pitch = this._pitch * component.pitch;
			data.loop = this._loop;
			data.startTime = this._startTime;
			data.duration = this._duration;
			data.onPlay = this._onInstancePlayHandler;
			data.onPause = this._onInstancePauseHandler;
			data.onResume = this._onInstanceResumeHandler;
			data.onStop = this._onInstanceStopHandler;
			data.onEnd = this._onInstanceEndHandler;
			if (component.positional) {
				data.position.copy(component.entity.getPosition());
				data.maxDistance = component.maxDistance;
				data.refDistance = component.refDistance;
				data.rollOffFactor = component.rollOffFactor;
				data.distanceModel = component.distanceModel;
				instance = new SoundInstance3d(this._manager, sound, data);
			} else {
				instance = new SoundInstance(this._manager, sound, data);
			}
			if (this._firstNode) {
				instance.setExternalNodes(this._firstNode, this._lastNode);
			}
			return instance;
		};
		_proto._onInstancePlay = function _onInstancePlay(instance) {
			this.fire('play', instance);
			this._component.fire('play', this, instance);
		};
		_proto._onInstancePause = function _onInstancePause(instance) {
			this.fire('pause', instance);
			this._component.fire('pause', this, instance);
		};
		_proto._onInstanceResume = function _onInstanceResume(instance) {
			this.fire('resume', instance);
			this._component.fire('resume', this, instance);
		};
		_proto._onInstanceStop = function _onInstanceStop(instance) {
			var idx = this.instances.indexOf(instance);
			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}
			this.fire('stop', instance);
			this._component.fire('stop', this, instance);
		};
		_proto._onInstanceEnd = function _onInstanceEnd(instance) {
			var idx = this.instances.indexOf(instance);
			if (idx !== -1) {
				this.instances.splice(idx, 1);
			}
			this.fire('end', instance);
			this._component.fire('end', this, instance);
		};
		_proto._onAssetAdd = function _onAssetAdd(asset) {
			this.load();
		};
		_proto._onAssetLoad = function _onAssetLoad(asset) {
			this.load();
		};
		_proto._onAssetRemoved = function _onAssetRemoved(asset) {
			asset.off('remove', this._onAssetRemoved, this);
			this._assets.off("add:" + asset.id, this._onAssetAdd, this);
			this.stop();
		};
		_proto.updatePosition = function updatePosition(position) {
			var instances = this.instances;
			for (var i = 0, len = instances.length; i < len; i++) {
				instances[i].position = position;
			}
		};
		return _createClass(SoundSlot, [{
			key: "asset",
			get: function get() {
				return this._asset;
			},
			set: function set(value) {
				var old = this._asset;
				if (old) {
					this._assets.off("add:" + old, this._onAssetAdd, this);
					var oldAsset = this._assets.get(old);
					if (oldAsset) {
						oldAsset.off('remove', this._onAssetRemoved, this);
					}
				}
				this._asset = value;
				if (this._asset instanceof Asset) {
					this._asset = this._asset.id;
				}
				if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
					this.load();
				}
			}
		}, {
			key: "autoPlay",
			get: function get() {
				return this._autoPlay;
			},
			set: function set(value) {
				this._autoPlay = !!value;
			}
		}, {
			key: "duration",
			get: function get() {
				var assetDuration = 0;
				if (this._hasAsset()) {
					var asset = this._assets.get(this._asset);
					assetDuration = asset != null && asset.resource ? asset.resource.duration : 0;
				}
				if (this._duration != null) {
					return this._duration % (assetDuration || 1);
				}
				return assetDuration;
			},
			set: function set(value) {
				this._duration = Math.max(0, Number(value) || 0) || null;
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].duration = this._duration;
					}
				}
			}
		}, {
			key: "isLoaded",
			get: function get() {
				if (this._hasAsset()) {
					var asset = this._assets.get(this._asset);
					if (asset) {
						return !!asset.resource;
					}
				}
				return false;
			}
		}, {
			key: "isPaused",
			get: function get() {
				var instances = this.instances;
				var len = instances.length;
				if (len === 0) {
					return false;
				}
				for (var i = 0; i < len; i++) {
					if (!instances[i].isPaused) {
						return false;
					}
				}
				return true;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					if (instances[i].isPlaying) {
						return true;
					}
				}
				return false;
			}
		}, {
			key: "isStopped",
			get: function get() {
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					if (!instances[i].isStopped) {
						return false;
					}
				}
				return true;
			}
		}, {
			key: "loop",
			get: function get() {
				return this._loop;
			},
			set: function set(value) {
				this._loop = !!value;
				var instances = this.instances;
				for (var i = 0, len = instances.length; i < len; i++) {
					instances[i].loop = this._loop;
				}
			}
		}, {
			key: "overlap",
			get: function get() {
				return this._overlap;
			},
			set: function set(value) {
				this._overlap = !!value;
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(value) {
				this._pitch = Math.max(Number(value) || 0, 0.01);
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].pitch = this.pitch * this._component.pitch;
					}
				}
			}
		}, {
			key: "startTime",
			get: function get() {
				return this._startTime;
			},
			set: function set(value) {
				this._startTime = Math.max(0, Number(value) || 0);
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].startTime = this._startTime;
					}
				}
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(value) {
				this._volume = math.clamp(Number(value) || 0, 0, 1);
				if (!this._overlap) {
					var instances = this.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i].volume = this._volume * this._component.volume;
					}
				}
			}
		}]);
	}(EventHandler);
	SoundSlot.EVENT_PLAY = 'play';
	SoundSlot.EVENT_PAUSE = 'pause';
	SoundSlot.EVENT_RESUME = 'resume';
	SoundSlot.EVENT_STOP = 'stop';
	SoundSlot.EVENT_LOAD = 'load';

	var SoundComponent = function (_Component) {
		function SoundComponent() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Component.call.apply(_Component, [this].concat(args)) || this;
			_this._volume = 1;
			_this._pitch = 1;
			_this._positional = true;
			_this._refDistance = 1;
			_this._maxDistance = 10000;
			_this._rollOffFactor = 1;
			_this._distanceModel = DISTANCE_LINEAR;
			_this._slots = {};
			_this._playingBeforeDisable = {};
			return _this;
		}
		_inheritsLoose(SoundComponent, _Component);
		var _proto = SoundComponent.prototype;
		_proto._updateSoundInstances = function _updateSoundInstances(property, value, isFactor) {
			var slots = this._slots;
			for (var key in slots) {
				var slot = slots[key];
				if (!slot.overlap) {
					var instances = slot.instances;
					for (var i = 0, len = instances.length; i < len; i++) {
						instances[i][property] = isFactor ? slot[property] * value : value;
					}
				}
			}
		};
		_proto.onEnable = function onEnable() {
			if (this.system._inTools) {
				return;
			}
			var slots = this._slots;
			var playingBeforeDisable = this._playingBeforeDisable;
			for (var key in slots) {
				var slot = slots[key];
				if (slot.autoPlay && slot.isStopped) {
					slot.play();
				} else if (playingBeforeDisable[key]) {
					slot.resume();
				} else if (!slot.isLoaded) {
					slot.load();
				}
			}
		};
		_proto.onDisable = function onDisable() {
			var slots = this._slots;
			var playingBeforeDisable = {};
			for (var key in slots) {
				if (!slots[key].overlap) {
					if (slots[key].isPlaying) {
						slots[key].pause();
						playingBeforeDisable[key] = true;
					}
				}
			}
			this._playingBeforeDisable = playingBeforeDisable;
		};
		_proto.onRemove = function onRemove() {
			this.off();
		};
		_proto.addSlot = function addSlot(name, options) {
			var slots = this._slots;
			if (slots[name]) {
				return null;
			}
			var slot = new SoundSlot(this, name, options);
			slots[name] = slot;
			if (slot.autoPlay && this.enabled && this.entity.enabled) {
				slot.play();
			}
			return slot;
		};
		_proto.removeSlot = function removeSlot(name) {
			var slots = this._slots;
			if (slots[name]) {
				slots[name].stop();
				delete slots[name];
			}
		};
		_proto.slot = function slot(name) {
			return this._slots[name];
		};
		_proto._getSlotProperty = function _getSlotProperty(name, property) {
			if (!this.enabled || !this.entity.enabled) {
				return undefined;
			}
			var slot = this._slots[name];
			if (!slot) {
				return undefined;
			}
			return slot[property];
		};
		_proto.isPlaying = function isPlaying(name) {
			return this._getSlotProperty(name, 'isPlaying') || false;
		};
		_proto.isLoaded = function isLoaded(name) {
			return this._getSlotProperty(name, 'isLoaded') || false;
		};
		_proto.isPaused = function isPaused(name) {
			return this._getSlotProperty(name, 'isPaused') || false;
		};
		_proto.isStopped = function isStopped(name) {
			return this._getSlotProperty(name, 'isStopped') || false;
		};
		_proto.play = function play(name) {
			if (!this.enabled || !this.entity.enabled) {
				return null;
			}
			var slot = this._slots[name];
			if (!slot) {
				return null;
			}
			return slot.play();
		};
		_proto.pause = function pause(name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				slot.pause();
			} else {
				for (var key in slots) {
					slots[key].pause();
				}
			}
		};
		_proto.resume = function resume(name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				if (slot.isPaused) {
					slot.resume();
				}
			} else {
				for (var key in slots) {
					slots[key].resume();
				}
			}
		};
		_proto.stop = function stop(name) {
			var slots = this._slots;
			if (name) {
				var slot = slots[name];
				if (!slot) {
					return;
				}
				slot.stop();
			} else {
				for (var key in slots) {
					slots[key].stop();
				}
			}
		};
		return _createClass(SoundComponent, [{
			key: "distanceModel",
			get: function get() {
				return this._distanceModel;
			},
			set: function set(value) {
				this._distanceModel = value;
				this._updateSoundInstances('distanceModel', value, false);
			}
		}, {
			key: "maxDistance",
			get: function get() {
				return this._maxDistance;
			},
			set: function set(value) {
				this._maxDistance = value;
				this._updateSoundInstances('maxDistance', value, false);
			}
		}, {
			key: "refDistance",
			get: function get() {
				return this._refDistance;
			},
			set: function set(value) {
				this._refDistance = value;
				this._updateSoundInstances('refDistance', value, false);
			}
		}, {
			key: "rollOffFactor",
			get: function get() {
				return this._rollOffFactor;
			},
			set: function set(value) {
				this._rollOffFactor = value;
				this._updateSoundInstances('rollOffFactor', value, false);
			}
		}, {
			key: "pitch",
			get: function get() {
				return this._pitch;
			},
			set: function set(value) {
				this._pitch = value;
				this._updateSoundInstances('pitch', value, true);
			}
		}, {
			key: "volume",
			get: function get() {
				return this._volume;
			},
			set: function set(value) {
				this._volume = value;
				this._updateSoundInstances('volume', value, true);
			}
		}, {
			key: "positional",
			get: function get() {
				return this._positional;
			},
			set: function set(newValue) {
				this._positional = newValue;
				var slots = this._slots;
				for (var key in slots) {
					var slot = slots[key];
					if (!slot.overlap) {
						var instances = slot.instances;
						var oldLength = instances.length;
						for (var i = oldLength - 1; i >= 0; i--) {
							var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
							var currentTime = instances[i].currentTime;
							if (isPlaying) {
								instances[i].stop();
							}
							var instance = slot._createInstance();
							if (isPlaying) {
								instance.play();
								instance.currentTime = currentTime;
							}
							instances.push(instance);
						}
					}
				}
			}
		}, {
			key: "slots",
			get: function get() {
				return this._slots;
			},
			set: function set(newValue) {
				var oldValue = this._slots;
				if (oldValue) {
					for (var key in oldValue) {
						oldValue[key].stop();
					}
				}
				var slots = {};
				for (var _key2 in newValue) {
					if (!(newValue[_key2] instanceof SoundSlot)) {
						if (newValue[_key2].name) {
							slots[newValue[_key2].name] = new SoundSlot(this, newValue[_key2].name, newValue[_key2]);
						}
					} else {
						slots[newValue[_key2].name] = newValue[_key2];
					}
				}
				this._slots = slots;
				if (this.enabled && this.entity.enabled) {
					this.onEnable();
				}
			}
		}]);
	}(Component);
	SoundComponent.EVENT_PLAY = 'play';
	SoundComponent.EVENT_PAUSE = 'pause';
	SoundComponent.EVENT_RESUME = 'resume';
	SoundComponent.EVENT_STOP = 'stop';
	SoundComponent.EVENT_END = 'end';

	var SoundComponentData = function SoundComponentData() {
		this.enabled = true;
	};

	var _schema$4 = ['enabled'];
	var SoundComponentSystem = function (_ComponentSystem) {
		function SoundComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'sound';
			_this.ComponentType = SoundComponent;
			_this.DataType = SoundComponentData;
			_this.schema = _schema$4;
			_this.manager = app.soundManager;
			_this.app.systems.on('update', _this.onUpdate, _this);
			_this.on('beforeremove', _this.onBeforeRemove, _this);
			return _this;
		}
		_inheritsLoose(SoundComponentSystem, _ComponentSystem);
		var _proto = SoundComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];
			for (var i = 0; i < properties.length; i++) {
				if (data.hasOwnProperty(properties[i])) {
					component[properties[i]] = data[properties[i]];
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var srcComponent = entity.sound;
			var srcSlots = srcComponent.slots;
			var slots = {};
			for (var key in srcSlots) {
				var srcSlot = srcSlots[key];
				slots[key] = {
					name: srcSlot.name,
					volume: srcSlot.volume,
					pitch: srcSlot.pitch,
					loop: srcSlot.loop,
					duration: srcSlot.duration,
					startTime: srcSlot.startTime,
					overlap: srcSlot.overlap,
					autoPlay: srcSlot.autoPlay,
					asset: srcSlot.asset
				};
			}
			var cloneData = {
				distanceModel: srcComponent.distanceModel,
				enabled: srcComponent.enabled,
				maxDistance: srcComponent.maxDistance,
				pitch: srcComponent.pitch,
				positional: srcComponent.positional,
				refDistance: srcComponent.refDistance,
				rollOffFactor: srcComponent.rollOffFactor,
				slots: slots,
				volume: srcComponent.volume
			};
			return this.addComponent(clone, cloneData);
		};
		_proto.onUpdate = function onUpdate(dt) {
			var store = this.store;
			for (var id in store) {
				if (store.hasOwnProperty(id)) {
					var item = store[id];
					var entity = item.entity;
					if (entity.enabled) {
						var component = entity.sound;
						if (component.enabled && component.positional) {
							var position = entity.getPosition();
							var slots = component.slots;
							for (var key in slots) {
								slots[key].updatePosition(position);
							}
						}
					}
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			var slots = component.slots;
			for (var key in slots) {
				if (!slots[key].overlap) {
					slots[key].stop();
				}
			}
			component.onRemove();
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
		};
		return _createClass(SoundComponentSystem, [{
			key: "volume",
			get: function get() {
				return this.manager.volume;
			},
			set: function set(volume) {
				this.manager.volume = volume;
			}
		}, {
			key: "context",
			get: function get() {
				if (!hasAudioContext()) {
					return null;
				}
				return this.manager.context;
			}
		}]);
	}(ComponentSystem);
	Component._buildAccessors(SoundComponent.prototype, _schema$4);

	var SPRITETYPE_SIMPLE = 'simple';
	var SPRITETYPE_ANIMATED = 'animated';

	var SpriteAnimationClip = function (_EventHandler) {
		function SpriteAnimationClip(component, data) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._evtSetMeshes = null;
			_this._component = component;
			_this._frame = 0;
			_this._sprite = null;
			_this._spriteAsset = null;
			_this.spriteAsset = data.spriteAsset;
			_this.name = data.name;
			_this.fps = data.fps || 0;
			_this.loop = data.loop || false;
			_this._playing = false;
			_this._paused = false;
			_this._time = 0;
			return _this;
		}
		_inheritsLoose(SpriteAnimationClip, _EventHandler);
		var _proto = SpriteAnimationClip.prototype;
		_proto._onSpriteAssetAdded = function _onSpriteAssetAdded(asset) {
			this._component.system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
			if (this._spriteAsset === asset.id) {
				this._bindSpriteAsset(asset);
			}
		};
		_proto._bindSpriteAsset = function _bindSpriteAsset(asset) {
			asset.on('load', this._onSpriteAssetLoad, this);
			asset.on('remove', this._onSpriteAssetRemove, this);
			if (asset.resource) {
				this._onSpriteAssetLoad(asset);
			} else {
				this._component.system.app.assets.load(asset);
			}
		};
		_proto._unbindSpriteAsset = function _unbindSpriteAsset(asset) {
			if (!asset) {
				return;
			}
			asset.off('load', this._onSpriteAssetLoad, this);
			asset.off('remove', this._onSpriteAssetRemove, this);
			if (asset.resource && !asset.resource.atlas) {
				this._component.system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
			}
		};
		_proto._onSpriteAssetLoad = function _onSpriteAssetLoad(asset) {
			if (!asset.resource) {
				this.sprite = null;
			} else {
				if (!asset.resource.atlas) {
					var atlasAssetId = asset.data.textureAtlasAsset;
					var assets = this._component.system.app.assets;
					assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
					assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
				} else {
					this.sprite = asset.resource;
				}
			}
		};
		_proto._onTextureAtlasLoad = function _onTextureAtlasLoad(atlasAsset) {
			var spriteAsset = this._spriteAsset;
			if (spriteAsset instanceof Asset) {
				this._onSpriteAssetLoad(spriteAsset);
			} else {
				this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
			}
		};
		_proto._onSpriteAssetRemove = function _onSpriteAssetRemove(asset) {
			this.sprite = null;
		};
		_proto._onSpriteMeshesChange = function _onSpriteMeshesChange() {
			if (this._component.currentClip === this) {
				this._component._showFrame(this.frame);
			}
		};
		_proto._onSpritePpuChanged = function _onSpritePpuChanged() {
			if (this._component.currentClip === this) {
				if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
					this._component._showFrame(this.frame);
				}
			}
		};
		_proto._update = function _update(dt) {
			if (this.fps === 0) return;
			if (!this._playing || this._paused || !this._sprite) return;
			var dir = this.fps < 0 ? -1 : 1;
			var time = this._time + dt * this._component.speed * dir;
			var duration = this.duration;
			var end = time > duration || time < 0;
			this._setTime(time);
			var frame = this.frame;
			if (this._sprite) {
				frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
			} else {
				frame = 0;
			}
			if (frame !== this._frame) {
				this._setFrame(frame);
			}
			if (end) {
				if (this.loop) {
					this.fire('loop');
					this._component.fire('loop', this);
				} else {
					this._playing = false;
					this._paused = false;
					this.fire('end');
					this._component.fire('end', this);
				}
			}
		};
		_proto._setTime = function _setTime(value) {
			this._time = value;
			var duration = this.duration;
			if (this._time < 0) {
				if (this.loop) {
					this._time = this._time % duration + duration;
				} else {
					this._time = 0;
				}
			} else if (this._time > duration) {
				if (this.loop) {
					this._time %= duration;
				} else {
					this._time = duration;
				}
			}
		};
		_proto._setFrame = function _setFrame(value) {
			if (this._sprite) {
				this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
			} else {
				this._frame = value;
			}
			if (this._component.currentClip === this) {
				this._component._showFrame(this._frame);
			}
		};
		_proto._destroy = function _destroy() {
			if (this._spriteAsset) {
				var assets = this._component.system.app.assets;
				this._unbindSpriteAsset(assets.get(this._spriteAsset));
			}
			if (this._sprite) {
				this.sprite = null;
			}
			if (this._spriteAsset) {
				this.spriteAsset = null;
			}
		};
		_proto.play = function play() {
			if (this._playing) {
				return;
			}
			this._playing = true;
			this._paused = false;
			this.frame = 0;
			this.fire('play');
			this._component.fire('play', this);
		};
		_proto.pause = function pause() {
			if (!this._playing || this._paused) {
				return;
			}
			this._paused = true;
			this.fire('pause');
			this._component.fire('pause', this);
		};
		_proto.resume = function resume() {
			if (!this._paused) return;
			this._paused = false;
			this.fire('resume');
			this._component.fire('resume', this);
		};
		_proto.stop = function stop() {
			if (!this._playing) return;
			this._playing = false;
			this._paused = false;
			this._time = 0;
			this.frame = 0;
			this.fire('stop');
			this._component.fire('stop', this);
		};
		return _createClass(SpriteAnimationClip, [{
			key: "duration",
			get: function get() {
				if (this._sprite) {
					var fps = this.fps || Number.MIN_VALUE;
					return this._sprite.frameKeys.length / Math.abs(fps);
				}
				return 0;
			}
		}, {
			key: "frame",
			get: function get() {
				return this._frame;
			},
			set: function set(value) {
				this._setFrame(value);
				var fps = this.fps || Number.MIN_VALUE;
				this._setTime(this._frame / fps);
			}
		}, {
			key: "isPaused",
			get: function get() {
				return this._paused;
			}
		}, {
			key: "isPlaying",
			get: function get() {
				return this._playing;
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._sprite;
			},
			set: function set(value) {
				if (this._sprite) {
					var _this$_evtSetMeshes;
					(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();
					this._evtSetMeshes = null;
					this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);
					this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);
					if (this._sprite.atlas) {
						this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
					}
				}
				this._sprite = value;
				if (this._sprite) {
					this._evtSetMeshes = this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);
					this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);
					this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);
					if (this._sprite.atlas) {
						this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
					}
				}
				if (this._component.currentClip === this) {
					var mi;
					if (!value || !value.atlas) {
						mi = this._component._meshInstance;
						if (mi) {
							mi.deleteParameter('texture_emissiveMap');
							mi.deleteParameter('texture_opacityMap');
						}
						this._component._hideModel();
					} else {
						if (value.atlas.texture) {
							mi = this._component._meshInstance;
							if (mi) {
								mi.setParameter('texture_emissiveMap', value.atlas.texture);
								mi.setParameter('texture_opacityMap', value.atlas.texture);
							}
							if (this._component.enabled && this._component.entity.enabled) {
								this._component._showModel();
							}
						}
						if (this.time && this.fps) {
							this.time = this.time;
						} else {
							this.frame = this.frame;
						}
					}
				}
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._spriteAsset;
			},
			set: function set(value) {
				var assets = this._component.system.app.assets;
				var id = value;
				if (value instanceof Asset) {
					id = value.id;
				}
				if (this._spriteAsset !== id) {
					if (this._spriteAsset) {
						var prev = assets.get(this._spriteAsset);
						if (prev) {
							this._unbindSpriteAsset(prev);
						}
					}
					this._spriteAsset = id;
					if (this._spriteAsset) {
						var asset = assets.get(this._spriteAsset);
						if (!asset) {
							this.sprite = null;
							assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
						} else {
							this._bindSpriteAsset(asset);
						}
					} else {
						this.sprite = null;
					}
				}
			}
		}, {
			key: "time",
			get: function get() {
				return this._time;
			},
			set: function set(value) {
				this._setTime(value);
				if (this._sprite) {
					this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
				} else {
					this.frame = 0;
				}
			}
		}]);
	}(EventHandler);
	SpriteAnimationClip.EVENT_PLAY = 'play';
	SpriteAnimationClip.EVENT_PAUSE = 'pause';
	SpriteAnimationClip.EVENT_RESUME = 'resume';
	SpriteAnimationClip.EVENT_STOP = 'stop';
	SpriteAnimationClip.EVENT_END = 'end';
	SpriteAnimationClip.EVENT_LOOP = 'loop';

	var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
	var PARAM_OPACITY_MAP = 'texture_opacityMap';
	var PARAM_EMISSIVE = 'material_emissive';
	var PARAM_OPACITY = 'material_opacity';
	var PARAM_INNER_OFFSET = 'innerOffset';
	var PARAM_OUTER_SCALE = 'outerScale';
	var PARAM_ATLAS_RECT = 'atlasRect';
	var SpriteComponent = function (_Component) {
		function SpriteComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._type = SPRITETYPE_SIMPLE;
			_this._material = system.defaultMaterial;
			_this._color = new Color(1, 1, 1, 1);
			_this._colorUniform = new Float32Array(3);
			_this._speed = 1;
			_this._flipX = false;
			_this._flipY = false;
			_this._width = 1;
			_this._height = 1;
			_this._drawOrder = 0;
			_this._layers = [LAYERID_WORLD];
			_this._outerScale = new Vec2(1, 1);
			_this._outerScaleUniform = new Float32Array(2);
			_this._innerOffset = new Vec4();
			_this._innerOffsetUniform = new Float32Array(4);
			_this._atlasRect = new Vec4();
			_this._atlasRectUniform = new Float32Array(4);
			_this._batchGroupId = -1;
			_this._batchGroup = null;
			_this._node = new GraphNode();
			_this._model = new Model();
			_this._model.graph = _this._node;
			_this._meshInstance = null;
			entity.addChild(_this._model.graph);
			_this._model._entity = entity;
			_this._updateAabbFunc = _this._updateAabb.bind(_this);
			_this._addedModel = false;
			_this._autoPlayClip = null;
			_this._clips = {};
			_this._defaultClip = new SpriteAnimationClip(_this, {
				name: _this.entity.name,
				fps: 0,
				loop: false,
				spriteAsset: null
			});
			_this._currentClip = _this._defaultClip;
			return _this;
		}
		_inheritsLoose(SpriteComponent, _Component);
		var _proto = SpriteComponent.prototype;
		_proto.onEnable = function onEnable() {
			var app = this.system.app;
			var scene = app.scene;
			var layers = scene.layers;
			this._evtLayersChanged = scene.on('set:layers', this._onLayersChanged, this);
			if (layers) {
				this._evtLayerAdded = layers.on('add', this._onLayerAdded, this);
				this._evtLayerRemoved = layers.on('remove', this._onLayerRemoved, this);
			}
			this._showModel();
			if (this._autoPlayClip) {
				this._tryAutoPlay();
			}
			if (this._batchGroupId >= 0) {
				var _app$batcher;
				(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang;
			var app = this.system.app;
			var scene = app.scene;
			var layers = scene.layers;
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = null;
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = null;
			}
			this.stop();
			this._hideModel();
			if (this._batchGroupId >= 0) {
				var _app$batcher2;
				(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
			}
		};
		_proto.onDestroy = function onDestroy() {
			var _this$_node;
			this._currentClip = null;
			if (this._defaultClip) {
				this._defaultClip._destroy();
				this._defaultClip = null;
			}
			for (var key in this._clips) {
				this._clips[key]._destroy();
			}
			this._clips = null;
			this._hideModel();
			this._model = null;
			(_this$_node = this._node) == null || _this$_node.remove();
			this._node = null;
			if (this._meshInstance) {
				this._meshInstance.material = null;
				this._meshInstance.mesh = null;
				this._meshInstance = null;
			}
		};
		_proto._showModel = function _showModel() {
			if (this._addedModel) return;
			if (!this._meshInstance) return;
			var meshInstances = [this._meshInstance];
			for (var i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.addMeshInstances(meshInstances);
				}
			}
			this._addedModel = true;
		};
		_proto._hideModel = function _hideModel() {
			if (!this._addedModel || !this._meshInstance) return;
			var meshInstances = [this._meshInstance];
			for (var i = 0, len = this._layers.length; i < len; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
				if (layer) {
					layer.removeMeshInstances(meshInstances);
				}
			}
			this._addedModel = false;
		};
		_proto._showFrame = function _showFrame(frame) {
			if (!this.sprite) return;
			var mesh = this.sprite.meshes[frame];
			if (!mesh) {
				if (this._meshInstance) {
					this._meshInstance.mesh = null;
					this._meshInstance.visible = false;
				}
				return;
			}
			var material;
			if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
				material = this.system.default9SlicedMaterialSlicedMode;
			} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
				material = this.system.default9SlicedMaterialTiledMode;
			} else {
				material = this.system.defaultMaterial;
			}
			if (!this._meshInstance) {
				this._meshInstance = new MeshInstance(mesh, this._material, this._node);
				this._meshInstance.castShadow = false;
				this._meshInstance.receiveShadow = false;
				this._meshInstance.drawOrder = this._drawOrder;
				this._model.meshInstances.push(this._meshInstance);
				this._colorUniform[0] = this._color.r;
				this._colorUniform[1] = this._color.g;
				this._colorUniform[2] = this._color.b;
				this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
				this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);
				if (this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
			if (this._meshInstance.material !== material) {
				this._meshInstance.material = material;
			}
			if (this._meshInstance.mesh !== mesh) {
				this._meshInstance.mesh = mesh;
				this._meshInstance.visible = true;
				this._meshInstance._aabbVer = -1;
			}
			if (this.sprite.atlas && this.sprite.atlas.texture) {
				this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
				this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
			} else {
				this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
				this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
			}
			if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				this._meshInstance._updateAabbFunc = this._updateAabbFunc;
				var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
				if (frameData) {
					var borderWidthScale = 2 / frameData.rect.z;
					var borderHeightScale = 2 / frameData.rect.w;
					this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
					var tex = this.sprite.atlas.texture;
					this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
				} else {
					this._innerOffset.set(0, 0, 0, 0);
				}
				this._innerOffsetUniform[0] = this._innerOffset.x;
				this._innerOffsetUniform[1] = this._innerOffset.y;
				this._innerOffsetUniform[2] = this._innerOffset.z;
				this._innerOffsetUniform[3] = this._innerOffset.w;
				this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
				this._atlasRectUniform[0] = this._atlasRect.x;
				this._atlasRectUniform[1] = this._atlasRect.y;
				this._atlasRectUniform[2] = this._atlasRect.z;
				this._atlasRectUniform[3] = this._atlasRect.w;
				this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
			} else {
				this._meshInstance._updateAabbFunc = null;
			}
			this._updateTransform();
		};
		_proto._updateTransform = function _updateTransform() {
			var scaleX = this.flipX ? -1 : 1;
			var scaleY = this.flipY ? -1 : 1;
			var posX = 0;
			var posY = 0;
			if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
				var w = 1;
				var h = 1;
				if (this.sprite.atlas) {
					var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
					if (frameData) {
						w = frameData.rect.z;
						h = frameData.rect.w;
						posX = (0.5 - frameData.pivot.x) * this._width;
						posY = (0.5 - frameData.pivot.y) * this._height;
					}
				}
				var scaleMulX = w / this.sprite.pixelsPerUnit;
				var scaleMulY = h / this.sprite.pixelsPerUnit;
				this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
				scaleX *= scaleMulX;
				scaleY *= scaleMulY;
				this._outerScale.x /= scaleMulX;
				this._outerScale.y /= scaleMulY;
				scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
				scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);
				if (this._meshInstance) {
					this._outerScaleUniform[0] = this._outerScale.x;
					this._outerScaleUniform[1] = this._outerScale.y;
					this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
				}
			}
			this._node.setLocalScale(scaleX, scaleY, 1);
			this._node.setLocalPosition(posX, posY, 0);
		};
		_proto._updateAabb = function _updateAabb(aabb) {
			aabb.center.set(0, 0, 0);
			aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
			aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
			return aabb;
		};
		_proto._tryAutoPlay = function _tryAutoPlay() {
			if (!this._autoPlayClip) return;
			if (this.type !== SPRITETYPE_ANIMATED) return;
			var clip = this._clips[this._autoPlayClip];
			if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
				if (this.enabled && this.entity.enabled) {
					this.play(clip.name);
				}
			}
		};
		_proto._onLayersChanged = function _onLayersChanged(oldComp, newComp) {
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
			if (this.enabled && this.entity.enabled) {
				this._showModel();
			}
		};
		_proto._onLayerAdded = function _onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
				layer.addMeshInstances([this._meshInstance]);
			}
		};
		_proto._onLayerRemoved = function _onLayerRemoved(layer) {
			if (!this._meshInstance) return;
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeMeshInstances([this._meshInstance]);
		};
		_proto.removeModelFromLayers = function removeModelFromLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (!layer) continue;
				layer.removeMeshInstances([this._meshInstance]);
			}
		};
		_proto.addClip = function addClip(data) {
			var clip = new SpriteAnimationClip(this, {
				name: data.name,
				fps: data.fps,
				loop: data.loop,
				spriteAsset: data.spriteAsset
			});
			this._clips[data.name] = clip;
			if (clip.name && clip.name === this._autoPlayClip) {
				this._tryAutoPlay();
			}
			return clip;
		};
		_proto.removeClip = function removeClip(name) {
			delete this._clips[name];
		};
		_proto.clip = function clip(name) {
			return this._clips[name];
		};
		_proto.play = function play(name) {
			var clip = this._clips[name];
			var current = this._currentClip;
			if (current && current !== clip) {
				current._playing = false;
			}
			this._currentClip = clip;
			if (this._currentClip) {
				this._currentClip = clip;
				this._currentClip.play();
			}
			return clip;
		};
		_proto.pause = function pause() {
			if (this._currentClip === this._defaultClip) return;
			if (this._currentClip.isPlaying) {
				this._currentClip.pause();
			}
		};
		_proto.resume = function resume() {
			if (this._currentClip === this._defaultClip) return;
			if (this._currentClip.isPaused) {
				this._currentClip.resume();
			}
		};
		_proto.stop = function stop() {
			if (this._currentClip === this._defaultClip) return;
			this._currentClip.stop();
		};
		return _createClass(SpriteComponent, [{
			key: "type",
			get: function get() {
				return this._type;
			},
			set: function set(value) {
				if (this._type === value) {
					return;
				}
				this._type = value;
				if (this._type === SPRITETYPE_SIMPLE) {
					this.stop();
					this._currentClip = this._defaultClip;
					if (this.enabled && this.entity.enabled) {
						this._currentClip.frame = this.frame;
						if (this._currentClip.sprite) {
							this._showModel();
						} else {
							this._hideModel();
						}
					}
				} else if (this._type === SPRITETYPE_ANIMATED) {
					this.stop();
					if (this._autoPlayClip) {
						this._tryAutoPlay();
					}
					if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
						this._showModel();
					} else {
						this._hideModel();
					}
				}
			}
		}, {
			key: "frame",
			get: function get() {
				return this._currentClip.frame;
			},
			set: function set(value) {
				this._currentClip.frame = value;
			}
		}, {
			key: "spriteAsset",
			get: function get() {
				return this._defaultClip._spriteAsset;
			},
			set: function set(value) {
				this._defaultClip.spriteAsset = value;
			}
		}, {
			key: "sprite",
			get: function get() {
				return this._currentClip.sprite;
			},
			set: function set(value) {
				this._currentClip.sprite = value;
			}
		}, {
			key: "material",
			get: function get() {
				return this._material;
			},
			set: function set(value) {
				this._material = value;
				if (this._meshInstance) {
					this._meshInstance.material = value;
				}
			}
		}, {
			key: "color",
			get: function get() {
				return this._color;
			},
			set: function set(value) {
				this._color.r = value.r;
				this._color.g = value.g;
				this._color.b = value.b;
				if (this._meshInstance) {
					this._colorUniform[0] = this._color.r;
					this._colorUniform[1] = this._color.g;
					this._colorUniform[2] = this._color.b;
					this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
				}
			}
		}, {
			key: "opacity",
			get: function get() {
				return this._color.a;
			},
			set: function set(value) {
				this._color.a = value;
				if (this._meshInstance) {
					this._meshInstance.setParameter(PARAM_OPACITY, value);
				}
			}
		}, {
			key: "clips",
			get: function get() {
				return this._clips;
			},
			set: function set(value) {
				if (!value) {
					for (var name in this._clips) {
						this.removeClip(name);
					}
					return;
				}
				for (var _name in this._clips) {
					var found = false;
					for (var key in value) {
						if (value[key].name === _name) {
							found = true;
							this._clips[_name].fps = value[key].fps;
							this._clips[_name].loop = value[key].loop;
							if (value[key].hasOwnProperty('sprite')) {
								this._clips[_name].sprite = value[key].sprite;
							} else if (value[key].hasOwnProperty('spriteAsset')) {
								this._clips[_name].spriteAsset = value[key].spriteAsset;
							}
							break;
						}
					}
					if (!found) {
						this.removeClip(_name);
					}
				}
				for (var _key in value) {
					if (this._clips[value[_key].name]) continue;
					this.addClip(value[_key]);
				}
				if (this._autoPlayClip) {
					this._tryAutoPlay();
				}
				if (!this._currentClip || !this._currentClip.sprite) {
					this._hideModel();
				}
			}
		}, {
			key: "currentClip",
			get: function get() {
				return this._currentClip;
			}
		}, {
			key: "speed",
			get: function get() {
				return this._speed;
			},
			set: function set(value) {
				this._speed = value;
			}
		}, {
			key: "flipX",
			get: function get() {
				return this._flipX;
			},
			set: function set(value) {
				if (this._flipX === value) return;
				this._flipX = value;
				this._updateTransform();
			}
		}, {
			key: "flipY",
			get: function get() {
				return this._flipY;
			},
			set: function set(value) {
				if (this._flipY === value) return;
				this._flipY = value;
				this._updateTransform();
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				if (value === this._width) return;
				this._width = value;
				this._outerScale.x = this._width;
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
					this._updateTransform();
				}
			}
		}, {
			key: "height",
			get: function get() {
				return this._height;
			},
			set: function set(value) {
				if (value === this._height) return;
				this._height = value;
				this._outerScale.y = this.height;
				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
					this._updateTransform();
				}
			}
		}, {
			key: "batchGroupId",
			get: function get() {
				return this._batchGroupId;
			},
			set: function set(value) {
				if (this._batchGroupId === value) {
					return;
				}
				var prev = this._batchGroupId;
				this._batchGroupId = value;
				if (this.entity.enabled && prev >= 0) {
					var _this$system$app$batc;
					(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.SPRITE, prev, this.entity);
				}
				if (this.entity.enabled && value >= 0) {
					var _this$system$app$batc2;
					(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.SPRITE, value, this.entity);
				} else {
					if (prev >= 0) {
						if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
							this._showModel();
						}
					}
				}
			}
		}, {
			key: "autoPlayClip",
			get: function get() {
				return this._autoPlayClip;
			},
			set: function set(value) {
				this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;
				this._tryAutoPlay();
			}
		}, {
			key: "drawOrder",
			get: function get() {
				return this._drawOrder;
			},
			set: function set(value) {
				this._drawOrder = value;
				if (this._meshInstance) {
					this._meshInstance.drawOrder = value;
				}
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				if (this._addedModel) {
					this._hideModel();
				}
				this._layers = value;
				if (!this._meshInstance) {
					return;
				}
				if (this.enabled && this.entity.enabled) {
					this._showModel();
				}
			}
		}, {
			key: "aabb",
			get: function get() {
				if (this._meshInstance) {
					return this._meshInstance.aabb;
				}
				return null;
			}
		}]);
	}(Component);
	SpriteComponent.EVENT_PLAY = 'play';
	SpriteComponent.EVENT_PAUSE = 'pause';
	SpriteComponent.EVENT_RESUME = 'resume';
	SpriteComponent.EVENT_STOP = 'stop';
	SpriteComponent.EVENT_END = 'end';
	SpriteComponent.EVENT_LOOP = 'loop';

	var SpriteComponentData = function SpriteComponentData() {
		this.enabled = true;
	};

	var _schema$3 = ['enabled'];
	var SpriteComponentSystem = function (_ComponentSystem) {
		function SpriteComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'sprite';
			_this.ComponentType = SpriteComponent;
			_this.DataType = SpriteComponentData;
			_this.schema = _schema$3;
			_this._defaultTexture = null;
			_this._defaultMaterial = null;
			_this._default9SlicedMaterialSlicedMode = null;
			_this._default9SlicedMaterialTiledMode = null;
			_this.app.systems.on('update', _this.onUpdate, _this);
			_this.on('beforeremove', _this.onBeforeRemove, _this);
			return _this;
		}
		_inheritsLoose(SpriteComponentSystem, _ComponentSystem);
		var _proto = SpriteComponentSystem.prototype;
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('update', this.onUpdate, this);
			if (this._defaultTexture) {
				this._defaultTexture.destroy();
				this._defaultTexture = null;
			}
		};
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			if (data.enabled !== undefined) {
				component.enabled = data.enabled;
			}
			component.type = data.type;
			if (data.layers && Array.isArray(data.layers)) {
				component.layers = data.layers.slice(0);
			}
			if (data.drawOrder !== undefined) {
				component.drawOrder = data.drawOrder;
			}
			if (data.color !== undefined) {
				if (data.color instanceof Color) {
					var _data$opacity;
					component.color.set(data.color.r, data.color.g, data.color.b, (_data$opacity = data.opacity) != null ? _data$opacity : 1);
				} else {
					var _data$opacity2;
					component.color.set(data.color[0], data.color[1], data.color[2], (_data$opacity2 = data.opacity) != null ? _data$opacity2 : 1);
				}
				component.color = component.color;
			}
			if (data.opacity !== undefined) {
				component.opacity = data.opacity;
			}
			if (data.flipX !== undefined) {
				component.flipX = data.flipX;
			}
			if (data.flipY !== undefined) {
				component.flipY = data.flipY;
			}
			if (data.width !== undefined) {
				component.width = data.width;
			}
			if (data.height !== undefined) {
				component.height = data.height;
			}
			if (data.spriteAsset !== undefined) {
				component.spriteAsset = data.spriteAsset;
			}
			if (data.sprite) {
				component.sprite = data.sprite;
			}
			if (data.frame !== undefined) {
				component.frame = data.frame;
			}
			if (data.clips) {
				for (var name in data.clips) {
					component.addClip(data.clips[name]);
				}
			}
			if (data.speed !== undefined) {
				component.speed = data.speed;
			}
			if (data.autoPlayClip) {
				component.autoPlayClip = data.autoPlayClip;
			}
			component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var source = entity.sprite;
			return this.addComponent(clone, {
				enabled: source.enabled,
				type: source.type,
				spriteAsset: source.spriteAsset,
				sprite: source.sprite,
				width: source.width,
				height: source.height,
				frame: source.frame,
				color: source.color.clone(),
				opacity: source.opacity,
				flipX: source.flipX,
				flipY: source.flipY,
				speed: source.speed,
				clips: source.clips,
				autoPlayClip: source.autoPlayClip,
				batchGroupId: source.batchGroupId,
				drawOrder: source.drawOrder,
				layers: source.layers.slice(0)
			});
		};
		_proto.onUpdate = function onUpdate(dt) {
			var components = this.store;
			for (var id in components) {
				if (components.hasOwnProperty(id)) {
					var component = components[id];
					if (component.data.enabled && component.entity.enabled) {
						var sprite = component.entity.sprite;
						if (sprite._currentClip) {
							sprite._currentClip._update(dt);
						}
					}
				}
			}
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			component.onDestroy();
		};
		return _createClass(SpriteComponentSystem, [{
			key: "defaultMaterial",
			get: function get() {
				if (!this._defaultMaterial) {
					var texture = new Texture(this.app.graphicsDevice, {
						width: 1,
						height: 1,
						format: PIXELFORMAT_RGBA8,
						name: 'sprite'
					});
					var pixels = new Uint8Array(texture.lock());
					pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
					texture.unlock();
					var material = new StandardMaterial();
					material.diffuse.set(0, 0, 0);
					material.emissive.set(1, 1, 1);
					material.emissiveMap = texture;
					material.opacityMap = texture;
					material.opacityMapChannel = 'a';
					material.useLighting = false;
					material.useTonemap = false;
					material.useFog = false;
					material.useSkybox = false;
					material.blendType = BLEND_PREMULTIPLIED;
					material.depthWrite = false;
					material.pixelSnap = false;
					material.cull = CULLFACE_NONE;
					material.update();
					this._defaultTexture = texture;
					this._defaultMaterial = material;
				}
				return this._defaultMaterial;
			},
			set: function set(material) {
				this._defaultMaterial = material;
			}
		}, {
			key: "default9SlicedMaterialSlicedMode",
			get: function get() {
				if (!this._default9SlicedMaterialSlicedMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
					material.update();
					this._default9SlicedMaterialSlicedMode = material;
				}
				return this._default9SlicedMaterialSlicedMode;
			},
			set: function set(material) {
				this._default9SlicedMaterialSlicedMode = material;
			}
		}, {
			key: "default9SlicedMaterialTiledMode",
			get: function get() {
				if (!this._default9SlicedMaterialTiledMode) {
					var material = this.defaultMaterial.clone();
					material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
					material.update();
					this._default9SlicedMaterialTiledMode = material;
				}
				return this._default9SlicedMaterialTiledMode;
			},
			set: function set(material) {
				this._default9SlicedMaterialTiledMode = material;
			}
		}]);
	}(ComponentSystem);
	Component._buildAccessors(SpriteComponent.prototype, _schema$3);

	var ZoneComponent = function (_Component) {
		function ZoneComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._oldState = true;
			_this._size = new Vec3();
			_this.on('set_enabled', _this._onSetEnabled, _this);
			return _this;
		}
		_inheritsLoose(ZoneComponent, _Component);
		var _proto = ZoneComponent.prototype;
		_proto.onEnable = function onEnable() {
			this._checkState();
		};
		_proto.onDisable = function onDisable() {
			this._checkState();
		};
		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
			this._checkState();
		};
		_proto._checkState = function _checkState() {
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState) {
				return;
			}
			this._oldState = state;
			this.fire('enable');
			this.fire('state', this.enabled);
		};
		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
		};
		return _createClass(ZoneComponent, [{
			key: "size",
			get: function get() {
				return this._size;
			},
			set: function set(data) {
				if (data instanceof Vec3) {
					this._size.copy(data);
				} else if (data instanceof Array && data.length >= 3) {
					this.size.set(data[0], data[1], data[2]);
				}
			}
		}]);
	}(Component);
	ZoneComponent.EVENT_ENABLE = 'enable';
	ZoneComponent.EVENT_DISABLE = 'disable';
	ZoneComponent.EVENT_STATE = 'state';
	ZoneComponent.EVENT_REMOVE = 'remove';

	var ZoneComponentData = function ZoneComponentData() {
		this.enabled = true;
	};

	var _schema$2 = ['enabled'];
	var ZoneComponentSystem = function (_ComponentSystem) {
		function ZoneComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'zone';
			_this.ComponentType = ZoneComponent;
			_this.DataType = ZoneComponentData;
			_this.schema = _schema$2;
			_this.on('beforeremove', _this._onBeforeRemove, _this);
			return _this;
		}
		_inheritsLoose(ZoneComponentSystem, _ComponentSystem);
		var _proto = ZoneComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
			if (data.size) {
				if (data.size instanceof Vec3) {
					component.size.copy(data.size);
				} else if (data.size instanceof Array && data.size.length >= 3) {
					component.size.set(data.size[0], data.size[1], data.size[2]);
				}
			}
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var data = {
				enabled: entity.zone.enabled,
				size: entity.zone.size
			};
			return this.addComponent(clone, data);
		};
		_proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
			component._onBeforeRemove();
		};
		return ZoneComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(ZoneComponent.prototype, _schema$2);

	var PostEffectEntry = function PostEffectEntry(effect, inputTarget) {
		this.effect = effect;
		this.inputTarget = inputTarget;
		this.outputTarget = null;
		this.name = effect.constructor.name;
	};
	var PostEffectQueue = function () {
		function PostEffectQueue(app, camera) {
			this.app = app;
			this.camera = camera;
			this.destinationRenderTarget = null;
			this.effects = [];
			this.enabled = false;
			this.depthTarget = null;
			camera.on('set:rect', this.onCameraRectChanged, this);
		}
		var _proto = PostEffectQueue.prototype;
		_proto._allocateColorBuffer = function _allocateColorBuffer(format, name) {
			var _renderTarget$width, _renderTarget$height;
			var rect = this.camera.rect;
			var renderTarget = this.destinationRenderTarget;
			var device = this.app.graphicsDevice;
			var width = Math.floor(rect.z * ((_renderTarget$width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width : device.width));
			var height = Math.floor(rect.w * ((_renderTarget$height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height : device.height));
			var colorBuffer = new Texture(device, {
				name: name,
				format: format,
				width: width,
				height: height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			return colorBuffer;
		};
		_proto._createOffscreenTarget = function _createOffscreenTarget(useDepth, hdr) {
			var _this$destinationRend, _ref;
			var device = this.app.graphicsDevice;
			var outputRt = (_this$destinationRend = this.destinationRenderTarget) != null ? _this$destinationRend : device.backBuffer;
			var srgb = outputRt.isColorBufferSrgb(0);
			var format = (_ref = hdr && device.getRenderableHdrFormat([PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F], true)) != null ? _ref : srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8;
			var name = this.camera.entity.name + "-posteffect-" + this.effects.length;
			var colorBuffer = this._allocateColorBuffer(format, name);
			return new RenderTarget({
				colorBuffer: colorBuffer,
				depth: useDepth,
				stencil: useDepth && this.app.graphicsDevice.supportsStencil,
				samples: useDepth ? device.samples : 1
			});
		};
		_proto._resizeOffscreenTarget = function _resizeOffscreenTarget(rt) {
			var format = rt.colorBuffer.format;
			var name = rt.colorBuffer.name;
			rt.destroyFrameBuffers();
			rt.destroyTextureBuffers();
			rt._colorBuffer = this._allocateColorBuffer(format, name);
			rt._colorBuffers = [rt._colorBuffer];
		};
		_proto._destroyOffscreenTarget = function _destroyOffscreenTarget(rt) {
			rt.destroyTextureBuffers();
			rt.destroy();
		};
		_proto.addEffect = function addEffect(effect) {
			var effects = this.effects;
			var isFirstEffect = effects.length === 0;
			var inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);
			var newEntry = new PostEffectEntry(effect, inputTarget);
			effects.push(newEntry);
			this._sourceTarget = newEntry.inputTarget;
			if (effects.length > 1) {
				effects[effects.length - 2].outputTarget = newEntry.inputTarget;
			}
			this._newPostEffect = effect;
			if (effect.needsDepthBuffer) {
				this._requestDepthMap();
			}
			this.enable();
			this._newPostEffect = undefined;
		};
		_proto.removeEffect = function removeEffect(effect) {
			var index = -1;
			for (var i = 0, len = this.effects.length; i < len; i++) {
				if (this.effects[i].effect === effect) {
					index = i;
					break;
				}
			}
			if (index >= 0) {
				if (index > 0) {
					this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
				} else {
					if (this.effects.length > 1) {
						if (!this.effects[1].inputTarget._depth) {
							this._destroyOffscreenTarget(this.effects[1].inputTarget);
							this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
							this._sourceTarget = this.effects[1].inputTarget;
						}
						this.camera.renderTarget = this.effects[1].inputTarget;
					}
				}
				this._destroyOffscreenTarget(this.effects[index].inputTarget);
				this.effects.splice(index, 1);
			}
			if (this.enabled) {
				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}
			if (this.effects.length === 0) {
				this.disable();
			}
		};
		_proto._requestDepthMaps = function _requestDepthMaps() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;
				if (this._newPostEffect === effect) {
					continue;
				}
				if (effect.needsDepthBuffer) {
					this._requestDepthMap();
				}
			}
		};
		_proto._releaseDepthMaps = function _releaseDepthMaps() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				var effect = this.effects[i].effect;
				if (effect.needsDepthBuffer) {
					this._releaseDepthMap();
				}
			}
		};
		_proto._requestDepthMap = function _requestDepthMap() {
			var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer) {
				depthLayer.incrementCounter();
				this.camera.requestSceneDepthMap(true);
			}
		};
		_proto._releaseDepthMap = function _releaseDepthMap() {
			var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
			if (depthLayer) {
				depthLayer.decrementCounter();
				this.camera.requestSceneDepthMap(false);
			}
		};
		_proto.destroy = function destroy() {
			for (var i = 0, len = this.effects.length; i < len; i++) {
				this.effects[i].inputTarget.destroy();
			}
			this.effects.length = 0;
			this.disable();
		};
		_proto.enable = function enable() {
			var _this = this;
			if (!this.enabled && this.effects.length) {
				this.enabled = true;
				this._requestDepthMaps();
				this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
				this.destinationRenderTarget = this.camera.renderTarget;
				this.camera.renderTarget = this.effects[0].inputTarget;
				this.camera.onPostprocessing = function () {
					if (_this.enabled) {
						var rect = null;
						var len = _this.effects.length;
						if (len) {
							for (var i = 0; i < len; i++) {
								var fx = _this.effects[i];
								var destTarget = fx.outputTarget;
								if (i === len - 1) {
									rect = _this.camera.rect;
									if (_this.destinationRenderTarget) {
										destTarget = _this.destinationRenderTarget;
									}
								}
								fx.effect.render(fx.inputTarget, destTarget, rect);
							}
						}
					}
				};
			}
		};
		_proto.disable = function disable() {
			if (this.enabled) {
				this.enabled = false;
				this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);
				this._releaseDepthMaps();
				this._destroyOffscreenTarget(this._sourceTarget);
				this.camera.renderTarget = this.destinationRenderTarget;
				this.camera.onPostprocessing = null;
			}
		};
		_proto._onCanvasResized = function _onCanvasResized(width, height) {
			var _renderTarget$width2, _renderTarget$height2;
			var rect = this.camera.rect;
			var renderTarget = this.destinationRenderTarget;
			width = (_renderTarget$width2 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width2 : width;
			height = (_renderTarget$height2 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height2 : height;
			this.camera.camera.aspectRatio = width * rect.z / (height * rect.w);
			this.resizeRenderTargets();
		};
		_proto.resizeRenderTargets = function resizeRenderTargets() {
			var _renderTarget$width3, _renderTarget$height3;
			var device = this.app.graphicsDevice;
			var renderTarget = this.destinationRenderTarget;
			var width = (_renderTarget$width3 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width3 : device.width;
			var height = (_renderTarget$height3 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height3 : device.height;
			var rect = this.camera.rect;
			var desiredWidth = Math.floor(rect.z * width);
			var desiredHeight = Math.floor(rect.w * height);
			var effects = this.effects;
			for (var i = 0, len = effects.length; i < len; i++) {
				var fx = effects[i];
				if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
					this._resizeOffscreenTarget(fx.inputTarget);
				}
			}
		};
		_proto.onCameraRectChanged = function onCameraRectChanged(name, oldValue, newValue) {
			if (this.enabled) {
				this.resizeRenderTargets();
			}
		};
		return PostEffectQueue;
	}();

	var CameraComponent = function (_Component) {
		function CameraComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this.onPostprocessing = null;
			_this._renderSceneDepthMap = 0;
			_this._renderSceneColorMap = 0;
			_this._sceneDepthMapRequested = false;
			_this._sceneColorMapRequested = false;
			_this._priority = 0;
			_this._disablePostEffectsLayer = LAYERID_UI;
			_this._camera = new Camera();
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._camera.node = entity;
			_this._postEffects = new PostEffectQueue(system.app, _this);
			return _this;
		}
		_inheritsLoose(CameraComponent, _Component);
		var _proto = CameraComponent.prototype;
		_proto.setShaderPass = function setShaderPass(name) {
			var shaderPass = ShaderPass.get(this.system.app.graphicsDevice);
			var shaderPassInfo = name ? shaderPass.allocate(name, {
				isForward: true
			}) : null;
			this._camera.shaderPassInfo = shaderPassInfo;
			return shaderPassInfo.index;
		};
		_proto.getShaderPass = function getShaderPass() {
			var _this$_camera$shaderP;
			return (_this$_camera$shaderP = this._camera.shaderPassInfo) == null ? void 0 : _this$_camera$shaderP.name;
		};
		_proto._enableDepthLayer = function _enableDepthLayer(value) {
			var hasDepthLayer = this.layers.find(function (layerId) {
				return layerId === LAYERID_DEPTH;
			});
			if (hasDepthLayer) {
				var depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
				if (value) {
					depthLayer == null || depthLayer.incrementCounter();
				} else {
					depthLayer == null || depthLayer.decrementCounter();
				}
			} else if (value) {
				return false;
			}
			return true;
		};
		_proto.requestSceneColorMap = function requestSceneColorMap(enabled) {
			this._renderSceneColorMap += enabled ? 1 : -1;
			this._enableDepthLayer(enabled);
			this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice, this.renderSceneColorMap);
		};
		_proto.requestSceneDepthMap = function requestSceneDepthMap(enabled) {
			this._renderSceneDepthMap += enabled ? 1 : -1;
			this._enableDepthLayer(enabled);
			this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice, this.system.app.renderer, this.renderSceneDepthMap);
		};
		_proto.dirtyLayerCompositionCameras = function dirtyLayerCompositionCameras() {
			var layerComp = this.system.app.scene.layers;
			layerComp._dirty = true;
		};
		_proto.screenToWorld = function screenToWorld(screenx, screeny, cameraz, worldCoord) {
			var device = this.system.app.graphicsDevice;
			var _device$clientRect = device.clientRect,
				width = _device$clientRect.width,
				height = _device$clientRect.height;
			return this._camera.screenToWorld(screenx, screeny, cameraz, width, height, worldCoord);
		};
		_proto.worldToScreen = function worldToScreen(worldCoord, screenCoord) {
			var device = this.system.app.graphicsDevice;
			var _device$clientRect2 = device.clientRect,
				width = _device$clientRect2.width,
				height = _device$clientRect2.height;
			return this._camera.worldToScreen(worldCoord, width, height, screenCoord);
		};
		_proto.onAppPrerender = function onAppPrerender() {
			this._camera._viewMatDirty = true;
			this._camera._viewProjMatDirty = true;
		};
		_proto.addCameraToLayers = function addCameraToLayers() {
			var layers = this.layers;
			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.addCamera(this);
				}
			}
		};
		_proto.removeCameraFromLayers = function removeCameraFromLayers() {
			var layers = this.layers;
			for (var i = 0; i < layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(layers[i]);
				if (layer) {
					layer.removeCamera(this);
				}
			}
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addCameraToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.addCamera(this);
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			layer.removeCamera(this);
		};
		_proto.onEnable = function onEnable() {
			var _this$_evtLayersChang;
			var scene = this.system.app.scene;
			var layers = scene.layers;
			this.system.addCamera(this);
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled) {
				this.addCameraToLayers();
			}
			this.postEffects.enable();
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang2;
			var scene = this.system.app.scene;
			var layers = scene.layers;
			this.postEffects.disable();
			this.removeCameraFromLayers();
			(_this$_evtLayersChang2 = this._evtLayersChanged) == null || _this$_evtLayersChang2.off();
			this._evtLayersChanged = null;
			if (layers) {
				var _this$_evtLayerAdded2, _this$_evtLayerRemove2;
				(_this$_evtLayerAdded2 = this._evtLayerAdded) == null || _this$_evtLayerAdded2.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove2 = this._evtLayerRemoved) == null || _this$_evtLayerRemove2.off();
				this._evtLayerRemoved = null;
			}
			this.system.removeCamera(this);
		};
		_proto.onRemove = function onRemove() {
			this.onDisable();
			this.off();
			this.camera.destroy();
		};
		_proto.calculateAspectRatio = function calculateAspectRatio(rt) {
			var device = this.system.app.graphicsDevice;
			var width = rt ? rt.width : device.width;
			var height = rt ? rt.height : device.height;
			return width * this.rect.z / (height * this.rect.w);
		};
		_proto.frameUpdate = function frameUpdate(rt) {
			if (this.aspectRatioMode === ASPECT_AUTO) {
				this.aspectRatio = this.calculateAspectRatio(rt);
			}
		};
		_proto.startXr = function startXr(type, spaceType, options) {
			this.system.app.xr.start(this, type, spaceType, options);
		};
		_proto.endXr = function endXr(callback) {
			if (!this._camera.xr) {
				if (callback) callback(new Error('Camera is not in XR'));
				return;
			}
			this._camera.xr.end(callback);
		};
		_proto.copy = function copy(source) {
			this.aperture = source.aperture;
			this.aspectRatio = source.aspectRatio;
			this.aspectRatioMode = source.aspectRatioMode;
			this.calculateProjection = source.calculateProjection;
			this.calculateTransform = source.calculateTransform;
			this.clearColor = source.clearColor;
			this.clearColorBuffer = source.clearColorBuffer;
			this.clearDepthBuffer = source.clearDepthBuffer;
			this.clearStencilBuffer = source.clearStencilBuffer;
			this.cullFaces = source.cullFaces;
			this.disablePostEffectsLayer = source.disablePostEffectsLayer;
			this.farClip = source.farClip;
			this.flipFaces = source.flipFaces;
			this.fov = source.fov;
			this.frustumCulling = source.frustumCulling;
			this.horizontalFov = source.horizontalFov;
			this.layers = source.layers;
			this.nearClip = source.nearClip;
			this.orthoHeight = source.orthoHeight;
			this.priority = source.priority;
			this.projection = source.projection;
			this.rect = source.rect;
			this.renderTarget = source.renderTarget;
			this.scissorRect = source.scissorRect;
			this.sensitivity = source.sensitivity;
			this.shutter = source.shutter;
		};
		return _createClass(CameraComponent, [{
			key: "renderPasses",
			get: function get() {
				return this._camera.renderPasses;
			},
			set: function set(passes) {
				this._camera.renderPasses = passes || [];
				this.dirtyLayerCompositionCameras();
				this.system.app.scene.updateShaders = true;
			}
		}, {
			key: "shaderParams",
			get: function get() {
				return this._camera.shaderParams;
			}
		}, {
			key: "gammaCorrection",
			get: function get() {
				return this.camera.shaderParams.gammaCorrection;
			},
			set: function set(value) {
				this.camera.shaderParams.gammaCorrection = value;
			}
		}, {
			key: "toneMapping",
			get: function get() {
				return this.camera.shaderParams.toneMapping;
			},
			set: function set(value) {
				this.camera.shaderParams.toneMapping = value;
			}
		}, {
			key: "fog",
			get: function get() {
				return this._camera.fogParams;
			},
			set: function set(value) {
				this._camera.fogParams = value;
			}
		}, {
			key: "aperture",
			get: function get() {
				return this._camera.aperture;
			},
			set: function set(value) {
				this._camera.aperture = value;
			}
		}, {
			key: "aspectRatio",
			get: function get() {
				return this._camera.aspectRatio;
			},
			set: function set(value) {
				this._camera.aspectRatio = value;
			}
		}, {
			key: "aspectRatioMode",
			get: function get() {
				return this._camera.aspectRatioMode;
			},
			set: function set(value) {
				this._camera.aspectRatioMode = value;
			}
		}, {
			key: "calculateProjection",
			get: function get() {
				return this._camera.calculateProjection;
			},
			set: function set(value) {
				this._camera.calculateProjection = value;
			}
		}, {
			key: "calculateTransform",
			get: function get() {
				return this._camera.calculateTransform;
			},
			set: function set(value) {
				this._camera.calculateTransform = value;
			}
		}, {
			key: "camera",
			get: function get() {
				return this._camera;
			}
		}, {
			key: "clearColor",
			get: function get() {
				return this._camera.clearColor;
			},
			set: function set(value) {
				this._camera.clearColor = value;
			}
		}, {
			key: "clearColorBuffer",
			get: function get() {
				return this._camera.clearColorBuffer;
			},
			set: function set(value) {
				this._camera.clearColorBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "clearDepthBuffer",
			get: function get() {
				return this._camera.clearDepthBuffer;
			},
			set: function set(value) {
				this._camera.clearDepthBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "clearStencilBuffer",
			get: function get() {
				return this._camera.clearStencilBuffer;
			},
			set: function set(value) {
				this._camera.clearStencilBuffer = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "cullFaces",
			get: function get() {
				return this._camera.cullFaces;
			},
			set: function set(value) {
				this._camera.cullFaces = value;
			}
		}, {
			key: "disablePostEffectsLayer",
			get: function get() {
				return this._disablePostEffectsLayer;
			},
			set: function set(layer) {
				this._disablePostEffectsLayer = layer;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "farClip",
			get: function get() {
				return this._camera.farClip;
			},
			set: function set(value) {
				this._camera.farClip = value;
			}
		}, {
			key: "flipFaces",
			get: function get() {
				return this._camera.flipFaces;
			},
			set: function set(value) {
				this._camera.flipFaces = value;
			}
		}, {
			key: "fov",
			get: function get() {
				return this._camera.fov;
			},
			set: function set(value) {
				this._camera.fov = value;
			}
		}, {
			key: "frustum",
			get: function get() {
				return this._camera.frustum;
			}
		}, {
			key: "frustumCulling",
			get: function get() {
				return this._camera.frustumCulling;
			},
			set: function set(value) {
				this._camera.frustumCulling = value;
			}
		}, {
			key: "horizontalFov",
			get: function get() {
				return this._camera.horizontalFov;
			},
			set: function set(value) {
				this._camera.horizontalFov = value;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._camera.layers;
			},
			set: function set(newValue) {
				var _this2 = this;
				var oldLayers = this._camera.layers;
				var scene = this.system.app.scene;
				oldLayers.forEach(function (layerId) {
					var layer = scene.layers.getLayerById(layerId);
					layer == null || layer.removeCamera(_this2);
				});
				this._camera.layers = newValue;
				if (this.enabled && this.entity.enabled) {
					newValue.forEach(function (layerId) {
						var layer = scene.layers.getLayerById(layerId);
						layer == null || layer.addCamera(_this2);
					});
				}
			}
		}, {
			key: "layersSet",
			get: function get() {
				return this._camera.layersSet;
			}
		}, {
			key: "jitter",
			get: function get() {
				return this._camera.jitter;
			},
			set: function set(value) {
				this._camera.jitter = value;
			}
		}, {
			key: "nearClip",
			get: function get() {
				return this._camera.nearClip;
			},
			set: function set(value) {
				this._camera.nearClip = value;
			}
		}, {
			key: "orthoHeight",
			get: function get() {
				return this._camera.orthoHeight;
			},
			set: function set(value) {
				this._camera.orthoHeight = value;
			}
		}, {
			key: "postEffects",
			get: function get() {
				return this._postEffects;
			}
		}, {
			key: "postEffectsEnabled",
			get: function get() {
				return this._postEffects.enabled;
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			},
			set: function set(newValue) {
				this._priority = newValue;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "projection",
			get: function get() {
				return this._camera.projection;
			},
			set: function set(value) {
				this._camera.projection = value;
			}
		}, {
			key: "projectionMatrix",
			get: function get() {
				return this._camera.projectionMatrix;
			}
		}, {
			key: "rect",
			get: function get() {
				return this._camera.rect;
			},
			set: function set(value) {
				this._camera.rect = value;
				this.fire('set:rect', this._camera.rect);
			}
		}, {
			key: "renderSceneColorMap",
			get: function get() {
				return this._renderSceneColorMap > 0;
			},
			set: function set(value) {
				if (value && !this._sceneColorMapRequested) {
					this.requestSceneColorMap(true);
					this._sceneColorMapRequested = true;
				} else if (this._sceneColorMapRequested) {
					this.requestSceneColorMap(false);
					this._sceneColorMapRequested = false;
				}
			}
		}, {
			key: "renderSceneDepthMap",
			get: function get() {
				return this._renderSceneDepthMap > 0;
			},
			set: function set(value) {
				if (value && !this._sceneDepthMapRequested) {
					this.requestSceneDepthMap(true);
					this._sceneDepthMapRequested = true;
				} else if (this._sceneDepthMapRequested) {
					this.requestSceneDepthMap(false);
					this._sceneDepthMapRequested = false;
				}
			}
		}, {
			key: "renderTarget",
			get: function get() {
				return this._camera.renderTarget;
			},
			set: function set(value) {
				this._camera.renderTarget = value;
				this.dirtyLayerCompositionCameras();
			}
		}, {
			key: "scissorRect",
			get: function get() {
				return this._camera.scissorRect;
			},
			set: function set(value) {
				this._camera.scissorRect = value;
			}
		}, {
			key: "sensitivity",
			get: function get() {
				return this._camera.sensitivity;
			},
			set: function set(value) {
				this._camera.sensitivity = value;
			}
		}, {
			key: "shutter",
			get: function get() {
				return this._camera.shutter;
			},
			set: function set(value) {
				this._camera.shutter = value;
			}
		}, {
			key: "viewMatrix",
			get: function get() {
				return this._camera.viewMatrix;
			}
		}]);
	}(Component);

	var CameraComponentData = function CameraComponentData() {
		this.enabled = true;
	};

	var _schema$1 = ['enabled'];
	var CameraComponentSystem = function (_ComponentSystem) {
		function CameraComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.cameras = [];
			_this.id = 'camera';
			_this.ComponentType = CameraComponent;
			_this.DataType = CameraComponentData;
			_this.schema = _schema$1;
			_this.on('beforeremove', _this.onBeforeRemove, _this);
			_this.app.on('prerender', _this.onAppPrerender, _this);
			return _this;
		}
		_inheritsLoose(CameraComponentSystem, _ComponentSystem);
		var _proto = CameraComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data, properties) {
			properties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'renderSceneColorMap', 'renderSceneDepthMap', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect', 'aperture', 'shutter', 'sensitivity', 'gammaCorrection', 'toneMapping'];
			for (var i = 0; i < properties.length; i++) {
				var property = properties[i];
				if (data.hasOwnProperty(property)) {
					var value = data[property];
					switch (property) {
						case 'rect':
						case 'scissorRect':
							if (Array.isArray(value)) {
								component[property] = new Vec4(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}
							break;
						case 'clearColor':
							if (Array.isArray(value)) {
								component[property] = new Color(value[0], value[1], value[2], value[3]);
							} else {
								component[property] = value;
							}
							break;
						default:
							component[property] = value;
							break;
					}
				}
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, ['enabled']);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var c = entity.camera;
			return this.addComponent(clone, {
				aspectRatio: c.aspectRatio,
				aspectRatioMode: c.aspectRatioMode,
				calculateProjection: c.calculateProjection,
				calculateTransform: c.calculateTransform,
				clearColor: c.clearColor,
				clearColorBuffer: c.clearColorBuffer,
				clearDepthBuffer: c.clearDepthBuffer,
				clearStencilBuffer: c.clearStencilBuffer,
				renderSceneDepthMap: c.renderSceneDepthMap,
				renderSceneColorMap: c.renderSceneColorMap,
				cullFaces: c.cullFaces,
				enabled: c.enabled,
				farClip: c.farClip,
				flipFaces: c.flipFaces,
				fov: c.fov,
				frustumCulling: c.frustumCulling,
				horizontalFov: c.horizontalFov,
				layers: c.layers,
				renderTarget: c.renderTarget,
				nearClip: c.nearClip,
				orthoHeight: c.orthoHeight,
				projection: c.projection,
				priority: c.priority,
				rect: c.rect,
				scissorRect: c.scissorRect,
				aperture: c.aperture,
				sensitivity: c.sensitivity,
				shutter: c.shutter,
				gammaCorrection: c.gammaCorrection,
				toneMapping: c.toneMapping
			});
		};
		_proto.onBeforeRemove = function onBeforeRemove(entity, component) {
			this.removeCamera(component);
			component.onRemove();
		};
		_proto.onAppPrerender = function onAppPrerender() {
			for (var i = 0, len = this.cameras.length; i < len; i++) {
				this.cameras[i].onAppPrerender();
			}
		};
		_proto.addCamera = function addCamera(camera) {
			this.cameras.push(camera);
			sortPriority(this.cameras);
		};
		_proto.removeCamera = function removeCamera(camera) {
			var index = this.cameras.indexOf(camera);
			if (index >= 0) {
				this.cameras.splice(index, 1);
				sortPriority(this.cameras);
			}
		};
		_proto.destroy = function destroy() {
			this.app.off('prerender', this.onAppPrerender, this);
			_ComponentSystem.prototype.destroy.call(this);
		};
		return CameraComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(CameraComponent.prototype, _schema$1);

	var LightComponentData = function LightComponentData() {
		this.enabled = true;
		this.light = void 0;
		this.type = 'directional';
		this.color = new Color(1, 1, 1);
		this.intensity = 1;
		this.luminance = 0;
		this.shape = LIGHTSHAPE_PUNCTUAL;
		this.affectSpecularity = true;
		this.castShadows = false;
		this.shadowDistance = 40;
		this.shadowIntensity = 1;
		this.shadowResolution = 1024;
		this.shadowBias = 0.05;
		this.numCascades = 1;
		this.cascadeBlend = 0;
		this.bakeNumSamples = 1;
		this.bakeArea = 0;
		this.cascadeDistribution = 0.5;
		this.normalOffsetBias = 0;
		this.range = 10;
		this.innerConeAngle = 40;
		this.outerConeAngle = 45;
		this.falloffMode = LIGHTFALLOFF_LINEAR;
		this.shadowType = SHADOW_PCF3_32F;
		this.vsmBlurSize = 11;
		this.vsmBlurMode = BLUR_GAUSSIAN;
		this.vsmBias = 0.01 * 0.25;
		this.cookieAsset = null;
		this.cookie = null;
		this.cookieIntensity = 1;
		this.cookieFalloff = true;
		this.cookieChannel = 'rgb';
		this.cookieAngle = 0;
		this.cookieScale = null;
		this.cookieOffset = null;
		this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
		this.mask = 1;
		this.affectDynamic = true;
		this.affectLightmapped = false;
		this.bake = false;
		this.bakeDir = true;
		this.isStatic = false;
		this.layers = [LAYERID_WORLD];
		this.penumbraSize = 1;
	};
	var properties = Object.keys(new LightComponentData());

	var LightComponent = function (_Component) {
		function LightComponent() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _Component.call.apply(_Component, [this].concat(args)) || this;
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._cookieAsset = null;
			_this._cookieAssetId = null;
			_this._cookieAssetAdd = false;
			_this._cookieMatrix = null;
			return _this;
		}
		_inheritsLoose(LightComponent, _Component);
		var _proto = LightComponent.prototype;
		_proto._setValue = function _setValue(name, value, setFunc, skipEqualsCheck) {
			var data = this.data;
			var oldValue = data[name];
			if (!skipEqualsCheck && oldValue === value) return;
			data[name] = value;
			if (setFunc) setFunc.call(this, value, oldValue);
		};
		_proto.addLightToLayers = function addLightToLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (layer) {
					layer.addLight(this);
					this.light.addLayer(layer);
				}
			}
		};
		_proto.removeLightFromLayers = function removeLightFromLayers() {
			for (var i = 0; i < this.layers.length; i++) {
				var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
				if (layer) {
					layer.removeLight(this);
					this.light.removeLayer(layer);
				}
			}
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index >= 0 && this.enabled && this.entity.enabled) {
				layer.addLight(this);
				this.light.addLayer(layer);
			}
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index >= 0) {
				layer.removeLight(this);
				this.light.removeLayer(layer);
			}
		};
		_proto.refreshProperties = function refreshProperties() {
			for (var i = 0; i < properties.length; i++) {
				var name = properties[i];
				this[name] = this[name];
			}
			if (this.enabled && this.entity.enabled) {
				this.onEnable();
			}
		};
		_proto.onCookieAssetSet = function onCookieAssetSet() {
			var forceLoad = false;
			if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
				this._cookieAsset.loadFaces = true;
				forceLoad = true;
			}
			if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
			if (this._cookieAsset.resource) {
				this.onCookieAssetLoad();
			}
		};
		_proto.onCookieAssetAdd = function onCookieAssetAdd(asset) {
			if (this._cookieAssetId !== asset.id) return;
			this._cookieAsset = asset;
			if (this.light.enabled) {
				this.onCookieAssetSet();
			}
			this._cookieAsset.on('load', this.onCookieAssetLoad, this);
			this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
		};
		_proto.onCookieAssetLoad = function onCookieAssetLoad() {
			if (!this._cookieAsset || !this._cookieAsset.resource) {
				return;
			}
			this.cookie = this._cookieAsset.resource;
		};
		_proto.onCookieAssetRemove = function onCookieAssetRemove() {
			if (!this._cookieAssetId) {
				return;
			}
			if (this._cookieAssetAdd) {
				this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
				this._cookieAssetAdd = false;
			}
			if (this._cookieAsset) {
				this._cookieAsset.off('load', this.onCookieAssetLoad, this);
				this._cookieAsset.off('remove', this.onCookieAssetRemove, this);
				this._cookieAsset = null;
			}
			this.cookie = null;
		};
		_proto.onEnable = function onEnable() {
			var scene = this.system.app.scene;
			var layers = scene.layers;
			this.light.enabled = true;
			this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
				this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
			}
			if (this.enabled && this.entity.enabled) {
				this.addLightToLayers();
			}
			if (this._cookieAsset && !this.cookie) {
				this.onCookieAssetSet();
			}
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang;
			var scene = this.system.app.scene;
			var layers = scene.layers;
			this.light.enabled = false;
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = null;
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = null;
			}
			this.removeLightFromLayers();
		};
		_proto.onRemove = function onRemove() {
			this.onDisable();
			this.light.destroy();
			this.cookieAsset = null;
		};
		return _createClass(LightComponent, [{
			key: "data",
			get: function get() {
				var record = this.system.store[this.entity.getGuid()];
				return record ? record.data : null;
			}
		}, {
			key: "enabled",
			get: function get() {
				return this.data.enabled;
			},
			set: function set(arg) {
				this._setValue('enabled', arg, function (newValue, oldValue) {
					this.onSetEnabled(null, oldValue, newValue);
				});
			}
		}, {
			key: "light",
			get: function get() {
				return this.data.light;
			},
			set: function set(arg) {
				this._setValue('light', arg);
			}
		}, {
			key: "type",
			get: function get() {
				return this.data.type;
			},
			set: function set(arg) {
				this._setValue('type', arg, function (newValue, oldValue) {
					this.system.changeType(this, oldValue, newValue);
					this.refreshProperties();
				});
			}
		}, {
			key: "color",
			get: function get() {
				return this.data.color;
			},
			set: function set(arg) {
				this._setValue('color', arg, function (newValue, oldValue) {
					this.light.setColor(newValue);
				}, true);
			}
		}, {
			key: "intensity",
			get: function get() {
				return this.data.intensity;
			},
			set: function set(arg) {
				this._setValue('intensity', arg, function (newValue, oldValue) {
					this.light.intensity = newValue;
				});
			}
		}, {
			key: "luminance",
			get: function get() {
				return this.data.luminance;
			},
			set: function set(arg) {
				this._setValue('luminance', arg, function (newValue, oldValue) {
					this.light.luminance = newValue;
				});
			}
		}, {
			key: "shape",
			get: function get() {
				return this.data.shape;
			},
			set: function set(arg) {
				this._setValue('shape', arg, function (newValue, oldValue) {
					this.light.shape = newValue;
				});
			}
		}, {
			key: "affectSpecularity",
			get: function get() {
				return this.data.affectSpecularity;
			},
			set: function set(arg) {
				this._setValue('affectSpecularity', arg, function (newValue, oldValue) {
					this.light.affectSpecularity = newValue;
				});
			}
		}, {
			key: "castShadows",
			get: function get() {
				return this.data.castShadows;
			},
			set: function set(arg) {
				this._setValue('castShadows', arg, function (newValue, oldValue) {
					this.light.castShadows = newValue;
				});
			}
		}, {
			key: "shadowDistance",
			get: function get() {
				return this.data.shadowDistance;
			},
			set: function set(arg) {
				this._setValue('shadowDistance', arg, function (newValue, oldValue) {
					this.light.shadowDistance = newValue;
				});
			}
		}, {
			key: "shadowIntensity",
			get: function get() {
				return this.data.shadowIntensity;
			},
			set: function set(arg) {
				this._setValue('shadowIntensity', arg, function (newValue, oldValue) {
					this.light.shadowIntensity = newValue;
				});
			}
		}, {
			key: "shadowResolution",
			get: function get() {
				return this.data.shadowResolution;
			},
			set: function set(arg) {
				this._setValue('shadowResolution', arg, function (newValue, oldValue) {
					this.light.shadowResolution = newValue;
				});
			}
		}, {
			key: "shadowBias",
			get: function get() {
				return this.data.shadowBias;
			},
			set: function set(arg) {
				this._setValue('shadowBias', arg, function (newValue, oldValue) {
					this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
				});
			}
		}, {
			key: "numCascades",
			get: function get() {
				return this.data.numCascades;
			},
			set: function set(arg) {
				this._setValue('numCascades', arg, function (newValue, oldValue) {
					this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
				});
			}
		}, {
			key: "cascadeBlend",
			get: function get() {
				return this.data.cascadeBlend;
			},
			set: function set(value) {
				this._setValue('cascadeBlend', value, function (newValue, oldValue) {
					this.light.cascadeBlend = math.clamp(newValue, 0, 1);
				});
			}
		}, {
			key: "bakeNumSamples",
			get: function get() {
				return this.data.bakeNumSamples;
			},
			set: function set(arg) {
				this._setValue('bakeNumSamples', arg, function (newValue, oldValue) {
					this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
				});
			}
		}, {
			key: "bakeArea",
			get: function get() {
				return this.data.bakeArea;
			},
			set: function set(arg) {
				this._setValue('bakeArea', arg, function (newValue, oldValue) {
					this.light.bakeArea = math.clamp(newValue, 0, 180);
				});
			}
		}, {
			key: "cascadeDistribution",
			get: function get() {
				return this.data.cascadeDistribution;
			},
			set: function set(arg) {
				this._setValue('cascadeDistribution', arg, function (newValue, oldValue) {
					this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
				});
			}
		}, {
			key: "normalOffsetBias",
			get: function get() {
				return this.data.normalOffsetBias;
			},
			set: function set(arg) {
				this._setValue('normalOffsetBias', arg, function (newValue, oldValue) {
					this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
				});
			}
		}, {
			key: "range",
			get: function get() {
				return this.data.range;
			},
			set: function set(arg) {
				this._setValue('range', arg, function (newValue, oldValue) {
					this.light.attenuationEnd = newValue;
				});
			}
		}, {
			key: "innerConeAngle",
			get: function get() {
				return this.data.innerConeAngle;
			},
			set: function set(arg) {
				this._setValue('innerConeAngle', arg, function (newValue, oldValue) {
					this.light.innerConeAngle = newValue;
				});
			}
		}, {
			key: "outerConeAngle",
			get: function get() {
				return this.data.outerConeAngle;
			},
			set: function set(arg) {
				this._setValue('outerConeAngle', arg, function (newValue, oldValue) {
					this.light.outerConeAngle = newValue;
				});
			}
		}, {
			key: "falloffMode",
			get: function get() {
				return this.data.falloffMode;
			},
			set: function set(arg) {
				this._setValue('falloffMode', arg, function (newValue, oldValue) {
					this.light.falloffMode = newValue;
				});
			}
		}, {
			key: "shadowType",
			get: function get() {
				return this.data.shadowType;
			},
			set: function set(arg) {
				this._setValue('shadowType', arg, function (newValue, oldValue) {
					this.light.shadowType = newValue;
				});
			}
		}, {
			key: "vsmBlurSize",
			get: function get() {
				return this.data.vsmBlurSize;
			},
			set: function set(arg) {
				this._setValue('vsmBlurSize', arg, function (newValue, oldValue) {
					this.light.vsmBlurSize = newValue;
				});
			}
		}, {
			key: "vsmBlurMode",
			get: function get() {
				return this.data.vsmBlurMode;
			},
			set: function set(arg) {
				this._setValue('vsmBlurMode', arg, function (newValue, oldValue) {
					this.light.vsmBlurMode = newValue;
				});
			}
		}, {
			key: "vsmBias",
			get: function get() {
				return this.data.vsmBias;
			},
			set: function set(arg) {
				this._setValue('vsmBias', arg, function (newValue, oldValue) {
					this.light.vsmBias = math.clamp(newValue, 0, 1);
				});
			}
		}, {
			key: "cookieAsset",
			get: function get() {
				return this.data.cookieAsset;
			},
			set: function set(arg) {
				this._setValue('cookieAsset', arg, function (newValue, oldValue) {
					if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) {
						return;
					}
					this.onCookieAssetRemove();
					this._cookieAssetId = null;
					if (newValue instanceof Asset) {
						this.data.cookieAsset = newValue.id;
						this._cookieAssetId = newValue.id;
						this.onCookieAssetAdd(newValue);
					} else if (typeof newValue === 'number') {
						this._cookieAssetId = newValue;
						var asset = this.system.app.assets.get(newValue);
						if (asset) {
							this.onCookieAssetAdd(asset);
						} else {
							this._cookieAssetAdd = true;
							this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
						}
					}
				});
			}
		}, {
			key: "cookie",
			get: function get() {
				return this.data.cookie;
			},
			set: function set(arg) {
				this._setValue('cookie', arg, function (newValue, oldValue) {
					this.light.cookie = newValue;
				});
			}
		}, {
			key: "cookieIntensity",
			get: function get() {
				return this.data.cookieIntensity;
			},
			set: function set(arg) {
				this._setValue('cookieIntensity', arg, function (newValue, oldValue) {
					this.light.cookieIntensity = math.clamp(newValue, 0, 1);
				});
			}
		}, {
			key: "cookieFalloff",
			get: function get() {
				return this.data.cookieFalloff;
			},
			set: function set(arg) {
				this._setValue('cookieFalloff', arg, function (newValue, oldValue) {
					this.light.cookieFalloff = newValue;
				});
			}
		}, {
			key: "cookieChannel",
			get: function get() {
				return this.data.cookieChannel;
			},
			set: function set(arg) {
				this._setValue('cookieChannel', arg, function (newValue, oldValue) {
					this.light.cookieChannel = newValue;
				});
			}
		}, {
			key: "cookieAngle",
			get: function get() {
				return this.data.cookieAngle;
			},
			set: function set(arg) {
				this._setValue('cookieAngle', arg, function (newValue, oldValue) {
					if (newValue !== 0 || this.cookieScale !== null) {
						if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
						var scx = 1;
						var scy = 1;
						if (this.cookieScale) {
							scx = this.cookieScale.x;
							scy = this.cookieScale.y;
						}
						var c = Math.cos(newValue * math.DEG_TO_RAD);
						var s = Math.sin(newValue * math.DEG_TO_RAD);
						this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
						this.light.cookieTransform = this._cookieMatrix;
					} else {
						this.light.cookieTransform = null;
					}
				});
			}
		}, {
			key: "cookieScale",
			get: function get() {
				return this.data.cookieScale;
			},
			set: function set(arg) {
				this._setValue('cookieScale', arg, function (newValue, oldValue) {
					if (newValue !== null || this.cookieAngle !== 0) {
						if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
						var scx = newValue.x;
						var scy = newValue.y;
						var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
						var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);
						this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
						this.light.cookieTransform = this._cookieMatrix;
					} else {
						this.light.cookieTransform = null;
					}
				}, true);
			}
		}, {
			key: "cookieOffset",
			get: function get() {
				return this.data.cookieOffset;
			},
			set: function set(arg) {
				this._setValue('cookieOffset', arg, function (newValue, oldValue) {
					this.light.cookieOffset = newValue;
				}, true);
			}
		}, {
			key: "shadowUpdateMode",
			get: function get() {
				return this.data.shadowUpdateMode;
			},
			set: function set(arg) {
				this._setValue('shadowUpdateMode', arg, function (newValue, oldValue) {
					this.light.shadowUpdateMode = newValue;
				}, true);
			}
		}, {
			key: "mask",
			get: function get() {
				return this.data.mask;
			},
			set: function set(arg) {
				this._setValue('mask', arg, function (newValue, oldValue) {
					this.light.mask = newValue;
				});
			}
		}, {
			key: "affectDynamic",
			get: function get() {
				return this.data.affectDynamic;
			},
			set: function set(arg) {
				this._setValue('affectDynamic', arg, function (newValue, oldValue) {
					if (newValue) {
						this.light.mask |= MASK_AFFECT_DYNAMIC;
					} else {
						this.light.mask &= ~MASK_AFFECT_DYNAMIC;
					}
					this.light.layersDirty();
				});
			}
		}, {
			key: "affectLightmapped",
			get: function get() {
				return this.data.affectLightmapped;
			},
			set: function set(arg) {
				this._setValue('affectLightmapped', arg, function (newValue, oldValue) {
					if (newValue) {
						this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
						if (this.bake) this.light.mask &= ~MASK_BAKE;
					} else {
						this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
						if (this.bake) this.light.mask |= MASK_BAKE;
					}
				});
			}
		}, {
			key: "bake",
			get: function get() {
				return this.data.bake;
			},
			set: function set(arg) {
				this._setValue('bake', arg, function (newValue, oldValue) {
					if (newValue) {
						this.light.mask |= MASK_BAKE;
						if (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;
					} else {
						this.light.mask &= ~MASK_BAKE;
						if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
					}
					this.light.layersDirty();
				});
			}
		}, {
			key: "bakeDir",
			get: function get() {
				return this.data.bakeDir;
			},
			set: function set(arg) {
				this._setValue('bakeDir', arg, function (newValue, oldValue) {
					this.light.bakeDir = newValue;
				});
			}
		}, {
			key: "isStatic",
			get: function get() {
				return this.data.isStatic;
			},
			set: function set(arg) {
				this._setValue('isStatic', arg, function (newValue, oldValue) {
					this.light.isStatic = newValue;
				});
			}
		}, {
			key: "layers",
			get: function get() {
				return this.data.layers;
			},
			set: function set(arg) {
				this._setValue('layers', arg, function (newValue, oldValue) {
					for (var i = 0; i < oldValue.length; i++) {
						var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
						if (!layer) continue;
						layer.removeLight(this);
						this.light.removeLayer(layer);
					}
					for (var _i = 0; _i < newValue.length; _i++) {
						var _layer = this.system.app.scene.layers.getLayerById(newValue[_i]);
						if (!_layer) continue;
						if (this.enabled && this.entity.enabled) {
							_layer.addLight(this);
							this.light.addLayer(_layer);
						}
					}
				});
			}
		}, {
			key: "shadowUpdateOverrides",
			get: function get() {
				return this.light.shadowUpdateOverrides;
			},
			set: function set(values) {
				this.light.shadowUpdateOverrides = values;
			}
		}, {
			key: "penumbraSize",
			get: function get() {
				return this.light.penumbraSize;
			},
			set: function set(value) {
				this.light.penumbraSize = value;
			}
		}]);
	}(Component);

	var LightComponentSystem = function (_ComponentSystem) {
		function LightComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'light';
			_this.ComponentType = LightComponent;
			_this.DataType = LightComponentData;
			_this.on('beforeremove', _this._onRemoveComponent, _this);
			return _this;
		}
		_inheritsLoose(LightComponentSystem, _ComponentSystem);
		var _proto = LightComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data) {
			var data = _extends({}, _data);
			if (!data.type) {
				data.type = component.data.type;
			}
			component.data.type = data.type;
			if (data.layers && Array.isArray(data.layers)) {
				data.layers = data.layers.slice(0);
			}
			if (data.color && Array.isArray(data.color)) {
				data.color = new Color(data.color[0], data.color[1], data.color[2]);
			}
			if (data.cookieOffset && data.cookieOffset instanceof Array) {
				data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
			}
			if (data.cookieScale && data.cookieScale instanceof Array) {
				data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);
			}
			if (data.enable) {
				console.warn('WARNING: enable: Property is deprecated. Set enabled property instead.');
				data.enabled = data.enable;
			}
			if (!data.shape) {
				data.shape = LIGHTSHAPE_PUNCTUAL;
			}
			var light = new Light(this.app.graphicsDevice, this.app.scene.clusteredLightingEnabled);
			light.type = lightTypes[data.type];
			light._node = component.entity;
			component.data.light = light;
			_ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
		};
		_proto._onRemoveComponent = function _onRemoveComponent(entity, component) {
			component.onRemove();
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var light = entity.light;
			var data = [];
			var name;
			for (var i = 0; i < properties.length; i++) {
				name = properties[i];
				if (name === 'light') {
					continue;
				}
				if (light[name] && light[name].clone) {
					data[name] = light[name].clone();
				} else {
					data[name] = light[name];
				}
			}
			return this.addComponent(clone, data);
		};
		_proto.changeType = function changeType(component, oldValue, newValue) {
			if (oldValue !== newValue) {
				component.light.type = lightTypes[newValue];
			}
		};
		return LightComponentSystem;
	}(ComponentSystem);

	var components = ['x', 'y', 'z', 'w'];
	var vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];
	function rawToValue(app, args, value, old) {
		switch (args.type) {
			case 'boolean':
				return !!value;
			case 'number':
				if (typeof value === 'number') {
					return value;
				} else if (typeof value === 'string') {
					var v = parseInt(value, 10);
					if (isNaN(v)) return null;
					return v;
				} else if (typeof value === 'boolean') {
					return 0 + value;
				}
				return null;
			case 'json':
				{
					var result = {};
					if (Array.isArray(args.schema)) {
						if (!value || typeof value !== 'object') {
							value = {};
						}
						for (var i = 0; i < args.schema.length; i++) {
							var field = args.schema[i];
							if (!field.name) continue;
							if (field.array) {
								result[field.name] = [];
								var arr = Array.isArray(value[field.name]) ? value[field.name] : [];
								for (var j = 0; j < arr.length; j++) {
									result[field.name].push(rawToValue(app, field, arr[j]));
								}
							} else {
								var val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
								result[field.name] = rawToValue(app, field, val);
							}
						}
					}
					return result;
				}
			case 'asset':
				if (value instanceof Asset) {
					return value;
				} else if (typeof value === 'number') {
					return app.assets.get(value) || null;
				} else if (typeof value === 'string') {
					return app.assets.get(parseInt(value, 10)) || null;
				}
				return null;
			case 'entity':
				if (value instanceof GraphNode) {
					return value;
				} else if (typeof value === 'string') {
					return app.getEntityFromIndex(value);
				}
				return null;
			case 'rgb':
			case 'rgba':
				if (value instanceof Color) {
					if (old instanceof Color) {
						old.copy(value);
						return old;
					}
					return value.clone();
				} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
					for (var _i = 0; _i < value.length; _i++) {
						if (typeof value[_i] !== 'number') {
							return null;
						}
					}
					if (!old) old = new Color();
					old.r = value[0];
					old.g = value[1];
					old.b = value[2];
					old.a = value.length === 3 ? 1 : value[3];
					return old;
				} else if (typeof value === 'string' && /#(?:[0-9a-f]{2}){3,4}/i.test(value)) {
					if (!old) {
						old = new Color();
					}
					old.fromString(value);
					return old;
				}
				return null;
			case 'vec2':
			case 'vec3':
			case 'vec4':
				{
					var len = parseInt(args.type.slice(3), 10);
					var vecType = vecLookup[len];
					if (value instanceof vecType) {
						if (old instanceof vecType) {
							old.copy(value);
							return old;
						}
						return value.clone();
					} else if (value instanceof Array && value.length === len) {
						for (var _i2 = 0; _i2 < value.length; _i2++) {
							if (typeof value[_i2] !== 'number') {
								return null;
							}
						}
						if (!old) old = new vecType();
						for (var _i3 = 0; _i3 < len; _i3++) {
							old[components[_i3]] = value[_i3];
						}
						return old;
					}
					return null;
				}
			case 'curve':
				if (value) {
					var curve;
					if (value instanceof Curve || value instanceof CurveSet) {
						curve = value.clone();
					} else {
						var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
						curve = new CurveType(value.keys);
						curve.type = value.type;
					}
					return curve;
				}
				break;
		}
		return value;
	}
	function attributeToValue(app, schema, value, current) {
		if (schema.array) {
			return value.map(function (item, index) {
				return rawToValue(app, schema, item, current ? current[index] : null);
			});
		}
		return rawToValue(app, schema, value, current);
	}
	function assignAttributesToScript(app, attributeSchemaMap, data, script) {
		if (!data) return;
		for (var attributeName in attributeSchemaMap) {
			var attributeSchema = attributeSchemaMap[attributeName];
			var dataToAssign = data[attributeName];
			if (dataToAssign === undefined) continue;
			script[attributeName] = attributeToValue(app, attributeSchema, dataToAssign, script[attributeName]);
		}
	}
	var ScriptAttributes = function () {
		function ScriptAttributes(scriptType) {
			this.scriptType = scriptType;
			this.index = {};
		}
		var _proto = ScriptAttributes.prototype;
		_proto.add = function add(name, args) {
			if (this.index[name]) {
				return;
			} else if (ScriptAttributes.reservedNames.has(name)) {
				return;
			}
			this.index[name] = args;
			Object.defineProperty(this.scriptType.prototype, name, {
				get: function get() {
					return this.__attributes[name];
				},
				set: function set(raw) {
					var evt = 'attr';
					var evtName = "attr:" + name;
					var old = this.__attributes[name];
					var oldCopy = old;
					if (old && args.type !== 'json' && args.type !== 'entity' && old.clone) {
						if (this.hasEvent(evt) || this.hasEvent(evtName)) {
							oldCopy = old.clone();
						}
					}
					if (args.array) {
						this.__attributes[name] = [];
						if (raw) {
							for (var i = 0, len = raw.length; i < len; i++) {
								this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
							}
						}
					} else {
						this.__attributes[name] = rawToValue(this.app, args, raw, old);
					}
					this.fire(evt, name, this.__attributes[name], oldCopy);
					this.fire(evtName, this.__attributes[name], oldCopy);
				}
			});
		};
		_proto.remove = function remove(name) {
			if (!this.index[name]) {
				return false;
			}
			delete this.index[name];
			delete this.scriptType.prototype[name];
			return true;
		};
		_proto.has = function has(name) {
			return !!this.index[name];
		};
		_proto.get = function get(name) {
			return this.index[name] || null;
		};
		return ScriptAttributes;
	}();
	ScriptAttributes.assignAttributesToScript = assignAttributesToScript;
	ScriptAttributes.attributeToValue = attributeToValue;
	ScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', '_callbackActive', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);

	var SCRIPT_INITIALIZE = 'initialize';
	var SCRIPT_POST_INITIALIZE = 'postInitialize';
	var SCRIPT_UPDATE = 'update';
	var SCRIPT_POST_UPDATE = 'postUpdate';
	var SCRIPT_SWAP = 'swap';

	var Script = function (_EventHandler) {
		function Script(args) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.app = void 0;
			_this.entity = void 0;
			_this._enabled = void 0;
			_this._enabledOld = void 0;
			_this._initialized = void 0;
			_this._postInitialized = void 0;
			_this.__destroyed = void 0;
			_this.__scriptType = void 0;
			_this.__executionOrder = void 0;
			_this.initScript(args);
			return _this;
		}
		_inheritsLoose(Script, _EventHandler);
		var _proto = Script.prototype;
		_proto.initScript = function initScript(args) {
			var script = this.constructor;
			this.app = args.app;
			this.entity = args.entity;
			this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
			this._enabledOld = this.enabled;
			this.__destroyed = false;
			this.__scriptType = script;
			this.__executionOrder = -1;
		};
		return _createClass(Script, [{
			key: "enabled",
			get: function get() {
				return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
			},
			set: function set(value) {
				this._enabled = !!value;
				if (this.enabled === this._enabledOld) return;
				this._enabledOld = this.enabled;
				this.fire(this.enabled ? 'enable' : 'disable');
				this.fire('state', this.enabled);
				if (!this._initialized && this.enabled) {
					this._initialized = true;
					this.fire('preInitialize');
					if (this.initialize) {
						this.entity.script._scriptMethod(this, SCRIPT_INITIALIZE);
					}
				}
				if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
					this._postInitialized = true;
					if (this.postInitialize) {
						this.entity.script._scriptMethod(this, SCRIPT_POST_INITIALIZE);
					}
				}
			}
		}], [{
			key: "scriptName",
			get: function get() {
				return this.__name;
			}
		}]);
	}(EventHandler);
	Script.EVENT_ENABLE = 'enable';
	Script.EVENT_DISABLE = 'disable';
	Script.EVENT_STATE = 'state';
	Script.EVENT_DESTROY = 'destroy';
	Script.EVENT_ATTR = 'attr';
	Script.EVENT_ERROR = 'error';
	Script.__name = null;
	Script.__getScriptName = getScriptName;
	var funcNameRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s\/]*)\s*/;
	function getScriptName(constructorFn) {
		if (typeof constructorFn !== 'function') return undefined;
		if ('name' in Function.prototype) return constructorFn.name;
		if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
		var match = ("" + constructorFn).match(funcNameRegex);
		return match ? match[1] : undefined;
	}

	var ScriptType = function (_Script) {
		function ScriptType(args) {
			var _this;
			_this = _Script.call(this, args) || this;
			_this.__attributes = void 0;
			_this.__attributesRaw = void 0;
			_this.initScriptType(args);
			return _this;
		}
		_inheritsLoose(ScriptType, _Script);
		var _proto = ScriptType.prototype;
		_proto.initScript = function initScript(args) {
			Script.prototype.initScript.call(this, args);
			this.__attributes = {};
			this.__attributesRaw = args.attributes || {};
		};
		_proto.initScriptType = function initScriptType(args) {
			this.initScript(args);
		};
		_proto.__initializeAttributes = function __initializeAttributes(force) {
			if (!force && !this.__attributesRaw) {
				return;
			}
			for (var key in this.__scriptType.attributes.index) {
				if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
					this[key] = this.__attributesRaw[key];
				} else if (!this.__attributes.hasOwnProperty(key)) {
					if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
						this[key] = this.__scriptType.attributes.index[key].default;
					} else {
						this[key] = null;
					}
				}
			}
			this.__attributesRaw = null;
		};
		ScriptType.extend = function extend(methods) {
			for (var key in methods) {
				if (!methods.hasOwnProperty(key)) {
					continue;
				}
				this.prototype[key] = methods[key];
			}
		};
		return _createClass(ScriptType, null, [{
			key: "attributes",
			get: function get() {
				if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
				return this.__attributes;
			}
		}]);
	}(Script);

	var toLowerCamelCase$1 = function toLowerCamelCase(str) {
		return str[0].toLowerCase() + str.substring(1);
	};
	var ScriptComponent = function (_Component) {
		function ScriptComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._attributeDataMap = new Map();
			_this._scripts = [];
			_this._updateList = new SortedLoopArray({
				sortBy: '__executionOrder'
			});
			_this._postUpdateList = new SortedLoopArray({
				sortBy: '__executionOrder'
			});
			_this._scriptsIndex = {};
			_this._destroyedScripts = [];
			_this._destroyed = false;
			_this._scriptsData = null;
			_this._oldState = true;
			_this._enabled = true;
			_this._beingEnabled = false;
			_this._isLoopingThroughScripts = false;
			_this._executionOrder = -1;
			_this.on('set_enabled', _this._onSetEnabled, _this);
			return _this;
		}
		_inheritsLoose(ScriptComponent, _Component);
		var _proto = ScriptComponent.prototype;
		_proto.onEnable = function onEnable() {
			this._beingEnabled = true;
			this._checkState();
			if (!this.entity._beingEnabled) {
				this.onPostStateChange();
			}
			this._beingEnabled = false;
		};
		_proto.onDisable = function onDisable() {
			this._checkState();
		};
		_proto.onPostStateChange = function onPostStateChange() {
			var wasLooping = this._beginLooping();
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				var script = this.scripts[i];
				if (script._initialized && !script._postInitialized && script.enabled) {
					script._postInitialized = true;
					if (script.postInitialize) {
						this._scriptMethod(script, SCRIPT_POST_INITIALIZE);
					}
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._beginLooping = function _beginLooping() {
			var looping = this._isLoopingThroughScripts;
			this._isLoopingThroughScripts = true;
			return looping;
		};
		_proto._endLooping = function _endLooping(wasLoopingBefore) {
			this._isLoopingThroughScripts = wasLoopingBefore;
			if (!this._isLoopingThroughScripts) {
				this._removeDestroyedScripts();
			}
		};
		_proto._onSetEnabled = function _onSetEnabled(prop, old, value) {
			this._beingEnabled = true;
			this._checkState();
			this._beingEnabled = false;
		};
		_proto._checkState = function _checkState() {
			var _this2 = this;
			var state = this.enabled && this.entity.enabled;
			if (state === this._oldState) {
				return;
			}
			this._oldState = state;
			this.fire(state ? 'enable' : 'disable');
			this.fire('state', state);
			if (state) {
				this.system._addComponentToEnabled(this);
			} else {
				this.system._removeComponentFromEnabled(this);
			}
			var wasLooping = this._beginLooping();
			var _loop = function _loop() {
				var script = _this2.scripts[i];
				script.once('preInitialize', function () {
					_this2.initializeAttributes(script);
				});
				script.enabled = script._enabled;
			};
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				_loop();
			}
			this._endLooping(wasLooping);
		};
		_proto._onBeforeRemove = function _onBeforeRemove() {
			this.fire('remove');
			var wasLooping = this._beginLooping();
			for (var i = 0; i < this.scripts.length; i++) {
				var script = this.scripts[i];
				if (!script) continue;
				this.destroy(script.__scriptType.__name);
			}
			this._endLooping(wasLooping);
		};
		_proto._removeDestroyedScripts = function _removeDestroyedScripts() {
			var len = this._destroyedScripts.length;
			if (!len) return;
			for (var i = 0; i < len; i++) {
				var script = this._destroyedScripts[i];
				this._removeScriptInstance(script);
			}
			this._destroyedScripts.length = 0;
			this._resetExecutionOrder(0, this._scripts.length);
		};
		_proto._onInitializeAttributes = function _onInitializeAttributes() {
			for (var i = 0, len = this.scripts.length; i < len; i++) {
				var script = this.scripts[i];
				this.initializeAttributes(script);
			}
		};
		_proto.initializeAttributes = function initializeAttributes(script) {
			if (script instanceof ScriptType) {
				script.__initializeAttributes();
			} else {
				var _this$system$app$scri;
				var name = script.__scriptType.__name;
				var data = this._attributeDataMap.get(name);
				if (!data) {
					return;
				}
				var schema = (_this$system$app$scri = this.system.app.scripts) == null ? void 0 : _this$system$app$scri.getSchema(name);
				assignAttributesToScript(this.system.app, schema.attributes, data, script);
			}
		};
		_proto._scriptMethod = function _scriptMethod(script, method, arg) {
			script[method](arg);
		};
		_proto._onInitialize = function _onInitialize() {
			var scripts = this._scripts;
			var wasLooping = this._beginLooping();
			for (var i = 0, len = scripts.length; i < len; i++) {
				var script = scripts[i];
				if (!script._initialized && script.enabled) {
					script._initialized = true;
					if (script.initialize) {
						this._scriptMethod(script, SCRIPT_INITIALIZE);
					}
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._onPostInitialize = function _onPostInitialize() {
			this.onPostStateChange();
		};
		_proto._onUpdate = function _onUpdate(dt) {
			var list = this._updateList;
			if (!list.length) return;
			var wasLooping = this._beginLooping();
			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				var script = list.items[list.loopIndex];
				if (script.enabled) {
					this._scriptMethod(script, SCRIPT_UPDATE, dt);
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._onPostUpdate = function _onPostUpdate(dt) {
			var list = this._postUpdateList;
			if (!list.length) return;
			var wasLooping = this._beginLooping();
			for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
				var script = list.items[list.loopIndex];
				if (script.enabled) {
					this._scriptMethod(script, SCRIPT_POST_UPDATE, dt);
				}
			}
			this._endLooping(wasLooping);
		};
		_proto._insertScriptInstance = function _insertScriptInstance(scriptInstance, index, scriptsLength) {
			if (index === -1) {
				this._scripts.push(scriptInstance);
				scriptInstance.__executionOrder = scriptsLength;
				if (scriptInstance.update) {
					this._updateList.append(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
					this._postUpdateList.append(scriptInstance);
				}
			} else {
				this._scripts.splice(index, 0, scriptInstance);
				scriptInstance.__executionOrder = index;
				this._resetExecutionOrder(index + 1, scriptsLength + 1);
				if (scriptInstance.update) {
					this._updateList.insert(scriptInstance);
				}
				if (scriptInstance.postUpdate) {
					this._postUpdateList.insert(scriptInstance);
				}
			}
		};
		_proto._removeScriptInstance = function _removeScriptInstance(scriptInstance) {
			var idx = this._scripts.indexOf(scriptInstance);
			if (idx === -1) return idx;
			this._scripts.splice(idx, 1);
			if (scriptInstance.update) {
				this._updateList.remove(scriptInstance);
			}
			if (scriptInstance.postUpdate) {
				this._postUpdateList.remove(scriptInstance);
			}
			return idx;
		};
		_proto._resetExecutionOrder = function _resetExecutionOrder(startIndex, scriptsLength) {
			for (var i = startIndex; i < scriptsLength; i++) {
				this._scripts[i].__executionOrder = i;
			}
		};
		_proto._resolveEntityScriptAttribute = function _resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
			if (attribute.array) {
				var len = oldValue.length;
				if (!len) {
					return;
				}
				var newGuidArray = oldValue.slice();
				for (var i = 0; i < len; i++) {
					var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
					if (duplicatedIdsMap[guid]) {
						newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
					}
				}
				newAttributes[attributeName] = newGuidArray;
			} else {
				if (oldValue instanceof Entity) {
					oldValue = oldValue.getGuid();
				} else if (typeof oldValue !== 'string') {
					return;
				}
				if (duplicatedIdsMap[oldValue]) {
					newAttributes[attributeName] = duplicatedIdsMap[oldValue];
				}
			}
		};
		_proto.has = function has(nameOrType) {
			if (typeof nameOrType === 'string') {
				return !!this._scriptsIndex[nameOrType];
			}
			if (!nameOrType) return false;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType;
		};
		_proto.get = function get(nameOrType) {
			if (typeof nameOrType === 'string') {
				var data = this._scriptsIndex[nameOrType];
				return data ? data.instance : null;
			}
			if (!nameOrType) return null;
			var scriptType = nameOrType;
			var scriptName = scriptType.__name;
			var scriptData = this._scriptsIndex[scriptName];
			var scriptInstance = scriptData && scriptData.instance;
			return scriptInstance instanceof scriptType ? scriptInstance : null;
		};
		_proto.create = function create(nameOrType, args) {
			if (args === void 0) {
				args = {};
			}
			var self = this;
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				var _scriptType$__name;
				scriptName = (_scriptType$__name = scriptType.__name) != null ? _scriptType$__name : toLowerCamelCase$1(getScriptName(scriptType));
			}
			if (scriptType) {
				if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
					var scriptInstance = new scriptType({
						app: this.system.app,
						entity: this.entity,
						enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
						attributes: args.attributes || {}
					});
					if (args.properties && typeof args.properties === 'object') {
						Object.assign(scriptInstance, args.properties);
					}
					if (!(scriptInstance instanceof ScriptType)) {
						this._attributeDataMap.set(scriptName, args.attributes);
					}
					var len = this._scripts.length;
					var ind = -1;
					if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) {
						ind = args.ind;
					}
					this._insertScriptInstance(scriptInstance, ind, len);
					this._scriptsIndex[scriptName] = {
						instance: scriptInstance,
						onSwap: function onSwap() {
							self.swap(scriptName);
						}
					};
					this[scriptName] = scriptInstance;
					if (!args.preloading) {
						this.initializeAttributes(scriptInstance);
					}
					this.fire('create', scriptName, scriptInstance);
					this.fire("create:" + scriptName, scriptInstance);
					this.system.app.scripts.on("swap:" + scriptName, this._scriptsIndex[scriptName].onSwap);
					if (!args.preloading) {
						if (scriptInstance.enabled && !scriptInstance._initialized) {
							scriptInstance._initialized = true;
							if (scriptInstance.initialize) {
								this._scriptMethod(scriptInstance, SCRIPT_INITIALIZE);
							}
						}
						if (scriptInstance.enabled && !scriptInstance._postInitialized) {
							scriptInstance._postInitialized = true;
							if (scriptInstance.postInitialize) {
								this._scriptMethod(scriptInstance, SCRIPT_POST_INITIALIZE);
							}
						}
					}
					return scriptInstance;
				}
			} else {
				this._scriptsIndex[scriptName] = {
					awaiting: true,
					ind: this._scripts.length
				};
			}
			return null;
		};
		_proto.destroy = function destroy(nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			var scriptData = this._scriptsIndex[scriptName];
			delete this._scriptsIndex[scriptName];
			if (!scriptData) return false;
			this._attributeDataMap.delete(scriptName);
			var scriptInstance = scriptData.instance;
			if (scriptInstance && !scriptInstance._destroyed) {
				scriptInstance.enabled = false;
				scriptInstance._destroyed = true;
				if (!this._isLoopingThroughScripts) {
					var ind = this._removeScriptInstance(scriptInstance);
					if (ind >= 0) {
						this._resetExecutionOrder(ind, this._scripts.length);
					}
				} else {
					this._destroyedScripts.push(scriptInstance);
				}
			}
			this.system.app.scripts.off("swap:" + scriptName, scriptData.onSwap);
			delete this[scriptName];
			this.fire('destroy', scriptName, scriptInstance || null);
			this.fire("destroy:" + scriptName, scriptInstance || null);
			if (scriptInstance) {
				scriptInstance.fire('destroy');
			}
			return true;
		};
		_proto.swap = function swap(nameOrType) {
			var scriptName = nameOrType;
			var scriptType = nameOrType;
			if (typeof scriptType === 'string') {
				scriptType = this.system.app.scripts.get(scriptType);
			} else if (scriptType) {
				scriptName = scriptType.__name;
			}
			var old = this._scriptsIndex[scriptName];
			if (!old || !old.instance) return false;
			var scriptInstanceOld = old.instance;
			var ind = this._scripts.indexOf(scriptInstanceOld);
			var scriptInstance = new scriptType({
				app: this.system.app,
				entity: this.entity,
				enabled: scriptInstanceOld.enabled,
				attributes: scriptInstanceOld.__attributes
			});
			if (!scriptInstance.swap) {
				return false;
			}
			this.initializeAttributes(scriptInstance);
			this._scripts[ind] = scriptInstance;
			this._scriptsIndex[scriptName].instance = scriptInstance;
			this[scriptName] = scriptInstance;
			scriptInstance.__executionOrder = ind;
			if (scriptInstanceOld.update) {
				this._updateList.remove(scriptInstanceOld);
			}
			if (scriptInstanceOld.postUpdate) {
				this._postUpdateList.remove(scriptInstanceOld);
			}
			if (scriptInstance.update) {
				this._updateList.insert(scriptInstance);
			}
			if (scriptInstance.postUpdate) {
				this._postUpdateList.insert(scriptInstance);
			}
			this._scriptMethod(scriptInstance, SCRIPT_SWAP, scriptInstanceOld);
			this.fire('swap', scriptName, scriptInstance);
			this.fire("swap:" + scriptName, scriptInstance);
			return true;
		};
		_proto.resolveDuplicatedEntityReferenceProperties = function resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
			var newScriptComponent = this.entity.script;
			for (var scriptName in oldScriptComponent._scriptsIndex) {
				var scriptType = this.system.app.scripts.get(scriptName);
				if (!scriptType) {
					continue;
				}
				var script = oldScriptComponent._scriptsIndex[scriptName];
				if (!script || !script.instance) {
					continue;
				}
				var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
				var newAttributes = newScriptComponent[scriptName].__attributes;
				if (!newAttributesRaw && !newAttributes) {
					continue;
				}
				var useGuid = !!newAttributesRaw;
				var oldAttributes = script.instance.__attributes;
				for (var attributeName in oldAttributes) {
					if (!oldAttributes[attributeName]) {
						continue;
					}
					var attribute = scriptType.attributes.get(attributeName);
					if (!attribute) {
						continue;
					}
					if (attribute.type === 'entity') {
						this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
					} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
						var oldValue = oldAttributes[attributeName];
						var newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];
						for (var i = 0; i < attribute.schema.length; i++) {
							var field = attribute.schema[i];
							if (field.type !== 'entity') {
								continue;
							}
							if (attribute.array) {
								for (var j = 0; j < oldValue.length; j++) {
									this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
								}
							} else {
								this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
							}
						}
					}
				}
			}
		};
		_proto.move = function move(nameOrType, ind) {
			var len = this._scripts.length;
			if (ind >= len || ind < 0) {
				return false;
			}
			var scriptType = nameOrType;
			var scriptName = nameOrType;
			if (typeof scriptName !== 'string') {
				scriptName = nameOrType.__name;
			} else {
				scriptType = null;
			}
			var scriptData = this._scriptsIndex[scriptName];
			if (!scriptData || !scriptData.instance) {
				return false;
			}
			var scriptInstance = scriptData.instance;
			if (scriptType && !(scriptInstance instanceof scriptType)) {
				return false;
			}
			var indOld = this._scripts.indexOf(scriptInstance);
			if (indOld === -1 || indOld === ind) {
				return false;
			}
			this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
			this._resetExecutionOrder(0, len);
			this._updateList.sort();
			this._postUpdateList.sort();
			this.fire('move', scriptName, scriptInstance, ind, indOld);
			this.fire("move:" + scriptName, scriptInstance, ind, indOld);
			return true;
		};
		return _createClass(ScriptComponent, [{
			key: "scripts",
			get: function get() {
				return this._scripts;
			},
			set: function set(value) {
				var _this3 = this;
				this._scriptsData = value;
				var _loop2 = function _loop2() {
					if (!value.hasOwnProperty(key)) {
						return 1;
					}
					var script = _this3._scriptsIndex[key];
					if (script) {
						if (typeof value[key].enabled === 'boolean') {
							script.once('preInitialize', function () {
								_this3.initializeAttributes(script);
							});
							script.enabled = !!value[key].enabled;
						}
						if (typeof value[key].attributes === 'object') {
							for (var attr in value[key].attributes) {
								if (ScriptAttributes.reservedNames.has(attr)) {
									continue;
								}
								if (!script.__attributes.hasOwnProperty(attr)) {
									var scriptType = _this3.system.app.scripts.get(key);
									if (scriptType) {
										scriptType.attributes.add(attr, {});
									}
								}
								script[attr] = value[key].attributes[attr];
							}
						}
					} else {
						console.log(_this3.order);
					}
				};
				for (var key in value) {
					if (_loop2()) continue;
				}
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				var oldValue = this._enabled;
				this._enabled = value;
				this.fire('set', 'enabled', oldValue, value);
			}
		}]);
	}(Component);
	ScriptComponent.EVENT_CREATE = 'create';
	ScriptComponent.EVENT_DESTROY = 'destroy';
	ScriptComponent.EVENT_ENABLE = 'enable';
	ScriptComponent.EVENT_DISABLE = 'disable';
	ScriptComponent.EVENT_REMOVE = 'remove';
	ScriptComponent.EVENT_STATE = 'state';
	ScriptComponent.EVENT_MOVE = 'move';
	ScriptComponent.EVENT_ERROR = 'error';

	var ScriptComponentData = function ScriptComponentData() {
		this.enabled = true;
	};

	var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
	var METHOD_INITIALIZE = '_onInitialize';
	var METHOD_POST_INITIALIZE = '_onPostInitialize';
	var METHOD_UPDATE = '_onUpdate';
	var METHOD_POST_UPDATE = '_onPostUpdate';
	var executionOrderCounter = 0;
	var ScriptComponentSystem = function (_ComponentSystem) {
		function ScriptComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'script';
			_this.ComponentType = ScriptComponent;
			_this.DataType = ScriptComponentData;
			_this._components = new SortedLoopArray({
				sortBy: '_executionOrder'
			});
			_this._enabledComponents = new SortedLoopArray({
				sortBy: '_executionOrder'
			});
			_this.preloading = true;
			_this.on('beforeremove', _this._onBeforeRemove, _this);
			_this.app.systems.on('initialize', _this._onInitialize, _this);
			_this.app.systems.on('postInitialize', _this._onPostInitialize, _this);
			_this.app.systems.on('update', _this._onUpdate, _this);
			_this.app.systems.on('postUpdate', _this._onPostUpdate, _this);
			return _this;
		}
		_inheritsLoose(ScriptComponentSystem, _ComponentSystem);
		var _proto = ScriptComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, data) {
			component._executionOrder = executionOrderCounter++;
			this._components.append(component);
			if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
				this._resetExecutionOrder();
			}
			component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
			if (component.enabled && component.entity.enabled) {
				this._enabledComponents.append(component);
			}
			if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
				component._scriptsData = data.scripts;
				for (var i = 0; i < data.order.length; i++) {
					component.create(data.order[i], {
						enabled: data.scripts[data.order[i]].enabled,
						attributes: data.scripts[data.order[i]].attributes,
						preloading: this.preloading
					});
				}
			}
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var order = [];
			var scripts = {};
			for (var i = 0; i < entity.script._scripts.length; i++) {
				var scriptInstance = entity.script._scripts[i];
				var scriptName = scriptInstance.__scriptType.__name;
				order.push(scriptName);
				var attributes = {};
				for (var key in scriptInstance.__attributes) {
					attributes[key] = scriptInstance.__attributes[key];
				}
				scripts[scriptName] = {
					enabled: scriptInstance._enabled,
					attributes: attributes
				};
			}
			for (var _key in entity.script._scriptsIndex) {
				if (_key.awaiting) {
					order.splice(_key.ind, 0, _key);
				}
			}
			var data = {
				enabled: entity.script.enabled,
				order: order,
				scripts: scripts
			};
			return this.addComponent(clone, data);
		};
		_proto._resetExecutionOrder = function _resetExecutionOrder() {
			executionOrderCounter = 0;
			for (var i = 0, len = this._components.length; i < len; i++) {
				this._components.items[i]._executionOrder = executionOrderCounter++;
			}
		};
		_proto._callComponentMethod = function _callComponentMethod(components, name, dt) {
			for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
				components.items[components.loopIndex][name](dt);
			}
		};
		_proto._onInitialize = function _onInitialize() {
			this.preloading = false;
			this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);
			this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
		};
		_proto._onPostInitialize = function _onPostInitialize() {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
		};
		_proto._onUpdate = function _onUpdate(dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
		};
		_proto._onPostUpdate = function _onPostUpdate(dt) {
			this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
		};
		_proto._addComponentToEnabled = function _addComponentToEnabled(component) {
			this._enabledComponents.insert(component);
		};
		_proto._removeComponentFromEnabled = function _removeComponentFromEnabled(component) {
			this._enabledComponents.remove(component);
		};
		_proto._onBeforeRemove = function _onBeforeRemove(entity, component) {
			var ind = this._components.items.indexOf(component);
			if (ind >= 0) {
				component._onBeforeRemove();
			}
			this._removeComponentFromEnabled(component);
			this._components.remove(component);
		};
		_proto.destroy = function destroy() {
			_ComponentSystem.prototype.destroy.call(this);
			this.app.systems.off('initialize', this._onInitialize, this);
			this.app.systems.off('postInitialize', this._onPostInitialize, this);
			this.app.systems.off('update', this._onUpdate, this);
			this.app.systems.off('postUpdate', this._onPostUpdate, this);
		};
		return ScriptComponentSystem;
	}(ComponentSystem);

	var GSplatComponent = function (_Component) {
		function GSplatComponent(system, entity) {
			var _this;
			_this = _Component.call(this, system, entity) || this;
			_this._layers = [LAYERID_WORLD];
			_this._instance = null;
			_this._customAabb = null;
			_this._assetReference = void 0;
			_this._materialOptions = null;
			_this._evtLayersChanged = null;
			_this._evtLayerAdded = null;
			_this._evtLayerRemoved = null;
			_this._assetReference = new AssetReference('asset', _this, system.app.assets, {
				add: _this._onGSplatAssetAdded,
				load: _this._onGSplatAssetLoad,
				remove: _this._onGSplatAssetRemove,
				unload: _this._onGSplatAssetUnload
			}, _this);
			entity.on('remove', _this.onRemoveChild, _this);
			entity.on('removehierarchy', _this.onRemoveChild, _this);
			entity.on('insert', _this.onInsertChild, _this);
			entity.on('inserthierarchy', _this.onInsertChild, _this);
			return _this;
		}
		_inheritsLoose(GSplatComponent, _Component);
		var _proto = GSplatComponent.prototype;
		_proto.assignAsset = function assignAsset(asset) {
			var id = asset instanceof Asset ? asset.id : asset;
			this._assetReference.id = id;
		};
		_proto.destroyInstance = function destroyInstance() {
			if (this._instance) {
				var _this$_instance;
				this.removeFromLayers();
				(_this$_instance = this._instance) == null || _this$_instance.destroy();
				this._instance = null;
			}
		};
		_proto.addToLayers = function addToLayers() {
			var _this$instance;
			var meshInstance = (_this$instance = this.instance) == null ? void 0 : _this$instance.meshInstance;
			if (meshInstance) {
				var layers = this.system.app.scene.layers;
				for (var i = 0; i < this._layers.length; i++) {
					var _layers$getLayerById;
					(_layers$getLayerById = layers.getLayerById(this._layers[i])) == null || _layers$getLayerById.addMeshInstances([meshInstance]);
				}
			}
		};
		_proto.removeFromLayers = function removeFromLayers() {
			var _this$instance2;
			var meshInstance = (_this$instance2 = this.instance) == null ? void 0 : _this$instance2.meshInstance;
			if (meshInstance) {
				var layers = this.system.app.scene.layers;
				for (var i = 0; i < this._layers.length; i++) {
					var _layers$getLayerById2;
					(_layers$getLayerById2 = layers.getLayerById(this._layers[i])) == null || _layers$getLayerById2.removeMeshInstances([meshInstance]);
				}
			}
		};
		_proto.onRemoveChild = function onRemoveChild() {
			this.removeFromLayers();
		};
		_proto.onInsertChild = function onInsertChild() {
			if (this._instance && this.enabled && this.entity.enabled) {
				this.addToLayers();
			}
		};
		_proto.onRemove = function onRemove() {
			this.destroyInstance();
			this.asset = null;
			this._assetReference.id = null;
			this.entity.off('remove', this.onRemoveChild, this);
			this.entity.off('insert', this.onInsertChild, this);
		};
		_proto.onLayersChanged = function onLayersChanged(oldComp, newComp) {
			this.addToLayers();
			oldComp.off('add', this.onLayerAdded, this);
			oldComp.off('remove', this.onLayerRemoved, this);
			newComp.on('add', this.onLayerAdded, this);
			newComp.on('remove', this.onLayerRemoved, this);
		};
		_proto.onLayerAdded = function onLayerAdded(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._instance) {
				layer.addMeshInstances(this._instance.meshInstance);
			}
		};
		_proto.onLayerRemoved = function onLayerRemoved(layer) {
			var index = this.layers.indexOf(layer.id);
			if (index < 0) return;
			if (this._instance) {
				layer.removeMeshInstances(this._instance.meshInstance);
			}
		};
		_proto.onEnable = function onEnable() {
			var scene = this.system.app.scene;
			var layers = scene.layers;
			this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
			if (layers) {
				this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
				this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
			}
			if (this._instance) {
				this.addToLayers();
			} else if (this.asset) {
				this._onGSplatAssetAdded();
			}
		};
		_proto.onDisable = function onDisable() {
			var _this$_evtLayersChang;
			var scene = this.system.app.scene;
			var layers = scene.layers;
			(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();
			this._evtLayersChanged = null;
			if (layers) {
				var _this$_evtLayerAdded, _this$_evtLayerRemove;
				(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();
				this._evtLayerAdded = null;
				(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();
				this._evtLayerRemoved = null;
			}
			this.removeFromLayers();
		};
		_proto.hide = function hide() {
			if (this._instance) {
				this._instance.meshInstance.visible = false;
			}
		};
		_proto.show = function show() {
			if (this._instance) {
				this._instance.meshInstance.visible = true;
			}
		};
		_proto._onGSplatAssetAdded = function _onGSplatAssetAdded() {
			if (!this._assetReference.asset) {
				return;
			}
			if (this._assetReference.asset.resource) {
				this._onGSplatAssetLoad();
			} else if (this.enabled && this.entity.enabled) {
				this.system.app.assets.load(this._assetReference.asset);
			}
		};
		_proto._onGSplatAssetLoad = function _onGSplatAssetLoad() {
			this.destroyInstance();
			var asset = this._assetReference.asset;
			if (asset) {
				this.instance = asset.resource.createInstance();
			}
		};
		_proto._onGSplatAssetUnload = function _onGSplatAssetUnload() {
			this.destroyInstance();
		};
		_proto._onGSplatAssetRemove = function _onGSplatAssetRemove() {
			this._onGSplatAssetUnload();
		};
		return _createClass(GSplatComponent, [{
			key: "customAabb",
			get: function get() {
				return this._customAabb;
			},
			set: function set(value) {
				var _this$_instance2;
				this._customAabb = value;
				(_this$_instance2 = this._instance) == null || (_this$_instance2 = _this$_instance2.meshInstance) == null || _this$_instance2.setCustomAabb(this._customAabb);
			}
		}, {
			key: "instance",
			get: function get() {
				return this._instance;
			},
			set: function set(value) {
				var _this$_instance3;
				this.destroyInstance();
				this._instance = value;
				if ((_this$_instance3 = this._instance) != null && _this$_instance3.meshInstance) {
					var mi = this._instance.meshInstance;
					if (!mi.node) {
						mi.node = this.entity;
					}
					mi.setCustomAabb(this._customAabb);
					if (this._materialOptions) {
						this._instance.createMaterial(this._materialOptions);
					}
					if (this.enabled && this.entity.enabled) {
						this.addToLayers();
					}
				}
			}
		}, {
			key: "materialOptions",
			get: function get() {
				return this._materialOptions;
			},
			set: function set(value) {
				this._materialOptions = Object.assign({}, value);
				if (this._instance) {
					this._instance.createMaterial(this._materialOptions);
				}
			}
		}, {
			key: "material",
			get: function get() {
				var _this$_instance4;
				return (_this$_instance4 = this._instance) == null ? void 0 : _this$_instance4.material;
			}
		}, {
			key: "layers",
			get: function get() {
				return this._layers;
			},
			set: function set(value) {
				this.removeFromLayers();
				this._layers.length = 0;
				for (var i = 0; i < value.length; i++) {
					this._layers[i] = value[i];
				}
				if (!this.enabled || !this.entity.enabled) {
					return;
				}
				this.addToLayers();
			}
		}, {
			key: "asset",
			get: function get() {
				return this._assetReference.id;
			},
			set: function set(value) {
				var id = value instanceof Asset ? value.id : value;
				if (this._assetReference.id === id) return;
				if (this._assetReference.asset && this._assetReference.asset.resource) {
					this._onGSplatAssetRemove();
				}
				this._assetReference.id = id;
				if (this._assetReference.asset) {
					this._onGSplatAssetAdded();
				}
			}
		}]);
	}(Component);

	var GSplatComponentData = function GSplatComponentData() {
		this.enabled = true;
	};

	var _schema = ['enabled'];
	var _properties = ['instance', 'asset', 'layers'];
	var GSplatComponentSystem = function (_ComponentSystem) {
		function GSplatComponentSystem(app) {
			var _this;
			_this = _ComponentSystem.call(this, app) || this;
			_this.id = 'gsplat';
			_this.ComponentType = GSplatComponent;
			_this.DataType = GSplatComponentData;
			_this.schema = _schema;
			_this.on('beforeremove', _this.onRemove, _this);
			return _this;
		}
		_inheritsLoose(GSplatComponentSystem, _ComponentSystem);
		var _proto = GSplatComponentSystem.prototype;
		_proto.initializeComponentData = function initializeComponentData(component, _data, properties) {
			if (_data.layers && _data.layers.length) {
				_data.layers = _data.layers.slice(0);
			}
			for (var i = 0; i < _properties.length; i++) {
				if (_data.hasOwnProperty(_properties[i])) {
					component[_properties[i]] = _data[_properties[i]];
				}
			}
			if (_data.aabbCenter && _data.aabbHalfExtents) {
				component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
			}
			_ComponentSystem.prototype.initializeComponentData.call(this, component, _data, _schema);
		};
		_proto.cloneComponent = function cloneComponent(entity, clone) {
			var gSplatComponent = entity.gsplat;
			var data = {};
			for (var i = 0; i < _properties.length; i++) {
				data[_properties[i]] = gSplatComponent[_properties[i]];
			}
			data.enabled = gSplatComponent.enabled;
			delete data.instance;
			var component = this.addComponent(clone, data);
			component.instance = gSplatComponent.instance.clone();
			if (gSplatComponent.customAabb) {
				component.customAabb = gSplatComponent.customAabb.clone();
			}
			return component;
		};
		_proto.onRemove = function onRemove(entity, component) {
			component.onRemove();
		};
		return GSplatComponentSystem;
	}(ComponentSystem);
	Component._buildAccessors(GSplatComponent.prototype, _schema);

	var Render = function (_EventHandler) {
		function Render() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _EventHandler.call.apply(_EventHandler, [this].concat(args)) || this;
			_this._meshes = null;
			return _this;
		}
		_inheritsLoose(Render, _EventHandler);
		var _proto = Render.prototype;
		_proto.destroy = function destroy() {
			this.meshes = null;
		};
		_proto.decRefMeshes = function decRefMeshes() {
			var _this$_meshes,
				_this2 = this;
			(_this$_meshes = this._meshes) == null || _this$_meshes.forEach(function (mesh, index) {
				if (mesh) {
					mesh.decRefCount();
					if (mesh.refCount < 1) {
						mesh.destroy();
						_this2._meshes[index] = null;
					}
				}
			});
		};
		_proto.incRefMeshes = function incRefMeshes() {
			var _this$_meshes2;
			(_this$_meshes2 = this._meshes) == null || _this$_meshes2.forEach(function (mesh) {
				mesh == null || mesh.incRefCount();
			});
		};
		return _createClass(Render, [{
			key: "meshes",
			get: function get() {
				return this._meshes;
			},
			set: function set(value) {
				this.decRefMeshes();
				this._meshes = value;
				this.incRefMeshes();
				this.fire('set:meshes', value);
			}
		}]);
	}(EventHandler);
	Render.EVENT_SETMESHES = 'set:meshes';

	function onContainerAssetLoaded(containerAsset) {
		var renderAsset = this;
		if (!renderAsset.resource) return;
		var containerResource = containerAsset.resource;
		var render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];
		if (render) {
			renderAsset.resource.meshes = render.resource.meshes;
		}
	}
	function onContainerAssetAdded(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.on("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
		renderAsset.registry.off("remove:" + containerAsset.id, onContainerAssetRemoved, renderAsset);
		renderAsset.registry.once("remove:" + containerAsset.id, onContainerAssetRemoved, renderAsset);
		if (!containerAsset.resource) {
			renderAsset.registry.load(containerAsset);
		} else {
			onContainerAssetLoaded.call(renderAsset, containerAsset);
		}
	}
	function onContainerAssetRemoved(containerAsset) {
		var renderAsset = this;
		renderAsset.registry.off("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
		if (renderAsset.resource) {
			renderAsset.resource.destroy();
		}
	}
	var RenderHandler = function (_ResourceHandler) {
		function RenderHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'render') || this;
			_this._registry = app.assets;
			return _this;
		}
		_inheritsLoose(RenderHandler, _ResourceHandler);
		var _proto = RenderHandler.prototype;
		_proto.open = function open(url, data) {
			return new Render();
		};
		_proto.patch = function patch(asset, registry) {
			if (!asset.data.containerAsset) {
				return;
			}
			var containerAsset = registry.get(asset.data.containerAsset);
			if (!containerAsset) {
				registry.once("add:" + asset.data.containerAsset, onContainerAssetAdded, asset);
				return;
			}
			onContainerAssetAdded.call(asset, containerAsset);
		};
		return RenderHandler;
	}(ResourceHandler);

	var AnimCurve = function () {
		function AnimCurve(paths, input, output, interpolation) {
			this._paths = paths;
			this._input = input;
			this._output = output;
			this._interpolation = interpolation;
		}
		return _createClass(AnimCurve, [{
			key: "paths",
			get: function get() {
				return this._paths;
			}
		}, {
			key: "input",
			get: function get() {
				return this._input;
			}
		}, {
			key: "output",
			get: function get() {
				return this._output;
			}
		}, {
			key: "interpolation",
			get: function get() {
				return this._interpolation;
			}
		}]);
	}();

	var AnimData = function () {
		function AnimData(components, data) {
			this._components = components;
			this._data = data;
		}
		return _createClass(AnimData, [{
			key: "components",
			get: function get() {
				return this._components;
			}
		}, {
			key: "data",
			get: function get() {
				return this._data;
			}
		}]);
	}();

	function DracoWorker(jsUrl, wasmUrl) {
		var draco;
		var POSITION_ATTRIBUTE = 0;
		var NORMAL_ATTRIBUTE = 1;
		var wrap = function wrap(typedArray, dataType) {
			switch (dataType) {
				case draco.DT_INT8:
					return new Int8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
				case draco.DT_INT16:
					return new Int16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
				case draco.DT_INT32:
					return new Int32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
				case draco.DT_UINT8:
					return new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
				case draco.DT_UINT16:
					return new Uint16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
				case draco.DT_UINT32:
					return new Uint32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
				case draco.DT_FLOAT32:
					return new Float32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
			}
			return null;
		};
		var componentSizeInBytes = function componentSizeInBytes(dataType) {
			switch (dataType) {
				case draco.DT_INT8:
					return 1;
				case draco.DT_INT16:
					return 2;
				case draco.DT_INT32:
					return 4;
				case draco.DT_UINT8:
					return 1;
				case draco.DT_UINT16:
					return 2;
				case draco.DT_UINT32:
					return 4;
				case draco.DT_FLOAT32:
					return 4;
			}
			return 1;
		};
		var attributeSizeInBytes = function attributeSizeInBytes(attribute) {
			return attribute.num_components() * componentSizeInBytes(attribute.data_type());
		};
		var attributeOrder = {
			0: 0,
			1: 1,
			5: 2,
			2: 3,
			7: 4,
			8: 5,
			4: 6,
			3: 7
		};
		var generateNormals = function generateNormals(vertices, indices) {
			var subtract = function subtract(dst, a, b) {
				dst[0] = a[0] - b[0];
				dst[1] = a[1] - b[1];
				dst[2] = a[2] - b[2];
			};
			var cross = function cross(dst, a, b) {
				dst[0] = a[1] * b[2] - b[1] * a[2];
				dst[1] = a[2] * b[0] - b[2] * a[0];
				dst[2] = a[0] * b[1] - b[0] * a[1];
			};
			var normalize = function normalize(dst, offset) {
				var a = dst[offset + 0];
				var b = dst[offset + 1];
				var c = dst[offset + 2];
				var l = 1.0 / Math.sqrt(a * a + b * b + c * c);
				dst[offset + 0] *= l;
				dst[offset + 1] *= l;
				dst[offset + 2] *= l;
			};
			var copy = function copy(dst, src, srcOffset) {
				for (var i = 0; i < 3; ++i) {
					dst[i] = src[srcOffset + i];
				}
			};
			var numTriangles = indices.length / 3;
			var numVertices = vertices.length / 3;
			var result = new Float32Array(vertices.length);
			var a = [0, 0, 0],
				b = [0, 0, 0],
				c = [0, 0, 0],
				t1 = [0, 0, 0],
				t2 = [0, 0, 0],
				n = [0, 0, 0];
			for (var i = 0; i < numTriangles; ++i) {
				var v0 = indices[i * 3 + 0] * 3;
				var v1 = indices[i * 3 + 1] * 3;
				var v2 = indices[i * 3 + 2] * 3;
				copy(a, vertices, v0);
				copy(b, vertices, v1);
				copy(c, vertices, v2);
				subtract(t1, b, a);
				subtract(t2, c, a);
				cross(n, t1, t2);
				normalize(n, 0);
				for (var j = 0; j < 3; ++j) {
					result[v0 + j] += n[j];
					result[v1 + j] += n[j];
					result[v2 + j] += n[j];
				}
			}
			for (var _i = 0; _i < numVertices; ++_i) {
				normalize(result, _i * 3);
			}
			return new Uint8Array(result.buffer);
		};
		var decodeMesh = function decodeMesh(inputBuffer) {
			var result = {};
			var buffer = new draco.DecoderBuffer();
			buffer.Init(inputBuffer, inputBuffer.length);
			var decoder = new draco.Decoder();
			if (decoder.GetEncodedGeometryType(buffer) !== draco.TRIANGULAR_MESH) {
				result.error = 'Failed to decode draco mesh: not a mesh';
				return result;
			}
			var mesh = new draco.Mesh();
			var status = decoder.DecodeBufferToMesh(buffer, mesh);
			if (!status || !status.ok() || draco.getPointer(mesh) === 0) {
				result.error = 'Failed to decode draco asset';
				return result;
			}
			var numIndices = mesh.num_faces() * 3;
			var shortIndices = mesh.num_points() <= 65535;
			var indicesSize = numIndices * (shortIndices ? 2 : 4);
			var indicesPtr = draco._malloc(indicesSize);
			if (shortIndices) {
				decoder.GetTrianglesUInt16Array(mesh, indicesSize, indicesPtr);
				result.indices = new Uint16Array(draco.HEAPU16.buffer, indicesPtr, numIndices).slice().buffer;
			} else {
				decoder.GetTrianglesUInt32Array(mesh, indicesSize, indicesPtr);
				result.indices = new Uint32Array(draco.HEAPU32.buffer, indicesPtr, numIndices).slice().buffer;
			}
			draco._free(indicesPtr);
			var attributes = [];
			for (var i = 0; i < mesh.num_attributes(); ++i) {
				attributes.push(decoder.GetAttribute(mesh, i));
			}
			attributes.sort(function (a, b) {
				var _attributeOrder$a$att, _attributeOrder$b$att;
				return ((_attributeOrder$a$att = attributeOrder[a.attribute_type()]) != null ? _attributeOrder$a$att : attributeOrder.length) - ((_attributeOrder$b$att = attributeOrder[b.attribute_type()]) != null ? _attributeOrder$b$att : attributeOrder.length);
			});
			result.attributes = attributes.map(function (a) {
				return a.unique_id();
			});
			var totalVertexSize = 0;
			var offsets = attributes.map(function (a) {
				var offset = totalVertexSize;
				totalVertexSize += Math.ceil(attributeSizeInBytes(a) / 4) * 4;
				return offset;
			});
			var hasNormals = attributes.some(function (a) {
				return a.attribute_type() === NORMAL_ATTRIBUTE;
			});
			var normalOffset = offsets[1];
			if (!hasNormals) {
				for (var _i2 = 1; _i2 < offsets.length; ++_i2) {
					offsets[_i2] += 12;
				}
				totalVertexSize += 12;
			}
			result.vertices = new ArrayBuffer(mesh.num_points() * totalVertexSize);
			var dst = new Uint8Array(result.vertices);
			for (var _i3 = 0; _i3 < mesh.num_attributes(); ++_i3) {
				var attribute = attributes[_i3];
				var sizeInBytes = attributeSizeInBytes(attribute);
				var ptrSize = mesh.num_points() * sizeInBytes;
				var ptr = draco._malloc(ptrSize);
				decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, attribute.data_type(), ptrSize, ptr);
				var src = new Uint8Array(draco.HEAPU8.buffer, ptr, ptrSize);
				for (var j = 0; j < mesh.num_points(); ++j) {
					for (var c = 0; c < sizeInBytes; ++c) {
						dst[j * totalVertexSize + offsets[_i3] + c] = src[j * sizeInBytes + c];
					}
				}
				if (!hasNormals && attribute.attribute_type() === POSITION_ATTRIBUTE) {
					var normals = generateNormals(wrap(src, attribute.data_type()), shortIndices ? new Uint16Array(result.indices) : new Uint32Array(result.indices));
					for (var _j = 0; _j < mesh.num_points(); ++_j) {
						for (var _c = 0; _c < 12; ++_c) {
							dst[_j * totalVertexSize + normalOffset + _c] = normals[_j * 12 + _c];
						}
					}
				}
				draco._free(ptr);
			}
			draco.destroy(mesh);
			draco.destroy(decoder);
			draco.destroy(buffer);
			return result;
		};
		var decode = function decode(data) {
			var result = decodeMesh(new Uint8Array(data.buffer));
			self.postMessage({
				jobId: data.jobId,
				error: result.error,
				indices: result.indices,
				vertices: result.vertices,
				attributes: result.attributes
			}, [result.indices, result.vertices].filter(function (t) {
				return t != null;
			}));
		};
		var workQueue = [];
		self.onmessage = function (message) {
			var data = message.data;
			switch (data.type) {
				case 'init':
					self.DracoDecoderModule({
						instantiateWasm: function instantiateWasm(imports, successCallback) {
							WebAssembly.instantiate(data.module, imports).then(function (result) {
								return successCallback(result);
							}).catch(function (reason) {
								return console.error("instantiate failed + " + reason);
							});
							return {};
						}
					}).then(function (instance) {
						draco = instance;
						workQueue.forEach(function (data) {
							return decode(data);
						});
					});
					break;
				case 'decodeMesh':
					if (draco) {
						decode(data);
					} else {
						workQueue.push(data);
					}
					break;
			}
		};
	}

	var downloadMaxRetries = 3;
	var JobQueue = function () {
		function JobQueue() {
			this.workers = [[], [], []];
			this.jobId = 0;
			this.jobQueue = [];
			this.jobCallbacks = new Map();
			this.run = function (worker, job) {
				worker.postMessage({
					type: 'decodeMesh',
					jobId: job.jobId,
					buffer: job.buffer
				}, [job.buffer]);
			};
		}
		var _proto = JobQueue.prototype;
		_proto.init = function init(workers) {
			var _this = this;
			workers.forEach(function (worker) {
				worker.addEventListener('message', function (message) {
					var data = message.data;
					var callback = _this.jobCallbacks.get(data.jobId);
					if (callback) {
						callback(data.error, {
							indices: data.indices,
							vertices: data.vertices,
							attributes: data.attributes
						});
					}
					_this.jobCallbacks.delete(data.jobId);
					if (_this.jobQueue.length > 0) {
						var job = _this.jobQueue.shift();
						_this.run(worker, job);
					} else {
						var index2 = _this.workers[2].indexOf(worker);
						if (index2 !== -1) {
							_this.workers[2].splice(index2, 1);
							_this.workers[1].push(worker);
						} else {
							var index1 = _this.workers[1].indexOf(worker);
							if (index1 !== -1) {
								_this.workers[1].splice(index1, 1);
								_this.workers[0].push(worker);
							}
						}
					}
				});
			});
			this.workers[0] = workers;
			while (this.jobQueue.length && (this.workers[0].length || this.workers[1].length)) {
				var job = this.jobQueue.shift();
				if (this.workers[0].length > 0) {
					var worker = this.workers[0].shift();
					this.workers[1].push(worker);
					this.run(worker, job);
				} else {
					var _worker = this.workers[1].shift();
					this.workers[2].push(_worker);
					this.run(_worker, job);
				}
			}
		};
		_proto.enqueueJob = function enqueueJob(buffer, callback) {
			var job = {
				jobId: this.jobId++,
				buffer: buffer
			};
			this.jobCallbacks.set(job.jobId, callback);
			if (this.workers[0].length > 0) {
				var worker = this.workers[0].shift();
				this.workers[1].push(worker);
				this.run(worker, job);
			} else if (this.workers[1].length > 0) {
				var _worker2 = this.workers[1].shift();
				this.workers[2].push(_worker2);
				this.run(_worker2, job);
			} else {
				this.jobQueue.push(job);
			}
		};
		return JobQueue;
	}();
	var downloadScript = function downloadScript(url) {
		return new Promise(function (resolve, reject) {
			var options = {
				cache: true,
				responseType: 'text',
				retry: downloadMaxRetries > 0,
				maxRetries: downloadMaxRetries
			};
			http.get(url, options, function (err, response) {
				if (err) {
					reject(err);
				} else {
					resolve(response);
				}
			});
		});
	};
	var compileModule = function compileModule(url) {
		var compileManual = function compileManual() {
			return fetch(url).then(function (result) {
				return result.arrayBuffer();
			}).then(function (buffer) {
				return WebAssembly.compile(buffer);
			});
		};
		var compileStreaming = function compileStreaming() {
			return WebAssembly.compileStreaming(fetch(url)).catch(function (err) {
				return compileManual();
			});
		};
		return WebAssembly.compileStreaming ? compileStreaming() : compileManual();
	};
	var defaultNumWorkers$1 = 1;
	var jobQueue;
	var lazyConfig$1;
	var initializeWorkers = function initializeWorkers(config) {
		if (jobQueue) {
			return true;
		}
		if (!config) {
			if (lazyConfig$1) {
				config = lazyConfig$1;
			} else {
				var moduleConfig = WasmModule.getConfig('DracoDecoderModule');
				if (moduleConfig) {
					config = {
						jsUrl: moduleConfig.glueUrl,
						wasmUrl: moduleConfig.wasmUrl,
						numWorkers: moduleConfig.numWorkers
					};
				} else {
					config = {
						jsUrl: 'draco.wasm.js',
						wasmUrl: 'draco.wasm.wasm',
						numWorkers: defaultNumWorkers$1
					};
				}
			}
		}
		if (!config.jsUrl || !config.wasmUrl) {
			return false;
		}
		jobQueue = new JobQueue();
		Promise.all([downloadScript(config.jsUrl), compileModule(config.wasmUrl)]).then(function (_ref) {
			var dracoSource = _ref[0],
				dracoModule = _ref[1];
			var code = ['/* draco */', dracoSource, '/* worker */', "(\n" + DracoWorker.toString() + "\n)()\n\n"].join('\n');
			var blob = new Blob([code], {
				type: 'application/javascript'
			});
			var workerUrl = URL.createObjectURL(blob);
			var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers$1));
			var workers = [];
			for (var i = 0; i < numWorkers; ++i) {
				var worker = new Worker(workerUrl);
				worker.postMessage({
					type: 'init',
					module: dracoModule
				});
				workers.push(worker);
			}
			jobQueue.init(workers);
		});
		return true;
	};
	var dracoInitialize = function dracoInitialize(config) {
		if (config != null && config.lazyInit) {
			lazyConfig$1 = config;
		} else {
			initializeWorkers(config);
		}
	};
	var dracoDecode = function dracoDecode(buffer, callback) {
		if (!initializeWorkers()) {
			return false;
		}
		jobQueue.enqueueJob(buffer, callback);
		return true;
	};

	var _attributeOrder;
	var GlbResources = function () {
		function GlbResources() {
			this.gltf = void 0;
			this.nodes = void 0;
			this.scenes = void 0;
			this.animations = void 0;
			this.textures = void 0;
			this.materials = void 0;
			this.variants = void 0;
			this.meshVariants = void 0;
			this.meshDefaultMaterials = void 0;
			this.renders = void 0;
			this.skins = void 0;
			this.lights = void 0;
			this.cameras = void 0;
			this.nodeInstancingMap = void 0;
		}
		var _proto = GlbResources.prototype;
		_proto.destroy = function destroy() {
			if (this.renders) {
				this.renders.forEach(function (render) {
					render.meshes = null;
				});
			}
		};
		return GlbResources;
	}();
	var isDataURI = function isDataURI(uri) {
		return /^data:[^\n\r,\u2028\u2029]*,.*$/i.test(uri);
	};
	var getDataURIMimeType = function getDataURIMimeType(uri) {
		return uri.substring(uri.indexOf(':') + 1, uri.indexOf(';'));
	};
	var getNumComponents = function getNumComponents(accessorType) {
		switch (accessorType) {
			case 'SCALAR':
				return 1;
			case 'VEC2':
				return 2;
			case 'VEC3':
				return 3;
			case 'VEC4':
				return 4;
			case 'MAT2':
				return 4;
			case 'MAT3':
				return 9;
			case 'MAT4':
				return 16;
			default:
				return 3;
		}
	};
	var getComponentType$1 = function getComponentType(componentType) {
		switch (componentType) {
			case 5120:
				return TYPE_INT8;
			case 5121:
				return TYPE_UINT8;
			case 5122:
				return TYPE_INT16;
			case 5123:
				return TYPE_UINT16;
			case 5124:
				return TYPE_INT32;
			case 5125:
				return TYPE_UINT32;
			case 5126:
				return TYPE_FLOAT32;
			default:
				return 0;
		}
	};
	var getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {
		switch (componentType) {
			case 5120:
				return 1;
			case 5121:
				return 1;
			case 5122:
				return 2;
			case 5123:
				return 2;
			case 5124:
				return 4;
			case 5125:
				return 4;
			case 5126:
				return 4;
			default:
				return 0;
		}
	};
	var getComponentDataType = function getComponentDataType(componentType) {
		switch (componentType) {
			case 5120:
				return Int8Array;
			case 5121:
				return Uint8Array;
			case 5122:
				return Int16Array;
			case 5123:
				return Uint16Array;
			case 5124:
				return Int32Array;
			case 5125:
				return Uint32Array;
			case 5126:
				return Float32Array;
			default:
				return null;
		}
	};
	var gltfToEngineSemanticMap = {
		'POSITION': SEMANTIC_POSITION,
		'NORMAL': SEMANTIC_NORMAL,
		'TANGENT': SEMANTIC_TANGENT,
		'COLOR_0': SEMANTIC_COLOR,
		'JOINTS_0': SEMANTIC_BLENDINDICES,
		'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
		'TEXCOORD_0': SEMANTIC_TEXCOORD0,
		'TEXCOORD_1': SEMANTIC_TEXCOORD1,
		'TEXCOORD_2': SEMANTIC_TEXCOORD2,
		'TEXCOORD_3': SEMANTIC_TEXCOORD3,
		'TEXCOORD_4': SEMANTIC_TEXCOORD4,
		'TEXCOORD_5': SEMANTIC_TEXCOORD5,
		'TEXCOORD_6': SEMANTIC_TEXCOORD6,
		'TEXCOORD_7': SEMANTIC_TEXCOORD7
	};
	var attributeOrder = (_attributeOrder = {}, _attributeOrder[SEMANTIC_POSITION] = 0, _attributeOrder[SEMANTIC_NORMAL] = 1, _attributeOrder[SEMANTIC_TANGENT] = 2, _attributeOrder[SEMANTIC_COLOR] = 3, _attributeOrder[SEMANTIC_BLENDINDICES] = 4, _attributeOrder[SEMANTIC_BLENDWEIGHT] = 5, _attributeOrder[SEMANTIC_TEXCOORD0] = 6, _attributeOrder[SEMANTIC_TEXCOORD1] = 7, _attributeOrder[SEMANTIC_TEXCOORD2] = 8, _attributeOrder[SEMANTIC_TEXCOORD3] = 9, _attributeOrder[SEMANTIC_TEXCOORD4] = 10, _attributeOrder[SEMANTIC_TEXCOORD5] = 11, _attributeOrder[SEMANTIC_TEXCOORD6] = 12, _attributeOrder[SEMANTIC_TEXCOORD7] = 13, _attributeOrder);
	var getDequantizeFunc = function getDequantizeFunc(srcType) {
		switch (srcType) {
			case TYPE_INT8:
				return function (x) {
					return Math.max(x / 127.0, -1.0);
				};
			case TYPE_UINT8:
				return function (x) {
					return x / 255.0;
				};
			case TYPE_INT16:
				return function (x) {
					return Math.max(x / 32767.0, -1.0);
				};
			case TYPE_UINT16:
				return function (x) {
					return x / 65535.0;
				};
			default:
				return function (x) {
					return x;
				};
		}
	};
	var dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {
		var convFunc = getDequantizeFunc(srcType);
		var len = srcArray.length;
		for (var i = 0; i < len; ++i) {
			dstArray[i] = convFunc(srcArray[i]);
		}
		return dstArray;
	};
	var _getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten) {
		if (flatten === void 0) {
			flatten = false;
		}
		var numComponents = getNumComponents(gltfAccessor.type);
		var dataType = getComponentDataType(gltfAccessor.componentType);
		if (!dataType) {
			return null;
		}
		var result;
		if (gltfAccessor.sparse) {
			var sparse = gltfAccessor.sparse;
			var indicesAccessor = {
				count: sparse.count,
				type: 'SCALAR'
			};
			var indices = _getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
			var valuesAccessor = {
				count: sparse.count,
				type: gltfAccessor.type,
				componentType: gltfAccessor.componentType
			};
			var values = _getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);
			if (gltfAccessor.hasOwnProperty('bufferView')) {
				var baseAccessor = {
					bufferView: gltfAccessor.bufferView,
					byteOffset: gltfAccessor.byteOffset,
					componentType: gltfAccessor.componentType,
					count: gltfAccessor.count,
					type: gltfAccessor.type
				};
				result = _getAccessorData(baseAccessor, bufferViews, true).slice();
			} else {
				result = new dataType(gltfAccessor.count * numComponents);
			}
			for (var i = 0; i < sparse.count; ++i) {
				var targetIndex = indices[i];
				for (var j = 0; j < numComponents; ++j) {
					result[targetIndex * numComponents + j] = values[i * numComponents + j];
				}
			}
		} else {
			if (gltfAccessor.hasOwnProperty('bufferView')) {
				var bufferView = bufferViews[gltfAccessor.bufferView];
				if (flatten && bufferView.hasOwnProperty('byteStride')) {
					var bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
					var storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
					var tmpArray = new Uint8Array(storage);
					var dstOffset = 0;
					for (var _i = 0; _i < gltfAccessor.count; ++_i) {
						var srcOffset = (gltfAccessor.byteOffset || 0) + _i * bufferView.byteStride;
						for (var b = 0; b < bytesPerElement; ++b) {
							tmpArray[dstOffset++] = bufferView[srcOffset++];
						}
					}
					result = new dataType(storage);
				} else {
					result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
				}
			} else {
				result = new dataType(gltfAccessor.count * numComponents);
			}
		}
		return result;
	};
	var getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {
		var data = _getAccessorData(gltfAccessor, bufferViews, true);
		if (data instanceof Float32Array || !gltfAccessor.normalized) {
			return data;
		}
		var float32Data = new Float32Array(data.length);
		dequantizeArray(float32Data, data, getComponentType$1(gltfAccessor.componentType));
		return float32Data;
	};
	var getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {
		var min = gltfAccessor.min;
		var max = gltfAccessor.max;
		if (!min || !max) {
			return null;
		}
		if (gltfAccessor.normalized) {
			var ctype = getComponentType$1(gltfAccessor.componentType);
			min = dequantizeArray([], min, ctype);
			max = dequantizeArray([], max, ctype);
		}
		return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
	};
	var getPrimitiveType = function getPrimitiveType(primitive) {
		if (!primitive.hasOwnProperty('mode')) {
			return PRIMITIVE_TRIANGLES;
		}
		switch (primitive.mode) {
			case 0:
				return PRIMITIVE_POINTS;
			case 1:
				return PRIMITIVE_LINES;
			case 2:
				return PRIMITIVE_LINELOOP;
			case 3:
				return PRIMITIVE_LINESTRIP;
			case 4:
				return PRIMITIVE_TRIANGLES;
			case 5:
				return PRIMITIVE_TRISTRIP;
			case 6:
				return PRIMITIVE_TRIFAN;
			default:
				return PRIMITIVE_TRIANGLES;
		}
	};
	var generateIndices = function generateIndices(numVertices) {
		var dummyIndices = new Uint16Array(numVertices);
		for (var i = 0; i < numVertices; i++) {
			dummyIndices[i] = i;
		}
		return dummyIndices;
	};
	var generateNormals = function generateNormals(sourceDesc, indices) {
		var p = sourceDesc[SEMANTIC_POSITION];
		if (!p || p.components !== 3) {
			return;
		}
		var positions;
		if (p.size !== p.stride) {
			var srcStride = p.stride / typedArrayTypesByteSize[p.type];
			var src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
			positions = new typedArrayTypes[p.type](p.count * 3);
			for (var i = 0; i < p.count; ++i) {
				positions[i * 3 + 0] = src[i * srcStride + 0];
				positions[i * 3 + 1] = src[i * srcStride + 1];
				positions[i * 3 + 2] = src[i * srcStride + 2];
			}
		} else {
			positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
		}
		var numVertices = p.count;
		if (!indices) {
			indices = generateIndices(numVertices);
		}
		var normalsTemp = calculateNormals(positions, indices);
		var normals = new Float32Array(normalsTemp.length);
		normals.set(normalsTemp);
		sourceDesc[SEMANTIC_NORMAL] = {
			buffer: normals.buffer,
			size: 12,
			offset: 0,
			stride: 12,
			count: numVertices,
			components: 3,
			type: TYPE_FLOAT32
		};
	};
	var cloneTexture = function cloneTexture(texture) {
		var shallowCopyLevels = function shallowCopyLevels(texture) {
			var result = [];
			for (var mip = 0; mip < texture._levels.length; ++mip) {
				var level = [];
				if (texture.cubemap) {
					for (var face = 0; face < 6; ++face) {
						level.push(texture._levels[mip][face]);
					}
				} else {
					level = texture._levels[mip];
				}
				result.push(level);
			}
			return result;
		};
		var result = new Texture(texture.device, texture);
		result._levels = shallowCopyLevels(texture);
		return result;
	};
	var cloneTextureAsset = function cloneTextureAsset(src) {
		var result = new Asset(src.name + "_clone", src.type, src.file, src.data, src.options);
		result.loaded = true;
		result.resource = cloneTexture(src.resource);
		src.registry.add(result);
		return result;
	};
	var createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc) {
		var positionDesc = sourceDesc[SEMANTIC_POSITION];
		if (!positionDesc) {
			return null;
		}
		var numVertices = positionDesc.count;
		var vertexDesc = [];
		for (var semantic in sourceDesc) {
			if (sourceDesc.hasOwnProperty(semantic)) {
				var element = {
					semantic: semantic,
					components: sourceDesc[semantic].components,
					type: sourceDesc[semantic].type,
					normalize: !!sourceDesc[semantic].normalize
				};
				if (!VertexFormat.isElementValid(device, element)) {
					element.components++;
				}
				vertexDesc.push(element);
			}
		}
		vertexDesc.sort(function (lhs, rhs) {
			return attributeOrder[lhs.semantic] - attributeOrder[rhs.semantic];
		});
		var i, j, k;
		var source, target, sourceOffset;
		var vertexFormat = new VertexFormat(device, vertexDesc);
		var isCorrectlyInterleaved = true;
		for (i = 0; i < vertexFormat.elements.length; ++i) {
			target = vertexFormat.elements[i];
			source = sourceDesc[target.name];
			sourceOffset = source.offset - positionDesc.offset;
			if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
				isCorrectlyInterleaved = false;
				break;
			}
		}
		var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices);
		var vertexData = vertexBuffer.lock();
		var targetArray = new Uint32Array(vertexData);
		var sourceArray;
		if (isCorrectlyInterleaved) {
			sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
			targetArray.set(sourceArray);
		} else {
			var targetStride, sourceStride;
			for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
				target = vertexBuffer.format.elements[i];
				targetStride = target.stride / 4;
				source = sourceDesc[target.name];
				sourceStride = source.stride / 4;
				sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
				var src = 0;
				var dst = target.offset / 4;
				var kend = Math.floor((source.size + 3) / 4);
				for (j = 0; j < numVertices; ++j) {
					for (k = 0; k < kend; ++k) {
						targetArray[dst + k] = sourceArray[src + k];
					}
					src += sourceStride;
					dst += targetStride;
				}
			}
		}
		vertexBuffer.unlock();
		return vertexBuffer;
	};
	var createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, vertexBufferDict) {
		var useAttributes = {};
		var attribIds = [];
		for (var attrib in attributes) {
			if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
				useAttributes[attrib] = attributes[attrib];
				attribIds.push(attrib + ":" + attributes[attrib]);
			}
		}
		attribIds.sort();
		var vbKey = attribIds.join();
		var vb = vertexBufferDict[vbKey];
		if (!vb) {
			var sourceDesc = {};
			for (var _attrib in useAttributes) {
				var accessor = accessors[attributes[_attrib]];
				var accessorData = _getAccessorData(accessor, bufferViews);
				var bufferView = bufferViews[accessor.bufferView];
				var semantic = gltfToEngineSemanticMap[_attrib];
				var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
				var stride = bufferView && bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
				sourceDesc[semantic] = {
					buffer: accessorData.buffer,
					size: size,
					offset: accessorData.byteOffset,
					stride: stride,
					count: accessor.count,
					components: getNumComponents(accessor.type),
					type: getComponentType$1(accessor.componentType),
					normalize: accessor.normalized
				};
			}
			if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
				generateNormals(sourceDesc, indices);
			}
			vb = createVertexBufferInternal(device, sourceDesc);
			vertexBufferDict[vbKey] = vb;
		}
		return vb;
	};
	var createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {
		var i, j, bindMatrix;
		var joints = gltfSkin.joints;
		var numJoints = joints.length;
		var ibp = [];
		if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
			var inverseBindMatrices = gltfSkin.inverseBindMatrices;
			var ibmData = _getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
			var ibmValues = [];
			for (i = 0; i < numJoints; i++) {
				for (j = 0; j < 16; j++) {
					ibmValues[j] = ibmData[i * 16 + j];
				}
				bindMatrix = new Mat4();
				bindMatrix.set(ibmValues);
				ibp.push(bindMatrix);
			}
		} else {
			for (i = 0; i < numJoints; i++) {
				bindMatrix = new Mat4();
				ibp.push(bindMatrix);
			}
		}
		var boneNames = [];
		for (i = 0; i < numJoints; i++) {
			boneNames[i] = nodes[joints[i]].name;
		}
		var key = boneNames.join('#');
		var skin = glbSkins.get(key);
		if (!skin) {
			skin = new Skin(device, ibp, boneNames);
			glbSkins.set(key, skin);
		}
		return skin;
	};
	var createDracoMesh = function createDracoMesh(device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises) {
		var _primitive$extensions;
		var result = new Mesh(device);
		result.aabb = getAccessorBoundingBox(accessors[primitive.attributes.POSITION]);
		var vertexDesc = [];
		for (var _i2 = 0, _Object$entries = Object.entries(primitive.attributes); _i2 < _Object$entries.length; _i2++) {
			var _accessor$normalized;
			var _Object$entries$_i = _Object$entries[_i2],
				name = _Object$entries$_i[0],
				index = _Object$entries$_i[1];
			var accessor = accessors[index];
			var semantic = gltfToEngineSemanticMap[name];
			var componentType = getComponentType$1(accessor.componentType);
			vertexDesc.push({
				semantic: semantic,
				components: getNumComponents(accessor.type),
				type: componentType,
				normalize: (_accessor$normalized = accessor.normalized) != null ? _accessor$normalized : semantic === SEMANTIC_COLOR && (componentType === TYPE_UINT8 || componentType === TYPE_UINT16)
			});
		}
		promises.push(new Promise(function (resolve, reject) {
			var dracoExt = primitive.extensions.KHR_draco_mesh_compression;
			dracoDecode(bufferViews[dracoExt.bufferView].slice().buffer, function (err, decompressedData) {
				if (err) {
					console.log(err);
					reject(err);
				} else {
					var _primitive$attributes;
					var order = {};
					for (var _i3 = 0, _Object$entries2 = Object.entries(dracoExt.attributes); _i3 < _Object$entries2.length; _i3++) {
						var _Object$entries2$_i = _Object$entries2[_i3],
							_name = _Object$entries2$_i[0],
							_index = _Object$entries2$_i[1];
						order[gltfToEngineSemanticMap[_name]] = decompressedData.attributes.indexOf(_index);
					}
					vertexDesc.sort(function (a, b) {
						return order[a.semantic] - order[b.semantic];
					});
					if (!((_primitive$attributes = primitive.attributes) != null && _primitive$attributes.NORMAL)) {
						vertexDesc.splice(1, 0, {
							semantic: 'NORMAL',
							components: 3,
							type: TYPE_FLOAT32
						});
					}
					var vertexFormat = new VertexFormat(device, vertexDesc);
					var numVertices = decompressedData.vertices.byteLength / vertexFormat.size;
					var indexFormat = numVertices <= 65535 ? INDEXFORMAT_UINT16 : INDEXFORMAT_UINT32;
					var numIndices = decompressedData.indices.byteLength / (numVertices <= 65535 ? 2 : 4);
					var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, {
						data: decompressedData.vertices
					});
					var indexBuffer = new IndexBuffer(device, indexFormat, numIndices, BUFFER_STATIC, decompressedData.indices);
					result.vertexBuffer = vertexBuffer;
					result.indexBuffer[0] = indexBuffer;
					result.primitive[0].type = getPrimitiveType(primitive);
					result.primitive[0].base = 0;
					result.primitive[0].count = indexBuffer ? numIndices : numVertices;
					result.primitive[0].indexed = !!indexBuffer;
					resolve();
				}
			});
		}));
		if (primitive != null && (_primitive$extensions = primitive.extensions) != null && _primitive$extensions.KHR_materials_variants) {
			var variants = primitive.extensions.KHR_materials_variants;
			var tempMapping = {};
			variants.mappings.forEach(function (mapping) {
				mapping.variants.forEach(function (variant) {
					tempMapping[variant] = mapping.material;
				});
			});
			meshVariants[result.id] = tempMapping;
		}
		meshDefaultMaterials[result.id] = primitive.material;
		return result;
	};
	var createMesh$1 = function createMesh(device, gltfMesh, accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, assetOptions, promises) {
		var meshes = [];
		gltfMesh.primitives.forEach(function (primitive) {
			var _primitive$extensions2;
			if ((_primitive$extensions2 = primitive.extensions) != null && _primitive$extensions2.KHR_draco_mesh_compression) {
				meshes.push(createDracoMesh(device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises));
			} else {
				var indices = primitive.hasOwnProperty('indices') ? _getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
				var vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, vertexBufferDict);
				var primitiveType = getPrimitiveType(primitive);
				var mesh = new Mesh(device);
				mesh.vertexBuffer = vertexBuffer;
				mesh.primitive[0].type = primitiveType;
				mesh.primitive[0].base = 0;
				mesh.primitive[0].indexed = indices !== null;
				if (indices !== null) {
					var indexFormat;
					if (indices instanceof Uint8Array) {
						indexFormat = INDEXFORMAT_UINT8;
					} else if (indices instanceof Uint16Array) {
						indexFormat = INDEXFORMAT_UINT16;
					} else {
						indexFormat = INDEXFORMAT_UINT32;
					}
					if (indexFormat === INDEXFORMAT_UINT8 && device.isWebGPU) {
						indexFormat = INDEXFORMAT_UINT16;
						indices = new Uint16Array(indices);
					}
					var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
					mesh.indexBuffer[0] = indexBuffer;
					mesh.primitive[0].count = indices.length;
				} else {
					mesh.primitive[0].count = vertexBuffer.numVertices;
				}
				if (primitive.hasOwnProperty('extensions') && primitive.extensions.hasOwnProperty('KHR_materials_variants')) {
					var variants = primitive.extensions.KHR_materials_variants;
					var tempMapping = {};
					variants.mappings.forEach(function (mapping) {
						mapping.variants.forEach(function (variant) {
							tempMapping[variant] = mapping.material;
						});
					});
					meshVariants[mesh.id] = tempMapping;
				}
				meshDefaultMaterials[mesh.id] = primitive.material;
				var accessor = accessors[primitive.attributes.POSITION];
				mesh.aabb = getAccessorBoundingBox(accessor);
				if (primitive.hasOwnProperty('targets')) {
					var targets = [];
					primitive.targets.forEach(function (target, index) {
						var options = {};
						if (target.hasOwnProperty('POSITION')) {
							accessor = accessors[target.POSITION];
							options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
							options.aabb = getAccessorBoundingBox(accessor);
						}
						if (target.hasOwnProperty('NORMAL')) {
							accessor = accessors[target.NORMAL];
							options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
						}
						if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
							options.name = gltfMesh.extras.targetNames[index];
						} else {
							options.name = index.toString(10);
						}
						if (gltfMesh.hasOwnProperty('weights')) {
							options.defaultWeight = gltfMesh.weights[index];
						}
						options.preserveData = assetOptions.morphPreserveData;
						targets.push(new MorphTarget(options));
					});
					mesh.morph = new Morph(targets, device, {
						preferHighPrecision: assetOptions.morphPreferHighPrecision
					});
				}
				meshes.push(mesh);
			}
		});
		return meshes;
	};
	var extractTextureTransform = function extractTextureTransform(source, material, maps) {
		var _source$extensions;
		var map;
		var texCoord = source.texCoord;
		if (texCoord) {
			for (map = 0; map < maps.length; ++map) {
				material[maps[map] + "MapUv"] = texCoord;
			}
		}
		var zeros = [0, 0];
		var ones = [1, 1];
		var textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;
		if (textureTransform) {
			var offset = textureTransform.offset || zeros;
			var scale = textureTransform.scale || ones;
			var rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
			var tilingVec = new Vec2(scale[0], scale[1]);
			var offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);
			for (map = 0; map < maps.length; ++map) {
				material[maps[map] + "MapTiling"] = tilingVec;
				material[maps[map] + "MapOffset"] = offsetVec;
				material[maps[map] + "MapRotation"] = rotation;
			}
		}
	};
	var extensionPbrSpecGlossiness = function extensionPbrSpecGlossiness(data, material, textures) {
		var color, texture;
		if (data.hasOwnProperty('diffuseFactor')) {
			color = data.diffuseFactor;
			material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
			material.opacity = color[3];
		} else {
			material.diffuse.set(1, 1, 1);
			material.opacity = 1;
		}
		if (data.hasOwnProperty('diffuseTexture')) {
			var diffuseTexture = data.diffuseTexture;
			texture = textures[diffuseTexture.index];
			material.diffuseMap = texture;
			material.diffuseMapChannel = 'rgb';
			material.opacityMap = texture;
			material.opacityMapChannel = 'a';
			extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
		}
		material.useMetalness = false;
		if (data.hasOwnProperty('specularFactor')) {
			color = data.specularFactor;
			material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.specular.set(1, 1, 1);
		}
		if (data.hasOwnProperty('glossinessFactor')) {
			material.gloss = data.glossinessFactor;
		} else {
			material.gloss = 1.0;
		}
		if (data.hasOwnProperty('specularGlossinessTexture')) {
			var specularGlossinessTexture = data.specularGlossinessTexture;
			material.specularEncoding = 'srgb';
			material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
			material.specularMapChannel = 'rgb';
			material.glossMapChannel = 'a';
			extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
		}
	};
	var extensionClearCoat = function extensionClearCoat(data, material, textures) {
		if (data.hasOwnProperty('clearcoatFactor')) {
			material.clearCoat = data.clearcoatFactor * 0.25;
		} else {
			material.clearCoat = 0;
		}
		if (data.hasOwnProperty('clearcoatTexture')) {
			var clearcoatTexture = data.clearcoatTexture;
			material.clearCoatMap = textures[clearcoatTexture.index];
			material.clearCoatMapChannel = 'r';
			extractTextureTransform(clearcoatTexture, material, ['clearCoat']);
		}
		if (data.hasOwnProperty('clearcoatRoughnessFactor')) {
			material.clearCoatGloss = data.clearcoatRoughnessFactor;
		} else {
			material.clearCoatGloss = 0;
		}
		if (data.hasOwnProperty('clearcoatRoughnessTexture')) {
			var clearcoatRoughnessTexture = data.clearcoatRoughnessTexture;
			material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
			material.clearCoatGlossMapChannel = 'g';
			extractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);
		}
		if (data.hasOwnProperty('clearcoatNormalTexture')) {
			var clearcoatNormalTexture = data.clearcoatNormalTexture;
			material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
			extractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);
			if (clearcoatNormalTexture.hasOwnProperty('scale')) {
				material.clearCoatBumpiness = clearcoatNormalTexture.scale;
			}
		}
		material.clearCoatGlossInvert = true;
	};
	var extensionUnlit = function extensionUnlit(data, material, textures) {
		material.useLighting = false;
		material.emissive.copy(material.diffuse);
		material.emissiveMap = material.diffuseMap;
		material.emissiveMapUv = material.diffuseMapUv;
		material.emissiveMapTiling.copy(material.diffuseMapTiling);
		material.emissiveMapOffset.copy(material.diffuseMapOffset);
		material.emissiveMapRotation = material.diffuseMapRotation;
		material.emissiveMapChannel = material.diffuseMapChannel;
		material.emissiveVertexColor = material.diffuseVertexColor;
		material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
		material.useLighting = false;
		material.useSkybox = false;
		material.diffuse.set(1, 1, 1);
		material.diffuseMap = null;
		material.diffuseVertexColor = false;
	};
	var extensionSpecular = function extensionSpecular(data, material, textures) {
		material.useMetalnessSpecularColor = true;
		if (data.hasOwnProperty('specularColorTexture')) {
			material.specularEncoding = 'srgb';
			material.specularMap = textures[data.specularColorTexture.index];
			material.specularMapChannel = 'rgb';
			extractTextureTransform(data.specularColorTexture, material, ['specular']);
		}
		if (data.hasOwnProperty('specularColorFactor')) {
			var color = data.specularColorFactor;
			material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.specular.set(1, 1, 1);
		}
		if (data.hasOwnProperty('specularFactor')) {
			material.specularityFactor = data.specularFactor;
		} else {
			material.specularityFactor = 1;
		}
		if (data.hasOwnProperty('specularTexture')) {
			material.specularityFactorMapChannel = 'a';
			material.specularityFactorMap = textures[data.specularTexture.index];
			extractTextureTransform(data.specularTexture, material, ['specularityFactor']);
		}
	};
	var extensionIor = function extensionIor(data, material, textures) {
		if (data.hasOwnProperty('ior')) {
			material.refractionIndex = 1.0 / data.ior;
		}
	};
	var extensionDispersion = function extensionDispersion(data, material, textures) {
		if (data.hasOwnProperty('dispersion')) {
			material.dispersion = data.dispersion;
		}
	};
	var extensionTransmission = function extensionTransmission(data, material, textures) {
		material.blendType = BLEND_NORMAL;
		material.useDynamicRefraction = true;
		if (data.hasOwnProperty('transmissionFactor')) {
			material.refraction = data.transmissionFactor;
		}
		if (data.hasOwnProperty('transmissionTexture')) {
			material.refractionMapChannel = 'r';
			material.refractionMap = textures[data.transmissionTexture.index];
			extractTextureTransform(data.transmissionTexture, material, ['refraction']);
		}
	};
	var extensionSheen = function extensionSheen(data, material, textures) {
		material.useSheen = true;
		if (data.hasOwnProperty('sheenColorFactor')) {
			var color = data.sheenColorFactor;
			material.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		} else {
			material.sheen.set(1, 1, 1);
		}
		if (data.hasOwnProperty('sheenColorTexture')) {
			material.sheenMap = textures[data.sheenColorTexture.index];
			material.sheenEncoding = 'srgb';
			extractTextureTransform(data.sheenColorTexture, material, ['sheen']);
		}
		material.sheenGloss = data.hasOwnProperty('sheenRoughnessFactor') ? data.sheenRoughnessFactor : 0.0;
		if (data.hasOwnProperty('sheenRoughnessTexture')) {
			material.sheenGlossMap = textures[data.sheenRoughnessTexture.index];
			material.sheenGlossMapChannel = 'a';
			extractTextureTransform(data.sheenRoughnessTexture, material, ['sheenGloss']);
		}
		material.sheenGlossInvert = true;
	};
	var extensionVolume = function extensionVolume(data, material, textures) {
		material.blendType = BLEND_NORMAL;
		material.useDynamicRefraction = true;
		if (data.hasOwnProperty('thicknessFactor')) {
			material.thickness = data.thicknessFactor;
		}
		if (data.hasOwnProperty('thicknessTexture')) {
			material.thicknessMap = textures[data.thicknessTexture.index];
			material.thicknessMapChannel = 'g';
			extractTextureTransform(data.thicknessTexture, material, ['thickness']);
		}
		if (data.hasOwnProperty('attenuationDistance')) {
			material.attenuationDistance = data.attenuationDistance;
		}
		if (data.hasOwnProperty('attenuationColor')) {
			var color = data.attenuationColor;
			material.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		}
	};
	var extensionEmissiveStrength = function extensionEmissiveStrength(data, material, textures) {
		if (data.hasOwnProperty('emissiveStrength')) {
			material.emissiveIntensity = data.emissiveStrength;
		}
	};
	var extensionIridescence = function extensionIridescence(data, material, textures) {
		material.useIridescence = true;
		if (data.hasOwnProperty('iridescenceFactor')) {
			material.iridescence = data.iridescenceFactor;
		}
		if (data.hasOwnProperty('iridescenceTexture')) {
			material.iridescenceMapChannel = 'r';
			material.iridescenceMap = textures[data.iridescenceTexture.index];
			extractTextureTransform(data.iridescenceTexture, material, ['iridescence']);
		}
		if (data.hasOwnProperty('iridescenceIor')) {
			material.iridescenceRefractionIndex = data.iridescenceIor;
		}
		if (data.hasOwnProperty('iridescenceThicknessMinimum')) {
			material.iridescenceThicknessMin = data.iridescenceThicknessMinimum;
		}
		if (data.hasOwnProperty('iridescenceThicknessMaximum')) {
			material.iridescenceThicknessMax = data.iridescenceThicknessMaximum;
		}
		if (data.hasOwnProperty('iridescenceThicknessTexture')) {
			material.iridescenceThicknessMapChannel = 'g';
			material.iridescenceThicknessMap = textures[data.iridescenceThicknessTexture.index];
			extractTextureTransform(data.iridescenceThicknessTexture, material, ['iridescenceThickness']);
		}
	};
	var createMaterial = function createMaterial(gltfMaterial, textures) {
		var material = new StandardMaterial();
		if (gltfMaterial.hasOwnProperty('name')) {
			material.name = gltfMaterial.name;
		}
		material.occludeSpecular = SPECOCC_AO;
		material.diffuseVertexColor = true;
		material.specularTint = true;
		material.specularVertexColor = true;
		material.specular.set(1, 1, 1);
		material.gloss = 1;
		material.glossInvert = true;
		material.useMetalness = true;
		var color, texture;
		if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
			var pbrData = gltfMaterial.pbrMetallicRoughness;
			if (pbrData.hasOwnProperty('baseColorFactor')) {
				color = pbrData.baseColorFactor;
				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
				material.opacity = color[3];
			}
			if (pbrData.hasOwnProperty('baseColorTexture')) {
				var baseColorTexture = pbrData.baseColorTexture;
				texture = textures[baseColorTexture.index];
				material.diffuseMap = texture;
				material.diffuseMapChannel = 'rgb';
				material.opacityMap = texture;
				material.opacityMapChannel = 'a';
				extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
			}
			if (pbrData.hasOwnProperty('metallicFactor')) {
				material.metalness = pbrData.metallicFactor;
			}
			if (pbrData.hasOwnProperty('roughnessFactor')) {
				material.gloss = pbrData.roughnessFactor;
			}
			if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
				var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
				material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
				material.metalnessMapChannel = 'b';
				material.glossMapChannel = 'g';
				extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
			}
		}
		if (gltfMaterial.hasOwnProperty('normalTexture')) {
			var normalTexture = gltfMaterial.normalTexture;
			material.normalMap = textures[normalTexture.index];
			extractTextureTransform(normalTexture, material, ['normal']);
			if (normalTexture.hasOwnProperty('scale')) {
				material.bumpiness = normalTexture.scale;
			}
		}
		if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
			var occlusionTexture = gltfMaterial.occlusionTexture;
			material.aoMap = textures[occlusionTexture.index];
			material.aoMapChannel = 'r';
			extractTextureTransform(occlusionTexture, material, ['ao']);
		}
		if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
			color = gltfMaterial.emissiveFactor;
			material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
		}
		if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
			var emissiveTexture = gltfMaterial.emissiveTexture;
			material.emissiveMap = textures[emissiveTexture.index];
			extractTextureTransform(emissiveTexture, material, ['emissive']);
		}
		if (gltfMaterial.hasOwnProperty('alphaMode')) {
			switch (gltfMaterial.alphaMode) {
				case 'MASK':
					material.blendType = BLEND_NONE;
					if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
						material.alphaTest = gltfMaterial.alphaCutoff;
					} else {
						material.alphaTest = 0.5;
					}
					break;
				case 'BLEND':
					material.blendType = BLEND_NORMAL;
					material.depthWrite = false;
					break;
				default:
				case 'OPAQUE':
					material.blendType = BLEND_NONE;
					break;
			}
		} else {
			material.blendType = BLEND_NONE;
		}
		if (gltfMaterial.hasOwnProperty('doubleSided')) {
			material.twoSidedLighting = gltfMaterial.doubleSided;
			material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
		} else {
			material.twoSidedLighting = false;
			material.cull = CULLFACE_BACK;
		}
		var extensions = {
			'KHR_materials_clearcoat': extensionClearCoat,
			'KHR_materials_emissive_strength': extensionEmissiveStrength,
			'KHR_materials_ior': extensionIor,
			'KHR_materials_dispersion': extensionDispersion,
			'KHR_materials_iridescence': extensionIridescence,
			'KHR_materials_pbrSpecularGlossiness': extensionPbrSpecGlossiness,
			'KHR_materials_sheen': extensionSheen,
			'KHR_materials_specular': extensionSpecular,
			'KHR_materials_transmission': extensionTransmission,
			'KHR_materials_unlit': extensionUnlit,
			'KHR_materials_volume': extensionVolume
		};
		if (gltfMaterial.hasOwnProperty('extensions')) {
			for (var key in gltfMaterial.extensions) {
				var extensionFunc = extensions[key];
				if (extensionFunc !== undefined) {
					extensionFunc(gltfMaterial.extensions[key], material, textures);
				}
			}
		}
		material.update();
		return material;
	};
	var createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes, gltfNodes) {
		var createAnimData = function createAnimData(gltfAccessor) {
			return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
		};
		var interpMap = {
			'STEP': INTERPOLATION_STEP,
			'LINEAR': INTERPOLATION_LINEAR,
			'CUBICSPLINE': INTERPOLATION_CUBIC
		};
		var inputMap = {};
		var outputMap = {};
		var curveMap = {};
		var outputCounter = 1;
		var i;
		for (i = 0; i < gltfAnimation.samplers.length; ++i) {
			var sampler = gltfAnimation.samplers[i];
			if (!inputMap.hasOwnProperty(sampler.input)) {
				inputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);
			}
			if (!outputMap.hasOwnProperty(sampler.output)) {
				outputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);
			}
			var interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
			var curve = {
				paths: [],
				input: sampler.input,
				output: sampler.output,
				interpolation: interpolation
			};
			curveMap[i] = curve;
		}
		var quatArrays = [];
		var transformSchema = {
			'translation': 'localPosition',
			'rotation': 'localRotation',
			'scale': 'localScale'
		};
		var constructNodePath = function constructNodePath(node) {
			var path = [];
			while (node) {
				path.unshift(node.name);
				node = node.parent;
			}
			return path;
		};
		var createMorphTargetCurves = function createMorphTargetCurves(curve, gltfNode, entityPath) {
			var out = outputMap[curve.output];
			if (!out) {
				return;
			}
			var targetNames;
			if (meshes && meshes[gltfNode.mesh]) {
				var mesh = meshes[gltfNode.mesh];
				if (mesh.hasOwnProperty('extras') && mesh.extras.hasOwnProperty('targetNames')) {
					targetNames = mesh.extras.targetNames;
				}
			}
			var outData = out.data;
			var morphTargetCount = outData.length / inputMap[curve.input].data.length;
			var keyframeCount = outData.length / morphTargetCount;
			var singleBufferSize = keyframeCount * 4;
			var buffer = new ArrayBuffer(singleBufferSize * morphTargetCount);
			for (var j = 0; j < morphTargetCount; j++) {
				var _targetNames;
				var morphTargetOutput = new Float32Array(buffer, singleBufferSize * j, keyframeCount);
				for (var k = 0; k < keyframeCount; k++) {
					morphTargetOutput[k] = outData[k * morphTargetCount + j];
				}
				var output = new AnimData(1, morphTargetOutput);
				var weightName = (_targetNames = targetNames) != null && _targetNames[j] ? "name." + targetNames[j] : j;
				outputMap[-outputCounter] = output;
				var morphCurve = {
					paths: [{
						entityPath: entityPath,
						component: 'graph',
						propertyPath: ["weight." + weightName]
					}],
					input: curve.input,
					output: -outputCounter,
					interpolation: curve.interpolation
				};
				outputCounter++;
				curveMap["morphCurve-" + i + "-" + j] = morphCurve;
			}
		};
		for (i = 0; i < gltfAnimation.channels.length; ++i) {
			var channel = gltfAnimation.channels[i];
			var target = channel.target;
			var _curve = curveMap[channel.sampler];
			var node = nodes[target.node];
			var gltfNode = gltfNodes[target.node];
			var entityPath = constructNodePath(node);
			if (target.path.startsWith('weights')) {
				createMorphTargetCurves(_curve, gltfNode, entityPath);
				curveMap[channel.sampler].morphCurve = true;
			} else {
				_curve.paths.push({
					entityPath: entityPath,
					component: 'graph',
					propertyPath: [transformSchema[target.path]]
				});
			}
		}
		var inputs = [];
		var outputs = [];
		var curves = [];
		for (var inputKey in inputMap) {
			inputs.push(inputMap[inputKey]);
			inputMap[inputKey] = inputs.length - 1;
		}
		for (var outputKey in outputMap) {
			outputs.push(outputMap[outputKey]);
			outputMap[outputKey] = outputs.length - 1;
		}
		for (var curveKey in curveMap) {
			var curveData = curveMap[curveKey];
			if (curveData.morphCurve) {
				continue;
			}
			curves.push(new AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));
			if (curveData.paths.length > 0 && curveData.paths[0].propertyPath[0] === 'localRotation' && curveData.interpolation !== INTERPOLATION_CUBIC) {
				quatArrays.push(curves[curves.length - 1].output);
			}
		}
		quatArrays.sort();
		var prevIndex = null;
		var data;
		for (i = 0; i < quatArrays.length; ++i) {
			var index = quatArrays[i];
			if (i === 0 || index !== prevIndex) {
				data = outputs[index];
				if (data.components === 4) {
					var d = data.data;
					var len = d.length - 4;
					for (var j = 0; j < len; j += 4) {
						var dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];
						if (dp < 0) {
							d[j + 4] *= -1;
							d[j + 5] *= -1;
							d[j + 6] *= -1;
							d[j + 7] *= -1;
						}
					}
				}
				prevIndex = index;
			}
		}
		var duration = 0;
		for (i = 0; i < inputs.length; i++) {
			data = inputs[i]._data;
			duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
		}
		return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : "animation_" + animationIndex, duration, inputs, outputs, curves);
	};
	var tempMat = new Mat4();
	var tempVec = new Vec3();
	var createNode = function createNode(gltfNode, nodeIndex, nodeInstancingMap) {
		var entity = new GraphNode();
		if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
			entity.name = gltfNode.name;
		} else {
			entity.name = "node_" + nodeIndex;
		}
		if (gltfNode.hasOwnProperty('matrix')) {
			tempMat.data.set(gltfNode.matrix);
			tempMat.getTranslation(tempVec);
			entity.setLocalPosition(tempVec);
			tempMat.getEulerAngles(tempVec);
			entity.setLocalEulerAngles(tempVec);
			tempMat.getScale(tempVec);
			entity.setLocalScale(tempVec);
		}
		if (gltfNode.hasOwnProperty('rotation')) {
			var r = gltfNode.rotation;
			entity.setLocalRotation(r[0], r[1], r[2], r[3]);
		}
		if (gltfNode.hasOwnProperty('translation')) {
			var t = gltfNode.translation;
			entity.setLocalPosition(t[0], t[1], t[2]);
		}
		if (gltfNode.hasOwnProperty('scale')) {
			var s = gltfNode.scale;
			entity.setLocalScale(s[0], s[1], s[2]);
		}
		if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.EXT_mesh_gpu_instancing) {
			nodeInstancingMap.set(gltfNode, {
				ext: gltfNode.extensions.EXT_mesh_gpu_instancing
			});
		}
		return entity;
	};
	var createCamera = function createCamera(gltfCamera, node) {
		var projection = gltfCamera.type === 'orthographic' ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
		var gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
		var componentData = {
			enabled: false,
			projection: projection,
			nearClip: gltfProperties.znear,
			aspectRatioMode: ASPECT_AUTO
		};
		if (gltfProperties.zfar) {
			componentData.farClip = gltfProperties.zfar;
		}
		if (projection === PROJECTION_ORTHOGRAPHIC) {
			componentData.orthoHeight = 0.5 * gltfProperties.ymag;
			if (gltfProperties.ymag) {
				componentData.aspectRatioMode = ASPECT_MANUAL;
				componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
			}
		} else {
			componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;
			if (gltfProperties.aspectRatio) {
				componentData.aspectRatioMode = ASPECT_MANUAL;
				componentData.aspectRatio = gltfProperties.aspectRatio;
			}
		}
		var cameraEntity = new Entity(gltfCamera.name);
		cameraEntity.addComponent('camera', componentData);
		return cameraEntity;
	};
	var createLight = function createLight(gltfLight, node) {
		var lightProps = {
			enabled: false,
			type: gltfLight.type === 'point' ? 'omni' : gltfLight.type,
			color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
			range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
			falloffMode: LIGHTFALLOFF_INVERSESQUARED,
			intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
		};
		if (gltfLight.hasOwnProperty('spot')) {
			lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
			lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
		}
		if (gltfLight.hasOwnProperty('intensity')) {
			lightProps.luminance = gltfLight.intensity * Light.getLightUnitConversion(lightTypes[lightProps.type], lightProps.outerConeAngle, lightProps.innerConeAngle);
		}
		var lightEntity = new Entity(node.name);
		lightEntity.rotateLocal(90, 0, 0);
		lightEntity.addComponent('light', lightProps);
		return lightEntity;
	};
	var createSkins = function createSkins(device, gltf, nodes, bufferViews) {
		if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
			return [];
		}
		var glbSkins = new Map();
		return gltf.skins.map(function (gltfSkin) {
			return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
		});
	};
	var createMeshes = function createMeshes(device, gltf, bufferViews, options) {
		var _gltf$meshes, _gltf$accessors, _gltf$bufferViews;
		var vertexBufferDict = {};
		var meshVariants = {};
		var meshDefaultMaterials = {};
		var promises = [];
		var valid = !options.skipMeshes && (gltf == null || (_gltf$meshes = gltf.meshes) == null ? void 0 : _gltf$meshes.length) && (gltf == null || (_gltf$accessors = gltf.accessors) == null ? void 0 : _gltf$accessors.length) && (gltf == null || (_gltf$bufferViews = gltf.bufferViews) == null ? void 0 : _gltf$bufferViews.length);
		var meshes = valid ? gltf.meshes.map(function (gltfMesh) {
			return createMesh$1(device, gltfMesh, gltf.accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, options, promises);
		}) : [];
		return {
			meshes: meshes,
			meshVariants: meshVariants,
			meshDefaultMaterials: meshDefaultMaterials,
			promises: promises
		};
	};
	var createMaterials = function createMaterials(gltf, textures, options) {
		var _options$material, _options$material$pro, _options$material2, _options$material3;
		if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$material = options.material) == null ? void 0 : _options$material.preprocess;
		var process = (_options$material$pro = options == null || (_options$material2 = options.material) == null ? void 0 : _options$material2.process) != null ? _options$material$pro : createMaterial;
		var postprocess = options == null || (_options$material3 = options.material) == null ? void 0 : _options$material3.postprocess;
		return gltf.materials.map(function (gltfMaterial) {
			if (preprocess) {
				preprocess(gltfMaterial);
			}
			var material = process(gltfMaterial, textures);
			if (postprocess) {
				postprocess(gltfMaterial, material);
			}
			return material;
		});
	};
	var createVariants = function createVariants(gltf) {
		if (!gltf.hasOwnProperty('extensions') || !gltf.extensions.hasOwnProperty('KHR_materials_variants')) {
			return null;
		}
		var data = gltf.extensions.KHR_materials_variants.variants;
		var variants = {};
		for (var i = 0; i < data.length; i++) {
			variants[data[i].name] = i;
		}
		return variants;
	};
	var createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {
		var _options$animation, _options$animation2;
		if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$animation = options.animation) == null ? void 0 : _options$animation.preprocess;
		var postprocess = options == null || (_options$animation2 = options.animation) == null ? void 0 : _options$animation2.postprocess;
		return gltf.animations.map(function (gltfAnimation, index) {
			if (preprocess) {
				preprocess(gltfAnimation);
			}
			var animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes, gltf.nodes);
			if (postprocess) {
				postprocess(gltfAnimation, animation);
			}
			return animation;
		});
	};
	var createInstancing = function createInstancing(device, gltf, nodeInstancingMap, bufferViews) {
		var accessors = gltf.accessors;
		nodeInstancingMap.forEach(function (data, entity) {
			var attributes = data.ext.attributes;
			var translations;
			if (attributes.hasOwnProperty('TRANSLATION')) {
				var accessor = accessors[attributes.TRANSLATION];
				translations = getAccessorDataFloat32(accessor, bufferViews);
			}
			var rotations;
			if (attributes.hasOwnProperty('ROTATION')) {
				var _accessor = accessors[attributes.ROTATION];
				rotations = getAccessorDataFloat32(_accessor, bufferViews);
			}
			var scales;
			if (attributes.hasOwnProperty('SCALE')) {
				var _accessor2 = accessors[attributes.SCALE];
				scales = getAccessorDataFloat32(_accessor2, bufferViews);
			}
			var instanceCount = (translations ? translations.length / 3 : 0) || (rotations ? rotations.length / 4 : 0) || (scales ? scales.length / 3 : 0);
			if (instanceCount) {
				var matrices = new Float32Array(instanceCount * 16);
				var pos = new Vec3();
				var rot = new Quat();
				var scl = new Vec3(1, 1, 1);
				var matrix = new Mat4();
				var matrixIndex = 0;
				for (var i = 0; i < instanceCount; i++) {
					var i3 = i * 3;
					if (translations) {
						pos.set(translations[i3], translations[i3 + 1], translations[i3 + 2]);
					}
					if (rotations) {
						var i4 = i * 4;
						rot.set(rotations[i4], rotations[i4 + 1], rotations[i4 + 2], rotations[i4 + 3]);
					}
					if (scales) {
						scl.set(scales[i3], scales[i3 + 1], scales[i3 + 2]);
					}
					matrix.setTRS(pos, rot, scl);
					for (var m = 0; m < 16; m++) {
						matrices[matrixIndex++] = matrix.data[m];
					}
				}
				data.matrices = matrices;
			}
		});
	};
	var createNodes = function createNodes(gltf, options, nodeInstancingMap) {
		var _options$node, _options$node$process, _options$node2, _options$node3;
		if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$node = options.node) == null ? void 0 : _options$node.preprocess;
		var process = (_options$node$process = options == null || (_options$node2 = options.node) == null ? void 0 : _options$node2.process) != null ? _options$node$process : createNode;
		var postprocess = options == null || (_options$node3 = options.node) == null ? void 0 : _options$node3.postprocess;
		var nodes = gltf.nodes.map(function (gltfNode, index) {
			if (preprocess) {
				preprocess(gltfNode);
			}
			var node = process(gltfNode, index, nodeInstancingMap);
			if (postprocess) {
				postprocess(gltfNode, node);
			}
			return node;
		});
		for (var i = 0; i < gltf.nodes.length; ++i) {
			var gltfNode = gltf.nodes[i];
			if (gltfNode.hasOwnProperty('children')) {
				var parent = nodes[i];
				var uniqueNames = {};
				for (var j = 0; j < gltfNode.children.length; ++j) {
					var child = nodes[gltfNode.children[j]];
					if (!child.parent) {
						if (uniqueNames.hasOwnProperty(child.name)) {
							child.name += uniqueNames[child.name]++;
						} else {
							uniqueNames[child.name] = 1;
						}
						parent.addChild(child);
					}
				}
			}
		}
		return nodes;
	};
	var createScenes = function createScenes(gltf, nodes) {
		var _gltf$scenes$0$nodes;
		var scenes = [];
		var count = gltf.scenes.length;
		if (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {
			var nodeIndex = gltf.scenes[0].nodes[0];
			scenes.push(nodes[nodeIndex]);
		} else {
			for (var i = 0; i < count; i++) {
				var scene = gltf.scenes[i];
				if (scene.nodes) {
					var sceneRoot = new GraphNode(scene.name);
					for (var n = 0; n < scene.nodes.length; n++) {
						var childNode = nodes[scene.nodes[n]];
						sceneRoot.addChild(childNode);
					}
					scenes.push(sceneRoot);
				}
			}
		}
		return scenes;
	};
	var createCameras = function createCameras(gltf, nodes, options) {
		var cameras = null;
		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
			var _options$camera, _options$camera$proce, _options$camera2, _options$camera3;
			var preprocess = options == null || (_options$camera = options.camera) == null ? void 0 : _options$camera.preprocess;
			var process = (_options$camera$proce = options == null || (_options$camera2 = options.camera) == null ? void 0 : _options$camera2.process) != null ? _options$camera$proce : createCamera;
			var postprocess = options == null || (_options$camera3 = options.camera) == null ? void 0 : _options$camera3.postprocess;
			gltf.nodes.forEach(function (gltfNode, nodeIndex) {
				if (gltfNode.hasOwnProperty('camera')) {
					var gltfCamera = gltf.cameras[gltfNode.camera];
					if (gltfCamera) {
						if (preprocess) {
							preprocess(gltfCamera);
						}
						var camera = process(gltfCamera, nodes[nodeIndex]);
						if (postprocess) {
							postprocess(gltfCamera, camera);
						}
						if (camera) {
							if (!cameras) cameras = new Map();
							cameras.set(gltfNode, camera);
						}
					}
				}
			});
		}
		return cameras;
	};
	var createLights = function createLights(gltf, nodes, options) {
		var lights = null;
		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
			var gltfLights = gltf.extensions.KHR_lights_punctual.lights;
			if (gltfLights.length) {
				var _options$light, _options$light$proces, _options$light2, _options$light3;
				var preprocess = options == null || (_options$light = options.light) == null ? void 0 : _options$light.preprocess;
				var process = (_options$light$proces = options == null || (_options$light2 = options.light) == null ? void 0 : _options$light2.process) != null ? _options$light$proces : createLight;
				var postprocess = options == null || (_options$light3 = options.light) == null ? void 0 : _options$light3.postprocess;
				gltf.nodes.forEach(function (gltfNode, nodeIndex) {
					if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
						var lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
						var gltfLight = gltfLights[lightIndex];
						if (gltfLight) {
							if (preprocess) {
								preprocess(gltfLight);
							}
							var light = process(gltfLight, nodes[nodeIndex]);
							if (postprocess) {
								postprocess(gltfLight, light);
							}
							if (light) {
								if (!lights) lights = new Map();
								lights.set(gltfNode, light);
							}
						}
					}
				});
			}
		}
		return lights;
	};
	var linkSkins = function linkSkins(gltf, renders, skins) {
		gltf.nodes.forEach(function (gltfNode) {
			if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
				var meshGroup = renders[gltfNode.mesh].meshes;
				meshGroup.forEach(function (mesh) {
					mesh.skin = skins[gltfNode.skin];
				});
			}
		});
	};
	var createResources = function () {
		var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(device, gltf, bufferViews, textures, options) {
			var _options$global, _options$global2;
			var preprocess, postprocess, nodeInstancingMap, nodes, scenes, lights, cameras, variants, bufferViewData, _createMeshes, meshes, meshVariants, meshDefaultMaterials, promises, animations, textureAssets, textureInstances, materials, skins, renders, i, result;
			return _regeneratorRuntime().wrap(function _callee$(_context) {
				while (1) switch (_context.prev = _context.next) {
					case 0:
						preprocess = options == null || (_options$global = options.global) == null ? void 0 : _options$global.preprocess;
						postprocess = options == null || (_options$global2 = options.global) == null ? void 0 : _options$global2.postprocess;
						if (preprocess) {
							preprocess(gltf);
						}
						if (gltf.asset && gltf.asset.generator === 'PlayCanvas') ;
						nodeInstancingMap = new Map();
						nodes = createNodes(gltf, options, nodeInstancingMap);
						scenes = createScenes(gltf, nodes);
						lights = createLights(gltf, nodes, options);
						cameras = createCameras(gltf, nodes, options);
						variants = createVariants(gltf);
						_context.next = 12;
						return Promise.all(bufferViews);
					case 12:
						bufferViewData = _context.sent;
						_createMeshes = createMeshes(device, gltf, bufferViewData, options), meshes = _createMeshes.meshes, meshVariants = _createMeshes.meshVariants, meshDefaultMaterials = _createMeshes.meshDefaultMaterials, promises = _createMeshes.promises;
						animations = createAnimations(gltf, nodes, bufferViewData, options);
						createInstancing(device, gltf, nodeInstancingMap, bufferViewData);
						_context.next = 18;
						return Promise.all(textures);
					case 18:
						textureAssets = _context.sent;
						textureInstances = textureAssets.map(function (t) {
							return t.resource;
						});
						materials = createMaterials(gltf, textureInstances, options);
						skins = createSkins(device, gltf, nodes, bufferViewData);
						renders = [];
						for (i = 0; i < meshes.length; i++) {
							renders[i] = new Render();
							renders[i].meshes = meshes[i];
						}
						linkSkins(gltf, renders, skins);
						result = new GlbResources();
						result.gltf = gltf;
						result.nodes = nodes;
						result.scenes = scenes;
						result.animations = animations;
						result.textures = textureAssets;
						result.materials = materials;
						result.variants = variants;
						result.meshVariants = meshVariants;
						result.meshDefaultMaterials = meshDefaultMaterials;
						result.renders = renders;
						result.skins = skins;
						result.lights = lights;
						result.cameras = cameras;
						result.nodeInstancingMap = nodeInstancingMap;
						if (postprocess) {
							postprocess(gltf, result);
						}
						_context.next = 43;
						return Promise.all(promises);
					case 43:
						return _context.abrupt("return", result);
					case 44:
					case "end":
						return _context.stop();
				}
			}, _callee);
		}));
		return function createResources(_x, _x2, _x3, _x4, _x5) {
			return _ref.apply(this, arguments);
		};
	}();
	var applySampler = function applySampler(texture, gltfSampler) {
		var getFilter = function getFilter(filter, defaultValue) {
			switch (filter) {
				case 9728:
					return FILTER_NEAREST;
				case 9729:
					return FILTER_LINEAR;
				case 9984:
					return FILTER_NEAREST_MIPMAP_NEAREST;
				case 9985:
					return FILTER_LINEAR_MIPMAP_NEAREST;
				case 9986:
					return FILTER_NEAREST_MIPMAP_LINEAR;
				case 9987:
					return FILTER_LINEAR_MIPMAP_LINEAR;
				default:
					return defaultValue;
			}
		};
		var getWrap = function getWrap(wrap, defaultValue) {
			switch (wrap) {
				case 33071:
					return ADDRESS_CLAMP_TO_EDGE;
				case 33648:
					return ADDRESS_MIRRORED_REPEAT;
				case 10497:
					return ADDRESS_REPEAT;
				default:
					return defaultValue;
			}
		};
		if (texture) {
			var _gltfSampler;
			gltfSampler = (_gltfSampler = gltfSampler) != null ? _gltfSampler : {};
			texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
			texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
			texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
			texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
		}
	};
	var gltfTextureUniqueId = 0;
	var getTextureSource = function getTextureSource(gltfTexture) {
		var _ref2, _gltfTexture$extensio, _gltfTexture$extensio2, _gltfTexture$extensio3;
		return (_ref2 = (_gltfTexture$extensio = (_gltfTexture$extensio2 = gltfTexture.extensions) == null || (_gltfTexture$extensio2 = _gltfTexture$extensio2.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source) != null ? _gltfTexture$extensio : (_gltfTexture$extensio3 = gltfTexture.extensions) == null || (_gltfTexture$extensio3 = _gltfTexture$extensio3.EXT_texture_webp) == null ? void 0 : _gltfTexture$extensio3.source) != null ? _ref2 : gltfTexture.source;
	};
	var createImages = function createImages(gltf, bufferViews, urlBase, registry, options) {
		var _options$image, _options$image2, _options$image3;
		if (!gltf.images || gltf.images.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$image = options.image) == null ? void 0 : _options$image.preprocess;
		var processAsync = options == null || (_options$image2 = options.image) == null ? void 0 : _options$image2.processAsync;
		var postprocess = options == null || (_options$image3 = options.image) == null ? void 0 : _options$image3.postprocess;
		var mimeTypeFileExtensions = {
			'image/png': 'png',
			'image/jpeg': 'jpg',
			'image/basis': 'basis',
			'image/ktx': 'ktx',
			'image/ktx2': 'ktx2',
			'image/vnd-ms.dds': 'dds'
		};
		var getGammaTextures = function getGammaTextures(gltf) {
			var set = new Set();
			if (gltf.hasOwnProperty('materials')) {
				gltf.materials.forEach(function (gltfMaterial) {
					if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
						var pbrData = gltfMaterial.pbrMetallicRoughness;
						if (pbrData.hasOwnProperty('baseColorTexture')) {
							var gltfTexture = gltf.textures[pbrData.baseColorTexture.index];
							set.add(getTextureSource(gltfTexture));
						}
					}
					if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
						var _gltfTexture = gltf.textures[gltfMaterial.emissiveTexture.index];
						set.add(getTextureSource(_gltfTexture));
					}
				});
			}
			return set;
		};
		var loadTexture = function loadTexture(gltfImage, url, bufferView, mimeType, options, srgb) {
			return new Promise(function (resolve, reject) {
				var continuation = function continuation(bufferViewData) {
					var name = (gltfImage.name || 'gltf-texture') + "-" + gltfTextureUniqueId++;
					var file = {
						url: url || name
					};
					if (bufferViewData) {
						file.contents = bufferViewData.slice(0).buffer;
					}
					if (mimeType) {
						var extension = mimeTypeFileExtensions[mimeType];
						if (extension) {
							file.filename = file.url + "." + extension;
						}
					}
					var data = {
						srgb: srgb
					};
					var asset = new Asset(name, 'texture', file, data, options);
					asset.on('load', function (asset) {
						return resolve(asset);
					});
					asset.on('error', function (err) {
						return reject(err);
					});
					registry.add(asset);
					registry.load(asset);
				};
				if (bufferView) {
					bufferView.then(function (bufferViewData) {
						return continuation(bufferViewData);
					});
				} else {
					continuation(null);
				}
			});
		};
		var gammaTextures = getGammaTextures(gltf);
		return gltf.images.map(function (gltfImage, i) {
			if (preprocess) {
				preprocess(gltfImage);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfImage, function (err, textureAsset) {
						if (err) {
							reject(err);
						} else {
							resolve(textureAsset);
						}
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (textureAsset) {
				var srgb = gammaTextures.has(i);
				if (textureAsset) {
					return textureAsset;
				} else if (gltfImage.hasOwnProperty('uri')) {
					if (isDataURI(gltfImage.uri)) {
						return loadTexture(gltfImage, gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null, srgb);
					}
					return loadTexture(gltfImage, ABSOLUTE_URL.test(gltfImage.uri) ? gltfImage.uri : path.join(urlBase, gltfImage.uri), null, null, {
						crossOrigin: 'anonymous'
					}, srgb);
				} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
					return loadTexture(gltfImage, null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null, srgb);
				}
				return Promise.reject(new Error("Invalid image found in gltf (neither uri or bufferView found). index=" + i));
			});
			if (postprocess) {
				promise = promise.then(function (textureAsset) {
					postprocess(gltfImage, textureAsset);
					return textureAsset;
				});
			}
			return promise;
		});
	};
	var createTextures = function createTextures(gltf, images, options) {
		var _gltf$images, _gltf$textures, _options$texture, _options$texture2, _options$texture3;
		if (!(gltf != null && (_gltf$images = gltf.images) != null && _gltf$images.length) || !(gltf != null && (_gltf$textures = gltf.textures) != null && _gltf$textures.length)) {
			return [];
		}
		var preprocess = options == null || (_options$texture = options.texture) == null ? void 0 : _options$texture.preprocess;
		var processAsync = options == null || (_options$texture2 = options.texture) == null ? void 0 : _options$texture2.processAsync;
		var postprocess = options == null || (_options$texture3 = options.texture) == null ? void 0 : _options$texture3.postprocess;
		var seenImages = new Set();
		return gltf.textures.map(function (gltfTexture) {
			if (preprocess) {
				preprocess(gltfTexture);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfTexture, gltf.images, function (err, gltfImageIndex) {
						if (err) {
							reject(err);
						} else {
							resolve(gltfImageIndex);
						}
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (gltfImageIndex) {
				var _gltfImageIndex;
				gltfImageIndex = (_gltfImageIndex = gltfImageIndex) != null ? _gltfImageIndex : getTextureSource(gltfTexture);
				var cloneAsset = seenImages.has(gltfImageIndex);
				seenImages.add(gltfImageIndex);
				return images[gltfImageIndex].then(function (imageAsset) {
					var _gltf$samplers;
					var asset = cloneAsset ? cloneTextureAsset(imageAsset) : imageAsset;
					applySampler(asset.resource, ((_gltf$samplers = gltf.samplers) != null ? _gltf$samplers : [])[gltfTexture.sampler]);
					return asset;
				});
			});
			if (postprocess) {
				promise = promise.then(function (textureAsset) {
					postprocess(gltfTexture, textureAsset);
					return textureAsset;
				});
			}
			return promise;
		});
	};
	var loadBuffers = function loadBuffers(gltf, binaryChunk, urlBase, options) {
		var _options$buffer, _options$buffer2, _options$buffer3;
		if (!gltf.buffers || gltf.buffers.length === 0) {
			return [];
		}
		var preprocess = options == null || (_options$buffer = options.buffer) == null ? void 0 : _options$buffer.preprocess;
		var processAsync = options == null || (_options$buffer2 = options.buffer) == null ? void 0 : _options$buffer2.processAsync;
		var postprocess = options == null || (_options$buffer3 = options.buffer) == null ? void 0 : _options$buffer3.postprocess;
		return gltf.buffers.map(function (gltfBuffer, i) {
			if (preprocess) {
				preprocess(gltfBuffer);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfBuffer, function (err, arrayBuffer) {
						if (err) {
							reject(err);
						} else {
							resolve(arrayBuffer);
						}
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (arrayBuffer) {
				if (arrayBuffer) {
					return arrayBuffer;
				} else if (gltfBuffer.hasOwnProperty('uri')) {
					if (isDataURI(gltfBuffer.uri)) {
						var byteString = atob(gltfBuffer.uri.split(',')[1]);
						var binaryArray = new Uint8Array(byteString.length);
						for (var j = 0; j < byteString.length; j++) {
							binaryArray[j] = byteString.charCodeAt(j);
						}
						return binaryArray;
					}
					return new Promise(function (resolve, reject) {
						http.get(ABSOLUTE_URL.test(gltfBuffer.uri) ? gltfBuffer.uri : path.join(urlBase, gltfBuffer.uri), {
							cache: true,
							responseType: 'arraybuffer',
							retry: false
						}, function (err, result) {
							if (err) {
								reject(err);
							} else {
								resolve(new Uint8Array(result));
							}
						});
					});
				}
				return binaryChunk;
			});
			if (postprocess) {
				promise = promise.then(function (buffer) {
					postprocess(gltf.buffers[i], buffer);
					return buffer;
				});
			}
			return promise;
		});
	};
	var parseGltf = function parseGltf(gltfChunk, callback) {
		var decodeBinaryUtf8 = function decodeBinaryUtf8(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			}
			var str = '';
			for (var i = 0; i < array.length; i++) {
				str += String.fromCharCode(array[i]);
			}
			return decodeURIComponent(escape(str));
		};
		var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));
		if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
			callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
			return;
		}
		callback(null, gltf);
	};
	var parseGlb = function parseGlb(glbData, callback) {
		var data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
		var magic = data.getUint32(0, true);
		var version = data.getUint32(4, true);
		var length = data.getUint32(8, true);
		if (magic !== 0x46546C67) {
			callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
			return;
		}
		if (version !== 2) {
			callback("Invalid version number found in glb header. Expected 2, found " + version);
			return;
		}
		if (length <= 0 || length > data.byteLength) {
			callback("Invalid length found in glb header. Found " + length);
			return;
		}
		var chunks = [];
		var offset = 12;
		while (offset < length) {
			var chunkLength = data.getUint32(offset, true);
			if (offset + chunkLength + 8 > data.byteLength) {
				callback("Invalid chunk length found in glb. Found " + chunkLength);
			}
			var chunkType = data.getUint32(offset + 4, true);
			var chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
			chunks.push({
				length: chunkLength,
				type: chunkType,
				data: chunkData
			});
			offset += chunkLength + 8;
		}
		if (chunks.length !== 1 && chunks.length !== 2) {
			callback('Invalid number of chunks found in glb file.');
			return;
		}
		if (chunks[0].type !== 0x4E4F534A) {
			callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
			return;
		}
		if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
			callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
			return;
		}
		callback(null, {
			gltfChunk: chunks[0].data,
			binaryChunk: chunks.length === 2 ? chunks[1].data : null
		});
	};
	var parseChunk = function parseChunk(filename, data, callback) {
		var hasGlbHeader = function hasGlbHeader() {
			var u8 = new Uint8Array(data);
			return u8[0] === 103 && u8[1] === 108 && u8[2] === 84 && u8[3] === 70;
		};
		if (filename && filename.toLowerCase().endsWith('.glb') || hasGlbHeader()) {
			parseGlb(data, callback);
		} else {
			callback(null, {
				gltfChunk: data,
				binaryChunk: null
			});
		}
	};
	var createBufferViews = function createBufferViews(gltf, buffers, options) {
		var _options$bufferView, _options$bufferView2, _options$bufferView3, _gltf$bufferViews2;
		var result = [];
		var preprocess = options == null || (_options$bufferView = options.bufferView) == null ? void 0 : _options$bufferView.preprocess;
		var processAsync = options == null || (_options$bufferView2 = options.bufferView) == null ? void 0 : _options$bufferView2.processAsync;
		var postprocess = options == null || (_options$bufferView3 = options.bufferView) == null ? void 0 : _options$bufferView3.postprocess;
		if (!((_gltf$bufferViews2 = gltf.bufferViews) != null && _gltf$bufferViews2.length)) {
			return result;
		}
		var _loop = function _loop() {
			var gltfBufferView = gltf.bufferViews[i];
			if (preprocess) {
				preprocess(gltfBufferView);
			}
			var promise;
			if (processAsync) {
				promise = new Promise(function (resolve, reject) {
					processAsync(gltfBufferView, buffers, function (err, result) {
						if (err) {
							reject(err);
						} else {
							resolve(result);
						}
					});
				});
			} else {
				promise = new Promise(function (resolve) {
					resolve(null);
				});
			}
			promise = promise.then(function (buffer) {
				if (buffer) {
					return buffer;
				}
				return buffers[gltfBufferView.buffer].then(function (buffer) {
					return new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
				});
			});
			if (gltfBufferView.hasOwnProperty('byteStride')) {
				promise = promise.then(function (typedArray) {
					typedArray.byteStride = gltfBufferView.byteStride;
					return typedArray;
				});
			}
			if (postprocess) {
				promise = promise.then(function (typedArray) {
					postprocess(gltfBufferView, typedArray);
					return typedArray;
				});
			}
			result.push(promise);
		};
		for (var i = 0; i < gltf.bufferViews.length; ++i) {
			_loop();
		}
		return result;
	};
	var GlbParser = function () {
		function GlbParser() {}
		GlbParser.parse = function parse(filename, urlBase, data, device, registry, options, callback) {
			parseChunk(filename, data, function (err, chunks) {
				if (err) {
					callback(err);
					return;
				}
				parseGltf(chunks.gltfChunk, function (err, gltf) {
					if (err) {
						callback(err);
						return;
					}
					var buffers = loadBuffers(gltf, chunks.binaryChunk, urlBase, options);
					var bufferViews = createBufferViews(gltf, buffers, options);
					var images = createImages(gltf, bufferViews, urlBase, registry, options);
					var textures = createTextures(gltf, images, options);
					createResources(device, gltf, bufferViews, textures, options).then(function (result) {
						return callback(null, result);
					}).catch(function (err) {
						return callback(err);
					});
				});
			});
		};
		GlbParser.createDefaultMaterial = function createDefaultMaterial() {
			return createMaterial({
				name: 'defaultGlbMaterial'
			}, []);
		};
		return GlbParser;
	}();

	var AnimationHandler = function (_ResourceHandler) {
		function AnimationHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'animation') || this;
			_this.device = app.graphicsDevice;
			_this.assets = app.assets;
			return _this;
		}
		_inheritsLoose(AnimationHandler, _ResourceHandler);
		var _proto = AnimationHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			var _this2 = this;
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation resource: " + url.original + " [" + err + "]");
				} else {
					if (path.getExtension(url.original).toLowerCase() === '.glb') {
						var _asset$options;
						GlbParser.parse('filename.glb', '', response, _this2.device, _this2.assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, function (err, parseResult) {
							if (err) {
								callback(err);
							} else {
								var _asset$data;
								var animations = parseResult.animations;
								if (asset != null && (_asset$data = asset.data) != null && _asset$data.events) {
									for (var i = 0; i < animations.length; i++) {
										animations[i].events = new AnimEvents(Object.values(asset.data.events));
									}
								}
								parseResult.destroy();
								callback(null, animations);
							}
						});
					} else {
						callback(null, _this2["_parseAnimationV" + response.animation.version](response));
					}
				}
			});
		};
		_proto.open = function open(url, data, asset) {
			return data;
		};
		_proto._parseAnimationV3 = function _parseAnimationV3(data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.name = animData.name;
			anim.duration = animData.duration;
			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;
				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.time;
					var p = k.pos;
					var r = k.rot;
					var s = k.scale;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);
					node._keys.push(key);
				}
				anim.addNode(node);
			}
			return anim;
		};
		_proto._parseAnimationV4 = function _parseAnimationV4(data) {
			var animData = data.animation;
			var anim = new Animation();
			anim.name = animData.name;
			anim.duration = animData.duration;
			for (var i = 0; i < animData.nodes.length; i++) {
				var node = new Node();
				var n = animData.nodes[i];
				node._name = n.name;
				var defPos = n.defaults.p;
				var defRot = n.defaults.r;
				var defScl = n.defaults.s;
				for (var j = 0; j < n.keys.length; j++) {
					var k = n.keys[j];
					var t = k.t;
					var p = defPos ? defPos : k.p;
					var r = defRot ? defRot : k.r;
					var s = defScl ? defScl : k.s;
					var pos = new Vec3(p[0], p[1], p[2]);
					var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
					var scl = new Vec3(s[0], s[1], s[2]);
					var key = new Key(t, pos, rot, scl);
					node._keys.push(key);
				}
				anim.addNode(node);
			}
			return anim;
		};
		return AnimationHandler;
	}(ResourceHandler);

	var AnimClipHandler = function (_ResourceHandler) {
		function AnimClipHandler(app) {
			return _ResourceHandler.call(this, app, 'animclip') || this;
		}
		_inheritsLoose(AnimClipHandler, _ResourceHandler);
		var _proto = AnimClipHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		};
		_proto.open = function open(url, data) {
			var name = data.name;
			var duration = data.duration;
			var inputs = data.inputs.map(function (input) {
				return new AnimData(1, input);
			});
			var outputs = data.outputs.map(function (output) {
				return new AnimData(output.components, output.data);
			});
			var curves = data.curves.map(function (curve) {
				return new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);
			});
			return new AnimTrack(name, duration, inputs, outputs, curves);
		};
		return AnimClipHandler;
	}(ResourceHandler);

	var AnimStateGraphHandler = function (_ResourceHandler) {
		function AnimStateGraphHandler(app) {
			return _ResourceHandler.call(this, app, 'animstategraph') || this;
		}
		_inheritsLoose(AnimStateGraphHandler, _ResourceHandler);
		var _proto = AnimStateGraphHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
				} else {
					callback(null, response);
				}
			});
		};
		_proto.open = function open(url, data) {
			return new AnimStateGraph(data);
		};
		return AnimStateGraphHandler;
	}(ResourceHandler);

	var ie = function () {
		if (typeof window === 'undefined') {
			return false;
		}
		var ua = window.navigator.userAgent;
		var msie = ua.indexOf('MSIE ');
		if (msie > 0) {
			return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		}
		var trident = ua.indexOf('Trident/');
		if (trident > 0) {
			var rv = ua.indexOf('rv:');
			return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		}
		return false;
	}();
	var supportedExtensions = ['.ogg', '.mp3', '.wav', '.mp4a', '.m4a', '.mp4', '.aac', '.opus'];
	var AudioHandler = function (_ResourceHandler) {
		function AudioHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'audio') || this;
			_this.manager = app.soundManager;
			return _this;
		}
		_inheritsLoose(AudioHandler, _ResourceHandler);
		var _proto = AudioHandler.prototype;
		_proto._isSupported = function _isSupported(url) {
			var ext = path.getExtension(url);
			return supportedExtensions.indexOf(ext) > -1;
		};
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var success = function success(resource) {
				callback(null, new Sound(resource));
			};
			var error = function error(err) {
				var msg = "Error loading audio url: " + url.original;
				if (err) {
					msg += ": " + (err.message || err);
				}
				console.warn(msg);
				callback(msg);
			};
			if (this._createSound) {
				if (!this._isSupported(url.original)) {
					error("Audio format for " + url.original + " not supported");
					return;
				}
				this._createSound(url.load, success, error);
			} else {
				error(null);
			}
		};
		_proto._createSound = function _createSound(url, success, error) {
			if (hasAudioContext()) {
				var manager = this.manager;
				if (!manager.context) {
					error('Audio manager has no audio context');
					return;
				}
				var options = {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				};
				if (url.startsWith('blob:') || url.startsWith('data:')) {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				}
				http.get(url, options, function (err, response) {
					if (err) {
						error(err);
						return;
					}
					manager.context.decodeAudioData(response, success, error);
				});
			} else {
				var audio = null;
				try {
					audio = new Audio();
				} catch (e) {
					error('No support for Audio element');
					return;
				}
				if (ie) {
					document.body.appendChild(audio);
				}
				var _onReady = function onReady() {
					audio.removeEventListener('canplaythrough', _onReady);
					if (ie) {
						document.body.removeChild(audio);
					}
					success(audio);
				};
				audio.onerror = function () {
					audio.onerror = null;
					if (ie) {
						document.body.removeChild(audio);
					}
					error();
				};
				audio.addEventListener('canplaythrough', _onReady);
				audio.src = url;
			}
		};
		return AudioHandler;
	}(ResourceHandler);

	var BinaryHandler = function (_ResourceHandler) {
		function BinaryHandler(app) {
			return _ResourceHandler.call(this, app, 'binary') || this;
		}
		_inheritsLoose(BinaryHandler, _ResourceHandler);
		var _proto = BinaryHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				responseType: Http.ResponseType.ARRAY_BUFFER,
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading binary resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.openBinary = function openBinary(data) {
			return data.buffer;
		};
		return BinaryHandler;
	}(ResourceHandler);

	var GlbContainerResource = function () {
		function GlbContainerResource(data, asset, assets, defaultMaterial) {
			var createAsset = function createAsset(type, resource, index) {
				var subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
				assets.add(subAsset);
				return subAsset;
			};
			var renders = [];
			for (var i = 0; i < data.renders.length; ++i) {
				renders.push(createAsset('render', data.renders[i], i));
			}
			var materials = [];
			for (var _i = 0; _i < data.materials.length; ++_i) {
				materials.push(createAsset('material', data.materials[_i], _i));
			}
			var animations = [];
			for (var _i2 = 0; _i2 < data.animations.length; ++_i2) {
				animations.push(createAsset('animation', data.animations[_i2], _i2));
			}
			this.data = data;
			this._model = null;
			this._assetName = asset.name;
			this._assets = assets;
			this._defaultMaterial = defaultMaterial;
			this.renders = renders;
			this.materials = materials;
			this.textures = data.textures;
			this.animations = animations;
		}
		GlbContainerResource.createAsset = function createAsset(assetName, type, resource, index) {
			var subAsset = new Asset(assetName + "/" + type + "/" + index, type, {
				url: ''
			});
			subAsset.resource = resource;
			subAsset.loaded = true;
			return subAsset;
		};
		var _proto = GlbContainerResource.prototype;
		_proto.instantiateModelEntity = function instantiateModelEntity(options) {
			var entity = new Entity();
			entity.addComponent('model', Object.assign({
				type: 'asset',
				asset: this.model
			}, options));
			return entity;
		};
		_proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
			var _this = this;
			var defaultMaterial = this._defaultMaterial;
			var skinnedMeshInstances = [];
			var createMeshInstance = function createMeshInstance(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode, nodeInstancingMap) {
				var materialIndex = meshDefaultMaterials[mesh.id];
				var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
				var meshInstance = new MeshInstance(mesh, material);
				if (mesh.morph) {
					meshInstance.morphInstance = new MorphInstance(mesh.morph);
				}
				if (gltfNode.hasOwnProperty('skin')) {
					skinnedMeshInstances.push({
						meshInstance: meshInstance,
						rootBone: root,
						entity: entity
					});
				}
				var instData = nodeInstancingMap.get(gltfNode);
				if (instData) {
					var matrices = instData.matrices;
					var vbFormat = VertexFormat.getDefaultInstancingFormat(mesh.device);
					var vb = new VertexBuffer(mesh.device, vbFormat, matrices.length / 16, {
						data: matrices
					});
					meshInstance.setInstancing(vb);
					meshInstance.instancingData._destroyVertexBuffer = true;
				}
				return meshInstance;
			};
			var _cloneHierarchy = function cloneHierarchy(root, node, glb) {
				var entity = new Entity();
				node._cloneInternal(entity);
				if (!root) root = entity;
				var attachedMi = null;
				var renderAsset = null;
				for (var i = 0; i < glb.nodes.length; i++) {
					var glbNode = glb.nodes[i];
					if (glbNode === node) {
						var gltfNode = glb.gltf.nodes[i];
						if (gltfNode.hasOwnProperty('mesh')) {
							var meshGroup = glb.renders[gltfNode.mesh].meshes;
							renderAsset = _this.renders[gltfNode.mesh];
							for (var mi = 0; mi < meshGroup.length; mi++) {
								var mesh = meshGroup[mi];
								if (mesh) {
									var cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode, glb.nodeInstancingMap);
									if (!attachedMi) {
										attachedMi = [];
									}
									attachedMi.push(cloneMi);
								}
							}
						}
						if (glb.lights) {
							var lightEntity = glb.lights.get(gltfNode);
							if (lightEntity) {
								entity.addChild(lightEntity.clone());
							}
						}
						if (glb.cameras) {
							var cameraEntity = glb.cameras.get(gltfNode);
							if (cameraEntity) {
								cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
							}
						}
					}
				}
				if (attachedMi) {
					entity.addComponent('render', Object.assign({
						type: 'asset',
						meshInstances: attachedMi
					}, options));
					entity.render.assignAsset(renderAsset);
				}
				var children = node.children;
				for (var _i3 = 0; _i3 < children.length; _i3++) {
					var childClone = _cloneHierarchy(root, children[_i3], glb);
					entity.addChild(childClone);
				}
				return entity;
			};
			var sceneClones = [];
			for (var _iterator = _createForOfIteratorHelperLoose(this.data.scenes), _step; !(_step = _iterator()).done;) {
				var scene = _step.value;
				sceneClones.push(_cloneHierarchy(null, scene, this.data));
			}
			skinnedMeshInstances.forEach(function (data) {
				data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
				data.meshInstance.node.render.rootBone = data.rootBone;
			});
			return GlbContainerResource.createSceneHierarchy(sceneClones, Entity);
		};
		_proto.getMaterialVariants = function getMaterialVariants() {
			return this.data.variants ? Object.keys(this.data.variants) : [];
		};
		_proto.applyMaterialVariant = function applyMaterialVariant(entity, name) {
			var variant = name ? this.data.variants[name] : null;
			if (variant === undefined) {
				return;
			}
			var renders = entity.findComponents('render');
			for (var i = 0; i < renders.length; i++) {
				var renderComponent = renders[i];
				this._applyMaterialVariant(variant, renderComponent.meshInstances);
			}
		};
		_proto.applyMaterialVariantInstances = function applyMaterialVariantInstances(instances, name) {
			var variant = name ? this.data.variants[name] : null;
			if (variant === undefined) {
				return;
			}
			this._applyMaterialVariant(variant, instances);
		};
		_proto._applyMaterialVariant = function _applyMaterialVariant(variant, instances) {
			var _this2 = this;
			instances.forEach(function (instance) {
				if (variant === null) {
					instance.material = _this2._defaultMaterial;
				} else {
					var meshVariants = _this2.data.meshVariants[instance.mesh.id];
					if (meshVariants) {
						instance.material = _this2.data.materials[meshVariants[variant]];
					}
				}
			});
		};
		GlbContainerResource.createSceneHierarchy = function createSceneHierarchy(sceneNodes, nodeType) {
			var root = null;
			if (sceneNodes.length === 1) {
				root = sceneNodes[0];
			} else {
				root = new nodeType('SceneGroup');
				for (var _iterator2 = _createForOfIteratorHelperLoose(sceneNodes), _step2; !(_step2 = _iterator2()).done;) {
					var scene = _step2.value;
					root.addChild(scene);
				}
			}
			return root;
		};
		GlbContainerResource.createModel = function createModel(glb, defaultMaterial) {
			var createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
				var materialIndex = glb.meshDefaultMaterials[mesh.id];
				var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
				var meshInstance = new MeshInstance(mesh, material, node);
				if (mesh.morph) {
					var morphInstance = new MorphInstance(mesh.morph);
					meshInstance.morphInstance = morphInstance;
					model.morphInstances.push(morphInstance);
				}
				if (gltfNode.hasOwnProperty('skin')) {
					var skinIndex = gltfNode.skin;
					var skin = skins[skinIndex];
					mesh.skin = skin;
					var skinInstance = skinInstances[skinIndex];
					meshInstance.skinInstance = skinInstance;
					model.skinInstances.push(skinInstance);
				}
				model.meshInstances.push(meshInstance);
			};
			var model = new Model();
			var skinInstances = [];
			for (var _iterator3 = _createForOfIteratorHelperLoose(glb.skins), _step3; !(_step3 = _iterator3()).done;) {
				var skin = _step3.value;
				var skinInstance = new SkinInstance(skin);
				skinInstance.bones = skin.bones;
				skinInstances.push(skinInstance);
			}
			model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, GraphNode);
			for (var i = 0; i < glb.nodes.length; i++) {
				var node = glb.nodes[i];
				if (node.root === model.graph) {
					var gltfNode = glb.gltf.nodes[i];
					if (gltfNode.hasOwnProperty('mesh')) {
						var meshGroup = glb.renders[gltfNode.mesh].meshes;
						for (var mi = 0; mi < meshGroup.length; mi++) {
							var mesh = meshGroup[mi];
							if (mesh) {
								createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
							}
						}
					}
				}
			}
			return model;
		};
		_proto.destroy = function destroy() {
			var registry = this._assets;
			var destroyAsset = function destroyAsset(asset) {
				registry.remove(asset);
				asset.unload();
			};
			var destroyAssets = function destroyAssets(assets) {
				assets.forEach(function (asset) {
					destroyAsset(asset);
				});
			};
			if (this.animations) {
				destroyAssets(this.animations);
				this.animations = null;
			}
			if (this.textures) {
				destroyAssets(this.textures);
				this.textures = null;
			}
			if (this.materials) {
				destroyAssets(this.materials);
				this.materials = null;
			}
			if (this.renders) {
				destroyAssets(this.renders);
				this.renders = null;
			}
			if (this._model) {
				destroyAsset(this._model);
				this._model = null;
			}
			this.data = null;
			this.assets = null;
		};
		return _createClass(GlbContainerResource, [{
			key: "model",
			get: function get() {
				if (!this._model) {
					var model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
					var modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);
					this._assets.add(modelAsset);
					this._model = modelAsset;
				}
				return this._model;
			}
		}]);
	}();

	var GlbContainerParser = function () {
		function GlbContainerParser(device, assets, maxRetries) {
			this._device = device;
			this._assets = assets;
			this._defaultMaterial = GlbParser.createDefaultMaterial();
			this.maxRetries = maxRetries;
		}
		var _proto = GlbContainerParser.prototype;
		_proto._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};
		_proto.load = function load(url, callback, asset) {
			var _this = this;
			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err);
				} else {
					GlbParser.parse(_this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, _this._device, asset.registry, asset.options, function (err, result) {
						if (err) {
							callback(err);
						} else {
							callback(null, new GlbContainerResource(result, asset, _this._assets, _this._defaultMaterial));
						}
					});
				}
			}, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, asset) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		return GlbContainerParser;
	}();

	var ContainerResource = function () {
		function ContainerResource() {}
		var _proto = ContainerResource.prototype;
		_proto.instantiateModelEntity = function instantiateModelEntity(options) {
			return null;
		};
		_proto.instantiateRenderEntity = function instantiateRenderEntity(options) {
			return null;
		};
		_proto.getMaterialVariants = function getMaterialVariants() {
			return null;
		};
		_proto.applyMaterialVariant = function applyMaterialVariant(entity, name) {};
		_proto.applyMaterialVariantInstances = function applyMaterialVariantInstances(instances, name) {};
		return ContainerResource;
	}();
	var ContainerHandler = function (_ResourceHandler) {
		function ContainerHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'container') || this;
			_this.glbContainerParser = new GlbContainerParser(app.graphicsDevice, app.assets, 0);
			_this.parsers = {};
			return _this;
		}
		_inheritsLoose(ContainerHandler, _ResourceHandler);
		var _proto2 = ContainerHandler.prototype;
		_proto2._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};
		_proto2._getParser = function _getParser(url) {
			var ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
			return this.parsers[ext] || this.glbContainerParser;
		};
		_proto2.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			this._getParser(url.original).load(url, callback, asset);
		};
		_proto2.open = function open(url, data, asset) {
			return this._getParser(url).open(url, data, asset);
		};
		return _createClass(ContainerHandler, [{
			key: "maxRetries",
			get: function get() {
				return this.glbContainerParser.maxRetries;
			},
			set: function set(value) {
				this.glbContainerParser.maxRetries = value;
				for (var parser in this.parsers) {
					if (this.parsers.hasOwnProperty(parser)) {
						this.parsers[parser].maxRetries = value;
					}
				}
			}
		}]);
	}(ResourceHandler);

	var CssHandler = function (_ResourceHandler) {
		function CssHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'css') || this;
			_this.decoder = null;
			return _this;
		}
		_inheritsLoose(CssHandler, _ResourceHandler);
		var _proto = CssHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading css resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.openBinary = function openBinary(data) {
			var _this$decoder;
			(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');
			return this.decoder.decode(data);
		};
		return CssHandler;
	}(ResourceHandler);

	var CubemapHandler = function (_ResourceHandler) {
		function CubemapHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'cubemap') || this;
			_this._device = app.graphicsDevice;
			_this._registry = app.assets;
			_this._loader = app.loader;
			return _this;
		}
		_inheritsLoose(CubemapHandler, _ResourceHandler);
		var _proto = CubemapHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			this.loadAssets(asset, callback);
		};
		_proto.open = function open(url, data, asset) {
			return asset ? asset.resource : null;
		};
		_proto.patch = function patch(asset, registry) {
			this.loadAssets(asset, function (err, result) {
				if (err) {
					registry.fire('error', asset);
					registry.fire("error:" + asset.id, err, asset);
					asset.fire('error', asset);
				}
			});
		};
		_proto.getAssetIds = function getAssetIds(cubemapAsset) {
			var result = [];
			result[0] = cubemapAsset.file;
			if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
				for (var i = 0; i < 6; ++i) {
					result[i + 1] = cubemapAsset.data.textures[i];
				}
			} else {
				result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
			}
			return result;
		};
		_proto.compareAssetIds = function compareAssetIds(assetIdA, assetIdB) {
			if (assetIdA && assetIdB) {
				if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === 'string') {
					return assetIdA === assetIdB;
				}
				return assetIdA.url === assetIdB.url;
			}
			return assetIdA !== null === (assetIdB !== null);
		};
		_proto.update = function update(cubemapAsset, assetIds, assets) {
			var assetData = cubemapAsset.data || {};
			var oldAssets = cubemapAsset._handlerState.assets;
			var oldResources = cubemapAsset._resources;
			var tex, mip, i;
			var resources = [null, null, null, null, null, null, null];
			var getType = function getType() {
				if (assetData.hasOwnProperty('type')) {
					return assetData.type;
				}
				if (assetData.hasOwnProperty('rgbm')) {
					return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
				}
				return null;
			};
			if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
				if (assets[0]) {
					tex = assets[0].resource;
					if (tex.cubemap) {
						for (i = 0; i < 6; ++i) {
							resources[i + 1] = new Texture(this._device, {
								name: cubemapAsset.name + "_prelitCubemap" + (tex.width >> i),
								cubemap: true,
								type: getType() || tex.type,
								width: tex.width >> i,
								height: tex.height >> i,
								format: tex.format,
								levels: [tex._levels[i]],
								addressU: ADDRESS_CLAMP_TO_EDGE,
								addressV: ADDRESS_CLAMP_TO_EDGE,
								mipmaps: i === 0
							});
						}
					} else {
						resources[1] = tex;
					}
				}
			} else {
				resources[1] = oldResources[1] || null;
				resources[2] = oldResources[2] || null;
				resources[3] = oldResources[3] || null;
				resources[4] = oldResources[4] || null;
				resources[5] = oldResources[5] || null;
				resources[6] = oldResources[6] || null;
			}
			var faceAssets = assets.slice(1);
			if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
				if (faceAssets.indexOf(null) === -1) {
					var _assetData$mipmaps;
					var faceTextures = faceAssets.map(function (asset) {
						return asset.resource;
					});
					var faceLevels = [];
					for (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {
						faceLevels.push(faceTextures.map(function (faceTexture) {
							return faceTexture._levels[mip];
						}));
					}
					var format = faceTextures[0].format;
					var faces = new Texture(this._device, {
						name: cubemapAsset.name + "_faces",
						cubemap: true,
						type: getType() || faceTextures[0].type,
						width: faceTextures[0].width,
						height: faceTextures[0].height,
						format: format === PIXELFORMAT_RGB8 ? PIXELFORMAT_RGBA8 : format,
						mipmaps: (_assetData$mipmaps = assetData.mipmaps) != null ? _assetData$mipmaps : true,
						levels: faceLevels,
						minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
						magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
						anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
					});
					resources[0] = faces;
				}
			} else {
				resources[0] = oldResources[0] || null;
			}
			if (!this.cmpArrays(resources, oldResources)) {
				cubemapAsset.resources = resources;
				cubemapAsset._handlerState.assetIds = assetIds;
				cubemapAsset._handlerState.assets = assets;
				for (i = 0; i < oldResources.length; ++i) {
					if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
						oldResources[i].destroy();
					}
				}
			}
			for (i = 0; i < oldAssets.length; ++i) {
				if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
					oldAssets[i].unload();
				}
			}
		};
		_proto.cmpArrays = function cmpArrays(arr1, arr2) {
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; ++i) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		};
		_proto.resolveId = function resolveId(value) {
			var valueInt = parseInt(value, 10);
			return valueInt === value || valueInt.toString() === value ? valueInt : value;
		};
		_proto.loadAssets = function loadAssets(cubemapAsset, callback) {
			if (!cubemapAsset.hasOwnProperty('_handlerState')) {
				cubemapAsset._handlerState = {
					assetIds: [null, null, null, null, null, null, null],
					assets: [null, null, null, null, null, null, null]
				};
			}
			var self = this;
			var assetIds = self.getAssetIds(cubemapAsset);
			var assets = [null, null, null, null, null, null, null];
			var loadedAssetIds = cubemapAsset._handlerState.assetIds;
			var loadedAssets = cubemapAsset._handlerState.assets;
			var registry = self._registry;
			var awaiting = 7;
			var onLoad = function onLoad(index, asset) {
				assets[index] = asset;
				awaiting--;
				if (awaiting === 0) {
					self.update(cubemapAsset, assetIds, assets);
					callback(null, cubemapAsset.resources);
				}
			};
			var onError = function onError(index, err, asset) {
				callback(err);
			};
			var processTexAsset = function processTexAsset(index, texAsset) {
				if (texAsset.loaded) {
					onLoad(index, texAsset);
				} else {
					registry.once("load:" + texAsset.id, onLoad.bind(self, index));
					registry.once("error:" + texAsset.id, onError.bind(self, index));
					if (!texAsset.loading) {
						registry.load(texAsset);
					}
				}
			};
			var texAsset;
			for (var i = 0; i < 7; ++i) {
				var assetId = this.resolveId(assetIds[i]);
				if (!assetId) {
					onLoad(i, null);
				} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
					processTexAsset(i, loadedAssets[i]);
				} else if (parseInt(assetId, 10) === assetId) {
					texAsset = registry.get(assetId);
					if (texAsset) {
						processTexAsset(i, texAsset);
					} else {
						setTimeout(function (index, assetId_) {
							var texAsset = registry.get(assetId_);
							if (texAsset) {
								processTexAsset(index, texAsset);
							} else {
								onError(index, "failed to find dependent cubemap asset=" + assetId_);
							}
						}.bind(null, i, assetId));
					}
				} else {
					var file = typeof assetId === 'string' ? {
						url: assetId,
						filename: assetId
					} : assetId;
					var data = file.url.search('.dds') === -1 ? {
						type: 'rgbp',
						addressu: 'clamp',
						addressv: 'clamp',
						mipmaps: false
					} : null;
					texAsset = new Asset(cubemapAsset.name + "_part_" + i, 'texture', file, data);
					registry.add(texAsset);
					processTexAsset(i, texAsset);
				}
			}
		};
		return CubemapHandler;
	}(ResourceHandler);

	var FolderHandler = function (_ResourceHandler) {
		function FolderHandler(app) {
			return _ResourceHandler.call(this, app, 'folder') || this;
		}
		_inheritsLoose(FolderHandler, _ResourceHandler);
		var _proto = FolderHandler.prototype;
		_proto.load = function load(url, callback) {
			callback(null, null);
		};
		return FolderHandler;
	}(ResourceHandler);

	var Font = function () {
		function Font(textures, data) {
			this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
			this.em = 1;
			this.textures = textures;
			this.intensity = 0.0;
			this._data = null;
			this.data = data;
		}
		return _createClass(Font, [{
			key: "data",
			get: function get() {
				return this._data;
			},
			set: function set(value) {
				this._data = value;
				if (!value) {
					return;
				}
				if (this._data.intensity !== undefined) {
					this.intensity = this._data.intensity;
				}
				if (!this._data.info) {
					this._data.info = {};
				}
				if (!this._data.version || this._data.version < 2) {
					this._data.info.maps = [{
						width: this._data.info.width,
						height: this._data.info.height
					}];
					if (this._data.chars) {
						for (var key in this._data.chars) {
							this._data.chars[key].map = 0;
						}
					}
				}
			}
		}]);
	}();

	function upgradeDataSchema(data) {
		if (data.version < 3) {
			if (data.version < 2) {
				data.info.maps = data.info.maps || [{
					width: data.info.width,
					height: data.info.height
				}];
			}
			data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
				var existing = data.chars[key];
				var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);
				if (data.version < 2) {
					existing.map = existing.map || 0;
				}
				newChars[newKey] = existing;
				return newChars;
			}, {});
			data.version = 3;
		}
		return data;
	}
	var FontHandler = function (_ResourceHandler) {
		function FontHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'font') || this;
			_this._loader = app.loader;
			_this.maxRetries = 0;
			return _this;
		}
		_inheritsLoose(FontHandler, _ResourceHandler);
		var _proto = FontHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						var data = upgradeDataSchema(response);
						self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
							if (err) {
								callback(err);
							} else {
								callback(null, {
									data: data,
									textures: textures
								});
							}
						});
					} else {
						callback("Error loading font resource: " + url.original + " [" + err + "]");
					}
				});
			} else {
				if (asset && asset.data) {
					asset.data = upgradeDataSchema(asset.data);
				}
				this._loadTextures(url.load, asset && asset.data, callback);
			}
		};
		_proto._loadTextures = function _loadTextures(url, data, callback) {
			var numTextures = data.info.maps.length;
			var numLoaded = 0;
			var error = null;
			var textures = new Array(numTextures);
			var loader = this._loader;
			var loadTexture = function loadTexture(index) {
				var onLoaded = function onLoaded(err, texture) {
					if (error) return;
					if (err) {
						error = err;
						callback(err);
						return;
					}
					texture.upload();
					textures[index] = texture;
					numLoaded++;
					if (numLoaded === numTextures) {
						callback(null, textures);
					}
				};
				if (index === 0) {
					loader.load(url, 'texture', onLoaded);
				} else {
					loader.load(url.replace('.png', index + ".png"), 'texture', onLoaded);
				}
			};
			for (var i = 0; i < numTextures; i++) {
				loadTexture(i);
			}
		};
		_proto.open = function open(url, data, asset) {
			var font;
			if (data.textures) {
				font = new Font(data.textures, data.data);
			} else {
				font = new Font(data, null);
			}
			return font;
		};
		_proto.patch = function patch(asset, assets) {
			var font = asset.resource;
			if (!font.data && asset.data) {
				font.data = asset.data;
			} else if (!asset.data && font.data) {
				asset.data = font.data;
			}
			if (asset.data) {
				asset.data = upgradeDataSchema(asset.data);
			}
		};
		return FontHandler;
	}(ResourceHandler);

	var SH_C0 = 0.28209479177387814;
	var SplatCompressedIterator = function SplatCompressedIterator(gsplatData, p, r, s, c, sh) {
		var unpackUnorm = function unpackUnorm(value, bits) {
			var t = (1 << bits) - 1;
			return (value & t) / t;
		};
		var unpack111011 = function unpack111011(result, value) {
			result.x = unpackUnorm(value >>> 21, 11);
			result.y = unpackUnorm(value >>> 11, 10);
			result.z = unpackUnorm(value, 11);
		};
		var unpack8888 = function unpack8888(result, value) {
			result.x = unpackUnorm(value >>> 24, 8);
			result.y = unpackUnorm(value >>> 16, 8);
			result.z = unpackUnorm(value >>> 8, 8);
			result.w = unpackUnorm(value, 8);
		};
		var unpackRot = function unpackRot(result, value) {
			var norm = 1.0 / (Math.sqrt(2) * 0.5);
			var a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;
			var b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;
			var c = (unpackUnorm(value, 10) - 0.5) * norm;
			var m = Math.sqrt(1.0 - (a * a + b * b + c * c));
			switch (value >>> 30) {
				case 0:
					result.set(a, b, c, m);
					break;
				case 1:
					result.set(m, b, c, a);
					break;
				case 2:
					result.set(b, m, c, a);
					break;
				case 3:
					result.set(b, c, m, a);
					break;
			}
		};
		var lerp = function lerp(a, b, t) {
			return a * (1 - t) + b * t;
		};
		var chunkData = gsplatData.chunkData,
			chunkSize = gsplatData.chunkSize,
			vertexData = gsplatData.vertexData,
			shData = gsplatData.shData,
			shBands = gsplatData.shBands;
		var shCoeffs = [3, 8, 15][shBands - 1];
		this.read = function (i) {
			var ci = Math.floor(i / 256) * chunkSize;
			if (p) {
				unpack111011(p, vertexData[i * 4 + 0]);
				p.x = lerp(chunkData[ci + 0], chunkData[ci + 3], p.x);
				p.y = lerp(chunkData[ci + 1], chunkData[ci + 4], p.y);
				p.z = lerp(chunkData[ci + 2], chunkData[ci + 5], p.z);
			}
			if (r) {
				unpackRot(r, vertexData[i * 4 + 1]);
			}
			if (s) {
				unpack111011(s, vertexData[i * 4 + 2]);
				s.x = lerp(chunkData[ci + 6], chunkData[ci + 9], s.x);
				s.y = lerp(chunkData[ci + 7], chunkData[ci + 10], s.y);
				s.z = lerp(chunkData[ci + 8], chunkData[ci + 11], s.z);
			}
			if (c) {
				unpack8888(c, vertexData[i * 4 + 3]);
				if (chunkSize > 12) {
					c.x = lerp(chunkData[ci + 12], chunkData[ci + 15], c.x);
					c.y = lerp(chunkData[ci + 13], chunkData[ci + 16], c.y);
					c.z = lerp(chunkData[ci + 14], chunkData[ci + 17], c.z);
				}
			}
			if (sh && shBands > 0) {
				for (var j = 0; j < 3; ++j) {
					for (var k = 0; k < 15; ++k) {
						sh[j * 15 + k] = k < shCoeffs ? shData[(i * 3 + j) * shCoeffs + k] * (8 / 255) - 4 : 0;
					}
				}
			}
		};
	};
	var GSplatCompressedData = function () {
		function GSplatCompressedData() {
			this.numSplats = void 0;
			this.chunkData = void 0;
			this.vertexData = void 0;
			this.shData = void 0;
		}
		var _proto = GSplatCompressedData.prototype;
		_proto.createIter = function createIter(p, r, s, c, sh) {
			return new SplatCompressedIterator(this, p, r, s, c, sh);
		};
		_proto.calcAabb = function calcAabb(result) {
			var chunkData = this.chunkData,
				numChunks = this.numChunks,
				chunkSize = this.chunkSize;
			var s = Math.exp(Math.max(chunkData[9], chunkData[10], chunkData[11]));
			var mx = chunkData[0] - s;
			var my = chunkData[1] - s;
			var mz = chunkData[2] - s;
			var Mx = chunkData[3] + s;
			var My = chunkData[4] + s;
			var Mz = chunkData[5] + s;
			for (var i = 1; i < numChunks; ++i) {
				var off = i * chunkSize;
				s = Math.exp(Math.max(chunkData[off + 9], chunkData[off + 10], chunkData[off + 11]));
				mx = Math.min(mx, chunkData[off + 0] - s);
				my = Math.min(my, chunkData[off + 1] - s);
				mz = Math.min(mz, chunkData[off + 2] - s);
				Mx = Math.max(Mx, chunkData[off + 3] + s);
				My = Math.max(My, chunkData[off + 4] + s);
				Mz = Math.max(Mz, chunkData[off + 5] + s);
			}
			result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
			result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
			return true;
		};
		_proto.getCenters = function getCenters(result) {
			var vertexData = this.vertexData,
				chunkData = this.chunkData,
				numChunks = this.numChunks,
				chunkSize = this.chunkSize;
			var mx, my, mz, Mx, My, Mz;
			for (var c = 0; c < numChunks; ++c) {
				var off = c * chunkSize;
				mx = chunkData[off + 0];
				my = chunkData[off + 1];
				mz = chunkData[off + 2];
				Mx = chunkData[off + 3];
				My = chunkData[off + 4];
				Mz = chunkData[off + 5];
				var end = Math.min(this.numSplats, (c + 1) * 256);
				for (var i = c * 256; i < end; ++i) {
					var p = vertexData[i * 4];
					var px = (p >>> 21) / 2047;
					var py = (p >>> 11 & 0x3ff) / 1023;
					var pz = (p & 0x7ff) / 2047;
					result[i * 3 + 0] = (1 - px) * mx + px * Mx;
					result[i * 3 + 1] = (1 - py) * my + py * My;
					result[i * 3 + 2] = (1 - pz) * mz + pz * Mz;
				}
			}
		};
		_proto.calcFocalPoint = function calcFocalPoint(result) {
			var chunkData = this.chunkData,
				numChunks = this.numChunks,
				chunkSize = this.chunkSize;
			result.x = 0;
			result.y = 0;
			result.z = 0;
			for (var i = 0; i < numChunks; ++i) {
				var off = i * chunkSize;
				result.x += chunkData[off + 0] + chunkData[off + 3];
				result.y += chunkData[off + 1] + chunkData[off + 4];
				result.z += chunkData[off + 2] + chunkData[off + 5];
			}
			result.mulScalar(0.5 / numChunks);
		};
		_proto.decompress = function decompress() {
			var _this = this;
			var members = ['x', 'y', 'z', 'f_dc_0', 'f_dc_1', 'f_dc_2', 'opacity', 'scale_0', 'scale_1', 'scale_2', 'rot_0', 'rot_1', 'rot_2', 'rot_3'];
			var shBands = this.shBands;
			if (shBands > 0) {
				var shMembers = [];
				for (var i = 0; i < 45; ++i) {
					shMembers.push("f_rest_" + i);
				}
				members.splice.apply(members, [members.indexOf('f_dc_0') + 1, 0].concat(shMembers));
			}
			var data = {};
			members.forEach(function (name) {
				data[name] = new Float32Array(_this.numSplats);
			});
			var p = new Vec3();
			var r = new Quat();
			var s = new Vec3();
			var c = new Vec4();
			var sh = shBands > 0 ? new Float32Array(45) : null;
			var iter = this.createIter(p, r, s, c, sh);
			for (var _i = 0; _i < this.numSplats; ++_i) {
				iter.read(_i);
				data.x[_i] = p.x;
				data.y[_i] = p.y;
				data.z[_i] = p.z;
				data.rot_1[_i] = r.x;
				data.rot_2[_i] = r.y;
				data.rot_3[_i] = r.z;
				data.rot_0[_i] = r.w;
				data.scale_0[_i] = s.x;
				data.scale_1[_i] = s.y;
				data.scale_2[_i] = s.z;
				data.f_dc_0[_i] = (c.x - 0.5) / SH_C0;
				data.f_dc_1[_i] = (c.y - 0.5) / SH_C0;
				data.f_dc_2[_i] = (c.z - 0.5) / SH_C0;
				data.opacity[_i] = c.w <= 0 ? -40 : c.w >= 1 ? 40 : -Math.log(1 / c.w - 1);
				if (sh) {
					for (var _c = 0; _c < 45; ++_c) {
						data["f_rest_" + _c][_i] = sh[_c];
					}
				}
			}
			return new GSplatData([{
				name: 'vertex',
				count: this.numSplats,
				properties: members.map(function (name) {
					return {
						name: name,
						type: 'float',
						byteSize: 4,
						storage: data[name]
					};
				})
			}]);
		};
		return _createClass(GSplatCompressedData, [{
			key: "isCompressed",
			get: function get() {
				return true;
			}
		}, {
			key: "numChunks",
			get: function get() {
				return Math.ceil(this.numSplats / 256);
			}
		}, {
			key: "chunkSize",
			get: function get() {
				return this.chunkData.length / this.numChunks;
			}
		}, {
			key: "shBands",
			get: function get() {
				var _sizes, _this$shData;
				var sizes = {
					3: 1,
					8: 2,
					15: 3
				};
				return (_sizes = sizes[((_this$shData = this.shData) == null ? void 0 : _this$shData.length) / this.numSplats / 3]) != null ? _sizes : 0;
			}
		}]);
	}();

	var strideCopy = function strideCopy(target, targetStride, src, srcStride, numEntries) {
		for (var i = 0; i < numEntries; ++i) {
			for (var j = 0; j < srcStride; ++j) {
				target[i * targetStride + j] = src[i * srcStride + j];
			}
		}
	};
	var GSplatCompressed = function () {
		function GSplatCompressed(device, gsplatData) {
			this.device = void 0;
			this.numSplats = void 0;
			this.numSplatsVisible = void 0;
			this.aabb = void 0;
			this.centers = void 0;
			this.packedTexture = void 0;
			this.chunkTexture = void 0;
			this.shTexture0 = void 0;
			this.shTexture1 = void 0;
			this.shTexture2 = void 0;
			var chunkData = gsplatData.chunkData,
				chunkSize = gsplatData.chunkSize,
				numChunks = gsplatData.numChunks,
				numSplats = gsplatData.numSplats,
				vertexData = gsplatData.vertexData,
				shBands = gsplatData.shBands;
			this.device = device;
			this.numSplats = numSplats;
			this.numVisibleSplats = numSplats;
			this.aabb = new BoundingBox();
			gsplatData.calcAabb(this.aabb);
			this.centers = new Float32Array(numSplats * 3);
			gsplatData.getCenters(this.centers);
			this.packedTexture = this.createTexture('packedData', PIXELFORMAT_RGBA32U, this.evalTextureSize(numSplats), vertexData);
			var chunkTextureSize = this.evalTextureSize(numChunks);
			chunkTextureSize.x *= 5;
			this.chunkTexture = this.createTexture('chunkData', PIXELFORMAT_RGBA32F, chunkTextureSize);
			var chunkTextureData = this.chunkTexture.lock();
			strideCopy(chunkTextureData, 20, chunkData, chunkSize, numChunks);
			if (chunkSize === 12) {
				for (var i = 0; i < numChunks; ++i) {
					chunkTextureData[i * 20 + 15] = 1;
					chunkTextureData[i * 20 + 16] = 1;
					chunkTextureData[i * 20 + 17] = 1;
				}
			}
			this.chunkTexture.unlock();
			if (shBands > 0) {
				var shData = gsplatData.shData;
				var size = this.evalTextureSize(numSplats);
				var texture0 = this.createTexture('shTexture0', PIXELFORMAT_RGBA32U, size);
				var texture1 = this.createTexture('shTexture1', PIXELFORMAT_RGBA32U, size);
				var texture2 = this.createTexture('shTexture2', PIXELFORMAT_RGBA32U, size);
				var data0 = texture0.lock();
				var data1 = texture1.lock();
				var data2 = texture2.lock();
				var target0 = new Uint8Array(data0.buffer);
				var target1 = new Uint8Array(data1.buffer);
				var target2 = new Uint8Array(data2.buffer);
				var srcCoeffs = [3, 8, 15][shBands - 1];
				for (var _i = 0; _i < numSplats; ++_i) {
					for (var j = 0; j < 15; ++j) {
						target0[_i * 16 + j] = j < srcCoeffs ? shData[(_i * 3 + 0) * srcCoeffs + j] : 127;
						target1[_i * 16 + j] = j < srcCoeffs ? shData[(_i * 3 + 1) * srcCoeffs + j] : 127;
						target2[_i * 16 + j] = j < srcCoeffs ? shData[(_i * 3 + 2) * srcCoeffs + j] : 127;
					}
				}
				texture0.unlock();
				texture1.unlock();
				texture2.unlock();
				this.shTexture0 = texture0;
				this.shTexture1 = texture1;
				this.shTexture2 = texture2;
			} else {
				this.shTexture0 = null;
				this.shTexture1 = null;
				this.shTexture2 = null;
			}
		}
		var _proto = GSplatCompressed.prototype;
		_proto.destroy = function destroy() {
			var _this$packedTexture, _this$chunkTexture, _this$shTexture, _this$shTexture2, _this$shTexture3;
			(_this$packedTexture = this.packedTexture) == null || _this$packedTexture.destroy();
			(_this$chunkTexture = this.chunkTexture) == null || _this$chunkTexture.destroy();
			(_this$shTexture = this.shTexture0) == null || _this$shTexture.destroy();
			(_this$shTexture2 = this.shTexture1) == null || _this$shTexture2.destroy();
			(_this$shTexture3 = this.shTexture2) == null || _this$shTexture3.destroy();
		};
		_proto.createMaterial = function createMaterial(options) {
			var result = createGSplatMaterial(options);
			result.setDefine('GSPLAT_COMPRESSED_DATA', true);
			result.setParameter('packedTexture', this.packedTexture);
			result.setParameter('chunkTexture', this.chunkTexture);
			result.setParameter('numSplats', this.numSplatsVisible);
			if (this.shTexture0) {
				result.setDefine('SH_BANDS', 3);
				result.setParameter('shTexture0', this.shTexture0);
				result.setParameter('shTexture1', this.shTexture1);
				result.setParameter('shTexture2', this.shTexture2);
			} else {
				result.setDefine('SH_BANDS', 0);
			}
			return result;
		};
		_proto.evalTextureSize = function evalTextureSize(count) {
			var width = Math.ceil(Math.sqrt(count));
			var height = Math.ceil(count / width);
			return new Vec2(width, height);
		};
		_proto.createTexture = function createTexture(name, format, size, data) {
			return new Texture(this.device, _extends({
				name: name,
				width: size.x,
				height: size.y,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			}, data ? {
				levels: [data]
			} : {}));
		};
		return GSplatCompressed;
	}();

	var GSplatResource = function () {
		function GSplatResource(device, splatData) {
			this.device = void 0;
			this.splatData = void 0;
			this.splat = null;
			this.device = device;
			this.splatData = splatData;
		}
		var _proto = GSplatResource.prototype;
		_proto.destroy = function destroy() {
			var _this$splat;
			this.device = null;
			this.splatData = null;
			(_this$splat = this.splat) == null || _this$splat.destroy();
			this.splat = null;
		};
		_proto.createSplat = function createSplat() {
			if (!this.splat) {
				this.splat = this.splatData.isCompressed ? new GSplatCompressed(this.device, this.splatData) : new GSplat(this.device, this.splatData);
			}
			return this.splat;
		};
		_proto.instantiate = function instantiate(options) {
			if (options === void 0) {
				options = {};
			}
			var splatInstance = this.createInstance(options);
			var entity = new Entity();
			var component = entity.addComponent('gsplat', {
				instance: splatInstance
			});
			entity.setLocalEulerAngles(0, 0, 180);
			component.customAabb = splatInstance.splat.aabb.clone();
			return entity;
		};
		_proto.createInstance = function createInstance(options) {
			if (options === void 0) {
				options = {};
			}
			var splat = this.createSplat();
			return new GSplatInstance(splat, options);
		};
		return GSplatResource;
	}();

	var magicBytes = new Uint8Array([112, 108, 121, 10]);
	var endHeaderBytes = new Uint8Array([10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10]);
	var dataTypeMap = new Map([['char', Int8Array], ['uchar', Uint8Array], ['short', Int16Array], ['ushort', Uint16Array], ['int', Int32Array], ['uint', Uint32Array], ['float', Float32Array], ['double', Float64Array]]);
	var StreamBuf = function () {
		function StreamBuf(reader) {
			this.reader = void 0;
			this.data = void 0;
			this.view = void 0;
			this.head = 0;
			this.tail = 0;
			this.reader = reader;
		}
		var _proto = StreamBuf.prototype;
		_proto.read = function () {
			var _read = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
				var _yield$this$reader$re, value, done;
				return _regeneratorRuntime().wrap(function _callee$(_context) {
					while (1) switch (_context.prev = _context.next) {
						case 0:
							_context.next = 2;
							return this.reader.read();
						case 2:
							_yield$this$reader$re = _context.sent;
							value = _yield$this$reader$re.value;
							done = _yield$this$reader$re.done;
							if (!done) {
								_context.next = 7;
								break;
							}
							throw new Error('Stream finished before end of header');
						case 7:
							this.push(value);
						case 8:
						case "end":
							return _context.stop();
					}
				}, _callee, this);
			}));
			function read() {
				return _read.apply(this, arguments);
			}
			return read;
		}();
		_proto.push = function push(data) {
			if (!this.data) {
				this.data = data;
				this.view = new DataView(this.data.buffer);
				this.tail = data.length;
			} else {
				var remaining = this.tail - this.head;
				var newSize = remaining + data.length;
				if (this.data.length >= newSize) {
					if (this.head > 0) {
						this.data.copyWithin(0, this.head, this.tail);
						this.data.set(data, remaining);
						this.head = 0;
						this.tail = newSize;
					} else {
						this.data.set(data, this.tail);
						this.tail += data.length;
					}
				} else {
					var tmp = new Uint8Array(newSize);
					if (this.head > 0 || this.tail < this.data.length) {
						tmp.set(this.data.subarray(this.head, this.tail), 0);
					} else {
						tmp.set(this.data, 0);
					}
					tmp.set(data, remaining);
					this.data = tmp;
					this.view = new DataView(this.data.buffer);
					this.head = 0;
					this.tail = newSize;
				}
			}
		};
		_proto.compact = function compact() {
			if (this.head > 0) {
				this.data.copyWithin(0, this.head, this.tail);
				this.tail -= this.head;
				this.head = 0;
			}
		};
		_proto.getInt8 = function getInt8() {
			var result = this.view.getInt8(this.head);
			this.head++;
			return result;
		};
		_proto.getUint8 = function getUint8() {
			var result = this.view.getUint8(this.head);
			this.head++;
			return result;
		};
		_proto.getInt16 = function getInt16() {
			var result = this.view.getInt16(this.head, true);
			this.head += 2;
			return result;
		};
		_proto.getUint16 = function getUint16() {
			var result = this.view.getUint16(this.head, true);
			this.head += 2;
			return result;
		};
		_proto.getInt32 = function getInt32() {
			var result = this.view.getInt32(this.head, true);
			this.head += 4;
			return result;
		};
		_proto.getUint32 = function getUint32() {
			var result = this.view.getUint32(this.head, true);
			this.head += 4;
			return result;
		};
		_proto.getFloat32 = function getFloat32() {
			var result = this.view.getFloat32(this.head, true);
			this.head += 4;
			return result;
		};
		_proto.getFloat64 = function getFloat64() {
			var result = this.view.getFloat64(this.head, true);
			this.head += 8;
			return result;
		};
		return _createClass(StreamBuf, [{
			key: "remaining",
			get: function get() {
				return this.tail - this.head;
			}
		}]);
	}();
	var parseHeader = function parseHeader(lines) {
		var elements = [];
		var format;
		for (var i = 1; i < lines.length; ++i) {
			var words = lines[i].split(' ');
			switch (words[0]) {
				case 'format':
					format = words[1];
					break;
				case 'element':
					elements.push({
						name: words[1],
						count: parseInt(words[2], 10),
						properties: []
					});
					break;
				case 'property':
					{
						if (!dataTypeMap.has(words[1])) {
							throw new Error("Unrecognized property data type '" + words[1] + "' in ply header");
						}
						var element = elements[elements.length - 1];
						element.properties.push({
							type: words[1],
							name: words[2],
							storage: null,
							byteSize: dataTypeMap.get(words[1]).BYTES_PER_ELEMENT
						});
						break;
					}
				default:
					throw new Error("Unrecognized header value '" + words[0] + "' in ply header");
			}
		}
		return {
			elements: elements,
			format: format
		};
	};
	var isCompressedPly = function isCompressedPly(elements) {
		var chunkProperties = ['min_x', 'min_y', 'min_z', 'max_x', 'max_y', 'max_z', 'min_scale_x', 'min_scale_y', 'min_scale_z', 'max_scale_x', 'max_scale_y', 'max_scale_z', 'min_r', 'min_g', 'min_b', 'max_r', 'max_g', 'max_b'];
		var vertexProperties = ['packed_position', 'packed_rotation', 'packed_scale', 'packed_color'];
		var shProperties = new Array(45).fill('').map(function (_, i) {
			return "f_rest_" + i;
		});
		var hasBaseElements = function hasBaseElements() {
			return elements[0].name === 'chunk' && elements[0].properties.every(function (p, i) {
				return p.name === chunkProperties[i] && p.type === 'float';
			}) && elements[1].name === 'vertex' && elements[1].properties.every(function (p, i) {
				return p.name === vertexProperties[i] && p.type === 'uint';
			});
		};
		var hasSHElements = function hasSHElements() {
			return elements[2].name === 'sh' && [9, 24, 45].indexOf(elements[2].properties.length) !== -1 && elements[2].properties.every(function (p, i) {
				return p.name === shProperties[i] && p.type === 'uchar';
			});
		};
		return elements.length === 2 && hasBaseElements() || elements.length === 3 && hasBaseElements() && hasSHElements();
	};
	var isFloatPly = function isFloatPly(elements) {
		return elements.length === 1 && elements[0].name === 'vertex' && elements[0].properties.every(function (p) {
			return p.type === 'float';
		});
	};
	var readCompressedPly = function () {
		var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(streamBuf, elements, littleEndian) {
			var result, numChunks, numChunkProperties, numVertices, evalStorageSize, read;
			return _regeneratorRuntime().wrap(function _callee3$(_context3) {
				while (1) switch (_context3.prev = _context3.next) {
					case 0:
						result = new GSplatCompressedData();
						numChunks = elements[0].count;
						numChunkProperties = elements[0].properties.length;
						numVertices = elements[1].count;
						evalStorageSize = function evalStorageSize(count) {
							var width = Math.ceil(Math.sqrt(count));
							var height = Math.ceil(count / width);
							return width * height;
						};
						result.numSplats = numVertices;
						result.chunkData = new Float32Array(numChunks * numChunkProperties);
						result.vertexData = new Uint32Array(evalStorageSize(numVertices) * 4);
						read = function () {
							var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(buffer, length) {
								var target, cursor, toCopy, src, i;
								return _regeneratorRuntime().wrap(function _callee2$(_context2) {
									while (1) switch (_context2.prev = _context2.next) {
										case 0:
											target = new Uint8Array(buffer);
											cursor = 0;
										case 2:
											if (!(cursor < length)) {
												_context2.next = 13;
												break;
											}
										case 3:
											if (!(streamBuf.remaining === 0)) {
												_context2.next = 8;
												break;
											}
											_context2.next = 6;
											return streamBuf.read();
										case 6:
											_context2.next = 3;
											break;
										case 8:
											toCopy = Math.min(length - cursor, streamBuf.remaining);
											src = streamBuf.data;
											for (i = 0; i < toCopy; ++i) {
												target[cursor++] = src[streamBuf.head++];
											}
											_context2.next = 2;
											break;
										case 13:
										case "end":
											return _context2.stop();
									}
								}, _callee2);
							}));
							return function read(_x4, _x5) {
								return _ref2.apply(this, arguments);
							};
						}();
						_context3.next = 11;
						return read(result.chunkData.buffer, numChunks * numChunkProperties * 4);
					case 11:
						_context3.next = 13;
						return read(result.vertexData.buffer, numVertices * 4 * 4);
					case 13:
						if (!(elements.length === 3)) {
							_context3.next = 17;
							break;
						}
						result.shData = new Uint8Array(elements[2].count * elements[2].properties.length);
						_context3.next = 17;
						return read(result.shData.buffer, result.shData.byteLength);
					case 17:
						return _context3.abrupt("return", result);
					case 18:
					case "end":
						return _context3.stop();
				}
			}, _callee3);
		}));
		return function readCompressedPly(_x, _x2, _x3) {
			return _ref.apply(this, arguments);
		};
	}();
	var readFloatPly = function () {
		var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(streamBuf, elements, littleEndian) {
			var element, properties, numProperties, storage, inputSize, vertexIdx, floatData, checkFloatData, toRead, j, s, n;
			return _regeneratorRuntime().wrap(function _callee4$(_context4) {
				while (1) switch (_context4.prev = _context4.next) {
					case 0:
						element = elements[0];
						properties = element.properties;
						numProperties = properties.length;
						storage = properties.map(function (p) {
							return p.storage;
						});
						inputSize = properties.reduce(function (a, p) {
							return a + p.byteSize;
						}, 0);
						vertexIdx = 0;
						checkFloatData = function checkFloatData() {
							var _floatData;
							var buffer = streamBuf.data.buffer;
							if (((_floatData = floatData) == null ? void 0 : _floatData.buffer) !== buffer) {
								floatData = new Float32Array(buffer, 0, buffer.byteLength / 4);
							}
						};
						checkFloatData();
					case 8:
						if (!(vertexIdx < element.count)) {
							_context4.next = 21;
							break;
						}
					case 9:
						if (!(streamBuf.remaining < inputSize)) {
							_context4.next = 15;
							break;
						}
						_context4.next = 12;
						return streamBuf.read();
					case 12:
						checkFloatData();
						_context4.next = 9;
						break;
					case 15:
						toRead = Math.min(element.count - vertexIdx, Math.floor(streamBuf.remaining / inputSize));
						for (j = 0; j < numProperties; ++j) {
							s = storage[j];
							for (n = 0; n < toRead; ++n) {
								s[n + vertexIdx] = floatData[n * numProperties + j];
							}
						}
						vertexIdx += toRead;
						streamBuf.head += toRead * inputSize;
						_context4.next = 8;
						break;
					case 21:
						return _context4.abrupt("return", new GSplatData(elements));
					case 22:
					case "end":
						return _context4.stop();
				}
			}, _callee4);
		}));
		return function readFloatPly(_x6, _x7, _x8) {
			return _ref3.apply(this, arguments);
		};
	}();
	var readGeneralPly = function () {
		var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(streamBuf, elements, littleEndian) {
			var i, element, inputSize, propertyParsingFunctions, c, toRead, n, j;
			return _regeneratorRuntime().wrap(function _callee5$(_context5) {
				while (1) switch (_context5.prev = _context5.next) {
					case 0:
						i = 0;
					case 1:
						if (!(i < elements.length)) {
							_context5.next = 19;
							break;
						}
						element = elements[i];
						inputSize = element.properties.reduce(function (a, p) {
							return a + p.byteSize;
						}, 0);
						propertyParsingFunctions = element.properties.map(function (p) {
							if (p.storage) {
								switch (p.type) {
									case 'char':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getInt8();
										};
									case 'uchar':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getUint8();
										};
									case 'short':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getInt16();
										};
									case 'ushort':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getUint16();
										};
									case 'int':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getInt32();
										};
									case 'uint':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getUint32();
										};
									case 'float':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getFloat32();
										};
									case 'double':
										return function (streamBuf, c) {
											p.storage[c] = streamBuf.getFloat64();
										};
									default:
										throw new Error("Unsupported property data type '" + p.type + "' in ply header");
								}
							} else {
								return function (streamBuf) {
									streamBuf.head += p.byteSize;
								};
							}
						});
						c = 0;
					case 6:
						if (!(c < element.count)) {
							_context5.next = 16;
							break;
						}
					case 7:
						if (!(streamBuf.remaining < inputSize)) {
							_context5.next = 12;
							break;
						}
						_context5.next = 10;
						return streamBuf.read();
					case 10:
						_context5.next = 7;
						break;
					case 12:
						toRead = Math.min(element.count - c, Math.floor(streamBuf.remaining / inputSize));
						for (n = 0; n < toRead; ++n) {
							for (j = 0; j < element.properties.length; ++j) {
								propertyParsingFunctions[j](streamBuf, c);
							}
							c++;
						}
						_context5.next = 6;
						break;
					case 16:
						++i;
						_context5.next = 1;
						break;
					case 19:
						return _context5.abrupt("return", new GSplatData(elements));
					case 20:
					case "end":
						return _context5.stop();
				}
			}, _callee5);
		}));
		return function readGeneralPly(_x9, _x10, _x11) {
			return _ref4.apply(this, arguments);
		};
	}();
	var readPly = function () {
		var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(reader, propertyFilter) {
			var find, startsWith, streamBuf, headerLength, lines, _parseHeader, elements, format;
			return _regeneratorRuntime().wrap(function _callee6$(_context6) {
				while (1) switch (_context6.prev = _context6.next) {
					case 0:
						if (propertyFilter === void 0) {
							propertyFilter = null;
						}
						find = function find(buf, search) {
							var endIndex = buf.length - search.length;
							var i, j;
							for (i = 0; i <= endIndex; ++i) {
								for (j = 0; j < search.length; ++j) {
									if (buf[i + j] !== search[j]) {
										break;
									}
								}
								if (j === search.length) {
									return i;
								}
							}
							return -1;
						};
						startsWith = function startsWith(a, b) {
							if (a.length < b.length) {
								return false;
							}
							for (var i = 0; i < b.length; ++i) {
								if (a[i] !== b[i]) {
									return false;
								}
							}
							return true;
						};
						streamBuf = new StreamBuf(reader);
					case 4:
						_context6.next = 7;
						return streamBuf.read();
					case 7:
						if (!(streamBuf.tail >= magicBytes.length && !startsWith(streamBuf.data, magicBytes))) {
							_context6.next = 9;
							break;
						}
						throw new Error('Invalid ply header');
					case 9:
						headerLength = find(streamBuf.data, endHeaderBytes);
						if (!(headerLength !== -1)) {
							_context6.next = 12;
							break;
						}
						return _context6.abrupt("break", 14);
					case 12:
						_context6.next = 4;
						break;
					case 14:
						lines = new TextDecoder('ascii').decode(streamBuf.data.subarray(0, headerLength)).split('\n').filter(function (line) {
							return !line.startsWith('comment ');
						});
						_parseHeader = parseHeader(lines), elements = _parseHeader.elements, format = _parseHeader.format;
						if (!(format !== 'binary_little_endian' && format !== 'binary_big_endian')) {
							_context6.next = 18;
							break;
						}
						throw new Error('Unsupported ply format');
					case 18:
						streamBuf.head = headerLength + endHeaderBytes.length;
						streamBuf.compact();
						if (!isCompressedPly(elements)) {
							_context6.next = 24;
							break;
						}
						_context6.next = 23;
						return readCompressedPly(streamBuf, elements, format === 'binary_little_endian');
					case 23:
						return _context6.abrupt("return", _context6.sent);
					case 24:
						elements.forEach(function (e) {
							e.properties.forEach(function (p) {
								var storageType = dataTypeMap.get(p.type);
								if (storageType) {
									var storage = !propertyFilter || propertyFilter(p.name) ? new storageType(e.count) : null;
									p.storage = storage;
								}
							});
						});
						if (!isFloatPly(elements)) {
							_context6.next = 29;
							break;
						}
						_context6.next = 28;
						return readFloatPly(streamBuf, elements, format === 'binary_little_endian');
					case 28:
						return _context6.abrupt("return", _context6.sent);
					case 29:
						_context6.next = 31;
						return readGeneralPly(streamBuf, elements, format === 'binary_little_endian');
					case 31:
						return _context6.abrupt("return", _context6.sent);
					case 32:
					case "end":
						return _context6.stop();
				}
			}, _callee6);
		}));
		return function readPly(_x12, _x13) {
			return _ref5.apply(this, arguments);
		};
	}();
	var defaultElementFilter = function defaultElementFilter(val) {
		return true;
	};
	var PlyParser = function () {
		function PlyParser(device, assets, maxRetries) {
			this.device = void 0;
			this.assets = void 0;
			this.maxRetries = void 0;
			this.device = device;
			this.assets = assets;
			this.maxRetries = maxRetries;
		}
		var _proto2 = PlyParser.prototype;
		_proto2.load = function () {
			var _load = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7(url, callback, asset) {
				var response, _asset$data$elementFi, gsplatData, _asset$data$reorder, resource;
				return _regeneratorRuntime().wrap(function _callee7$(_context7) {
					while (1) switch (_context7.prev = _context7.next) {
						case 0:
							_context7.prev = 0;
							_context7.next = 3;
							return fetch(url.load);
						case 3:
							response = _context7.sent;
							if (!(!response || !response.body)) {
								_context7.next = 8;
								break;
							}
							callback('Error loading resource', null);
							_context7.next = 14;
							break;
						case 8:
							_context7.next = 10;
							return readPly(response.body.getReader(), (_asset$data$elementFi = asset.data.elementFilter) != null ? _asset$data$elementFi : defaultElementFilter);
						case 10:
							gsplatData = _context7.sent;
							if (!gsplatData.isCompressed) {
								if ((_asset$data$reorder = asset.data.reorder) != null ? _asset$data$reorder : true) {
									gsplatData.reorderData();
								}
							}
							resource = new GSplatResource(this.device, gsplatData.isCompressed && asset.data.decompress ? gsplatData.decompress() : gsplatData);
							callback(null, resource);
						case 14:
							_context7.next = 19;
							break;
						case 16:
							_context7.prev = 16;
							_context7.t0 = _context7["catch"](0);
							callback(_context7.t0, null);
						case 19:
						case "end":
							return _context7.stop();
					}
				}, _callee7, this, [[0, 16]]);
			}));
			function load(_x14, _x15, _x16) {
				return _load.apply(this, arguments);
			}
			return load;
		}();
		_proto2.open = function open(url, data) {
			return data;
		};
		return PlyParser;
	}();

	var GSplatHandler = function (_ResourceHandler) {
		function GSplatHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'gsplat') || this;
			_this.parser = new PlyParser(app.graphicsDevice, app.assets, 3);
			return _this;
		}
		_inheritsLoose(GSplatHandler, _ResourceHandler);
		var _proto = GSplatHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			this.parser.load(url, callback, asset);
		};
		_proto.open = function open(url, data, asset) {
			return this.parser.open(url, data, asset);
		};
		return GSplatHandler;
	}(ResourceHandler);

	var CompressUtils = function () {
		function CompressUtils() {}
		CompressUtils.setCompressedPRS = function setCompressedPRS(entity, data, compressed) {
			var a = compressed.singleVecs;
			var b, i;
			var v = data.___1;
			if (!v) {
				b = compressed.tripleVecs;
				i = data.___2;
			}
			var n = v ? v[0] : b[i];
			entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
			n = v ? v[1] : b[i + 1];
			entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
			n = v ? v[2] : b[i + 2];
			entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
		};
		CompressUtils.oneCharToKey = function oneCharToKey(s, data) {
			var i = s.charCodeAt(0) - data.fieldFirstCode;
			return data.fieldArray[i];
		};
		CompressUtils.multCharToKey = function multCharToKey(s, data) {
			var ind = 0;
			for (var i = 0; i < s.length; i++) {
				ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
			}
			return data.fieldArray[ind];
		};
		return CompressUtils;
	}();

	var Decompress = function () {
		function Decompress(node, data) {
			this._node = node;
			this._data = data;
		}
		var _proto = Decompress.prototype;
		_proto.run = function run() {
			var type = Object.prototype.toString.call(this._node);
			if (type === '[object Object]') {
				this._handleMap();
			} else if (type === '[object Array]') {
				this._handleArray();
			} else {
				this._result = this._node;
			}
			return this._result;
		};
		_proto._handleMap = function _handleMap() {
			this._result = {};
			var a = Object.keys(this._node);
			a.forEach(this._handleKey, this);
		};
		_proto._handleKey = function _handleKey(origKey) {
			var newKey = origKey;
			var len = origKey.length;
			if (len === 1) {
				newKey = CompressUtils.oneCharToKey(origKey, this._data);
			} else if (len === 2) {
				newKey = CompressUtils.multCharToKey(origKey, this._data);
			}
			this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
		};
		_proto._handleArray = function _handleArray() {
			this._result = [];
			this._node.forEach(this._handleArElt, this);
		};
		_proto._handleArElt = function _handleArElt(elt) {
			var v = new Decompress(elt, this._data).run();
			this._result.push(v);
		};
		return Decompress;
	}();

	var SceneParser = function () {
		function SceneParser(app, isTemplate) {
			this._app = app;
			this._isTemplate = isTemplate;
		}
		var _proto = SceneParser.prototype;
		_proto.parse = function parse(data) {
			var entities = {};
			var parent = null;
			var compressed = data.compressedFormat;
			if (compressed && !data.entDecompressed) {
				data.entDecompressed = true;
				data.entities = new Decompress(data.entities, compressed).run();
			}
			for (var id in data.entities) {
				var curData = data.entities[id];
				var curEnt = this._createEntity(curData, compressed);
				entities[id] = curEnt;
				if (curData.parent === null) {
					parent = curEnt;
				}
			}
			for (var _id in data.entities) {
				var _curEnt = entities[_id];
				var children = data.entities[_id].children;
				var len = children.length;
				for (var i = 0; i < len; i++) {
					var childEnt = entities[children[i]];
					if (childEnt) {
						_curEnt.addChild(childEnt);
					}
				}
			}
			this._openComponentData(parent, data.entities);
			return parent;
		};
		_proto._createEntity = function _createEntity(data, compressed) {
			var _data$enabled;
			var entity = new Entity(data.name, this._app);
			entity.setGuid(data.resource_id);
			this._setPosRotScale(entity, data, compressed);
			entity._enabled = (_data$enabled = data.enabled) != null ? _data$enabled : true;
			if (this._isTemplate) {
				entity._template = true;
			} else {
				entity._enabledInHierarchy = entity._enabled;
			}
			entity.template = data.template;
			if (data.tags) {
				for (var i = 0; i < data.tags.length; i++) {
					entity.tags.add(data.tags[i]);
				}
			}
			return entity;
		};
		_proto._setPosRotScale = function _setPosRotScale(entity, data, compressed) {
			if (compressed) {
				CompressUtils.setCompressedPRS(entity, data, compressed);
			} else {
				var p = data.position;
				var r = data.rotation;
				var s = data.scale;
				entity.setLocalPosition(p[0], p[1], p[2]);
				entity.setLocalEulerAngles(r[0], r[1], r[2]);
				entity.setLocalScale(s[0], s[1], s[2]);
			}
		};
		_proto._openComponentData = function _openComponentData(entity, entities) {
			var systemsList = this._app.systems.list;
			var len = systemsList.length;
			var entityData = entities[entity.getGuid()];
			for (var i = 0; i < len; i++) {
				var system = systemsList[i];
				var componentData = entityData.components[system.id];
				if (componentData) {
					system.addComponent(entity, componentData);
				}
			}
			len = entityData.children.length;
			var children = entity._children;
			for (var _i = 0; _i < len; _i++) {
				if (children[_i]) {
					children[_i] = this._openComponentData(children[_i], entities);
				}
			}
			return entity;
		};
		return SceneParser;
	}();

	var SceneUtils = function () {
		function SceneUtils() {}
		SceneUtils.load = function load(url, maxRetries, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: maxRetries > 0,
				maxRetries: maxRetries
			}, function (err, response) {
				if (!err) {
					callback(err, response);
				} else {
					var errMsg = "Error while loading scene JSON " + url.original;
					if (err.message) {
						errMsg += ": " + err.message;
						if (err.stack) {
							errMsg += "\n" + err.stack;
						}
					} else {
						errMsg += ": " + err;
					}
					callback(errMsg);
				}
			});
		};
		return SceneUtils;
	}();

	var HierarchyHandler = function (_ResourceHandler) {
		function HierarchyHandler(app) {
			return _ResourceHandler.call(this, app, 'hierarchy') || this;
		}
		_inheritsLoose(HierarchyHandler, _ResourceHandler);
		var _proto = HierarchyHandler.prototype;
		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};
		_proto.open = function open(url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			this._app.systems.script.preloading = false;
			return parent;
		};
		return HierarchyHandler;
	}(ResourceHandler);

	var HtmlHandler = function (_ResourceHandler) {
		function HtmlHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'html') || this;
			_this.decoder = null;
			return _this;
		}
		_inheritsLoose(HtmlHandler, _ResourceHandler);
		var _proto = HtmlHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading html resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.openBinary = function openBinary(data) {
			var _this$decoder;
			(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');
			return this.decoder.decode(data);
		};
		return HtmlHandler;
	}(ResourceHandler);

	var JsonHandler = function (_ResourceHandler) {
		function JsonHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'json') || this;
			_this.decoder = null;
			return _this;
		}
		_inheritsLoose(JsonHandler, _ResourceHandler);
		var _proto = JsonHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:')) {
				options.responseType = Http.ResponseType.JSON;
			}
			http.get(url.load, options, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading JSON resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.openBinary = function openBinary(data) {
			var _this$decoder;
			(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');
			return JSON.parse(this.decoder.decode(data));
		};
		return JsonHandler;
	}(ResourceHandler);

	var StandardMaterialValidator = function () {
		function StandardMaterialValidator() {
			this.removeInvalid = true;
			this.valid = true;
			this.enumValidators = {
				occludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),
				cull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),
				blendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),
				depthFunc: this._createEnumValidator([FUNC_NEVER, FUNC_LESS, FUNC_EQUAL, FUNC_LESSEQUAL, FUNC_GREATER, FUNC_NOTEQUAL, FUNC_GREATEREQUAL, FUNC_ALWAYS])
			};
		}
		var _proto = StandardMaterialValidator.prototype;
		_proto.setInvalid = function setInvalid(key, data) {
			this.valid = false;
			if (this.removeInvalid) {
				delete data[key];
			}
		};
		_proto.validate = function validate(data) {
			var TYPES = standardMaterialParameterTypes;
			var REMOVED = standardMaterialRemovedParameters;
			var pathMapping = data.mappingFormat === 'path';
			for (var key in data) {
				var type = TYPES[key];
				if (!type) {
					if (REMOVED[key]) {
						delete data[key];
					} else {
						this.valid = false;
					}
					continue;
				}
				if (type.startsWith('enum')) {
					var enumType = type.split(':')[1];
					if (this.enumValidators[enumType]) {
						if (!this.enumValidators[enumType](data[key])) {
							this.setInvalid(key, data);
						}
					}
				} else if (type === 'number') {
					if (typeof data[key] !== 'number') {
						this.setInvalid(key, data);
					}
				} else if (type === 'boolean') {
					if (typeof data[key] !== 'boolean') {
						this.setInvalid(key, data);
					}
				} else if (type === 'string') {
					if (typeof data[key] !== 'string') {
						this.setInvalid(key, data);
					}
				} else if (type === 'vec2') {
					if (!(data[key] instanceof Array && data[key].length === 2)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'rgb') {
					if (!(data[key] instanceof Array && data[key].length === 3)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'texture') {
					if (!pathMapping) {
						if (!(typeof data[key] === 'number' || data[key] === null)) {
							if (!(data[key] instanceof Texture)) {
								this.setInvalid(key, data);
							}
						}
					} else {
						if (!(typeof data[key] === 'string' || data[key] === null)) {
							if (!(data[key] instanceof Texture)) {
								this.setInvalid(key, data);
							}
						}
					}
				} else if (type === 'boundingbox') {
					if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
						this.setInvalid(key, data);
					}
					if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
						this.setInvalid(key, data);
					}
				} else if (type === 'cubemap') {
					if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
						if (!(data[key] instanceof Texture && data[key].cubemap)) {
							this.setInvalid(key, data);
						}
					}
				} else if (type === 'chunks') {
					var chunkNames = Object.keys(data[key]);
					for (var i = 0; i < chunkNames.length; i++) {
						if (typeof data[key][chunkNames[i]] !== 'string') {
							this.setInvalid(chunkNames[i], data[key]);
						}
					}
				} else {
					console.error("Unknown material type: " + type);
				}
			}
			data.validated = true;
			return this.valid;
		};
		_proto._createEnumValidator = function _createEnumValidator(values) {
			return function (value) {
				return values.indexOf(value) >= 0;
			};
		};
		return StandardMaterialValidator;
	}();

	var JsonStandardMaterialParser = function () {
		function JsonStandardMaterialParser() {
			this._validator = null;
		}
		var _proto = JsonStandardMaterialParser.prototype;
		_proto.parse = function parse(input) {
			var migrated = this.migrate(input);
			var validated = this._validate(migrated);
			var material = new StandardMaterial();
			this.initialize(material, validated);
			return material;
		};
		_proto.initialize = function initialize(material, data) {
			if (!data.validated) {
				data = this._validate(data);
			}
			if (data.chunks) {
				material.chunks = _extends({}, data.chunks);
			}
			for (var key in data) {
				var type = standardMaterialParameterTypes[key];
				var value = data[key];
				if (type === 'vec2') {
					material[key] = new Vec2(value[0], value[1]);
				} else if (type === 'rgb') {
					material[key] = new Color(value[0], value[1], value[2]);
				} else if (type === 'texture') {
					if (value instanceof Texture) {
						material[key] = value;
					} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
						material[key] = null;
					}
				} else if (type === 'cubemap') {
					if (value instanceof Texture) {
						material[key] = value;
					} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
						material[key] = null;
					}
					if (key === 'cubeMap' && !value) {
						material.prefilteredCubemaps = null;
					}
				} else if (type === 'boundingbox') {
					var center = new Vec3(value.center[0], value.center[1], value.center[2]);
					var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
					material[key] = new BoundingBox(center, halfExtents);
				} else {
					material[key] = data[key];
				}
			}
			material.update();
		};
		_proto.migrate = function migrate(data) {
			if (data.shader) delete data.shader;
			if (data.mapping_format) {
				data.mappingFormat = data.mapping_format;
				delete data.mapping_format;
			}
			var i;
			var RENAMED_PROPERTIES = [['bumpMapFactor', 'bumpiness'], ['aoUvSet', 'aoMapUv'], ['aoMapVertexColor', 'aoVertexColor'], ['diffuseMapVertexColor', 'diffuseVertexColor'], ['emissiveMapVertexColor', 'emissiveVertexColor'], ['specularMapVertexColor', 'specularVertexColor'], ['metalnessMapVertexColor', 'metalnessVertexColor'], ['opacityMapVertexColor', 'opacityVertexColor'], ['glossMapVertexColor', 'glossVertexColor'], ['lightMapVertexColor', 'lightVertexColor'], ['specularMapTint', 'specularTint'], ['metalnessMapTint', 'metalnessTint'], ['clearCoatGlossiness', 'clearCoatGloss']];
			for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
				var _old = RENAMED_PROPERTIES[i][0];
				var _new = RENAMED_PROPERTIES[i][1];
				if (data[_old] !== undefined) {
					if (data[_new] === undefined) {
						data[_new] = data[_old];
					}
					delete data[_old];
				}
			}
			var DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];
			for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
				var name = DEPRECATED_PROPERTIES[i];
				if (data.hasOwnProperty(name)) {
					delete data[name];
				}
			}
			return data;
		};
		_proto._validate = function _validate(data) {
			if (!data.validated) {
				if (!this._validator) {
					this._validator = new StandardMaterialValidator();
				}
				this._validator.validate(data);
			}
			return data;
		};
		return JsonStandardMaterialParser;
	}();

	var PLACEHOLDER_MAP = {
		aoMap: 'white',
		aoDetailMap: 'white',
		diffuseMap: 'gray',
		diffuseDetailMap: 'gray',
		specularMap: 'gray',
		specularityFactorMap: 'white',
		metalnessMap: 'black',
		glossMap: 'gray',
		sheenMap: 'black',
		sheenGlossMap: 'gray',
		clearCoatMap: 'black',
		clearCoatGlossMap: 'gray',
		clearCoatNormalMap: 'normal',
		refractionMap: 'white',
		emissiveMap: 'gray',
		normalMap: 'normal',
		normalDetailMap: 'normal',
		heightMap: 'gray',
		opacityMap: 'gray',
		sphereMap: 'gray',
		lightMap: 'white',
		thicknessMap: 'black',
		iridescenceMap: 'black',
		iridescenceThicknessMap: 'black',
		envAtlas: 'black'
	};
	var MaterialHandler = function (_ResourceHandler) {
		function MaterialHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'material') || this;
			_this._assets = app.assets;
			_this._device = app.graphicsDevice;
			_this._parser = new JsonStandardMaterialParser();
			return _this;
		}
		_inheritsLoose(MaterialHandler, _ResourceHandler);
		var _proto = MaterialHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					if (callback) {
						response._engine = true;
						callback(null, response);
					}
				} else {
					if (callback) {
						callback("Error loading material: " + url.original + " [" + err + "]");
					}
				}
			});
		};
		_proto.open = function open(url, data) {
			var material = this._parser.parse(data);
			if (data._engine) {
				material._data = data;
				delete data._engine;
			}
			return material;
		};
		_proto.patch = function patch(asset, assets) {
			if (asset.resource._data) {
				asset._data = asset.resource._data;
				delete asset.resource._data;
			}
			asset.data.name = asset.name;
			asset.resource.name = asset.name;
			this._bindAndAssignAssets(asset, assets);
			asset.off('unload', this._onAssetUnload, this);
			asset.on('unload', this._onAssetUnload, this);
		};
		_proto._onAssetUnload = function _onAssetUnload(asset) {
			delete asset.data.parameters;
			delete asset.data.chunks;
			delete asset.data.name;
		};
		_proto._assignTexture = function _assignTexture(parameterName, materialAsset, texture) {
			materialAsset.resource[parameterName] = texture;
		};
		_proto._getPlaceholderTexture = function _getPlaceholderTexture(parameterName) {
			var placeholder = PLACEHOLDER_MAP[parameterName];
			return getBuiltInTexture(this._device, placeholder);
		};
		_proto._assignPlaceholderTexture = function _assignPlaceholderTexture(parameterName, materialAsset) {
			materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);
		};
		_proto._onTextureLoad = function _onTextureLoad(parameterName, materialAsset, textureAsset) {
			this._assignTexture(parameterName, materialAsset, textureAsset.resource);
			materialAsset.resource.update();
		};
		_proto._onTextureAdd = function _onTextureAdd(parameterName, materialAsset, textureAsset) {
			this._assets.load(textureAsset);
		};
		_proto._onTextureRemoveOrUnload = function _onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
			var material = materialAsset.resource;
			if (material) {
				if (materialAsset.resource[parameterName] === textureAsset.resource) {
					this._assignPlaceholderTexture(parameterName, materialAsset);
					material.update();
				}
			}
		};
		_proto._assignCubemap = function _assignCubemap(parameterName, materialAsset, textures) {
			materialAsset.resource[parameterName] = textures[0];
			if (parameterName === 'cubeMap') {
				var prefiltered = textures.slice(1);
				if (prefiltered.every(function (t) {
					return t;
				})) {
					materialAsset.resource.prefilteredCubemaps = prefiltered;
				} else if (prefiltered[0]) {
					materialAsset.resource.envAtlas = prefiltered[0];
				}
			}
		};
		_proto._onCubemapLoad = function _onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
			this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);
			this._parser.initialize(materialAsset.resource, materialAsset.data);
		};
		_proto._onCubemapAdd = function _onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
			this._assets.load(cubemapAsset);
		};
		_proto._onCubemapRemoveOrUnload = function _onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
			var material = materialAsset.resource;
			if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
				this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);
				material.update();
			}
		};
		_proto._bindAndAssignAssets = function _bindAndAssignAssets(materialAsset, assets) {
			var data = this._parser.migrate(materialAsset.data);
			var material = materialAsset.resource;
			var pathMapping = data.mappingFormat === 'path';
			var TEXTURES = standardMaterialTextureParameters;
			var i, name, assetReference;
			for (i = 0; i < TEXTURES.length; i++) {
				name = TEXTURES[i];
				assetReference = material._assetReferences[name];
				var dataAssetId = data[name];
				var materialTexture = material[name];
				var isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);
				var dataValidated = data.validated;
				if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onTextureLoad,
							add: this._onTextureAdd,
							remove: this._onTextureRemoveOrUnload,
							unload: this._onTextureRemoveOrUnload
						}, this);
						material._assetReferences[name] = assetReference;
					}
					if (pathMapping) {
						assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
					} else {
						assetReference.id = dataAssetId;
					}
					if (assetReference.asset) {
						if (assetReference.asset.resource) {
							this._assignTexture(name, materialAsset, assetReference.asset.resource);
						} else {
							this._assignPlaceholderTexture(name, materialAsset);
						}
						assets.load(assetReference.asset);
					}
				} else {
					if (assetReference) {
						if (pathMapping) {
							assetReference.url = null;
						} else {
							assetReference.id = null;
						}
					}
				}
			}
			var CUBEMAPS = standardMaterialCubemapParameters;
			for (i = 0; i < CUBEMAPS.length; i++) {
				name = CUBEMAPS[i];
				assetReference = material._assetReferences[name];
				if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
					if (!assetReference) {
						assetReference = new AssetReference(name, materialAsset, assets, {
							load: this._onCubemapLoad,
							add: this._onCubemapAdd,
							remove: this._onCubemapRemoveOrUnload,
							unload: this._onCubemapRemoveOrUnload
						}, this);
						material._assetReferences[name] = assetReference;
					}
					if (pathMapping) {
						assetReference.url = data[name];
					} else {
						assetReference.id = data[name];
					}
					if (assetReference.asset) {
						if (assetReference.asset.loaded) {
							this._assignCubemap(name, materialAsset, assetReference.asset.resources);
						}
						assets.load(assetReference.asset);
					}
				}
			}
			this._parser.initialize(material, data);
		};
		return MaterialHandler;
	}(ResourceHandler);

	var GlbModelParser = function () {
		function GlbModelParser(modelHandler) {
			this._device = modelHandler.device;
			this._defaultMaterial = modelHandler.defaultMaterial;
			this._assets = modelHandler.assets;
		}
		var _proto = GlbModelParser.prototype;
		_proto.parse = function parse(data, callback, asset) {
			var _asset$options,
				_this = this;
			GlbParser.parse('filename.glb', '', data, this._device, this._assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, function (err, result) {
				if (err) {
					callback(err);
				} else {
					var model = GlbContainerResource.createModel(result, _this._defaultMaterial);
					result.destroy();
					callback(null, model);
				}
			});
		};
		return GlbModelParser;
	}();

	var JSON_PRIMITIVE_TYPE = {
		'points': PRIMITIVE_POINTS,
		'lines': PRIMITIVE_LINES,
		'lineloop': PRIMITIVE_LINELOOP,
		'linestrip': PRIMITIVE_LINESTRIP,
		'triangles': PRIMITIVE_TRIANGLES,
		'trianglestrip': PRIMITIVE_TRISTRIP,
		'trianglefan': PRIMITIVE_TRIFAN
	};
	var JSON_VERTEX_ELEMENT_TYPE = {
		'int8': TYPE_INT8,
		'uint8': TYPE_UINT8,
		'int16': TYPE_INT16,
		'uint16': TYPE_UINT16,
		'int32': TYPE_INT32,
		'uint32': TYPE_UINT32,
		'float32': TYPE_FLOAT32
	};
	var JsonModelParser = function () {
		function JsonModelParser(modelHandler) {
			this._device = modelHandler.device;
			this._defaultMaterial = modelHandler.defaultMaterial;
		}
		var _proto = JsonModelParser.prototype;
		_proto.parse = function parse(data, callback) {
			var modelData = data.model;
			if (!modelData) {
				callback(null, null);
				return;
			}
			if (modelData.version <= 1) {
				callback('JsonModelParser#parse: Trying to parse unsupported model format.');
				return;
			}
			var nodes = this._parseNodes(data);
			var skins = this._parseSkins(data, nodes);
			var vertexBuffers = this._parseVertexBuffers(data);
			var indices = this._parseIndexBuffers(data, vertexBuffers);
			var morphs = this._parseMorphs(data, nodes, vertexBuffers);
			var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);
			var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);
			var model = new Model();
			model.graph = nodes[0];
			model.meshInstances = meshInstances;
			model.skinInstances = skins.instances;
			model.morphInstances = morphs.instances;
			model.getGraph().syncHierarchy();
			callback(null, model);
		};
		_proto._parseNodes = function _parseNodes(data) {
			var modelData = data.model;
			var nodes = [];
			var i;
			for (i = 0; i < modelData.nodes.length; i++) {
				var nodeData = modelData.nodes[i];
				var node = new GraphNode(nodeData.name);
				node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
				node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
				node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
				node.scaleCompensation = !!nodeData.scaleCompensation;
				nodes.push(node);
			}
			for (i = 1; i < modelData.parents.length; i++) {
				nodes[modelData.parents[i]].addChild(nodes[i]);
			}
			return nodes;
		};
		_proto._parseSkins = function _parseSkins(data, nodes) {
			var modelData = data.model;
			var skins = [];
			var skinInstances = [];
			var i, j;
			for (i = 0; i < modelData.skins.length; i++) {
				var skinData = modelData.skins[i];
				var inverseBindMatrices = [];
				for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
					var ibm = skinData.inverseBindMatrices[j];
					inverseBindMatrices[j] = new Mat4().set(ibm);
				}
				var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
				skins.push(skin);
				var skinInstance = new SkinInstance(skin);
				var bones = [];
				for (j = 0; j < skin.boneNames.length; j++) {
					var boneName = skin.boneNames[j];
					var bone = nodes[0].findByName(boneName);
					bones.push(bone);
				}
				skinInstance.bones = bones;
				skinInstances.push(skinInstance);
			}
			return {
				skins: skins,
				instances: skinInstances
			};
		};
		_proto._getMorphVertexCount = function _getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
			for (var i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				if (meshData.morph === morphIndex) {
					var vertexBuffer = vertexBuffers[meshData.vertices];
					return vertexBuffer.numVertices;
				}
			}
			return undefined;
		};
		_proto._parseMorphs = function _parseMorphs(data, nodes, vertexBuffers) {
			var modelData = data.model;
			var morphs = [];
			var morphInstances = [];
			var i, j, vertexCount;
			var targets, morphTarget, morphTargetArray;
			if (modelData.morphs) {
				var sparseToFull = function sparseToFull(data, indices, totalCount) {
					var full = new Float32Array(totalCount * 3);
					for (var s = 0; s < indices.length; s++) {
						var dstIndex = indices[s] * 3;
						full[dstIndex] = data[s * 3];
						full[dstIndex + 1] = data[s * 3 + 1];
						full[dstIndex + 2] = data[s * 3 + 2];
					}
					return full;
				};
				for (i = 0; i < modelData.morphs.length; i++) {
					targets = modelData.morphs[i].targets;
					morphTargetArray = [];
					vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);
					for (j = 0; j < targets.length; j++) {
						var targetAabb = targets[j].aabb;
						var min = targetAabb.min;
						var max = targetAabb.max;
						var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
						var indices = targets[j].indices;
						var deltaPositions = targets[j].deltaPositions;
						var deltaNormals = targets[j].deltaNormals;
						if (indices) {
							deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
							deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
						}
						morphTarget = new MorphTarget({
							deltaPositions: deltaPositions,
							deltaNormals: deltaNormals,
							name: targets[j].name,
							aabb: aabb
						});
						morphTargetArray.push(morphTarget);
					}
					var morph = new Morph(morphTargetArray, this._device);
					morphs.push(morph);
					var morphInstance = new MorphInstance(morph);
					morphInstances.push(morphInstance);
				}
			}
			return {
				morphs: morphs,
				instances: morphInstances
			};
		};
		_proto._parseVertexBuffers = function _parseVertexBuffers(data) {
			var modelData = data.model;
			var vertexBuffers = [];
			var attributeMap = {
				position: SEMANTIC_POSITION,
				normal: SEMANTIC_NORMAL,
				tangent: SEMANTIC_TANGENT,
				blendWeight: SEMANTIC_BLENDWEIGHT,
				blendIndices: SEMANTIC_BLENDINDICES,
				color: SEMANTIC_COLOR,
				texCoord0: SEMANTIC_TEXCOORD0,
				texCoord1: SEMANTIC_TEXCOORD1,
				texCoord2: SEMANTIC_TEXCOORD2,
				texCoord3: SEMANTIC_TEXCOORD3,
				texCoord4: SEMANTIC_TEXCOORD4,
				texCoord5: SEMANTIC_TEXCOORD5,
				texCoord6: SEMANTIC_TEXCOORD6,
				texCoord7: SEMANTIC_TEXCOORD7
			};
			for (var i = 0; i < modelData.vertices.length; i++) {
				var vertexData = modelData.vertices[i];
				var formatDesc = [];
				for (var attributeName in vertexData) {
					var attribute = vertexData[attributeName];
					formatDesc.push({
						semantic: attributeMap[attributeName],
						components: attribute.components,
						type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
						normalize: attributeMap[attributeName] === SEMANTIC_COLOR
					});
				}
				var vertexFormat = new VertexFormat(this._device, formatDesc);
				var numVertices = vertexData.position.data.length / vertexData.position.components;
				var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
				var iterator = new VertexIterator(vertexBuffer);
				for (var j = 0; j < numVertices; j++) {
					for (var _attributeName in vertexData) {
						var _attribute = vertexData[_attributeName];
						switch (_attribute.components) {
							case 1:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j]);
								break;
							case 2:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 2], 1.0 - _attribute.data[j * 2 + 1]);
								break;
							case 3:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 3], _attribute.data[j * 3 + 1], _attribute.data[j * 3 + 2]);
								break;
							case 4:
								iterator.element[attributeMap[_attributeName]].set(_attribute.data[j * 4], _attribute.data[j * 4 + 1], _attribute.data[j * 4 + 2], _attribute.data[j * 4 + 3]);
								break;
						}
					}
					iterator.next();
				}
				iterator.end();
				vertexBuffers.push(vertexBuffer);
			}
			return vertexBuffers;
		};
		_proto._parseIndexBuffers = function _parseIndexBuffers(data, vertexBuffers) {
			var modelData = data.model;
			var indexBuffer = null;
			var indexData = null;
			var i;
			var numIndices = 0;
			for (i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				if (meshData.indices !== undefined) {
					numIndices += meshData.indices.length;
				}
			}
			var maxVerts = 0;
			for (i = 0; i < vertexBuffers.length; i++) {
				maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
			}
			if (numIndices > 0) {
				if (maxVerts > 0xFFFF) {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
					indexData = new Uint32Array(indexBuffer.lock());
				} else {
					indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
					indexData = new Uint16Array(indexBuffer.lock());
				}
			}
			return {
				buffer: indexBuffer,
				data: indexData
			};
		};
		_proto._parseMeshes = function _parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
			var modelData = data.model;
			var meshes = [];
			var indexBase = 0;
			for (var i = 0; i < modelData.meshes.length; i++) {
				var meshData = modelData.meshes[i];
				var meshAabb = meshData.aabb;
				var min = meshAabb.min;
				var max = meshAabb.max;
				var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
				var indexed = meshData.indices !== undefined;
				var mesh = new Mesh(this._device);
				mesh.vertexBuffer = vertexBuffers[meshData.vertices];
				mesh.indexBuffer[0] = indexed ? indexBuffer : null;
				mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
				mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
				mesh.primitive[0].count = meshData.count;
				mesh.primitive[0].indexed = indexed;
				mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
				mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
				mesh.aabb = aabb;
				if (indexed) {
					indexData.set(meshData.indices, indexBase);
					indexBase += meshData.indices.length;
				}
				meshes.push(mesh);
			}
			if (indexBuffer !== null) {
				indexBuffer.unlock();
			}
			return meshes;
		};
		_proto._parseMeshInstances = function _parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
			var modelData = data.model;
			var meshInstances = [];
			var i;
			for (i = 0; i < modelData.meshInstances.length; i++) {
				var meshInstanceData = modelData.meshInstances[i];
				var node = nodes[meshInstanceData.node];
				var mesh = meshes[meshInstanceData.mesh];
				var meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);
				if (mesh.skin) {
					var skinIndex = skins.indexOf(mesh.skin);
					meshInstance.skinInstance = skinInstances[skinIndex];
				}
				if (mesh.morph) {
					var morphIndex = morphs.indexOf(mesh.morph);
					meshInstance.morphInstance = morphInstances[morphIndex];
				}
				meshInstances.push(meshInstance);
			}
			return meshInstances;
		};
		return JsonModelParser;
	}();

	var ModelHandler = function (_ResourceHandler) {
		function ModelHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'model') || this;
			_this._parsers = [];
			_this.device = app.graphicsDevice;
			_this.assets = app.assets;
			_this.defaultMaterial = getDefaultMaterial(_this.device);
			_this.addParser(new JsonModelParser(_this), function (url, data) {
				return path.getExtension(url) === '.json';
			});
			_this.addParser(new GlbModelParser(_this), function (url, data) {
				return path.getExtension(url) === '.glb';
			});
			return _this;
		}
		_inheritsLoose(ModelHandler, _ResourceHandler);
		var _proto = ModelHandler.prototype;
		_proto.load = function load(url, callback, asset) {
			var _this2 = this;
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
				if (path.getExtension(url.original).toLowerCase() === '.glb') {
					options.responseType = Http.ResponseType.ARRAY_BUFFER;
				} else {
					options.responseType = Http.ResponseType.JSON;
				}
			}
			http.get(url.load, options, function (err, response) {
				if (!callback) {
					return;
				}
				if (!err) {
					for (var i = 0; i < _this2._parsers.length; i++) {
						var p = _this2._parsers[i];
						if (p.decider(url.original, response)) {
							p.parser.parse(response, function (err, parseResult) {
								if (err) {
									callback(err);
								} else {
									callback(null, parseResult);
								}
							}, asset);
							return;
						}
					}
					callback('No parsers found');
				} else {
					callback("Error loading model: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {
			if (!asset.resource) {
				return;
			}
			var data = asset.data;
			var self = this;
			asset.resource.meshInstances.forEach(function (meshInstance, i) {
				if (data.mapping) {
					var _handleMaterial = function handleMaterial(asset) {
						if (asset.resource) {
							meshInstance.material = asset.resource;
						} else {
							asset.once('load', _handleMaterial);
							assets.load(asset);
						}
						asset.once('remove', function (asset) {
							if (meshInstance.material === asset.resource) {
								meshInstance.material = self.defaultMaterial;
							}
						});
					};
					if (!data.mapping[i]) {
						meshInstance.material = self.defaultMaterial;
						return;
					}
					var id = data.mapping[i].material;
					var url = data.mapping[i].path;
					var material;
					if (id !== undefined) {
						if (!id) {
							meshInstance.material = self.defaultMaterial;
						} else {
							material = assets.get(id);
							if (material) {
								_handleMaterial(material);
							} else {
								assets.once("add:" + id, _handleMaterial);
							}
						}
					} else if (url) {
						var _path = asset.getAbsoluteUrl(data.mapping[i].path);
						material = assets.getByUrl(_path);
						if (material) {
							_handleMaterial(material);
						} else {
							assets.once("add:url:" + _path, _handleMaterial);
						}
					}
				}
			});
		};
		_proto.addParser = function addParser(parser, decider) {
			this._parsers.push({
				parser: parser,
				decider: decider
			});
		};
		return ModelHandler;
	}(ResourceHandler);

	var SceneHandler = function (_ResourceHandler) {
		function SceneHandler(app) {
			return _ResourceHandler.call(this, app, 'scene') || this;
		}
		_inheritsLoose(SceneHandler, _ResourceHandler);
		var _proto = SceneHandler.prototype;
		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};
		_proto.open = function open(url, data) {
			this._app.systems.script.preloading = true;
			var parser = new SceneParser(this._app, false);
			var parent = parser.parse(data);
			var scene = this._app.scene;
			scene.root = parent;
			this._app.applySceneSettings(data.settings);
			this._app.systems.script.preloading = false;
			return scene;
		};
		return SceneHandler;
	}(ResourceHandler);

	var ScriptTypes = function () {
		function ScriptTypes() {}
		ScriptTypes.push = function push(Type) {
			ScriptTypes._types.push(Type);
		};
		return ScriptTypes;
	}();
	ScriptTypes._types = [];

	var reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'data', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', '_callbackActive', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);
	function getReservedScriptNames() {
		return reservedScriptNames;
	}
	function createScript(name, app) {
		if (reservedScriptNames.has(name)) {
			throw new Error("Script name '" + name + "' is reserved, please rename the script");
		}
		var scriptType = function scriptType(args) {
			EventHandler.prototype.initEventHandler.call(this);
			ScriptType.prototype.initScriptType.call(this, args);
		};
		scriptType.prototype = Object.create(ScriptType.prototype);
		scriptType.prototype.constructor = scriptType;
		scriptType.extend = ScriptType.extend;
		scriptType.attributes = new ScriptAttributes(scriptType);
		registerScript(scriptType, name, app);
		return scriptType;
	}
	var reservedAttributes = {};
	ScriptAttributes.reservedNames.forEach(function (value, value2, set) {
		reservedAttributes[value] = 1;
	});
	createScript.reservedAttributes = reservedAttributes;
	function registerScript(script, name, app) {
		if (typeof script !== 'function') {
			throw new Error("script class: '" + script + "' must be a constructor function (i.e. class).");
		}
		if (!(script.prototype instanceof Script)) {
			throw new Error("script class: '" + ScriptType.__getScriptName(script) + "' does not extend pc.Script.");
		}
		name = name || script.__name || ScriptType.__getScriptName(script);
		if (reservedScriptNames.has(name)) {
			throw new Error("script name: '" + name + "' is reserved, please change script name");
		}
		script.__name = name;
		var registry = app ? app.scripts : AppBase.getApplication().scripts;
		registry.add(script);
		ScriptTypes.push(script);
	}

	var toLowerCamelCase = function toLowerCamelCase(str) {
		return str[0].toLowerCase() + str.substring(1);
	};
	var ScriptHandler = function (_ResourceHandler) {
		function ScriptHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'script') || this;
			_this._scripts = {};
			_this._cache = {};
			return _this;
		}
		_inheritsLoose(ScriptHandler, _ResourceHandler);
		var _proto = ScriptHandler.prototype;
		_proto.clearCache = function clearCache() {
			for (var key in this._cache) {
				var element = this._cache[key];
				var parent = element.parentNode;
				if (parent) {
					parent.removeChild(element);
				}
			}
			this._cache = {};
		};
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			script.app = this._app;
			var onScriptLoad = (url.load, function (err, url, extra) {
				if (!err) {
					var obj = {};
					for (var i = 0; i < ScriptTypes._types.length; i++) {
						obj[ScriptTypes._types[i].name] = ScriptTypes._types[i];
					}
					ScriptTypes._types.length = 0;
					callback(null, obj, extra);
					var urlWithoutEndHash = url.split('&hash=')[0];
					delete self._loader._cache[ResourceLoader.makeKey(urlWithoutEndHash, 'script')];
				} else {
					callback(err);
				}
			});
			var _url$load$split = url.load.split('?'),
				basePath = _url$load$split[0],
				search = _url$load$split[1];
			var isEsmScript = basePath.endsWith('.mjs');
			if (isEsmScript) {
				var path = url.load;
				if (path.startsWith(this._app.assets.prefix)) {
					path = path.replace(this._app.assets.prefix, '');
				}
				var hash = this._app.assets.getByUrl(path).file.hash;
				var searchParams = new URLSearchParams(search);
				searchParams.set('hash', hash);
				var urlWithHash = basePath + "?" + searchParams.toString();
				this._loadModule(urlWithHash, onScriptLoad);
			} else {
				this._loadScript(url.load, onScriptLoad);
			}
		};
		_proto.open = function open(url, data) {
			return data;
		};
		_proto.patch = function patch(asset, assets) {};
		_proto._loadScript = function _loadScript(url, callback) {
			var head = document.head;
			var element = document.createElement('script');
			this._cache[url] = element;
			element.async = false;
			element.addEventListener('error', function (e) {
				callback("Script: " + e.target.src + " failed to load");
			}, false);
			var done = false;
			element.onload = element.onreadystatechange = function () {
				if (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {
					done = true;
					callback(null, url, element);
				}
			};
			element.src = url;
			head.appendChild(element);
		};
		_proto._loadModule = function _loadModule(url, callback) {
			var _this2 = this;
			var baseUrl = platform.browser ? window.location.origin + window.location.pathname : (typeof document === 'undefined' && typeof location === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : typeof document === 'undefined' ? location.href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('playcanvas.js', document.baseURI).href));
			var importUrl = new URL(url, baseUrl);
			new Function("modulePath", "return import(modulePath)")(importUrl.toString()).then(function (module) {
				var _this2$_app$assets$fi;
				var filename = importUrl.pathname.split('/').pop();
				var scriptSchema = (_this2$_app$assets$fi = _this2._app.assets.find(filename, 'script')) == null || (_this2$_app$assets$fi = _this2$_app$assets$fi.data) == null ? void 0 : _this2$_app$assets$fi.scripts;
				for (var key in module) {
					var scriptClass = module[key];
					var extendsScriptType = scriptClass.prototype instanceof Script;
					if (extendsScriptType) {
						var scriptName = toLowerCamelCase(scriptClass.name);
						registerScript(scriptClass, scriptName);
						if (scriptSchema) _this2._app.scripts.addSchema(scriptName, scriptSchema[scriptName]);
					}
				}
				callback(null, url, null);
			}).catch(function (err) {
				callback(err);
			});
		};
		return ScriptHandler;
	}(ResourceHandler);

	var ShaderHandler = function (_ResourceHandler) {
		function ShaderHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'shader') || this;
			_this.decoder = null;
			return _this;
		}
		_inheritsLoose(ShaderHandler, _ResourceHandler);
		var _proto = ShaderHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading shader resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.openBinary = function openBinary(data) {
			var _this$decoder;
			(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');
			return this.decoder.decode(data);
		};
		return ShaderHandler;
	}(ResourceHandler);

	function onTextureAtlasLoaded(atlasAsset) {
		var spriteAsset = this;
		if (spriteAsset.resource) {
			spriteAsset.resource.atlas = atlasAsset.resource;
		}
	}
	function onTextureAtlasAdded(atlasAsset) {
		var spriteAsset = this;
		spriteAsset.registry.load(atlasAsset);
	}
	var SpriteHandler = function (_ResourceHandler) {
		function SpriteHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'sprite') || this;
			_this._assets = app.assets;
			_this._device = app.graphicsDevice;
			return _this;
		}
		_inheritsLoose(SpriteHandler, _ResourceHandler);
		var _proto = SpriteHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						callback(null, response);
					} else {
						callback(err);
					}
				});
			}
		};
		_proto.open = function open(url, data) {
			var sprite = new Sprite(this._device);
			if (url) {
				sprite.__data = data;
			}
			return sprite;
		};
		_proto.patch = function patch(asset, assets) {
			var sprite = asset.resource;
			if (sprite.__data) {
				asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
				asset.data.renderMode = sprite.__data.renderMode;
				asset.data.frameKeys = sprite.__data.frameKeys;
				if (sprite.__data.textureAtlasAsset) {
					var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
					if (atlas) {
						asset.data.textureAtlasAsset = atlas.id;
					} else {
						console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
					}
				}
			}
			sprite.startUpdate();
			sprite.renderMode = asset.data.renderMode;
			sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
			sprite.frameKeys = asset.data.frameKeys;
			this._updateAtlas(asset);
			sprite.endUpdate();
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		};
		_proto._updateAtlas = function _updateAtlas(asset) {
			var sprite = asset.resource;
			if (!asset.data.textureAtlasAsset) {
				sprite.atlas = null;
				return;
			}
			this._assets.off("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
			this._assets.on("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
			var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
			if (atlasAsset && atlasAsset.resource) {
				sprite.atlas = atlasAsset.resource;
			} else {
				if (!atlasAsset) {
					this._assets.off("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
					this._assets.on("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
				} else {
					this._assets.load(atlasAsset);
				}
			}
		};
		_proto._onAssetChange = function _onAssetChange(asset, attribute, value, oldValue) {
			if (attribute === 'data') {
				if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
					this._assets.off("load:" + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
					this._assets.off("add:" + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
				}
			}
		};
		return SpriteHandler;
	}(ResourceHandler);

	var Template = function () {
		function Template(app, data) {
			this._app = void 0;
			this._data = void 0;
			this._templateRoot = null;
			this._app = app;
			this._data = data;
		}
		var _proto = Template.prototype;
		_proto.instantiate = function instantiate() {
			if (!this._templateRoot) {
				this._parseTemplate();
			}
			return this._templateRoot.clone();
		};
		_proto._parseTemplate = function _parseTemplate() {
			var parser = new SceneParser(this._app, true);
			this._templateRoot = parser.parse(this._data);
		};
		return Template;
	}();

	var TemplateHandler = function (_ResourceHandler) {
		function TemplateHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'template') || this;
			_this.decoder = null;
			return _this;
		}
		_inheritsLoose(TemplateHandler, _ResourceHandler);
		var _proto = TemplateHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var options = {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			http.get(url.load, options, function (err, response) {
				if (err) {
					callback("Error requesting template: " + url.original);
				} else {
					callback(err, response);
				}
			});
		};
		_proto.open = function open(url, data) {
			return new Template(this._app, data);
		};
		_proto.openBinary = function openBinary(data) {
			var _this$decoder;
			(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');
			return new Template(this._app, JSON.parse(this.decoder.decode(data)));
		};
		return TemplateHandler;
	}(ResourceHandler);

	var TextHandler = function (_ResourceHandler) {
		function TextHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'text') || this;
			_this.decoder = null;
			return _this;
		}
		_inheritsLoose(TextHandler, _ResourceHandler);
		var _proto = TextHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			http.get(url.load, {
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			}, function (err, response) {
				if (!err) {
					callback(null, response);
				} else {
					callback("Error loading text resource: " + url.original + " [" + err + "]");
				}
			});
		};
		_proto.openBinary = function openBinary(data) {
			var _this$decoder;
			(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');
			return this.decoder.decode(data);
		};
		return TextHandler;
	}(ResourceHandler);

	var JSON_ADDRESS_MODE$1 = {
		'repeat': ADDRESS_REPEAT,
		'clamp': ADDRESS_CLAMP_TO_EDGE,
		'mirror': ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE$1 = {
		'nearest': FILTER_NEAREST,
		'linear': FILTER_LINEAR,
		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
	};
	var regexFrame = /^data\.frames\.(\d+)$/;
	var TextureAtlasHandler = function (_ResourceHandler) {
		function TextureAtlasHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'textureatlas') || this;
			_this._loader = app.loader;
			return _this;
		}
		_inheritsLoose(TextureAtlasHandler, _ResourceHandler);
		var _proto = TextureAtlasHandler.prototype;
		_proto.load = function load(url, callback) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			var self = this;
			var handler = this._loader.getHandler('texture');
			if (path.getExtension(url.original) === '.json') {
				http.get(url.load, {
					retry: this.maxRetries > 0,
					maxRetries: this.maxRetries
				}, function (err, response) {
					if (!err) {
						var textureUrl = url.original.replace('.json', '.png');
						self._loader.load(textureUrl, 'texture', function (err, texture) {
							if (err) {
								callback(err);
							} else {
								callback(null, {
									data: response,
									texture: texture
								});
							}
						});
					} else {
						callback(err);
					}
				});
			} else {
				handler.load(url, callback);
			}
		};
		_proto.open = function open(url, data) {
			var resource = new TextureAtlas();
			if (data.texture && data.data) {
				resource.texture = data.texture;
				resource.__data = data.data;
			} else {
				var handler = this._loader.getHandler('texture');
				var texture = handler.open(url, data);
				if (!texture) return null;
				resource.texture = texture;
			}
			return resource;
		};
		_proto.patch = function patch(asset, assets) {
			if (!asset.resource) {
				return;
			}
			if (asset.resource.__data) {
				if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
				if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
				if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
				if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
				if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
				if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
				if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
				asset.data.frames = asset.resource.__data.frames;
				delete asset.resource.__data;
			}
			var texture = asset.resource.texture;
			if (texture) {
				texture.name = asset.name;
				if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) {
					texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];
				}
				if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) {
					texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];
				}
				if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) {
					texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];
				}
				if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) {
					texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];
				}
				if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) {
					texture.mipmaps = asset.data.mipmaps;
				}
				if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) {
					texture.anisotropy = asset.data.anisotropy;
				}
				if (asset.data.hasOwnProperty('rgbm')) {
					var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
					if (texture.type !== type) {
						texture.type = type;
					}
				}
			}
			asset.resource.texture = texture;
			var frames = {};
			for (var key in asset.data.frames) {
				var frame = asset.data.frames[key];
				frames[key] = {
					rect: new Vec4(frame.rect),
					pivot: new Vec2(frame.pivot),
					border: new Vec4(frame.border)
				};
			}
			asset.resource.frames = frames;
			asset.off('change', this._onAssetChange, this);
			asset.on('change', this._onAssetChange, this);
		};
		_proto._onAssetChange = function _onAssetChange(asset, attribute, value) {
			var frame;
			if (attribute === 'data' || attribute === 'data.frames') {
				var frames = {};
				for (var key in value.frames) {
					frame = value.frames[key];
					frames[key] = {
						rect: new Vec4(frame.rect),
						pivot: new Vec2(frame.pivot),
						border: new Vec4(frame.border)
					};
				}
				asset.resource.frames = frames;
			} else {
				var match = attribute.match(regexFrame);
				if (match) {
					var frameKey = match[1];
					if (value) {
						if (!asset.resource.frames[frameKey]) {
							asset.resource.frames[frameKey] = {
								rect: new Vec4(value.rect),
								pivot: new Vec2(value.pivot),
								border: new Vec4(value.border)
							};
						} else {
							frame = asset.resource.frames[frameKey];
							frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
							frame.pivot.set(value.pivot[0], value.pivot[1]);
							frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
						}
						asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
					} else {
						if (asset.resource.frames[frameKey]) {
							delete asset.resource.frames[frameKey];
							asset.resource.fire('remove:frame', frameKey);
						}
					}
				}
			}
		};
		return TextureAtlasHandler;
	}(ResourceHandler);

	function BasisWorker() {
		var BASIS_FORMAT = {
			cTFETC1: 0,
			cTFETC2: 1,
			cTFBC1: 2,
			cTFBC3: 3,
			cTFPVRTC1_4_RGB: 8,
			cTFPVRTC1_4_RGBA: 9,
			cTFASTC_4x4: 10,
			cTFATC_RGB: 11,
			cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
			cTFRGBA32: 13,
			cTFRGB565: 14,
			cTFRGBA4444: 16
		};
		var opaqueMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC1,
			etc1: BASIS_FORMAT.cTFETC1,
			etc2: BASIS_FORMAT.cTFETC1,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
			atc: BASIS_FORMAT.cTFATC_RGB,
			none: BASIS_FORMAT.cTFRGB565
		};
		var alphaMapping = {
			astc: BASIS_FORMAT.cTFASTC_4x4,
			dxt: BASIS_FORMAT.cTFBC3,
			etc1: BASIS_FORMAT.cTFRGBA4444,
			etc2: BASIS_FORMAT.cTFETC2,
			pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
			atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
			none: BASIS_FORMAT.cTFRGBA4444
		};
		var PIXEL_FORMAT = {
			ETC1: 21,
			ETC2_RGB: 22,
			ETC2_RGBA: 23,
			DXT1: 8,
			DXT5: 10,
			PVRTC_4BPP_RGB_1: 26,
			PVRTC_4BPP_RGBA_1: 27,
			ASTC_4x4: 28,
			ATC_RGB: 29,
			ATC_RGBA: 30,
			R8_G8_B8_A8: 7,
			R5_G6_B5: 3,
			R4_G4_B4_A4: 5
		};
		var basisToEngineMapping = function basisToEngineMapping(basisFormat, deviceDetails) {
			switch (basisFormat) {
				case BASIS_FORMAT.cTFETC1:
					return deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;
				case BASIS_FORMAT.cTFETC2:
					return PIXEL_FORMAT.ETC2_RGBA;
				case BASIS_FORMAT.cTFBC1:
					return PIXEL_FORMAT.DXT1;
				case BASIS_FORMAT.cTFBC3:
					return PIXEL_FORMAT.DXT5;
				case BASIS_FORMAT.cTFPVRTC1_4_RGB:
					return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;
				case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
					return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;
				case BASIS_FORMAT.cTFASTC_4x4:
					return PIXEL_FORMAT.ASTC_4x4;
				case BASIS_FORMAT.cTFATC_RGB:
					return PIXEL_FORMAT.ATC_RGB;
				case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
					return PIXEL_FORMAT.ATC_RGBA;
				case BASIS_FORMAT.cTFRGBA32:
					return PIXEL_FORMAT.R8_G8_B8_A8;
				case BASIS_FORMAT.cTFRGB565:
					return PIXEL_FORMAT.R5_G6_B5;
				case BASIS_FORMAT.cTFRGBA4444:
					return PIXEL_FORMAT.R4_G4_B4_A4;
			}
		};
		var unswizzleGGGR = function unswizzleGGGR(data) {
			var genB = function genB(R, G) {
				var r = R * (2.0 / 255.0) - 1.0;
				var g = G * (2.0 / 255.0) - 1.0;
				var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
				return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
			};
			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 3];
				var G = data[offset + 1];
				data[offset + 0] = R;
				data[offset + 2] = genB(R, G);
				data[offset + 3] = 255;
			}
			return data;
		};
		var pack565 = function pack565(data) {
			var result = new Uint16Array(data.length / 4);
			for (var offset = 0; offset < data.length; offset += 4) {
				var R = data[offset + 0];
				var G = data[offset + 1];
				var B = data[offset + 2];
				result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
			}
			return result;
		};
		var isPOT = function isPOT(width, height) {
			return (width & width - 1) === 0 && (height & height - 1) === 0;
		};
		var performanceNow = function performanceNow() {
			return typeof performance !== 'undefined' ? performance.now() : 0;
		};
		var basis;
		var rgbPriority;
		var rgbaPriority;
		var chooseTargetFormat = function chooseTargetFormat(deviceDetails, hasAlpha, isUASTC) {
			if (isUASTC) {
				if (deviceDetails.formats.astc) {
					return 'astc';
				}
			} else {
				if (hasAlpha) {
					if (deviceDetails.formats.etc2) {
						return 'etc2';
					}
				} else {
					if (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {
						return 'etc1';
					}
				}
			}
			var testInOrder = function testInOrder(priority) {
				for (var i = 0; i < priority.length; ++i) {
					var format = priority[i];
					if (deviceDetails.formats[format]) {
						return format;
					}
				}
				return 'none';
			};
			return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
		};
		var dimensionsValid = function dimensionsValid(width, height, format) {
			switch (format) {
				case BASIS_FORMAT.cTFETC1:
				case BASIS_FORMAT.cTFETC2:
					return true;
				case BASIS_FORMAT.cTFBC1:
				case BASIS_FORMAT.cTFBC3:
					return (width & 0x3) === 0 && (height & 0x3) === 0;
				case BASIS_FORMAT.cTFPVRTC1_4_RGB:
				case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
					return isPOT(width, height);
				case BASIS_FORMAT.cTFASTC_4x4:
					return true;
				case BASIS_FORMAT.cTFATC_RGB:
				case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
					return true;
			}
			return false;
		};
		var transcodeKTX2 = function transcodeKTX2(url, data, options) {
			if (!basis.KTX2File) {
				throw new Error('Basis transcoder module does not include support for KTX2.');
			}
			var funcStart = performanceNow();
			var basisFile = new basis.KTX2File(new Uint8Array(data));
			var width = basisFile.getWidth();
			var height = basisFile.getHeight();
			var levels = basisFile.getLevels();
			var hasAlpha = !!basisFile.getHasAlpha();
			var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
			if (!width || !height || !levels) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " levels=" + levels);
			}
			var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
			var unswizzle = !!options.isGGGR && format === 'pvr';
			var basisFormat;
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGBA32;
			} else {
				basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
				if (!dimensionsValid(width, height, basisFormat)) {
					basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
				}
			}
			if (!basisFile.startTranscoding()) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Failed to start transcoding url=" + url);
			}
			var i;
			var levelData = [];
			for (var mip = 0; mip < levels; ++mip) {
				var dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
				var dst = new Uint8Array(dstSize);
				if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
					basisFile.close();
					basisFile.delete();
					throw new Error("Failed to transcode image url=" + url);
				}
				var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
				levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
			}
			basisFile.close();
			basisFile.delete();
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGB565;
				for (i = 0; i < levelData.length; ++i) {
					levelData[i] = pack565(unswizzleGGGR(levelData[i]));
				}
			}
			return {
				format: basisToEngineMapping(basisFormat, options.deviceDetails),
				width: width,
				height: height,
				levels: levelData,
				cubemap: false,
				transcodeTime: performanceNow() - funcStart,
				url: url,
				unswizzledGGGR: unswizzle
			};
		};
		var transcodeBasis = function transcodeBasis(url, data, options) {
			var funcStart = performanceNow();
			var basisFile = new basis.BasisFile(new Uint8Array(data));
			var width = basisFile.getImageWidth(0, 0);
			var height = basisFile.getImageHeight(0, 0);
			var images = basisFile.getNumImages();
			var levels = basisFile.getNumLevels(0);
			var hasAlpha = !!basisFile.getHasAlpha();
			var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
			if (!width || !height || !images || !levels) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " images=" + images + " levels=" + levels);
			}
			var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
			var unswizzle = !!options.isGGGR && format === 'pvr';
			var basisFormat;
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGBA32;
			} else {
				basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
				if (!dimensionsValid(width, height, basisFormat)) {
					basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
				}
			}
			if (!basisFile.startTranscoding()) {
				basisFile.close();
				basisFile.delete();
				throw new Error("Failed to start transcoding url=" + url);
			}
			var i;
			var levelData = [];
			for (var mip = 0; mip < levels; ++mip) {
				var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
				var dst = new Uint8Array(dstSize);
				if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
					if (mip === levels - 1 && dstSize === levelData[mip - 1].buffer.byteLength) {
						dst.set(new Uint8Array(levelData[mip - 1].buffer));
						console.warn("Failed to transcode last mipmap level, using previous level instead url=" + url);
					} else {
						basisFile.close();
						basisFile.delete();
						throw new Error("Failed to transcode image url=" + url);
					}
				}
				var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
				levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
			}
			basisFile.close();
			basisFile.delete();
			if (unswizzle) {
				basisFormat = BASIS_FORMAT.cTFRGB565;
				for (i = 0; i < levelData.length; ++i) {
					levelData[i] = pack565(unswizzleGGGR(levelData[i]));
				}
			}
			return {
				format: basisToEngineMapping(basisFormat, options.deviceDetails),
				width: width,
				height: height,
				levels: levelData,
				cubemap: false,
				transcodeTime: performanceNow() - funcStart,
				url: url,
				unswizzledGGGR: unswizzle
			};
		};
		var transcode = function transcode(url, data, options) {
			return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
		};
		var workerTranscode = function workerTranscode(url, data, options) {
			try {
				var result = transcode(url, data, options);
				result.levels = result.levels.map(function (v) {
					return v.buffer;
				});
				self.postMessage({
					url: url,
					data: result
				}, result.levels);
			} catch (err) {
				self.postMessage({
					url: url,
					err: err
				}, null);
			}
		};
		var workerInit = function workerInit(config, callback) {
			var instantiateWasmFunc = function instantiateWasmFunc(imports, successCallback) {
				WebAssembly.instantiate(config.module, imports).then(function (result) {
					successCallback(result);
				}).catch(function (reason) {
					console.error("instantiate failed + " + reason);
				});
				return {};
			};
			self.BASIS(config.module ? {
				instantiateWasm: instantiateWasmFunc
			} : null).then(function (instance) {
				instance.initializeBasis();
				basis = instance;
				rgbPriority = config.rgbPriority;
				rgbaPriority = config.rgbaPriority;
				callback(null);
			});
		};
		var queue = [];
		self.onmessage = function (message) {
			var data = message.data;
			switch (data.type) {
				case 'init':
					workerInit(data.config, function () {
						for (var i = 0; i < queue.length; ++i) {
							workerTranscode(queue[i].url, queue[i].data, queue[i].options);
						}
						queue.length = 0;
					});
					break;
				case 'transcode':
					if (basis) {
						workerTranscode(data.url, data.data, data.options);
					} else {
						queue.push(data);
					}
					break;
			}
		};
	}

	var getCompressionFormats = function getCompressionFormats(device) {
		return {
			astc: !!device.extCompressedTextureASTC,
			atc: !!device.extCompressedTextureATC,
			dxt: !!device.extCompressedTextureS3TC,
			etc1: !!device.extCompressedTextureETC1,
			etc2: !!device.extCompressedTextureETC,
			pvr: !!device.extCompressedTexturePVRTC
		};
	};
	var prepareWorkerModules = function prepareWorkerModules(config, callback) {
		var getWorkerBlob = function getWorkerBlob(basisCode) {
			var code = ['/* basis */', basisCode, '', "(" + BasisWorker.toString() + ")()\n\n"].join('\n');
			return new Blob([code], {
				type: 'application/javascript'
			});
		};
		var wasmSupported = function wasmSupported() {
			try {
				if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
					var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
					if (module instanceof WebAssembly.Module) {
						return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
					}
				}
			} catch (e) {}
			return false;
		};
		var sendResponse = function sendResponse(basisCode, module) {
			callback(null, {
				workerUrl: URL.createObjectURL(getWorkerBlob(basisCode)),
				module: module,
				rgbPriority: config.rgbPriority,
				rgbaPriority: config.rgbaPriority
			});
		};
		var options = {
			cache: true,
			responseType: 'text',
			retry: config.maxRetries > 0,
			maxRetries: config.maxRetries
		};
		if (config.glueUrl && config.wasmUrl && wasmSupported()) {
			var basisCode = null;
			var module = null;
			http.get(config.glueUrl, options, function (err, response) {
				if (err) {
					callback(err);
				} else {
					if (module) {
						sendResponse(response, module);
					} else {
						basisCode = response;
					}
				}
			});
			var fetchPromise = fetch(config.wasmUrl);
			var compileManual = function compileManual() {
				fetchPromise.then(function (result) {
					return result.arrayBuffer();
				}).then(function (buffer) {
					return WebAssembly.compile(buffer);
				}).then(function (module_) {
					if (basisCode) {
						sendResponse(basisCode, module_);
					} else {
						module = module_;
					}
				}).catch(function (err) {
					callback(err, null);
				});
			};
			if (WebAssembly.compileStreaming) {
				WebAssembly.compileStreaming(fetchPromise).then(function (module_) {
					if (basisCode) {
						sendResponse(basisCode, module_);
					} else {
						module = module_;
					}
				}).catch(function (err) {
					compileManual();
				});
			} else {
				compileManual();
			}
		} else {
			http.get(config.fallbackUrl, options, function (err, response) {
				if (err) {
					callback(err, null);
				} else {
					sendResponse(response, null);
				}
			});
		}
	};
	var BasisQueue = function () {
		function BasisQueue() {
			this.callbacks = {};
			this.queue = [];
			this.clients = [];
		}
		var _proto = BasisQueue.prototype;
		_proto.enqueueJob = function enqueueJob(url, data, callback, options) {
			if (this.callbacks.hasOwnProperty(url)) {
				this.callbacks[url].push(callback);
			} else {
				this.callbacks[url] = [callback];
				var job = {
					url: url,
					data: data,
					options: options
				};
				if (this.clients.length > 0) {
					this.clients.shift().run(job);
				} else {
					this.queue.push(job);
				}
			}
		};
		_proto.enqueueClient = function enqueueClient(client) {
			if (this.queue.length > 0) {
				client.run(this.queue.shift());
			} else {
				this.clients.push(client);
			}
		};
		_proto.handleResponse = function handleResponse(url, err, data) {
			var callback = this.callbacks[url];
			if (err) {
				for (var i = 0; i < callback.length; ++i) {
					callback[i](err);
				}
			} else {
				if (data.format === PIXELFORMAT_RGB565 || data.format === PIXELFORMAT_RGBA4) {
					data.levels = data.levels.map(function (v) {
						return new Uint16Array(v);
					});
				} else {
					data.levels = data.levels.map(function (v) {
						return new Uint8Array(v);
					});
				}
				for (var _i = 0; _i < callback.length; ++_i) {
					callback[_i](null, data);
				}
			}
			delete this.callbacks[url];
		};
		return BasisQueue;
	}();
	var BasisClient = function () {
		function BasisClient(queue, config, eager) {
			var _this = this;
			this.queue = queue;
			this.worker = new Worker(config.workerUrl);
			this.worker.addEventListener('message', function (message) {
				var data = message.data;
				_this.queue.handleResponse(data.url, data.err, data.data);
				if (!_this.eager) {
					_this.queue.enqueueClient(_this);
				}
			});
			this.worker.postMessage({
				type: 'init',
				config: config
			});
			this.eager = eager;
		}
		var _proto2 = BasisClient.prototype;
		_proto2.run = function run(job) {
			var transfer = [];
			if (job.data instanceof ArrayBuffer) {
				transfer.push(job.data);
			}
			this.worker.postMessage({
				type: 'transcode',
				url: job.url,
				format: job.format,
				data: job.data,
				options: job.options
			}, transfer);
			if (this.eager) {
				this.queue.enqueueClient(this);
			}
		};
		return BasisClient;
	}();
	var defaultNumWorkers = 1;
	var defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];
	var defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];
	var defaultMaxRetries = 5;
	var queue = new BasisQueue();
	var lazyConfig = null;
	var initializing = false;
	function basisInitialize(config) {
		if (initializing) {
			return;
		}
		if (!config) {
			config = lazyConfig || {};
		} else if (config.lazyInit) {
			lazyConfig = config;
			return;
		}
		if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
			var moduleConfig = WasmModule.getConfig('BASIS');
			if (moduleConfig) {
				config = {
					glueUrl: moduleConfig.glueUrl,
					wasmUrl: moduleConfig.wasmUrl,
					fallbackUrl: moduleConfig.fallbackUrl,
					numWorkers: moduleConfig.numWorkers
				};
			}
		}
		if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
			initializing = true;
			var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
			var eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
			config.rgbPriority = config.rgbPriority || defaultRgbPriority;
			config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
			config.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;
			prepareWorkerModules(config, function (err, clientConfig) {
				if (err) {
					console.error("failed to initialize basis worker: " + err);
				} else {
					for (var i = 0; i < numWorkers; ++i) {
						queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
					}
				}
			});
		}
	}
	var deviceDetails = null;
	function basisTranscode(device, url, data, callback, options) {
		basisInitialize();
		if (!deviceDetails) {
			deviceDetails = {
				formats: getCompressionFormats(device)
			};
		}
		queue.enqueueJob(url, data, callback, {
			deviceDetails: deviceDetails,
			isGGGR: !!(options != null && options.isGGGR),
			isKTX2: !!(options != null && options.isKTX2)
		});
		return initializing;
	}

	var TextureParser = function () {
		function TextureParser() {}
		var _proto = TextureParser.prototype;
		_proto.load = function load(url, callback, asset) {
			throw new Error('not implemented');
		};
		_proto.open = function open(url, data, device) {
			throw new Error('not implemented');
		};
		return TextureParser;
	}();

	var BasisParser = function (_TextureParser) {
		function BasisParser(registry, device) {
			var _this;
			_this = _TextureParser.call(this) || this;
			_this.device = device;
			_this.maxRetries = 0;
			return _this;
		}
		_inheritsLoose(BasisParser, _TextureParser);
		var _proto = BasisParser.prototype;
		_proto.load = function load(url, callback, asset) {
			var device = this.device;
			var transcode = function transcode(data) {
				var _asset$file;
				var basisModuleFound = basisTranscode(device, url.load, data, callback, {
					isGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0
				});
				if (!basisModuleFound) {
					callback("Basis module not found. Asset [" + asset.name + "](" + asset.getFileUrl() + ") basis texture variant will not be loaded.");
				}
			};
			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err);
				} else {
					transcode(result);
				}
			}, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var format = textureOptions.srgb ? pixelFormatLinearToGamma(data.format) : data.format;
			var texture = new Texture(device, _extends({
				name: url,
				addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: data.width,
				height: data.height,
				format: format,
				cubemap: data.cubemap,
				levels: data.levels
			}, textureOptions));
			texture.upload();
			return texture;
		};
		return BasisParser;
	}(TextureParser);

	var ImgParser = function (_TextureParser) {
		function ImgParser(registry, device) {
			var _this;
			_this = _TextureParser.call(this) || this;
			_this.crossOrigin = registry.prefix ? 'anonymous' : null;
			_this.maxRetries = 0;
			_this.device = device;
			return _this;
		}
		_inheritsLoose(ImgParser, _TextureParser);
		var _proto = ImgParser.prototype;
		_proto.load = function load(url, callback, asset) {
			var _asset$file;
			var hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);
			if (hasContents) {
				if (this.device.supportsImageBitmap) {
					this._loadImageBitmapFromBlob(new Blob([asset.file.contents]), callback);
					return;
				}
				url = {
					load: URL.createObjectURL(new Blob([asset.file.contents])),
					original: url.original
				};
			}
			var handler = function handler(err, result) {
				if (hasContents) {
					URL.revokeObjectURL(url.load);
				}
				callback(err, result);
			};
			var crossOrigin;
			if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
				crossOrigin = asset.options.crossOrigin;
			} else if (ABSOLUTE_URL.test(url.load)) {
				crossOrigin = this.crossOrigin;
			}
			if (this.device.supportsImageBitmap) {
				this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
			} else {
				this._loadImage(url.load, url.original, crossOrigin, handler);
			}
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var texture = new Texture(device, _extends({
				name: url,
				width: data.width,
				height: data.height,
				format: textureOptions.srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8
			}, textureOptions));
			texture.setSource(data);
			return texture;
		};
		_proto._loadImage = function _loadImage(url, originalUrl, crossOrigin, callback) {
			var image = new Image();
			if (crossOrigin) {
				image.crossOrigin = crossOrigin;
			}
			var retries = 0;
			var maxRetries = this.maxRetries;
			var retryTimeout;
			image.onload = function () {
				callback(null, image);
			};
			image.onerror = function () {
				if (retryTimeout) return;
				if (maxRetries > 0 && ++retries <= maxRetries) {
					var retryDelay = Math.pow(2, retries) * 100;
					console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");
					var idx = url.indexOf('?');
					var separator = idx >= 0 ? '&' : '?';
					retryTimeout = setTimeout(function () {
						image.src = url + separator + "retry=" + Date.now();
						retryTimeout = null;
					}, retryDelay);
				} else {
					callback("Error loading Texture from: '" + originalUrl + "'");
				}
			};
			image.src = url;
		};
		_proto._loadImageBitmap = function _loadImageBitmap(url, originalUrl, crossOrigin, callback) {
			var _this2 = this;
			var options = {
				cache: true,
				responseType: 'blob',
				retry: this.maxRetries > 0,
				maxRetries: this.maxRetries
			};
			http.get(url, options, function (err, blob) {
				if (err) {
					callback(err);
				} else {
					_this2._loadImageBitmapFromBlob(blob, callback);
				}
			});
		};
		_proto._loadImageBitmapFromBlob = function _loadImageBitmapFromBlob(blob, callback) {
			createImageBitmap(blob, {
				premultiplyAlpha: 'none',
				colorSpaceConversion: 'none'
			}).then(function (imageBitmap) {
				return callback(null, imageBitmap);
			}).catch(function (e) {
				return callback(e);
			});
		};
		return ImgParser;
	}(TextureParser);

	var IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];
	var KNOWN_FORMATS = {
		0x83F0: PIXELFORMAT_DXT1,
		0x83F2: PIXELFORMAT_DXT3,
		0x83F3: PIXELFORMAT_DXT5,
		0x8D64: PIXELFORMAT_ETC1,
		0x9274: PIXELFORMAT_ETC2_RGB,
		0x9278: PIXELFORMAT_ETC2_RGBA,
		0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
		0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
		0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
		0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
		0x8051: PIXELFORMAT_RGB8,
		0x8058: PIXELFORMAT_RGBA8,
		0x8C41: PIXELFORMAT_SRGB8,
		0x8C43: PIXELFORMAT_SRGBA8,
		0x8C3A: PIXELFORMAT_111110F,
		0x881B: PIXELFORMAT_RGB16F,
		0x881A: PIXELFORMAT_RGBA16F
	};
	function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
		return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
	}
	var KtxParser = function (_TextureParser) {
		function KtxParser(registry) {
			var _this;
			_this = _TextureParser.call(this) || this;
			_this.maxRetries = 0;
			return _this;
		}
		_inheritsLoose(KtxParser, _TextureParser);
		var _proto = KtxParser.prototype;
		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var textureData = this.parse(data);
			if (!textureData) {
				return null;
			}
			var format = textureOptions.srgb ? pixelFormatLinearToGamma(textureData.format) : textureData.format;
			var texture = new Texture(device, _extends({
				name: url,
				addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: textureData.width,
				height: textureData.height,
				format: format,
				cubemap: textureData.cubemap,
				levels: textureData.levels
			}, textureOptions));
			texture.upload();
			return texture;
		};
		_proto.parse = function parse(data) {
			var dataU32 = new Uint32Array(data);
			if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
				return null;
			}
			var header = {
				endianness: dataU32[3],
				glType: dataU32[4],
				glTypeSize: dataU32[5],
				glFormat: dataU32[6],
				glInternalFormat: dataU32[7],
				glBaseInternalFormat: dataU32[8],
				pixelWidth: dataU32[9],
				pixelHeight: dataU32[10],
				pixelDepth: dataU32[11],
				numberOfArrayElements: dataU32[12],
				numberOfFaces: dataU32[13],
				numberOfMipmapLevels: dataU32[14],
				bytesOfKeyValueData: dataU32[15]
			};
			if (header.pixelDepth > 1) {
				return null;
			}
			if (header.numberOfArrayElements !== 0) {
				return null;
			}
			var format = KNOWN_FORMATS[header.glInternalFormat];
			if (format === undefined) {
				return null;
			}
			var offset = 16 + header.bytesOfKeyValueData / 4;
			var isCubemap = header.numberOfFaces > 1;
			var levels = [];
			for (var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
				var imageSizeInBytes = dataU32[offset++];
				if (isCubemap) {
					levels.push([]);
				}
				var target = isCubemap ? levels[mipmapLevel] : levels;
				for (var face = 0; face < (isCubemap ? 6 : 1); ++face) {
					target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
					offset += imageSizeInBytes + 3 >> 2;
				}
			}
			return {
				format: format,
				width: header.pixelWidth,
				height: header.pixelHeight,
				levels: levels,
				cubemap: isCubemap
			};
		};
		return KtxParser;
	}(TextureParser);

	var KHRConstants = {
		KHR_DF_MODEL_ETC1S: 163,
		KHR_DF_MODEL_UASTC: 166
	};
	var Ktx2Parser = function (_TextureParser) {
		function Ktx2Parser(registry, device) {
			var _this;
			_this = _TextureParser.call(this) || this;
			_this.maxRetries = 0;
			_this.device = device;
			return _this;
		}
		_inheritsLoose(Ktx2Parser, _TextureParser);
		var _proto = Ktx2Parser.prototype;
		_proto.load = function load(url, callback, asset) {
			var _this2 = this;
			Asset.fetchArrayBuffer(url.load, function (err, result) {
				if (err) {
					callback(err, result);
				} else {
					_this2.parse(result, url, callback, asset);
				}
			}, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var format = textureOptions.srgb ? pixelFormatLinearToGamma(data.format) : data.format;
			var texture = new Texture(device, _extends({
				name: url,
				addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: data.width,
				height: data.height,
				format: format,
				cubemap: data.cubemap,
				levels: data.levels
			}, textureOptions));
			texture.upload();
			return texture;
		};
		_proto.parse = function parse(arraybuffer, url, callback, asset) {
			var rs = new ReadStream(arraybuffer);
			var magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];
			if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
				return null;
			}
			var header = {
				vkFormat: rs.readU32(),
				typeSize: rs.readU32(),
				pixelWidth: rs.readU32(),
				pixelHeight: rs.readU32(),
				pixelDepth: rs.readU32(),
				layerCount: rs.readU32(),
				faceCount: rs.readU32(),
				levelCount: rs.readU32(),
				supercompressionScheme: rs.readU32()
			};
			var index = {
				dfdByteOffset: rs.readU32(),
				dfdByteLength: rs.readU32(),
				kvdByteOffset: rs.readU32(),
				kvdByteLength: rs.readU32(),
				sgdByteOffset: rs.readU64(),
				sgdByteLength: rs.readU64()
			};
			var levels = [];
			for (var i = 0; i < Math.max(1, header.levelCount); ++i) {
				levels.push({
					byteOffset: rs.readU64(),
					byteLength: rs.readU64(),
					uncompressedByteLength: rs.readU64()
				});
			}
			var dfdTotalSize = rs.readU32();
			if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
				return null;
			}
			rs.skip(8);
			var colorModel = rs.readU8();
			rs.skip(index.dfdByteLength - 9);
			rs.skip(index.kvdByteLength);
			if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
				var _asset$file;
				var basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
					isGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0,
					isKTX2: true
				});
				if (!basisModuleFound) {
					callback("Basis module not found. Asset [" + asset.name + "](" + asset.getFileUrl() + ") basis texture variant will not be loaded.");
				}
			} else {
				callback('unsupported KTX2 pixel format');
			}
		};
		return Ktx2Parser;
	}(TextureParser);

	var DdsParser = function (_TextureParser) {
		function DdsParser(registry) {
			var _this;
			_this = _TextureParser.call(this) || this;
			_this.maxRetries = 0;
			return _this;
		}
		_inheritsLoose(DdsParser, _TextureParser);
		var _proto = DdsParser.prototype;
		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var header = new Uint32Array(data, 0, 128 / 4);
			var width = header[4];
			var height = header[3];
			var mips = Math.max(header[7], 1);
			var isFourCc = header[20] === 4;
			var fcc = header[21];
			var bpp = header[22];
			var isCubemap = header[28] === 65024;
			var FCC_DXT1 = 827611204;
			var FCC_DXT5 = 894720068;
			var FCC_FP16 = 113;
			var FCC_FP32 = 116;
			var FCC_ETC1 = 826496069;
			var FCC_PVRTC_2BPP_RGB_1 = 825438800;
			var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
			var FCC_PVRTC_4BPP_RGB_1 = 825439312;
			var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
			var compressed = false;
			var etc1 = false;
			var pvrtc2 = false;
			var pvrtc4 = false;
			var format = null;
			var componentSize = 1;
			var texture;
			if (isFourCc) {
				if (fcc === FCC_DXT1) {
					format = PIXELFORMAT_DXT1;
					compressed = true;
				} else if (fcc === FCC_DXT5) {
					format = PIXELFORMAT_DXT5;
					compressed = true;
				} else if (fcc === FCC_FP16) {
					format = PIXELFORMAT_RGBA16F;
					componentSize = 2;
				} else if (fcc === FCC_FP32) {
					format = PIXELFORMAT_RGBA32F;
					componentSize = 4;
				} else if (fcc === FCC_ETC1) {
					format = PIXELFORMAT_ETC1;
					compressed = true;
					etc1 = true;
				} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
					compressed = true;
					pvrtc2 = true;
				} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
					format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
					compressed = true;
					pvrtc4 = true;
				}
			} else {
				if (bpp === 32) {
					format = PIXELFORMAT_RGBA8;
				}
			}
			if (!format) {
				texture = new Texture(device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_RGB8,
					name: 'dds-legacy-empty'
				});
				return texture;
			}
			texture = new Texture(device, _extends({
				name: url,
				addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
				width: width,
				height: height,
				format: format,
				cubemap: isCubemap,
				mipmaps: mips > 1
			}, textureOptions));
			var offset = 128;
			var faces = isCubemap ? 6 : 1;
			var mipSize;
			var DXT_BLOCK_WIDTH = 4;
			var DXT_BLOCK_HEIGHT = 4;
			var blockSize = fcc === FCC_DXT1 ? 8 : 16;
			var numBlocksAcross, numBlocksDown, numBlocks;
			for (var face = 0; face < faces; face++) {
				var mipWidth = width;
				var mipHeight = height;
				for (var i = 0; i < mips; i++) {
					if (compressed) {
						if (etc1) {
							mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
						} else if (pvrtc2) {
							mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
						} else if (pvrtc4) {
							mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
						} else {
							numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
							numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
							numBlocks = numBlocksAcross * numBlocksDown;
							mipSize = numBlocks * blockSize;
						}
					} else {
						mipSize = mipWidth * mipHeight * 4;
					}
					var mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
					if (!isCubemap) {
						texture._levels[i] = mipBuff;
					} else {
						if (!texture._levels[i]) texture._levels[i] = [];
						texture._levels[i][face] = mipBuff;
					}
					offset += mipSize * componentSize;
					mipWidth = Math.max(mipWidth * 0.5, 1);
					mipHeight = Math.max(mipHeight * 0.5, 1);
				}
			}
			texture.upload();
			return texture;
		};
		return DdsParser;
	}(TextureParser);

	var HdrParser = function (_TextureParser) {
		function HdrParser(registry) {
			var _this;
			_this = _TextureParser.call(this) || this;
			_this.maxRetries = 0;
			return _this;
		}
		_inheritsLoose(HdrParser, _TextureParser);
		var _proto = HdrParser.prototype;
		_proto.load = function load(url, callback, asset) {
			Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
		};
		_proto.open = function open(url, data, device, textureOptions) {
			if (textureOptions === void 0) {
				textureOptions = {};
			}
			var textureData = this.parse(data);
			if (!textureData) {
				return null;
			}
			var texture = new Texture(device, _extends({
				name: url,
				addressU: ADDRESS_REPEAT,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				width: textureData.width,
				height: textureData.height,
				levels: textureData.levels,
				format: PIXELFORMAT_RGBA8,
				type: TEXTURETYPE_RGBE,
				mipmaps: false
			}, textureOptions));
			texture.upload();
			return texture;
		};
		_proto.parse = function parse(data) {
			var readStream = new ReadStream(data);
			var magic = readStream.readLine();
			if (!magic.startsWith('#?RADIANCE')) {
				return null;
			}
			var variables = {};
			while (true) {
				var line = readStream.readLine();
				if (line.length === 0) {
					break;
				} else {
					var parts = line.split('=');
					if (parts.length === 2) {
						variables[parts[0]] = parts[1];
					}
				}
			}
			if (!variables.hasOwnProperty('FORMAT')) {
				return null;
			}
			var resolution = readStream.readLine().split(' ');
			if (resolution.length !== 4) {
				return null;
			}
			var height = parseInt(resolution[1], 10);
			var width = parseInt(resolution[3], 10);
			var pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');
			if (!pixels) {
				return null;
			}
			return {
				width: width,
				height: height,
				levels: [pixels]
			};
		};
		_proto._readPixels = function _readPixels(readStream, width, height, flipY) {
			if (width < 8 || width > 0x7fff) {
				return this._readPixelsFlat(readStream, width, height);
			}
			var rgbe = [0, 0, 0, 0];
			readStream.readArray(rgbe);
			if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
				readStream.skip(-4);
				return this._readPixelsFlat(readStream, width, height);
			}
			var buffer = new ArrayBuffer(width * height * 4);
			var view = new Uint8Array(buffer);
			var scanstart = flipY ? 0 : width * 4 * (height - 1);
			var x, y, i, channel, count, value;
			for (y = 0; y < height; ++y) {
				if (y) {
					readStream.readArray(rgbe);
				}
				if ((rgbe[2] << 8) + rgbe[3] !== width) {
					return null;
				}
				for (channel = 0; channel < 4; ++channel) {
					x = 0;
					while (x < width) {
						count = readStream.readU8();
						if (count > 128) {
							count -= 128;
							if (x + count > width) {
								return null;
							}
							value = readStream.readU8();
							for (i = 0; i < count; ++i) {
								view[scanstart + channel + 4 * x++] = value;
							}
						} else {
							if (count === 0 || x + count > width) {
								return null;
							}
							for (i = 0; i < count; ++i) {
								view[scanstart + channel + 4 * x++] = readStream.readU8();
							}
						}
					}
				}
				scanstart += width * 4 * (flipY ? 1 : -1);
			}
			return view;
		};
		_proto._readPixelsFlat = function _readPixelsFlat(readStream, width, height) {
			return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
		};
		return HdrParser;
	}(TextureParser);

	var JSON_ADDRESS_MODE = {
		'repeat': ADDRESS_REPEAT,
		'clamp': ADDRESS_CLAMP_TO_EDGE,
		'mirror': ADDRESS_MIRRORED_REPEAT
	};
	var JSON_FILTER_MODE = {
		'nearest': FILTER_NEAREST,
		'linear': FILTER_LINEAR,
		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
	};
	var JSON_TEXTURE_TYPE = {
		'default': TEXTURETYPE_DEFAULT,
		'rgbm': TEXTURETYPE_RGBM,
		'rgbe': TEXTURETYPE_RGBE,
		'rgbp': TEXTURETYPE_RGBP,
		'swizzleGGGR': TEXTURETYPE_SWIZZLEGGGR
	};
	var _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
		var requiredMipLevels = TextureUtils.calcMipLevelsCount(texture._width, texture._height);
		var isHtmlElement = function isHtmlElement(object) {
			return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
		};
		if (!(texture._format === PIXELFORMAT_RGBA8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
			return;
		}
		var downsample = function downsample(width, height, data) {
			var sampledWidth = Math.max(1, width >> 1);
			var sampledHeight = Math.max(1, height >> 1);
			var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
			var xs = Math.floor(width / sampledWidth);
			var ys = Math.floor(height / sampledHeight);
			var xsys = xs * ys;
			for (var y = 0; y < sampledHeight; ++y) {
				for (var x = 0; x < sampledWidth; ++x) {
					for (var e = 0; e < 4; ++e) {
						var sum = 0;
						for (var sy = 0; sy < ys; ++sy) {
							for (var sx = 0; sx < xs; ++sx) {
								sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
							}
						}
						sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
					}
				}
			}
			return sampledData;
		};
		for (var level = texture._levels.length; level < requiredMipLevels; ++level) {
			var width = Math.max(1, texture._width >> level - 1);
			var height = Math.max(1, texture._height >> level - 1);
			if (texture._cubemap) {
				var mips = [];
				for (var face = 0; face < 6; ++face) {
					mips.push(downsample(width, height, texture._levels[level - 1][face]));
				}
				texture._levels.push(mips);
			} else {
				texture._levels.push(downsample(width, height, texture._levels[level - 1]));
			}
		}
		texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
	};
	var TextureHandler = function (_ResourceHandler) {
		function TextureHandler(app) {
			var _this;
			_this = _ResourceHandler.call(this, app, 'texture') || this;
			var assets = app.assets;
			var device = app.graphicsDevice;
			_this._device = device;
			_this._assets = assets;
			_this.imgParser = new ImgParser(assets, device);
			_this.parsers = {
				dds: new DdsParser(assets),
				ktx: new KtxParser(assets),
				ktx2: new Ktx2Parser(assets, device),
				basis: new BasisParser(assets, device),
				hdr: new HdrParser(assets)
			};
			return _this;
		}
		_inheritsLoose(TextureHandler, _ResourceHandler);
		var _proto = TextureHandler.prototype;
		_proto._getUrlWithoutParams = function _getUrlWithoutParams(url) {
			return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
		};
		_proto._getParser = function _getParser(url) {
			var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
			return this.parsers[ext] || this.imgParser;
		};
		_proto._getTextureOptions = function _getTextureOptions(asset) {
			var options = {};
			if (asset) {
				var _asset$name;
				if (((_asset$name = asset.name) == null ? void 0 : _asset$name.length) > 0) {
					options.name = asset.name;
				}
				var assetData = asset.data;
				if (assetData.hasOwnProperty('minfilter')) {
					options.minFilter = JSON_FILTER_MODE[assetData.minfilter];
				}
				if (assetData.hasOwnProperty('magfilter')) {
					options.magFilter = JSON_FILTER_MODE[assetData.magfilter];
				}
				if (assetData.hasOwnProperty('addressu')) {
					options.addressU = JSON_ADDRESS_MODE[assetData.addressu];
				}
				if (assetData.hasOwnProperty('addressv')) {
					options.addressV = JSON_ADDRESS_MODE[assetData.addressv];
				}
				if (assetData.hasOwnProperty('mipmaps')) {
					options.mipmaps = assetData.mipmaps;
				}
				if (assetData.hasOwnProperty('anisotropy')) {
					options.anisotropy = assetData.anisotropy;
				}
				if (assetData.hasOwnProperty('flipY')) {
					options.flipY = !!assetData.flipY;
				}
				if (assetData.hasOwnProperty('srgb')) {
					options.srgb = !!assetData.srgb;
				}
				if (assetData.hasOwnProperty('type')) {
					options.type = JSON_TEXTURE_TYPE[assetData.type];
				} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
					options.type = TEXTURETYPE_RGBM;
				} else if (asset.file && (asset.file.opt & 8) !== 0) {
					options.type = TEXTURETYPE_SWIZZLEGGGR;
				}
			}
			return options;
		};
		_proto.load = function load(url, callback, asset) {
			if (typeof url === 'string') {
				url = {
					load: url,
					original: url
				};
			}
			this._getParser(url.original).load(url, callback, asset);
		};
		_proto.open = function open(url, data, asset) {
			if (!url) {
				return undefined;
			}
			var textureOptions = this._getTextureOptions(asset);
			var texture = this._getParser(url).open(url, data, this._device, textureOptions);
			if (texture === null) {
				texture = new Texture(this._device, {
					width: 4,
					height: 4,
					format: PIXELFORMAT_RGB8
				});
			} else {
				_completePartialMipmapChain(texture);
				if (data.unswizzledGGGR) {
					asset.file.variants.basis.opt &= ~8;
				}
			}
			return texture;
		};
		_proto.patch = function patch(asset, assets) {
			var texture = asset.resource;
			if (!texture) {
				return;
			}
			var options = this._getTextureOptions(asset);
			for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
				var key = _Object$keys[_i];
				texture[key] = options[key];
			}
		};
		return _createClass(TextureHandler, [{
			key: "crossOrigin",
			get: function get() {
				return this.imgParser.crossOrigin;
			},
			set: function set(value) {
				this.imgParser.crossOrigin = value;
			}
		}, {
			key: "maxRetries",
			get: function get() {
				return this.imgParser.maxRetries;
			},
			set: function set(value) {
				this.imgParser.maxRetries = value;
				for (var parser in this.parsers) {
					if (this.parsers.hasOwnProperty(parser)) {
						this.parsers[parser].maxRetries = value;
					}
				}
			}
		}]);
	}(ResourceHandler);

	var XRTYPE_INLINE = 'inline';
	var XRTYPE_VR = 'immersive-vr';
	var XRTYPE_AR = 'immersive-ar';
	var XRSPACE_VIEWER = 'viewer';
	var XRSPACE_LOCAL = 'local';
	var XRSPACE_LOCALFLOOR = 'local-floor';
	var XRSPACE_BOUNDEDFLOOR = 'bounded-floor';
	var XRSPACE_UNBOUNDED = 'unbounded';
	var XRTARGETRAY_GAZE = 'gaze';
	var XRTARGETRAY_SCREEN = 'screen';
	var XRTARGETRAY_POINTER = 'tracked-pointer';
	var XREYE_NONE = 'none';
	var XREYE_LEFT = 'left';
	var XREYE_RIGHT = 'right';
	var XRHAND_NONE = 'none';
	var XRHAND_LEFT = 'left';
	var XRHAND_RIGHT = 'right';
	var XRTRACKABLE_POINT = 'point';
	var XRTRACKABLE_PLANE = 'plane';
	var XRTRACKABLE_MESH = 'mesh';
	var XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
	var XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
	var XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';
	var XRDEPTHSENSINGFORMAT_R16U = 'unsigned-short';
	var XRDEPTHSENSINGFORMAT_F32 = 'float32';

	var XrDomOverlay = function () {
		function XrDomOverlay(manager) {
			this._manager = void 0;
			this._supported = platform.browser && !!window.XRDOMOverlayState;
			this._root = null;
			this._manager = manager;
		}
		return _createClass(XrDomOverlay, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
			}
		}, {
			key: "state",
			get: function get() {
				if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) {
					return null;
				}
				return this._manager._session.domOverlayState.type;
			}
		}, {
			key: "root",
			get: function get() {
				return this._root;
			},
			set: function set(value) {
				if (!this._supported || this._manager.active) {
					return;
				}
				this._root = value;
			}
		}]);
	}();

	var poolVec3 = [];
	var poolQuat = [];
	var XrHitTestSource = function (_EventHandler) {
		function XrHitTestSource(manager, xrHitTestSource, _transient, inputSource) {
			var _this;
			if (inputSource === void 0) {
				inputSource = null;
			}
			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._xrHitTestSource = void 0;
			_this._transient = void 0;
			_this._inputSource = void 0;
			_this.manager = manager;
			_this._xrHitTestSource = xrHitTestSource;
			_this._transient = _transient;
			_this._inputSource = inputSource;
			return _this;
		}
		_inheritsLoose(XrHitTestSource, _EventHandler);
		var _proto = XrHitTestSource.prototype;
		_proto.remove = function remove() {
			if (!this._xrHitTestSource) {
				return;
			}
			var sources = this.manager.hitTest.sources;
			var ind = sources.indexOf(this);
			if (ind !== -1) sources.splice(ind, 1);
			this.onStop();
		};
		_proto.onStop = function onStop() {
			this._xrHitTestSource.cancel();
			this._xrHitTestSource = null;
			this.fire('remove');
			this.manager.hitTest.fire('remove', this);
		};
		_proto.update = function update(frame) {
			if (this._transient) {
				var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);
				for (var i = 0; i < transientResults.length; i++) {
					var transientResult = transientResults[i];
					if (!transientResult.results.length) {
						continue;
					}
					var inputSource = void 0;
					if (transientResult.inputSource) {
						inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
					}
					this.updateHitResults(transientResult.results, inputSource);
				}
			} else {
				var results = frame.getHitTestResults(this._xrHitTestSource);
				if (!results.length) {
					return;
				}
				this.updateHitResults(results);
			}
		};
		_proto.updateHitResults = function updateHitResults(results, inputSource) {
			var _poolVec3$pop, _poolVec3$pop2, _poolQuat$pop;
			if (this._inputSource && this._inputSource !== inputSource) {
				return;
			}
			var origin = (_poolVec3$pop = poolVec3.pop()) != null ? _poolVec3$pop : new Vec3();
			if (inputSource) {
				origin.copy(inputSource.getOrigin());
			} else {
				origin.copy(this.manager.camera.getPosition());
			}
			var candidateDistance = Infinity;
			var candidateHitTestResult = null;
			var position = (_poolVec3$pop2 = poolVec3.pop()) != null ? _poolVec3$pop2 : new Vec3();
			var rotation = (_poolQuat$pop = poolQuat.pop()) != null ? _poolQuat$pop : new Quat();
			for (var i = 0; i < results.length; i++) {
				var pose = results[i].getPose(this.manager._referenceSpace);
				var distance = origin.distance(pose.transform.position);
				if (distance >= candidateDistance) {
					continue;
				}
				candidateDistance = distance;
				candidateHitTestResult = results[i];
				position.copy(pose.transform.position);
				rotation.copy(pose.transform.orientation);
			}
			this.fire('result', position, rotation, inputSource || this._inputSource, candidateHitTestResult);
			this.manager.hitTest.fire('result', this, position, rotation, inputSource || this._inputSource, candidateHitTestResult);
			poolVec3.push(origin);
			poolVec3.push(position);
			poolQuat.push(rotation);
		};
		return XrHitTestSource;
	}(EventHandler);
	XrHitTestSource.EVENT_REMOVE = 'remove';
	XrHitTestSource.EVENT_RESULT = 'result';

	var XrHitTest = function (_EventHandler) {
		function XrHitTest(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);
			_this._available = false;
			_this._checkingAvailability = false;
			_this.sources = [];
			_this.manager = manager;
			if (_this._supported) {
				_this.manager.on('start', _this._onSessionStart, _this);
				_this.manager.on('end', _this._onSessionEnd, _this);
			}
			return _this;
		}
		_inheritsLoose(XrHitTest, _EventHandler);
		var _proto = XrHitTest.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			var _this2 = this;
			if (this.manager.session.enabledFeatures) {
				var available = this.manager.session.enabledFeatures.indexOf('hit-test') !== -1;
				if (!available) return;
				this._available = available;
				this.fire('available');
			} else if (!this._checkingAvailability) {
				this._checkingAvailability = true;
				this.manager.session.requestReferenceSpace(XRSPACE_VIEWER).then(function (referenceSpace) {
					_this2.manager.session.requestHitTestSource({
						space: referenceSpace
					}).then(function (hitTestSource) {
						hitTestSource.cancel();
						if (_this2.manager.active) {
							_this2._available = true;
							_this2.fire('available');
						}
					}).catch(function () {});
				}).catch(function () {});
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			if (!this._available) return;
			this._available = false;
			for (var i = 0; i < this.sources.length; i++) {
				this.sources[i].onStop();
			}
			this.sources = [];
			this.fire('unavailable');
		};
		_proto.start = function start(options) {
			var _this3 = this;
			if (options === void 0) {
				options = {};
			}
			if (!this._supported) {
				options.callback == null || options.callback(new Error('XR HitTest is not supported'), null);
				return;
			}
			if (!this._available) {
				options.callback == null || options.callback(new Error('XR HitTest is not available'), null);
				return;
			}
			if (!options.profile && !options.spaceType) {
				options.spaceType = XRSPACE_VIEWER;
			}
			var xrRay;
			var offsetRay = options.offsetRay;
			if (offsetRay) {
				var origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1.0);
				var direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0.0);
				xrRay = new XRRay(origin, direction);
			}
			var callback = options.callback;
			if (options.spaceType) {
				this.manager.session.requestReferenceSpace(options.spaceType).then(function (referenceSpace) {
					if (!_this3.manager.session) {
						var err = new Error('XR Session is not started (2)');
						if (callback) callback(err);
						_this3.fire('error', err);
						return;
					}
					_this3.manager.session.requestHitTestSource({
						space: referenceSpace,
						entityTypes: options.entityTypes || undefined,
						offsetRay: xrRay
					}).then(function (xrHitTestSource) {
						_this3._onHitTestSource(xrHitTestSource, false, options.inputSource, callback);
					}).catch(function (ex) {
						if (callback) callback(ex);
						_this3.fire('error', ex);
					});
				}).catch(function (ex) {
					if (callback) callback(ex);
					_this3.fire('error', ex);
				});
			} else {
				this.manager.session.requestHitTestSourceForTransientInput({
					profile: options.profile,
					entityTypes: options.entityTypes || undefined,
					offsetRay: xrRay
				}).then(function (xrHitTestSource) {
					_this3._onHitTestSource(xrHitTestSource, true, options.inputSource, callback);
				}).catch(function (ex) {
					if (callback) callback(ex);
					_this3.fire('error', ex);
				});
			}
		};
		_proto._onHitTestSource = function _onHitTestSource(xrHitTestSource, _transient, inputSource, callback) {
			if (!this.manager.session) {
				xrHitTestSource.cancel();
				var err = new Error('XR Session is not started (3)');
				if (callback) callback(err);
				this.fire('error', err);
				return;
			}
			var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, _transient, inputSource != null ? inputSource : null);
			this.sources.push(hitTestSource);
			if (callback) callback(null, hitTestSource);
			this.fire('add', hitTestSource);
		};
		_proto.update = function update(frame) {
			if (!this._available) {
				return;
			}
			for (var i = 0; i < this.sources.length; i++) {
				this.sources[i].update(frame);
			}
		};
		return _createClass(XrHitTest, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}]);
	}(EventHandler);
	XrHitTest.EVENT_AVAILABLE = 'available';
	XrHitTest.EVENT_UNAVAILABLE = 'unavailable';
	XrHitTest.EVENT_ADD = 'add';
	XrHitTest.EVENT_REMOVE = 'remove';
	XrHitTest.EVENT_RESULT = 'result';
	XrHitTest.EVENT_ERROR = 'error';

	var XrTrackedImage = function (_EventHandler) {
		function XrTrackedImage(image, width) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._image = void 0;
			_this._width = void 0;
			_this._bitmap = null;
			_this._measuredWidth = 0;
			_this._trackable = false;
			_this._tracking = false;
			_this._emulated = false;
			_this._pose = null;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._image = image;
			_this._width = width;
			return _this;
		}
		_inheritsLoose(XrTrackedImage, _EventHandler);
		var _proto = XrTrackedImage.prototype;
		_proto.prepare = function prepare() {
			var _this2 = this;
			if (this._bitmap) {
				return {
					image: this._bitmap,
					widthInMeters: this._width
				};
			}
			return createImageBitmap(this._image).then(function (bitmap) {
				_this2._bitmap = bitmap;
				return {
					image: _this2._bitmap,
					widthInMeters: _this2._width
				};
			});
		};
		_proto.destroy = function destroy() {
			this._image = null;
			this._pose = null;
			if (this._bitmap) {
				this._bitmap.close();
				this._bitmap = null;
			}
		};
		_proto.getPosition = function getPosition() {
			if (this._pose) this._position.copy(this._pose.transform.position);
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			if (this._pose) this._rotation.copy(this._pose.transform.orientation);
			return this._rotation;
		};
		return _createClass(XrTrackedImage, [{
			key: "image",
			get: function get() {
				return this._image;
			}
		}, {
			key: "width",
			get: function get() {
				return this._width;
			},
			set: function set(value) {
				this._width = value;
			}
		}, {
			key: "trackable",
			get: function get() {
				return this._trackable;
			}
		}, {
			key: "tracking",
			get: function get() {
				return this._tracking;
			}
		}, {
			key: "emulated",
			get: function get() {
				return this._emulated;
			}
		}]);
	}(EventHandler);
	XrTrackedImage.EVENT_TRACKED = 'tracked';
	XrTrackedImage.EVENT_UNTRACKED = 'untracked';

	var XrImageTracking = function (_EventHandler) {
		function XrImageTracking(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = platform.browser && !!window.XRImageTrackingResult;
			_this._available = false;
			_this._images = [];
			_this._manager = manager;
			if (_this._supported) {
				_this._manager.on('start', _this._onSessionStart, _this);
				_this._manager.on('end', _this._onSessionEnd, _this);
			}
			return _this;
		}
		_inheritsLoose(XrImageTracking, _EventHandler);
		var _proto = XrImageTracking.prototype;
		_proto.add = function add(image, width) {
			if (!this._supported || this._manager.active) return null;
			var trackedImage = new XrTrackedImage(image, width);
			this._images.push(trackedImage);
			return trackedImage;
		};
		_proto.remove = function remove(trackedImage) {
			if (this._manager.active) return;
			var ind = this._images.indexOf(trackedImage);
			if (ind !== -1) {
				trackedImage.destroy();
				this._images.splice(ind, 1);
			}
		};
		_proto._onSessionStart = function _onSessionStart() {
			var _this2 = this;
			this._manager.session.getTrackedImageScores().then(function (images) {
				_this2._available = true;
				for (var i = 0; i < images.length; i++) {
					_this2._images[i]._trackable = images[i] === 'trackable';
				}
			}).catch(function (err) {
				_this2._available = false;
				_this2.fire('error', err);
			});
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			this._available = false;
			for (var i = 0; i < this._images.length; i++) {
				var image = this._images[i];
				image._pose = null;
				image._measuredWidth = 0;
				if (image._tracking) {
					image._tracking = false;
					image.fire('untracked');
				}
			}
		};
		_proto.prepareImages = function prepareImages(callback) {
			if (this._images.length) {
				Promise.all(this._images.map(function (trackedImage) {
					return trackedImage.prepare();
				})).then(function (bitmaps) {
					callback(null, bitmaps);
				}).catch(function (err) {
					callback(err, null);
				});
			} else {
				callback(null, null);
			}
		};
		_proto.update = function update(frame) {
			if (!this._available) return;
			var results = frame.getImageTrackingResults();
			var index = {};
			for (var i = 0; i < results.length; i++) {
				index[results[i].index] = results[i];
				var trackedImage = this._images[results[i].index];
				trackedImage._emulated = results[i].trackingState === 'emulated';
				trackedImage._measuredWidth = results[i].measuredWidthInMeters;
				trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
			}
			for (var _i = 0; _i < this._images.length; _i++) {
				if (this._images[_i]._tracking && !index[_i]) {
					this._images[_i]._tracking = false;
					this._images[_i].fire('untracked');
				} else if (!this._images[_i]._tracking && index[_i]) {
					this._images[_i]._tracking = true;
					this._images[_i].fire('tracked');
				}
			}
		};
		return _createClass(XrImageTracking, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "images",
			get: function get() {
				return this._images;
			}
		}]);
	}(EventHandler);
	XrImageTracking.EVENT_ERROR = 'error';

	var XrFinger = function () {
		function XrFinger(index, hand) {
			this._index = void 0;
			this._hand = void 0;
			this._joints = [];
			this._tip = null;
			this._index = index;
			this._hand = hand;
			this._hand._fingers.push(this);
		}
		return _createClass(XrFinger, [{
			key: "index",
			get: function get() {
				return this._index;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "joints",
			get: function get() {
				return this._joints;
			}
		}, {
			key: "tip",
			get: function get() {
				return this._tip;
			}
		}]);
	}();

	var tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];
	var tipJointIdsIndex = {};
	for (var i$1 = 0; i$1 < tipJointIds.length; i$1++) {
		tipJointIdsIndex[tipJointIds[i$1]] = true;
	}
	var XrJoint = function () {
		function XrJoint(index, id, hand, finger) {
			if (finger === void 0) {
				finger = null;
			}
			this._index = void 0;
			this._id = void 0;
			this._hand = void 0;
			this._finger = void 0;
			this._wrist = void 0;
			this._tip = void 0;
			this._radius = null;
			this._localTransform = new Mat4();
			this._worldTransform = new Mat4();
			this._localPosition = new Vec3();
			this._localRotation = new Quat();
			this._position = new Vec3();
			this._rotation = new Quat();
			this._dirtyLocal = true;
			this._index = index;
			this._id = id;
			this._hand = hand;
			this._finger = finger;
			this._wrist = id === 'wrist';
			this._tip = this._finger && !!tipJointIdsIndex[id];
		}
		var _proto = XrJoint.prototype;
		_proto.update = function update(pose) {
			this._dirtyLocal = true;
			this._radius = pose.radius;
			this._localPosition.copy(pose.transform.position);
			this._localRotation.copy(pose.transform.orientation);
		};
		_proto._updateTransforms = function _updateTransforms() {
			if (this._dirtyLocal) {
				this._dirtyLocal = false;
				this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
			}
			var manager = this._hand._manager;
			var parent = manager.camera.parent;
			if (parent) {
				this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
			} else {
				this._worldTransform.copy(this._localTransform);
			}
		};
		_proto.getPosition = function getPosition() {
			this._updateTransforms();
			this._worldTransform.getTranslation(this._position);
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			this._updateTransforms();
			this._rotation.setFromMat4(this._worldTransform);
			return this._rotation;
		};
		return _createClass(XrJoint, [{
			key: "id",
			get: function get() {
				return this._id;
			}
		}, {
			key: "index",
			get: function get() {
				return this._index;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "finger",
			get: function get() {
				return this._finger;
			}
		}, {
			key: "wrist",
			get: function get() {
				return this._wrist;
			}
		}, {
			key: "tip",
			get: function get() {
				return this._tip;
			}
		}, {
			key: "radius",
			get: function get() {
				return this._radius || 0.005;
			}
		}]);
	}();

	var fingerJointIds = [];
	var vecA$1 = new Vec3();
	var vecB$1 = new Vec3();
	var vecC = new Vec3();
	if (platform.browser && window.XRHand) {
		fingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];
	}
	var XrHand = function (_EventHandler) {
		function XrHand(inputSource) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._inputSource = void 0;
			_this._tracking = false;
			_this._fingers = [];
			_this._joints = [];
			_this._jointsById = {};
			_this._tips = [];
			_this._wrist = null;
			var xrHand = inputSource._xrInputSource.hand;
			_this._manager = inputSource._manager;
			_this._inputSource = inputSource;
			if (xrHand.get('wrist')) {
				var joint = new XrJoint(0, 'wrist', _this, null);
				_this._wrist = joint;
				_this._joints.push(joint);
				_this._jointsById.wrist = joint;
			}
			for (var f = 0; f < fingerJointIds.length; f++) {
				var finger = new XrFinger(f, _this);
				for (var j = 0; j < fingerJointIds[f].length; j++) {
					var jointId = fingerJointIds[f][j];
					if (!xrHand.get(jointId)) continue;
					var _joint = new XrJoint(j, jointId, _this, finger);
					_this._joints.push(_joint);
					_this._jointsById[jointId] = _joint;
					if (_joint.tip) {
						_this._tips.push(_joint);
						finger._tip = _joint;
					}
					finger._joints.push(_joint);
				}
			}
			return _this;
		}
		_inheritsLoose(XrHand, _EventHandler);
		var _proto = XrHand.prototype;
		_proto.update = function update(frame) {
			var xrInputSource = this._inputSource._xrInputSource;
			for (var j = 0; j < this._joints.length; j++) {
				var joint = this._joints[j];
				var jointSpace = xrInputSource.hand.get(joint._id);
				if (jointSpace) {
					var pose = void 0;
					if (frame.session.visibilityState !== 'hidden') {
						pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);
					}
					if (pose) {
						joint.update(pose);
						if (joint.wrist && !this._tracking) {
							this._tracking = true;
							this.fire('tracking');
						}
					} else if (joint.wrist) {
						if (this._tracking) {
							this._tracking = false;
							this.fire('trackinglost');
						}
						break;
					}
				}
			}
			var j1 = this._jointsById['thumb-metacarpal'];
			var j4 = this._jointsById['thumb-tip'];
			var j6 = this._jointsById['index-finger-phalanx-proximal'];
			var j9 = this._jointsById['index-finger-tip'];
			var j16 = this._jointsById['ring-finger-phalanx-proximal'];
			var j21 = this._jointsById['pinky-finger-phalanx-proximal'];
			if (j1 && j4 && j6 && j9 && j16 && j21) {
				this._inputSource._dirtyRay = true;
				this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);
				var jointL = j1;
				var jointR = j21;
				if (this._inputSource.handedness === XRHAND_LEFT) {
					var t = jointL;
					jointL = jointR;
					jointR = t;
				}
				vecA$1.sub2(jointL._localPosition, this._wrist._localPosition);
				vecB$1.sub2(jointR._localPosition, this._wrist._localPosition);
				vecC.cross(vecA$1, vecB$1).normalize();
				vecA$1.lerp(j6._localPosition, j16._localPosition, 0.5);
				vecA$1.sub(this._wrist._localPosition).normalize();
				this._inputSource._rayLocal.direction.lerp(vecC, vecA$1, 0.5).normalize();
			}
			var squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);
			if (squeezing) {
				if (!this._inputSource._squeezing) {
					this._inputSource._squeezing = true;
					this._inputSource.fire('squeezestart');
					this._manager.input.fire('squeezestart', this._inputSource);
				}
			} else {
				if (this._inputSource._squeezing) {
					this._inputSource._squeezing = false;
					this._inputSource.fire('squeeze');
					this._manager.input.fire('squeeze', this._inputSource);
					this._inputSource.fire('squeezeend');
					this._manager.input.fire('squeezeend', this._inputSource);
				}
			}
		};
		_proto._fingerIsClosed = function _fingerIsClosed(index) {
			var finger = this._fingers[index];
			vecA$1.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
			vecB$1.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
			return vecA$1.dot(vecB$1) < -0.8;
		};
		_proto.getJointById = function getJointById(id) {
			return this._jointsById[id] || null;
		};
		return _createClass(XrHand, [{
			key: "fingers",
			get: function get() {
				return this._fingers;
			}
		}, {
			key: "joints",
			get: function get() {
				return this._joints;
			}
		}, {
			key: "tips",
			get: function get() {
				return this._tips;
			}
		}, {
			key: "wrist",
			get: function get() {
				return this._wrist;
			}
		}, {
			key: "tracking",
			get: function get() {
				return this._tracking;
			}
		}]);
	}(EventHandler);
	XrHand.EVENT_TRACKING = 'tracking';
	XrHand.EVENT_TRACKINGLOST = 'trackinglost';

	var vec3A$1 = new Vec3();
	var quat = new Quat();
	var ids$1 = 0;
	var XrInputSource = function (_EventHandler) {
		function XrInputSource(manager, xrInputSource) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._id = void 0;
			_this._manager = void 0;
			_this._xrInputSource = void 0;
			_this._ray = new Ray();
			_this._rayLocal = new Ray();
			_this._grip = false;
			_this._hand = null;
			_this._velocitiesAvailable = false;
			_this._velocitiesTimestamp = now();
			_this._localTransform = null;
			_this._worldTransform = null;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._localPosition = null;
			_this._localPositionLast = null;
			_this._localRotation = null;
			_this._linearVelocity = null;
			_this._dirtyLocal = true;
			_this._dirtyRay = false;
			_this._selecting = false;
			_this._squeezing = false;
			_this._elementInput = true;
			_this._elementEntity = null;
			_this._hitTestSources = [];
			_this._id = ++ids$1;
			_this._manager = manager;
			_this._xrInputSource = xrInputSource;
			if (xrInputSource.hand) {
				_this._hand = new XrHand(_this);
			}
			return _this;
		}
		_inheritsLoose(XrInputSource, _EventHandler);
		var _proto = XrInputSource.prototype;
		_proto.update = function update(frame) {
			if (this._hand) {
				this._hand.update(frame);
			} else {
				var gripSpace = this._xrInputSource.gripSpace;
				if (gripSpace) {
					var gripPose = frame.getPose(gripSpace, this._manager._referenceSpace);
					if (gripPose) {
						if (!this._grip) {
							this._grip = true;
							this._localTransform = new Mat4();
							this._worldTransform = new Mat4();
							this._localPositionLast = new Vec3();
							this._localPosition = new Vec3();
							this._localRotation = new Quat();
							this._linearVelocity = new Vec3();
						}
						var timestamp = now();
						var dt = (timestamp - this._velocitiesTimestamp) / 1000;
						this._velocitiesTimestamp = timestamp;
						this._dirtyLocal = true;
						this._localPositionLast.copy(this._localPosition);
						this._localPosition.copy(gripPose.transform.position);
						this._localRotation.copy(gripPose.transform.orientation);
						this._velocitiesAvailable = true;
						if (this._manager.input.velocitiesSupported && gripPose.linearVelocity) {
							this._linearVelocity.copy(gripPose.linearVelocity);
						} else if (dt > 0) {
							vec3A$1.sub2(this._localPosition, this._localPositionLast).divScalar(dt);
							this._linearVelocity.lerp(this._linearVelocity, vec3A$1, 0.15);
						}
					} else {
						this._velocitiesAvailable = false;
					}
				}
				var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
				if (targetRayPose) {
					this._dirtyRay = true;
					this._rayLocal.origin.copy(targetRayPose.transform.position);
					this._rayLocal.direction.set(0, 0, -1);
					quat.copy(targetRayPose.transform.orientation);
					quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);
				}
			}
		};
		_proto._updateTransforms = function _updateTransforms() {
			if (this._dirtyLocal) {
				this._dirtyLocal = false;
				this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
			}
			var parent = this._manager.camera.parent;
			if (parent) {
				this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
			} else {
				this._worldTransform.copy(this._localTransform);
			}
		};
		_proto._updateRayTransforms = function _updateRayTransforms() {
			var dirty = this._dirtyRay;
			this._dirtyRay = false;
			var parent = this._manager.camera.parent;
			if (parent) {
				var parentTransform = this._manager.camera.parent.getWorldTransform();
				parentTransform.getTranslation(this._position);
				this._rotation.setFromMat4(parentTransform);
				this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);
				this._ray.origin.add(this._position);
				this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
			} else if (dirty) {
				this._ray.origin.copy(this._rayLocal.origin);
				this._ray.direction.copy(this._rayLocal.direction);
			}
		};
		_proto.getPosition = function getPosition() {
			if (!this._position) return null;
			this._updateTransforms();
			this._worldTransform.getTranslation(this._position);
			return this._position;
		};
		_proto.getLocalPosition = function getLocalPosition() {
			return this._localPosition;
		};
		_proto.getRotation = function getRotation() {
			if (!this._rotation) return null;
			this._updateTransforms();
			this._rotation.setFromMat4(this._worldTransform);
			return this._rotation;
		};
		_proto.getLocalRotation = function getLocalRotation() {
			return this._localRotation;
		};
		_proto.getLinearVelocity = function getLinearVelocity() {
			if (!this._velocitiesAvailable) {
				return null;
			}
			return this._linearVelocity;
		};
		_proto.getOrigin = function getOrigin() {
			this._updateRayTransforms();
			return this._ray.origin;
		};
		_proto.getDirection = function getDirection() {
			this._updateRayTransforms();
			return this._ray.direction;
		};
		_proto.hitTestStart = function hitTestStart(options) {
			var _this2 = this;
			if (options === void 0) {
				options = {};
			}
			options.inputSource = this;
			options.profile = this._xrInputSource.profiles[0];
			var callback = options.callback;
			options.callback = function (err, hitTestSource) {
				if (hitTestSource) _this2.onHitTestSourceAdd(hitTestSource);
				if (callback) callback(err, hitTestSource);
			};
			this._manager.hitTest.start(options);
		};
		_proto.onHitTestSourceAdd = function onHitTestSourceAdd(hitTestSource) {
			var _this3 = this;
			this._hitTestSources.push(hitTestSource);
			this.fire('hittest:add', hitTestSource);
			hitTestSource.on('result', function (position, rotation, inputSource, hitTestResult) {
				if (inputSource !== _this3) return;
				_this3.fire('hittest:result', hitTestSource, position, rotation, hitTestResult);
			});
			hitTestSource.once('remove', function () {
				_this3.onHitTestSourceRemove(hitTestSource);
				_this3.fire('hittest:remove', hitTestSource);
			});
		};
		_proto.onHitTestSourceRemove = function onHitTestSourceRemove(hitTestSource) {
			var ind = this._hitTestSources.indexOf(hitTestSource);
			if (ind !== -1) this._hitTestSources.splice(ind, 1);
		};
		return _createClass(XrInputSource, [{
			key: "id",
			get: function get() {
				return this._id;
			}
		}, {
			key: "inputSource",
			get: function get() {
				return this._xrInputSource;
			}
		}, {
			key: "targetRayMode",
			get: function get() {
				return this._xrInputSource.targetRayMode;
			}
		}, {
			key: "handedness",
			get: function get() {
				return this._xrInputSource.handedness;
			}
		}, {
			key: "profiles",
			get: function get() {
				return this._xrInputSource.profiles;
			}
		}, {
			key: "grip",
			get: function get() {
				return this._grip;
			}
		}, {
			key: "hand",
			get: function get() {
				return this._hand;
			}
		}, {
			key: "gamepad",
			get: function get() {
				return this._xrInputSource.gamepad || null;
			}
		}, {
			key: "selecting",
			get: function get() {
				return this._selecting;
			}
		}, {
			key: "squeezing",
			get: function get() {
				return this._squeezing;
			}
		}, {
			key: "elementInput",
			get: function get() {
				return this._elementInput;
			},
			set: function set(value) {
				if (this._elementInput === value) {
					return;
				}
				this._elementInput = value;
				if (!this._elementInput) {
					this._elementEntity = null;
				}
			}
		}, {
			key: "elementEntity",
			get: function get() {
				return this._elementEntity;
			}
		}, {
			key: "hitTestSources",
			get: function get() {
				return this._hitTestSources;
			}
		}]);
	}(EventHandler);
	XrInputSource.EVENT_REMOVE = 'remove';
	XrInputSource.EVENT_SELECT = 'select';
	XrInputSource.EVENT_SELECTSTART = 'selectstart';
	XrInputSource.EVENT_SELECTEND = 'selectend';
	XrInputSource.EVENT_SQUEEZE = 'squeeze';
	XrInputSource.EVENT_SQUEEZESTART = 'squeezestart';
	XrInputSource.EVENT_SQUEEZEEND = 'squeezeend';
	XrInputSource.EVENT_HITTESTADD = 'hittest:add';
	XrInputSource.EVENT_HITTESTREMOVE = 'hittest:remove';
	XrInputSource.EVENT_HITTESTRESULT = 'hittest:result';

	var XrInput = function (_EventHandler) {
		function XrInput(manager) {
			var _window$XRPose;
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._inputSources = [];
			_this._onInputSourcesChangeEvt = void 0;
			_this.velocitiesSupported = false;
			_this.manager = manager;
			_this.velocitiesSupported = !!(platform.browser && (_window$XRPose = window.XRPose) != null && (_window$XRPose = _window$XRPose.prototype) != null && _window$XRPose.hasOwnProperty('linearVelocity'));
			_this._onInputSourcesChangeEvt = function (evt) {
				_this._onInputSourcesChange(evt);
			};
			_this.manager.on('start', _this._onSessionStart, _this);
			_this.manager.on('end', _this._onSessionEnd, _this);
			return _this;
		}
		_inheritsLoose(XrInput, _EventHandler);
		var _proto = XrInput.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			var _this2 = this;
			var session = this.manager.session;
			session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
			session.addEventListener('select', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource.fire('select', evt);
				_this2.fire('select', inputSource, evt);
			});
			session.addEventListener('selectstart', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._selecting = true;
				inputSource.fire('selectstart', evt);
				_this2.fire('selectstart', inputSource, evt);
			});
			session.addEventListener('selectend', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._selecting = false;
				inputSource.fire('selectend', evt);
				_this2.fire('selectend', inputSource, evt);
			});
			session.addEventListener('squeeze', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource.fire('squeeze', evt);
				_this2.fire('squeeze', inputSource, evt);
			});
			session.addEventListener('squeezestart', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._squeezing = true;
				inputSource.fire('squeezestart', evt);
				_this2.fire('squeezestart', inputSource, evt);
			});
			session.addEventListener('squeezeend', function (evt) {
				var inputSource = _this2._getByInputSource(evt.inputSource);
				inputSource.update(evt.frame);
				inputSource._squeezing = false;
				inputSource.fire('squeezeend', evt);
				_this2.fire('squeezeend', inputSource, evt);
			});
			var inputSources = session.inputSources;
			for (var i = 0; i < inputSources.length; i++) {
				this._addInputSource(inputSources[i]);
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			var i = this._inputSources.length;
			while (i--) {
				var inputSource = this._inputSources[i];
				this._inputSources.splice(i, 1);
				inputSource.fire('remove');
				this.fire('remove', inputSource);
			}
			var session = this.manager.session;
			session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
		};
		_proto._onInputSourcesChange = function _onInputSourcesChange(evt) {
			for (var i = 0; i < evt.removed.length; i++) {
				this._removeInputSource(evt.removed[i]);
			}
			for (var _i = 0; _i < evt.added.length; _i++) {
				this._addInputSource(evt.added[_i]);
			}
		};
		_proto._getByInputSource = function _getByInputSource(xrInputSource) {
			for (var i = 0; i < this._inputSources.length; i++) {
				if (this._inputSources[i].inputSource === xrInputSource) {
					return this._inputSources[i];
				}
			}
			return null;
		};
		_proto._addInputSource = function _addInputSource(xrInputSource) {
			if (this._getByInputSource(xrInputSource)) {
				return;
			}
			var inputSource = new XrInputSource(this.manager, xrInputSource);
			this._inputSources.push(inputSource);
			this.fire('add', inputSource);
		};
		_proto._removeInputSource = function _removeInputSource(xrInputSource) {
			for (var i = 0; i < this._inputSources.length; i++) {
				if (this._inputSources[i].inputSource !== xrInputSource) {
					continue;
				}
				var inputSource = this._inputSources[i];
				this._inputSources.splice(i, 1);
				var h = inputSource.hitTestSources.length;
				while (h--) {
					inputSource.hitTestSources[h].remove();
				}
				inputSource.fire('remove');
				this.fire('remove', inputSource);
				return;
			}
		};
		_proto.update = function update(frame) {
			for (var i = 0; i < this._inputSources.length; i++) {
				this._inputSources[i].update(frame);
			}
		};
		return _createClass(XrInput, [{
			key: "inputSources",
			get: function get() {
				return this._inputSources;
			}
		}]);
	}(EventHandler);
	XrInput.EVENT_ADD = 'add';
	XrInput.EVENT_REMOVE = 'remove';
	XrInput.EVENT_SELECT = 'select';
	XrInput.EVENT_SELECTSTART = 'selectstart';
	XrInput.EVENT_SELECTEND = 'selectend';
	XrInput.EVENT_SQUEEZE = 'squeeze';
	XrInput.EVENT_SQUEEZESTART = 'squeezestart';
	XrInput.EVENT_SQUEEZEEND = 'squeezeend';

	var vec3A = new Vec3();
	var vec3B = new Vec3();
	var mat4A = new Mat4();
	var mat4B = new Mat4();
	var XrLightEstimation = function (_EventHandler) {
		function XrLightEstimation(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = false;
			_this._available = false;
			_this._lightProbeRequested = false;
			_this._lightProbe = null;
			_this._intensity = 0;
			_this._rotation = new Quat();
			_this._color = new Color();
			_this._sphericalHarmonics = new Float32Array(27);
			_this._manager = manager;
			_this._manager.on('start', _this._onSessionStart, _this);
			_this._manager.on('end', _this._onSessionEnd, _this);
			return _this;
		}
		_inheritsLoose(XrLightEstimation, _EventHandler);
		var _proto = XrLightEstimation.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			var supported = !!this._manager.session.requestLightProbe;
			if (!supported) return;
			this._supported = true;
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			this._supported = false;
			this._available = false;
			this._lightProbeRequested = false;
			this._lightProbe = null;
		};
		_proto.start = function start() {
			var _this2 = this;
			var err;
			if (!this._manager.session) {
				err = new Error('XR session is not running');
			}
			if (!err && this._manager.type !== XRTYPE_AR) {
				err = new Error('XR session type is not AR');
			}
			if (!err && !this._supported) {
				err = new Error('light-estimation is not supported');
			}
			if (!err && this._lightProbe || this._lightProbeRequested) {
				err = new Error('light estimation is already requested');
			}
			if (err) {
				this.fire('error', err);
				return;
			}
			this._lightProbeRequested = true;
			this._manager.session.requestLightProbe().then(function (lightProbe) {
				var wasRequested = _this2._lightProbeRequested;
				_this2._lightProbeRequested = false;
				if (_this2._manager.active) {
					if (wasRequested) {
						_this2._lightProbe = lightProbe;
					}
				} else {
					_this2.fire('error', new Error('XR session is not active'));
				}
			}).catch(function (ex) {
				_this2._lightProbeRequested = false;
				_this2.fire('error', ex);
			});
		};
		_proto.end = function end() {
			this._lightProbeRequested = false;
			this._lightProbe = null;
			this._available = false;
		};
		_proto.update = function update(frame) {
			if (!this._lightProbe) return;
			var lightEstimate = frame.getLightEstimate(this._lightProbe);
			if (!lightEstimate) return;
			if (!this._available) {
				this._available = true;
				this.fire('available');
			}
			var pli = lightEstimate.primaryLightIntensity;
			this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
			vec3A.copy(pli).mulScalar(1 / this._intensity);
			this._color.set(vec3A.x, vec3A.y, vec3A.z);
			vec3A.set(0, 0, 0);
			vec3B.copy(lightEstimate.primaryLightDirection);
			mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
			mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
			mat4A.mul(mat4B);
			this._rotation.setFromMat4(mat4A);
			this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
		};
		return _createClass(XrLightEstimation, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "intensity",
			get: function get() {
				return this._available ? this._intensity : null;
			}
		}, {
			key: "color",
			get: function get() {
				return this._available ? this._color : null;
			}
		}, {
			key: "rotation",
			get: function get() {
				return this._available ? this._rotation : null;
			}
		}, {
			key: "sphericalHarmonics",
			get: function get() {
				return this._available ? this._sphericalHarmonics : null;
			}
		}]);
	}(EventHandler);
	XrLightEstimation.EVENT_AVAILABLE = 'available';
	XrLightEstimation.EVENT_ERROR = 'error';

	var ids = 0;
	var XrPlane = function (_EventHandler) {
		function XrPlane(planeDetection, xrPlane) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._id = void 0;
			_this._planeDetection = void 0;
			_this._xrPlane = void 0;
			_this._lastChangedTime = void 0;
			_this._orientation = void 0;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._id = ++ids;
			_this._planeDetection = planeDetection;
			_this._xrPlane = xrPlane;
			_this._lastChangedTime = xrPlane.lastChangedTime;
			_this._orientation = xrPlane.orientation;
			return _this;
		}
		_inheritsLoose(XrPlane, _EventHandler);
		var _proto = XrPlane.prototype;
		_proto.destroy = function destroy() {
			if (!this._xrPlane) return;
			this._xrPlane = null;
			this.fire('remove');
		};
		_proto.update = function update(frame) {
			var manager = this._planeDetection._manager;
			var pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);
			if (pose) {
				this._position.copy(pose.transform.position);
				this._rotation.copy(pose.transform.orientation);
			}
			if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
				this._lastChangedTime = this._xrPlane.lastChangedTime;
				this.fire('change');
			}
		};
		_proto.getPosition = function getPosition() {
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			return this._rotation;
		};
		return _createClass(XrPlane, [{
			key: "id",
			get: function get() {
				return this._id;
			}
		}, {
			key: "orientation",
			get: function get() {
				return this._orientation;
			}
		}, {
			key: "points",
			get: function get() {
				return this._xrPlane.polygon;
			}
		}, {
			key: "label",
			get: function get() {
				return this._xrPlane.semanticLabel || '';
			}
		}]);
	}(EventHandler);
	XrPlane.EVENT_REMOVE = 'remove';
	XrPlane.EVENT_CHANGE = 'change';

	var XrPlaneDetection = function (_EventHandler) {
		function XrPlaneDetection(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = platform.browser && !!window.XRPlane;
			_this._available = false;
			_this._planesIndex = new Map();
			_this._planes = [];
			_this._manager = manager;
			if (_this._supported) {
				_this._manager.on('start', _this._onSessionStart, _this);
				_this._manager.on('end', _this._onSessionEnd, _this);
			}
			return _this;
		}
		_inheritsLoose(XrPlaneDetection, _EventHandler);
		var _proto = XrPlaneDetection.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			if (this._manager.session.enabledFeatures) {
				var available = this._manager.session.enabledFeatures.indexOf('plane-detection') !== -1;
				if (available) {
					this._available = true;
					this.fire('available');
				}
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			for (var i = 0; i < this._planes.length; i++) {
				this._planes[i].destroy();
				this.fire('remove', this._planes[i]);
			}
			this._planesIndex.clear();
			this._planes.length = 0;
			if (this._available) {
				this._available = false;
				this.fire('unavailable');
			}
		};
		_proto.update = function update(frame) {
			if (!this._available) {
				if (!this._manager.session.enabledFeatures && frame.detectedPlanes.size) {
					this._available = true;
					this.fire('available');
				} else {
					return;
				}
			}
			var detectedPlanes = frame.detectedPlanes;
			for (var _iterator = _createForOfIteratorHelperLoose(this._planesIndex), _step; !(_step = _iterator()).done;) {
				var _step$value = _step.value,
					xrPlane = _step$value[0],
					plane = _step$value[1];
				if (detectedPlanes.has(xrPlane)) {
					continue;
				}
				this._planesIndex.delete(xrPlane);
				this._planes.splice(this._planes.indexOf(plane), 1);
				plane.destroy();
				this.fire('remove', plane);
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(detectedPlanes), _step2; !(_step2 = _iterator2()).done;) {
				var _xrPlane = _step2.value;
				var _plane = this._planesIndex.get(_xrPlane);
				if (!_plane) {
					_plane = new XrPlane(this, _xrPlane);
					this._planesIndex.set(_xrPlane, _plane);
					this._planes.push(_plane);
					_plane.update(frame);
					this.fire('add', _plane);
				} else {
					_plane.update(frame);
				}
			}
		};
		return _createClass(XrPlaneDetection, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "planes",
			get: function get() {
				return this._planes;
			}
		}]);
	}(EventHandler);
	XrPlaneDetection.EVENT_AVAILABLE = 'available';
	XrPlaneDetection.EVENT_UNAVAILABLE = 'unavailable';
	XrPlaneDetection.EVENT_ADD = 'add';
	XrPlaneDetection.EVENT_REMOVE = 'remove';

	var XrAnchor = function (_EventHandler) {
		function XrAnchor(anchors, xrAnchor, uuid) {
			var _this;
			if (uuid === void 0) {
				uuid = null;
			}
			_this = _EventHandler.call(this) || this;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._uuid = null;
			_this._uuidRequests = null;
			_this._anchors = anchors;
			_this._xrAnchor = xrAnchor;
			_this._uuid = uuid;
			return _this;
		}
		_inheritsLoose(XrAnchor, _EventHandler);
		var _proto = XrAnchor.prototype;
		_proto.destroy = function destroy() {
			if (!this._xrAnchor) return;
			var xrAnchor = this._xrAnchor;
			this._xrAnchor.delete();
			this._xrAnchor = null;
			this.fire('destroy', xrAnchor, this);
		};
		_proto.update = function update(frame) {
			if (!this._xrAnchor) {
				return;
			}
			var pose = frame.getPose(this._xrAnchor.anchorSpace, this._anchors.manager._referenceSpace);
			if (pose) {
				if (this._position.equals(pose.transform.position) && this._rotation.equals(pose.transform.orientation)) {
					return;
				}
				this._position.copy(pose.transform.position);
				this._rotation.copy(pose.transform.orientation);
				this.fire('change');
			}
		};
		_proto.getPosition = function getPosition() {
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			return this._rotation;
		};
		_proto.persist = function persist(callback) {
			var _this2 = this;
			if (!this._anchors.persistence) {
				callback == null || callback(new Error('Persistent Anchors are not supported'), null);
				return;
			}
			if (this._uuid) {
				callback == null || callback(null, this._uuid);
				return;
			}
			if (this._uuidRequests) {
				if (callback) this._uuidRequests.push(callback);
				return;
			}
			this._uuidRequests = [];
			this._xrAnchor.requestPersistentHandle().then(function (uuid) {
				_this2._uuid = uuid;
				_this2._anchors._indexByUuid.set(_this2._uuid, _this2);
				callback == null || callback(null, uuid);
				for (var _iterator = _createForOfIteratorHelperLoose(_this2._uuidRequests), _step; !(_step = _iterator()).done;) {
					var uuidRequest = _step.value;
					uuidRequest(null, uuid);
				}
				_this2._uuidRequests = null;
				_this2.fire('persist', uuid);
			}).catch(function (ex) {
				callback == null || callback(ex, null);
				for (var _iterator2 = _createForOfIteratorHelperLoose(_this2._uuidRequests), _step2; !(_step2 = _iterator2()).done;) {
					var uuidRequest = _step2.value;
					uuidRequest(ex, null);
				}
				_this2._uuidRequests = null;
			});
		};
		_proto.forget = function forget(callback) {
			var _this3 = this;
			if (!this._uuid) {
				callback == null || callback(new Error('Anchor is not persistent'));
				return;
			}
			this._anchors.forget(this._uuid, function (ex) {
				_this3._uuid = null;
				callback == null || callback(ex);
				_this3.fire('forget');
			});
		};
		return _createClass(XrAnchor, [{
			key: "uuid",
			get: function get() {
				return this._uuid;
			}
		}, {
			key: "persistent",
			get: function get() {
				return !!this._uuid;
			}
		}]);
	}(EventHandler);
	XrAnchor.EVENT_DESTROY = 'destroy';
	XrAnchor.EVENT_CHANGE = 'change';
	XrAnchor.EVENT_PERSIST = 'persist';
	XrAnchor.EVENT_FORGET = 'forget';

	var XrAnchors = function (_EventHandler) {
		function XrAnchors(manager) {
			var _window;
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.manager = void 0;
			_this._supported = platform.browser && !!window.XRAnchor;
			_this._available = false;
			_this._checkingAvailability = false;
			_this._persistence = platform.browser && !!((_window = window) != null && (_window = _window.XRSession) != null && _window.prototype.restorePersistentAnchor);
			_this._creationQueue = [];
			_this._index = new Map();
			_this._indexByUuid = new Map();
			_this._list = [];
			_this._callbacksAnchors = new Map();
			_this.manager = manager;
			if (_this._supported) {
				_this.manager.on('start', _this._onSessionStart, _this);
				_this.manager.on('end', _this._onSessionEnd, _this);
			}
			return _this;
		}
		_inheritsLoose(XrAnchors, _EventHandler);
		var _proto = XrAnchors.prototype;
		_proto._onSessionStart = function _onSessionStart() {
			var available = this.manager.session.enabledFeatures.indexOf('anchors') !== -1;
			if (!available) return;
			this._available = available;
			this.fire('available');
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			if (!this._available) return;
			this._available = false;
			for (var _i = 0; _i < this._creationQueue.length; _i++) {
				if (!this._creationQueue[_i].callback) {
					continue;
				}
				this._creationQueue[_i].callback(new Error('session ended'), null);
			}
			this._creationQueue.length = 0;
			this._index.clear();
			this._indexByUuid.clear();
			var i = this._list.length;
			while (i--) {
				this._list[i].destroy();
			}
			this._list.length = 0;
			this.fire('unavailable');
		};
		_proto._createAnchor = function _createAnchor(xrAnchor, uuid) {
			if (uuid === void 0) {
				uuid = null;
			}
			var anchor = new XrAnchor(this, xrAnchor, uuid);
			this._index.set(xrAnchor, anchor);
			if (uuid) this._indexByUuid.set(uuid, anchor);
			this._list.push(anchor);
			anchor.once('destroy', this._onAnchorDestroy, this);
			return anchor;
		};
		_proto._onAnchorDestroy = function _onAnchorDestroy(xrAnchor, anchor) {
			this._index.delete(xrAnchor);
			if (anchor.uuid) this._indexByUuid.delete(anchor.uuid);
			var ind = this._list.indexOf(anchor);
			if (ind !== -1) this._list.splice(ind, 1);
			this.fire('destroy', anchor);
		};
		_proto.create = function create(position, rotation, callback) {
			var _this2 = this;
			if (!this._available) {
				callback == null || callback(new Error('Anchors API is not available'), null);
				return;
			}
			if (window.XRHitTestResult && position instanceof XRHitTestResult) {
				var hitResult = position;
				callback = rotation;
				if (!this._supported) {
					callback == null || callback(new Error('Anchors API is not supported'), null);
					return;
				}
				if (!hitResult.createAnchor) {
					callback == null || callback(new Error('Creating Anchor from Hit Test is not supported'), null);
					return;
				}
				hitResult.createAnchor().then(function (xrAnchor) {
					var anchor = _this2._createAnchor(xrAnchor);
					callback == null || callback(null, anchor);
					_this2.fire('add', anchor);
				}).catch(function (ex) {
					callback == null || callback(ex, null);
					_this2.fire('error', ex);
				});
			} else {
				this._creationQueue.push({
					transform: new XRRigidTransform(position, rotation),
					callback: callback
				});
			}
		};
		_proto.restore = function restore(uuid, callback) {
			var _this3 = this;
			if (!this._available) {
				callback == null || callback(new Error('Anchors API is not available'), null);
				return;
			}
			if (!this._persistence) {
				callback == null || callback(new Error('Anchor Persistence is not supported'), null);
				return;
			}
			if (!this.manager.active) {
				callback == null || callback(new Error('WebXR session is not active'), null);
				return;
			}
			this.manager.session.restorePersistentAnchor(uuid).then(function (xrAnchor) {
				var anchor = _this3._createAnchor(xrAnchor, uuid);
				callback == null || callback(null, anchor);
				_this3.fire('add', anchor);
			}).catch(function (ex) {
				callback == null || callback(ex, null);
				_this3.fire('error', ex);
			});
		};
		_proto.forget = function forget(uuid, callback) {
			var _this4 = this;
			if (!this._available) {
				callback == null || callback(new Error('Anchors API is not available'));
				return;
			}
			if (!this._persistence) {
				callback == null || callback(new Error('Anchor Persistence is not supported'));
				return;
			}
			if (!this.manager.active) {
				callback == null || callback(new Error('WebXR session is not active'));
				return;
			}
			this.manager.session.deletePersistentAnchor(uuid).then(function () {
				callback == null || callback(null);
			}).catch(function (ex) {
				callback == null || callback(ex);
				_this4.fire('error', ex);
			});
		};
		_proto.update = function update(frame) {
			var _this5 = this;
			if (!this._available) {
				if (!this.manager.session.enabledFeatures && !this._checkingAvailability) {
					this._checkingAvailability = true;
					frame.createAnchor(new XRRigidTransform(), this.manager._referenceSpace).then(function (xrAnchor) {
						xrAnchor.delete();
						if (_this5.manager.active) {
							_this5._available = true;
							_this5.fire('available');
						}
					}).catch(function () {});
				}
				return;
			}
			if (this._creationQueue.length) {
				var _loop = function _loop() {
					var request = _this5._creationQueue[i];
					frame.createAnchor(request.transform, _this5.manager._referenceSpace).then(function (xrAnchor) {
						if (request.callback) {
							_this5._callbacksAnchors.set(xrAnchor, request.callback);
						}
					}).catch(function (ex) {
						if (request.callback) {
							request.callback(ex, null);
						}
						_this5.fire('error', ex);
					});
				};
				for (var i = 0; i < this._creationQueue.length; i++) {
					_loop();
				}
				this._creationQueue.length = 0;
			}
			for (var _iterator = _createForOfIteratorHelperLoose(this._index), _step; !(_step = _iterator()).done;) {
				var _step$value = _step.value,
					xrAnchor = _step$value[0],
					anchor = _step$value[1];
				if (frame.trackedAnchors.has(xrAnchor)) {
					continue;
				}
				this._index.delete(xrAnchor);
				anchor.destroy();
			}
			for (var _i2 = 0; _i2 < this._list.length; _i2++) {
				this._list[_i2].update(frame);
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(frame.trackedAnchors), _step2; !(_step2 = _iterator2()).done;) {
				var _xrAnchor = _step2.value;
				if (this._index.has(_xrAnchor)) {
					continue;
				}
				try {
					var tmp = _xrAnchor.anchorSpace;
				} catch (ex) {
					continue;
				}
				var _anchor = this._createAnchor(_xrAnchor);
				_anchor.update(frame);
				var callback = this._callbacksAnchors.get(_xrAnchor);
				if (callback) {
					this._callbacksAnchors.delete(_xrAnchor);
					callback(null, _anchor);
				}
				this.fire('add', _anchor);
			}
		};
		return _createClass(XrAnchors, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "persistence",
			get: function get() {
				return this._persistence;
			}
		}, {
			key: "uuids",
			get: function get() {
				if (!this._available) {
					return null;
				}
				if (!this._persistence) {
					return null;
				}
				if (!this.manager.active) {
					return null;
				}
				return this.manager.session.persistentAnchors;
			}
		}, {
			key: "list",
			get: function get() {
				return this._list;
			}
		}]);
	}(EventHandler);
	XrAnchors.EVENT_AVAILABLE = 'available';
	XrAnchors.EVENT_UNAVAILABLE = 'unavailable';
	XrAnchors.EVENT_ERROR = 'error';
	XrAnchors.EVENT_ADD = 'add';
	XrAnchors.EVENT_DESTROY = 'destroy';

	var XrMesh = function (_EventHandler) {
		function XrMesh(meshDetection, xrMesh) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._meshDetection = void 0;
			_this._xrMesh = void 0;
			_this._lastChanged = 0;
			_this._position = new Vec3();
			_this._rotation = new Quat();
			_this._meshDetection = meshDetection;
			_this._xrMesh = xrMesh;
			_this._lastChanged = _this._xrMesh.lastChangedTime;
			return _this;
		}
		_inheritsLoose(XrMesh, _EventHandler);
		var _proto = XrMesh.prototype;
		_proto.destroy = function destroy() {
			if (!this._xrMesh) return;
			this._xrMesh = null;
			this.fire('remove');
		};
		_proto.update = function update(frame) {
			var manager = this._meshDetection._manager;
			var pose = frame.getPose(this._xrMesh.meshSpace, manager._referenceSpace);
			if (pose) {
				this._position.copy(pose.transform.position);
				this._rotation.copy(pose.transform.orientation);
			}
			if (this._lastChanged !== this._xrMesh.lastChangedTime) {
				this._lastChanged = this._xrMesh.lastChangedTime;
				this.fire('change');
			}
		};
		_proto.getPosition = function getPosition() {
			return this._position;
		};
		_proto.getRotation = function getRotation() {
			return this._rotation;
		};
		return _createClass(XrMesh, [{
			key: "xrMesh",
			get: function get() {
				return this._xrMesh;
			}
		}, {
			key: "label",
			get: function get() {
				return this._xrMesh.semanticLabel || '';
			}
		}, {
			key: "vertices",
			get: function get() {
				return this._xrMesh.vertices;
			}
		}, {
			key: "indices",
			get: function get() {
				return this._xrMesh.indices;
			}
		}]);
	}(EventHandler);
	XrMesh.EVENT_REMOVE = 'remove';
	XrMesh.EVENT_CHANGE = 'change';

	var XrMeshDetection = function (_EventHandler) {
		function XrMeshDetection(manager) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._supported = platform.browser && !!window.XRMesh;
			_this._available = false;
			_this._index = new Map();
			_this._list = [];
			_this._manager = manager;
			if (_this._supported) {
				_this._manager.on('start', _this._onSessionStart, _this);
				_this._manager.on('end', _this._onSessionEnd, _this);
			}
			return _this;
		}
		_inheritsLoose(XrMeshDetection, _EventHandler);
		var _proto = XrMeshDetection.prototype;
		_proto.update = function update(frame) {
			if (!this._available) {
				if (!this._manager.session.enabledFeatures && frame.detectedMeshes.size) {
					this._available = true;
					this.fire('available');
				} else {
					return;
				}
			}
			for (var _iterator = _createForOfIteratorHelperLoose(frame.detectedMeshes), _step; !(_step = _iterator()).done;) {
				var xrMesh = _step.value;
				var mesh = this._index.get(xrMesh);
				if (!mesh) {
					mesh = new XrMesh(this, xrMesh);
					this._index.set(xrMesh, mesh);
					this._list.push(mesh);
					mesh.update(frame);
					this.fire('add', mesh);
				} else {
					mesh.update(frame);
				}
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(this._index.values()), _step2; !(_step2 = _iterator2()).done;) {
				var _mesh = _step2.value;
				if (frame.detectedMeshes.has(_mesh.xrMesh)) {
					continue;
				}
				this._removeMesh(_mesh);
			}
		};
		_proto._removeMesh = function _removeMesh(mesh) {
			this._index.delete(mesh.xrMesh);
			this._list.splice(this._list.indexOf(mesh), 1);
			mesh.destroy();
			this.fire('remove', mesh);
		};
		_proto._onSessionStart = function _onSessionStart() {
			if (this._manager.session.enabledFeatures) {
				var available = this._manager.session.enabledFeatures.indexOf('mesh-detection') !== -1;
				if (!available) return;
				this._available = available;
				this.fire('available');
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			if (!this._available) return;
			this._available = false;
			for (var _iterator3 = _createForOfIteratorHelperLoose(this._index.values()), _step3; !(_step3 = _iterator3()).done;) {
				var mesh = _step3.value;
				this._removeMesh(mesh);
			}
			this.fire('unavailable');
		};
		return _createClass(XrMeshDetection, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "available",
			get: function get() {
				return this._available;
			}
		}, {
			key: "meshes",
			get: function get() {
				return this._list;
			}
		}]);
	}(EventHandler);
	XrMeshDetection.EVENT_AVAILABLE = 'available';
	XrMeshDetection.EVENT_UNAVAILABLE = 'unavailable';
	XrMeshDetection.EVENT_ADD = 'add';
	XrMeshDetection.EVENT_REMOVE = 'remove';

	var XrView = function (_EventHandler) {
		function XrView(manager, xrView, viewsCount) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._xrView = void 0;
			_this._positionData = new Float32Array(3);
			_this._viewport = new Vec4();
			_this._projMat = new Mat4();
			_this._projViewOffMat = new Mat4();
			_this._viewMat = new Mat4();
			_this._viewOffMat = new Mat4();
			_this._viewMat3 = new Mat3();
			_this._viewInvMat = new Mat4();
			_this._viewInvOffMat = new Mat4();
			_this._xrCamera = null;
			_this._textureColor = null;
			_this._textureDepth = null;
			_this._depthInfo = null;
			_this._emptyDepthBuffer = new Uint8Array(32);
			_this._depthMatrix = new Mat4();
			_this._manager = manager;
			_this._xrView = xrView;
			var device = _this._manager.app.graphicsDevice;
			if (_this._manager.views.supportedColor) {
				_this._xrCamera = _this._xrView.camera;
				if (_this._manager.views.availableColor && _this._xrCamera) {
					_this._textureColor = new Texture(device, {
						format: PIXELFORMAT_RGB8,
						mipmaps: false,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						minFilter: FILTER_LINEAR,
						magFilter: FILTER_LINEAR,
						width: _this._xrCamera.width,
						height: _this._xrCamera.height,
						name: "XrView-" + _this._xrView.eye + "-Color"
					});
				}
			}
			if (_this._manager.views.supportedDepth && _this._manager.views.availableDepth) {
				var filtering = _this._manager.views.depthGpuOptimized ? FILTER_NEAREST : FILTER_LINEAR;
				_this._textureDepth = new Texture(device, {
					format: _this._manager.views.depthPixelFormat,
					arrayLength: viewsCount === 1 ? 0 : viewsCount,
					mipmaps: false,
					addressU: ADDRESS_CLAMP_TO_EDGE,
					addressV: ADDRESS_CLAMP_TO_EDGE,
					minFilter: filtering,
					magFilter: filtering,
					width: 4,
					height: 4,
					name: "XrView-" + _this._xrView.eye + "-Depth"
				});
				for (var i = 0; i < _this._textureDepth._levels.length; i++) {
					_this._textureDepth._levels[i] = _this._emptyDepthBuffer;
				}
				_this._textureDepth.upload();
			}
			if (_this._textureColor || _this._textureDepth) {
				device.on('devicelost', _this._onDeviceLost, _this);
			}
			return _this;
		}
		_inheritsLoose(XrView, _EventHandler);
		var _proto = XrView.prototype;
		_proto.update = function update(frame, xrView) {
			this._xrView = xrView;
			if (this._manager.views.availableColor) {
				this._xrCamera = this._xrView.camera;
			}
			var layer = frame.session.renderState.baseLayer;
			var viewport = layer.getViewport(this._xrView);
			this._viewport.x = viewport.x;
			this._viewport.y = viewport.y;
			this._viewport.z = viewport.width;
			this._viewport.w = viewport.height;
			this._projMat.set(this._xrView.projectionMatrix);
			this._viewMat.set(this._xrView.transform.inverse.matrix);
			this._viewInvMat.set(this._xrView.transform.matrix);
			this._updateTextureColor();
			this._updateDepth(frame);
		};
		_proto._updateTextureColor = function _updateTextureColor() {
			if (!this._manager.views.availableColor || !this._xrCamera || !this._textureColor) {
				return;
			}
			var binding = this._manager.webglBinding;
			if (!binding) {
				return;
			}
			var texture = binding.getCameraImage(this._xrCamera);
			if (!texture) {
				return;
			}
			var device = this._manager.app.graphicsDevice;
			var gl = device.gl;
			if (!this._frameBufferSource) {
				this._frameBufferSource = gl.createFramebuffer();
				this._frameBuffer = gl.createFramebuffer();
			} else {
				var attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
				var width = this._xrCamera.width;
				var height = this._xrCamera.height;
				device.setFramebuffer(this._frameBufferSource);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, texture, 0);
				device.setFramebuffer(this._frameBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, this._textureColor.impl._glTexture, 0);
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._frameBufferSource);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
				gl.blitFramebuffer(0, height, width, 0, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
			}
		};
		_proto._updateDepth = function _updateDepth(frame) {
			var _this$_depthInfo, _this$_depthInfo2;
			if (!this._manager.views.availableDepth || !this._textureDepth) {
				return;
			}
			var gpu = this._manager.views.depthGpuOptimized;
			var infoSource = gpu ? this._manager.webglBinding : frame;
			if (!infoSource) {
				this._depthInfo = null;
				return;
			}
			var depthInfo = infoSource.getDepthInformation(this._xrView);
			if (!depthInfo) {
				this._depthInfo = null;
				return;
			}
			var matrixDirty = !this._depthInfo !== !depthInfo;
			this._depthInfo = depthInfo;
			var width = ((_this$_depthInfo = this._depthInfo) == null ? void 0 : _this$_depthInfo.width) || 4;
			var height = ((_this$_depthInfo2 = this._depthInfo) == null ? void 0 : _this$_depthInfo2.height) || 4;
			var resized = false;
			if (this._textureDepth.width !== width || this._textureDepth.height !== height) {
				this._textureDepth._width = width;
				this._textureDepth._height = height;
				matrixDirty = true;
				resized = true;
			}
			if (matrixDirty) {
				if (this._depthInfo) {
					this._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix);
				} else {
					this._depthMatrix.setIdentity();
				}
			}
			if (this._depthInfo) {
				if (gpu) {
					if (this._depthInfo.texture) {
						var gl = this._manager.app.graphicsDevice.gl;
						this._textureDepth.impl._glTexture = this._depthInfo.texture;
						if (this._depthInfo.textureType === 'texture-array') {
							this._textureDepth.impl._glTarget = gl.TEXTURE_2D_ARRAY;
						} else {
							this._textureDepth.impl._glTarget = gl.TEXTURE_2D;
						}
						switch (this._manager.views.depthPixelFormat) {
							case PIXELFORMAT_R32F:
								this._textureDepth.impl._glInternalFormat = gl.R32F;
								this._textureDepth.impl._glPixelType = gl.FLOAT;
								this._textureDepth.impl._glFormat = gl.RED;
								break;
							case PIXELFORMAT_DEPTH:
								this._textureDepth.impl._glInternalFormat = gl.DEPTH_COMPONENT16;
								this._textureDepth.impl._glPixelType = gl.UNSIGNED_SHORT;
								this._textureDepth.impl._glFormat = gl.DEPTH_COMPONENT;
								break;
						}
						this._textureDepth.impl._glCreated = true;
					}
				} else {
					this._textureDepth._levels[0] = new Uint8Array(this._depthInfo.data);
					this._textureDepth.upload();
				}
			} else {
				this._textureDepth._levels[0] = this._emptyDepthBuffer;
				this._textureDepth.upload();
			}
			if (resized) this.fire('depth:resize', width, height);
		};
		_proto.updateTransforms = function updateTransforms(transform) {
			if (transform) {
				this._viewInvOffMat.mul2(transform, this._viewInvMat);
				this.viewOffMat.copy(this._viewInvOffMat).invert();
			} else {
				this._viewInvOffMat.copy(this._viewInvMat);
				this.viewOffMat.copy(this._viewMat);
			}
			this._viewMat3.setFromMat4(this._viewOffMat);
			this._projViewOffMat.mul2(this._projMat, this._viewOffMat);
			this._positionData[0] = this._viewInvOffMat.data[12];
			this._positionData[1] = this._viewInvOffMat.data[13];
			this._positionData[2] = this._viewInvOffMat.data[14];
		};
		_proto._onDeviceLost = function _onDeviceLost() {
			this._frameBufferSource = null;
			this._frameBuffer = null;
			this._depthInfo = null;
		};
		_proto.getDepth = function getDepth(u, v) {
			var _this$_depthInfo$getD, _this$_depthInfo3;
			if (this._manager.views.depthGpuOptimized) {
				return null;
			}
			return (_this$_depthInfo$getD = (_this$_depthInfo3 = this._depthInfo) == null ? void 0 : _this$_depthInfo3.getDepthInMeters(u, v)) != null ? _this$_depthInfo$getD : null;
		};
		_proto.destroy = function destroy() {
			this._depthInfo = null;
			if (this._textureColor) {
				this._textureColor.destroy();
				this._textureColor = null;
			}
			if (this._textureDepth) {
				this._textureDepth.destroy();
				this._textureDepth = null;
			}
			if (this._frameBufferSource) {
				var gl = this._manager.app.graphicsDevice.gl;
				gl.deleteFramebuffer(this._frameBufferSource);
				this._frameBufferSource = null;
				gl.deleteFramebuffer(this._frameBuffer);
				this._frameBuffer = null;
			}
		};
		return _createClass(XrView, [{
			key: "textureColor",
			get: function get() {
				return this._textureColor;
			}
		}, {
			key: "textureDepth",
			get: function get() {
				return this._textureDepth;
			}
		}, {
			key: "depthUvMatrix",
			get: function get() {
				return this._depthMatrix;
			}
		}, {
			key: "depthValueToMeters",
			get: function get() {
				var _this$_depthInfo4;
				return ((_this$_depthInfo4 = this._depthInfo) == null ? void 0 : _this$_depthInfo4.rawValueToMeters) || 0;
			}
		}, {
			key: "eye",
			get: function get() {
				return this._xrView.eye;
			}
		}, {
			key: "viewport",
			get: function get() {
				return this._viewport;
			}
		}, {
			key: "projMat",
			get: function get() {
				return this._projMat;
			}
		}, {
			key: "projViewOffMat",
			get: function get() {
				return this._projViewOffMat;
			}
		}, {
			key: "viewOffMat",
			get: function get() {
				return this._viewOffMat;
			}
		}, {
			key: "viewInvOffMat",
			get: function get() {
				return this._viewInvOffMat;
			}
		}, {
			key: "viewMat3",
			get: function get() {
				return this._viewMat3;
			}
		}, {
			key: "positionData",
			get: function get() {
				return this._positionData;
			}
		}]);
	}(EventHandler);
	XrView.EVENT_DEPTHRESIZE = 'depth:resize';

	var XrViews = function (_EventHandler) {
		function XrViews(manager) {
			var _this$_depthFormats;
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._manager = void 0;
			_this._index = new Map();
			_this._indexTmp = new Map();
			_this._list = [];
			_this._supportedColor = platform.browser && !!window.XRCamera && !!window.XRWebGLBinding;
			_this._supportedDepth = platform.browser && !!window.XRDepthInformation;
			_this._availableColor = false;
			_this._availableDepth = false;
			_this._depthUsage = '';
			_this._depthFormat = '';
			_this._depthFormats = (_this$_depthFormats = {}, _this$_depthFormats[XRDEPTHSENSINGFORMAT_L8A8] = PIXELFORMAT_LA8, _this$_depthFormats[XRDEPTHSENSINGFORMAT_R16U] = PIXELFORMAT_DEPTH, _this$_depthFormats[XRDEPTHSENSINGFORMAT_F32] = PIXELFORMAT_R32F, _this$_depthFormats);
			_this._manager = manager;
			_this._manager.on('start', _this._onSessionStart, _this);
			_this._manager.on('end', _this._onSessionEnd, _this);
			return _this;
		}
		_inheritsLoose(XrViews, _EventHandler);
		var _proto = XrViews.prototype;
		_proto.update = function update(frame, xrViews) {
			for (var i = 0; i < xrViews.length; i++) {
				this._indexTmp.set(xrViews[i].eye, xrViews[i]);
			}
			for (var _iterator = _createForOfIteratorHelperLoose(this._indexTmp), _step; !(_step = _iterator()).done;) {
				var _step$value = _step.value,
					eye = _step$value[0],
					xrView = _step$value[1];
				var view = this._index.get(eye);
				if (!view) {
					view = new XrView(this._manager, xrView, xrViews.length);
					this._index.set(eye, view);
					this._list.push(view);
					view.update(frame, xrView);
					this.fire('add', view);
				} else {
					view.update(frame, xrView);
				}
			}
			for (var _iterator2 = _createForOfIteratorHelperLoose(this._index), _step2; !(_step2 = _iterator2()).done;) {
				var _step2$value = _step2.value,
					_eye = _step2$value[0],
					_view = _step2$value[1];
				if (this._indexTmp.has(_eye)) {
					continue;
				}
				_view.destroy();
				this._index.delete(_eye);
				var ind = this._list.indexOf(_view);
				if (ind !== -1) this._list.splice(ind, 1);
				this.fire('remove', _view);
			}
			this._indexTmp.clear();
		};
		_proto.get = function get(eye) {
			return this._index.get(eye) || null;
		};
		_proto._onSessionStart = function _onSessionStart() {
			if (this._manager.type !== XRTYPE_AR) {
				return;
			}
			if (!this._manager.session.enabledFeatures) {
				return;
			}
			this._availableColor = this._manager.session.enabledFeatures.indexOf('camera-access') !== -1;
			this._availableDepth = this._manager.session.enabledFeatures.indexOf('depth-sensing') !== -1;
			if (this._availableDepth) {
				var session = this._manager.session;
				this._depthUsage = session.depthUsage;
				this._depthFormat = session.depthDataFormat;
			}
		};
		_proto._onSessionEnd = function _onSessionEnd() {
			for (var _iterator3 = _createForOfIteratorHelperLoose(this._index.values()), _step3; !(_step3 = _iterator3()).done;) {
				var view = _step3.value;
				view.destroy();
			}
			this._index.clear();
			this._availableColor = false;
			this._availableDepth = false;
			this._depthUsage = '';
			this._depthFormat = '';
			this._list.length = 0;
		};
		return _createClass(XrViews, [{
			key: "list",
			get: function get() {
				return this._list;
			}
		}, {
			key: "supportedColor",
			get: function get() {
				return this._supportedColor;
			}
		}, {
			key: "supportedDepth",
			get: function get() {
				return this._supportedDepth;
			}
		}, {
			key: "availableColor",
			get: function get() {
				return this._availableColor;
			}
		}, {
			key: "availableDepth",
			get: function get() {
				return this._availableDepth;
			}
		}, {
			key: "depthUsage",
			get: function get() {
				return this._depthUsage;
			}
		}, {
			key: "depthGpuOptimized",
			get: function get() {
				return this._depthUsage === XRDEPTHSENSINGUSAGE_GPU;
			}
		}, {
			key: "depthFormat",
			get: function get() {
				return this._depthFormat;
			}
		}, {
			key: "depthPixelFormat",
			get: function get() {
				var _this$_depthFormats$t;
				return (_this$_depthFormats$t = this._depthFormats[this._depthFormat]) != null ? _this$_depthFormats$t : null;
			}
		}]);
	}(EventHandler);
	XrViews.EVENT_ADD = 'add';
	XrViews.EVENT_REMOVE = 'remove';

	var XrManager = function (_EventHandler) {
		function XrManager(app) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this.app = void 0;
			_this._supported = platform.browser && !!navigator.xr;
			_this._available = {};
			_this._type = null;
			_this._spaceType = null;
			_this._session = null;
			_this._baseLayer = null;
			_this.webglBinding = null;
			_this._referenceSpace = null;
			_this.domOverlay = void 0;
			_this.hitTest = void 0;
			_this.imageTracking = void 0;
			_this.planeDetection = void 0;
			_this.meshDetection = void 0;
			_this.input = void 0;
			_this.lightEstimation = void 0;
			_this.views = void 0;
			_this.anchors = void 0;
			_this._camera = null;
			_this._localPosition = new Vec3();
			_this._localRotation = new Quat();
			_this._depthNear = 0.1;
			_this._depthFar = 1000;
			_this._supportedFrameRates = null;
			_this._width = 0;
			_this._height = 0;
			_this._framebufferScaleFactor = 1.0;
			_this.app = app;
			_this._available[XRTYPE_INLINE] = false;
			_this._available[XRTYPE_VR] = false;
			_this._available[XRTYPE_AR] = false;
			_this.views = new XrViews(_this);
			_this.domOverlay = new XrDomOverlay(_this);
			_this.hitTest = new XrHitTest(_this);
			_this.imageTracking = new XrImageTracking(_this);
			_this.planeDetection = new XrPlaneDetection(_this);
			_this.meshDetection = new XrMeshDetection(_this);
			_this.input = new XrInput(_this);
			_this.lightEstimation = new XrLightEstimation(_this);
			_this.anchors = new XrAnchors(_this);
			_this.views = new XrViews(_this);
			if (_this._supported) {
				navigator.xr.addEventListener('devicechange', function () {
					_this._deviceAvailabilityCheck();
				});
				_this._deviceAvailabilityCheck();
				_this.app.graphicsDevice.on('devicelost', _this._onDeviceLost, _this);
				_this.app.graphicsDevice.on('devicerestored', _this._onDeviceRestored, _this);
			}
			return _this;
		}
		_inheritsLoose(XrManager, _EventHandler);
		var _proto = XrManager.prototype;
		_proto.destroy = function destroy() {};
		_proto.start = function start(camera, type, spaceType, options) {
			var _options$framebufferS,
				_this$app$graphicsDev,
				_this2 = this;
			var callback = options;
			if (typeof options === 'object') {
				callback = options.callback;
			}
			if (!this._available[type]) {
				if (callback) callback(new Error('XR is not available'));
				return;
			}
			if (this._session) {
				if (callback) callback(new Error('XR session is already started'));
				return;
			}
			this._camera = camera;
			this._camera.camera.xr = this;
			this._type = type;
			this._spaceType = spaceType;
			this._framebufferScaleFactor = (_options$framebufferS = options == null ? void 0 : options.framebufferScaleFactor) != null ? _options$framebufferS : 1.0;
			this._setClipPlanes(camera.nearClip, camera.farClip);
			var opts = {
				requiredFeatures: [spaceType],
				optionalFeatures: []
			};
			var webgl = (_this$app$graphicsDev = this.app.graphicsDevice) == null ? void 0 : _this$app$graphicsDev.isWebGL2;
			if (type === XRTYPE_AR) {
				opts.optionalFeatures.push('light-estimation');
				opts.optionalFeatures.push('hit-test');
				if (options) {
					if (options.imageTracking && this.imageTracking.supported) {
						opts.optionalFeatures.push('image-tracking');
					}
					if (options.planeDetection) {
						opts.optionalFeatures.push('plane-detection');
					}
					if (options.meshDetection) {
						opts.optionalFeatures.push('mesh-detection');
					}
				}
				if (this.domOverlay.supported && this.domOverlay.root) {
					opts.optionalFeatures.push('dom-overlay');
					opts.domOverlay = {
						root: this.domOverlay.root
					};
				}
				if (options && options.anchors && this.anchors.supported) {
					opts.optionalFeatures.push('anchors');
				}
				if (options && options.depthSensing && this.views.supportedDepth) {
					opts.optionalFeatures.push('depth-sensing');
					var usagePreference = [];
					var dataFormatPreference = [];
					usagePreference.push(XRDEPTHSENSINGUSAGE_GPU, XRDEPTHSENSINGUSAGE_CPU);
					dataFormatPreference.push(XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGFORMAT_R16U);
					if (options.depthSensing.usagePreference) {
						var ind = usagePreference.indexOf(options.depthSensing.usagePreference);
						if (ind !== -1) usagePreference.splice(ind, 1);
						usagePreference.unshift(options.depthSensing.usagePreference);
					}
					if (options.depthSensing.dataFormatPreference) {
						var _ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);
						if (_ind !== -1) dataFormatPreference.splice(_ind, 1);
						dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
					}
					opts.depthSensing = {
						usagePreference: usagePreference,
						dataFormatPreference: dataFormatPreference
					};
				}
				if (webgl && options && options.cameraColor && this.views.supportedColor) {
					opts.optionalFeatures.push('camera-access');
				}
			}
			opts.optionalFeatures.push('hand-tracking');
			if (options && options.optionalFeatures) {
				opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);
			}
			if (this.imageTracking.supported && this.imageTracking.images.length) {
				this.imageTracking.prepareImages(function (err, trackedImages) {
					if (err) {
						if (callback) callback(err);
						_this2.fire('error', err);
						return;
					}
					if (trackedImages !== null) {
						opts.trackedImages = trackedImages;
					}
					_this2._onStartOptionsReady(type, spaceType, opts, callback);
				});
			} else {
				this._onStartOptionsReady(type, spaceType, opts, callback);
			}
		};
		_proto._onStartOptionsReady = function _onStartOptionsReady(type, spaceType, options, callback) {
			var _this3 = this;
			navigator.xr.requestSession(type, options).then(function (session) {
				_this3._onSessionStart(session, spaceType, callback);
			}).catch(function (ex) {
				_this3._camera.camera.xr = null;
				_this3._camera = null;
				_this3._type = null;
				_this3._spaceType = null;
				if (callback) callback(ex);
				_this3.fire('error', ex);
			});
		};
		_proto.end = function end(callback) {
			if (!this._session) {
				if (callback) callback(new Error('XR Session is not initialized'));
				return;
			}
			this.webglBinding = null;
			if (callback) this.once('end', callback);
			this._session.end();
		};
		_proto.isAvailable = function isAvailable(type) {
			return this._available[type];
		};
		_proto._deviceAvailabilityCheck = function _deviceAvailabilityCheck() {
			for (var key in this._available) {
				this._sessionSupportCheck(key);
			}
		};
		_proto.initiateRoomCapture = function initiateRoomCapture(callback) {
			if (!this._session) {
				callback(new Error('Session is not active'));
				return;
			}
			if (!this._session.initiateRoomCapture) {
				callback(new Error('Session does not support manual room capture'));
				return;
			}
			this._session.initiateRoomCapture().then(function () {
				if (callback) callback(null);
			}).catch(function (err) {
				if (callback) callback(err);
			});
		};
		_proto.updateTargetFrameRate = function updateTargetFrameRate(frameRate, callback) {
			var _this$_session;
			if (!((_this$_session = this._session) != null && _this$_session.updateTargetFrameRate)) {
				callback == null || callback(new Error('unable to update frameRate'));
				return;
			}
			this._session.updateTargetFrameRate(frameRate).then(function () {
				callback == null || callback();
			}).catch(function (err) {
				callback == null || callback(err);
			});
		};
		_proto._sessionSupportCheck = function _sessionSupportCheck(type) {
			var _this4 = this;
			navigator.xr.isSessionSupported(type).then(function (available) {
				if (_this4._available[type] === available) {
					return;
				}
				_this4._available[type] = available;
				_this4.fire('available', type, available);
				_this4.fire("available:" + type, available);
			}).catch(function (ex) {
				_this4.fire('error', ex);
			});
		};
		_proto._onSessionStart = function _onSessionStart(session, spaceType, callback) {
			var _this5 = this;
			var failed = false;
			this._session = session;
			var onVisibilityChange = function onVisibilityChange() {
				_this5.fire('visibility:change', session.visibilityState);
			};
			var onClipPlanesChange = function onClipPlanesChange() {
				_this5._setClipPlanes(_this5._camera.nearClip, _this5._camera.farClip);
			};
			var _onEnd = function onEnd() {
				if (_this5._camera) {
					_this5._camera.off('set_nearClip', onClipPlanesChange);
					_this5._camera.off('set_farClip', onClipPlanesChange);
					_this5._camera.camera.xr = null;
					_this5._camera = null;
				}
				session.removeEventListener('end', _onEnd);
				session.removeEventListener('visibilitychange', onVisibilityChange);
				if (!failed) _this5.fire('end');
				_this5._session = null;
				_this5._referenceSpace = null;
				_this5._width = 0;
				_this5._height = 0;
				_this5._type = null;
				_this5._spaceType = null;
				if (_this5.app.systems) {
					_this5.app.tick();
				}
			};
			session.addEventListener('end', _onEnd);
			session.addEventListener('visibilitychange', onVisibilityChange);
			this._camera.on('set_nearClip', onClipPlanesChange);
			this._camera.on('set_farClip', onClipPlanesChange);
			this._createBaseLayer();
			if (this.session.supportedFrameRates) {
				this._supportedFrameRates = Array.from(this.session.supportedFrameRates);
			} else {
				this._supportedFrameRates = null;
			}
			this._session.addEventListener('frameratechange', function () {
				var _this5$_session;
				_this5.fire('frameratechange', (_this5$_session = _this5._session) == null ? void 0 : _this5$_session.frameRate);
			});
			session.requestReferenceSpace(spaceType).then(function (referenceSpace) {
				_this5._referenceSpace = referenceSpace;
				_this5.app.tick();
				if (callback) callback(null);
				_this5.fire('start');
			}).catch(function (ex) {
				failed = true;
				session.end();
				if (callback) callback(ex);
				_this5.fire('error', ex);
			});
		};
		_proto._setClipPlanes = function _setClipPlanes(near, far) {
			if (this._depthNear === near && this._depthFar === far) {
				return;
			}
			this._depthNear = near;
			this._depthFar = far;
			if (!this._session) {
				return;
			}
			this._session.updateRenderState({
				depthNear: this._depthNear,
				depthFar: this._depthFar
			});
		};
		_proto._createBaseLayer = function _createBaseLayer() {
			var device = this.app.graphicsDevice;
			var framebufferScaleFactor = device.maxPixelRatio / window.devicePixelRatio * this._framebufferScaleFactor;
			this._baseLayer = new XRWebGLLayer(this._session, device.gl, {
				alpha: true,
				depth: true,
				stencil: true,
				framebufferScaleFactor: framebufferScaleFactor,
				antialias: false
			});
			if (device != null && device.isWebGL2 && window.XRWebGLBinding) {
				try {
					this.webglBinding = new XRWebGLBinding(this._session, device.gl);
				} catch (ex) {
					this.fire('error', ex);
				}
			}
			this._session.updateRenderState({
				baseLayer: this._baseLayer,
				depthNear: this._depthNear,
				depthFar: this._depthFar
			});
		};
		_proto._onDeviceLost = function _onDeviceLost() {
			if (!this._session) {
				return;
			}
			if (this.webglBinding) {
				this.webglBinding = null;
			}
			this._baseLayer = null;
			this._session.updateRenderState({
				baseLayer: this._baseLayer,
				depthNear: this._depthNear,
				depthFar: this._depthFar
			});
		};
		_proto._onDeviceRestored = function _onDeviceRestored() {
			var _this6 = this;
			if (!this._session) {
				return;
			}
			setTimeout(function () {
				_this6.app.graphicsDevice.gl.makeXRCompatible().then(function () {
					_this6._createBaseLayer();
				}).catch(function (ex) {
					_this6.fire('error', ex);
				});
			}, 0);
		};
		_proto.update = function update(frame) {
			if (!this._session) return false;
			var width = frame.session.renderState.baseLayer.framebufferWidth;
			var height = frame.session.renderState.baseLayer.framebufferHeight;
			if (this._width !== width || this._height !== height) {
				this._width = width;
				this._height = height;
				this.app.graphicsDevice.setResolution(width, height);
			}
			var pose = frame.getViewerPose(this._referenceSpace);
			if (!pose) return false;
			var lengthOld = this.views.list.length;
			this.views.update(frame, pose.views);
			var posePosition = pose.transform.position;
			var poseOrientation = pose.transform.orientation;
			this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);
			this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);
			if (lengthOld === 0 && this.views.list.length > 0) {
				var viewProjMat = new Mat4();
				var view = this.views.list[0];
				viewProjMat.copy(view.projMat);
				var data = viewProjMat.data;
				var fov = 2.0 * Math.atan(1.0 / data[5]) * 180.0 / Math.PI;
				var aspectRatio = data[5] / data[0];
				var farClip = data[14] / (data[10] + 1);
				var nearClip = data[14] / (data[10] - 1);
				var horizontalFov = false;
				var camera = this._camera.camera;
				camera.setXrProperties({
					aspectRatio: aspectRatio,
					farClip: farClip,
					fov: fov,
					horizontalFov: horizontalFov,
					nearClip: nearClip
				});
			}
			this._camera.camera._node.setLocalPosition(this._localPosition);
			this._camera.camera._node.setLocalRotation(this._localRotation);
			this.input.update(frame);
			if (this._type === XRTYPE_AR) {
				if (this.hitTest.supported) {
					this.hitTest.update(frame);
				}
				if (this.lightEstimation.supported) {
					this.lightEstimation.update(frame);
				}
				if (this.imageTracking.supported) {
					this.imageTracking.update(frame);
				}
				if (this.anchors.supported) {
					this.anchors.update(frame);
				}
				if (this.planeDetection.supported) {
					this.planeDetection.update(frame);
				}
				if (this.meshDetection.supported) {
					this.meshDetection.update(frame);
				}
			}
			this.fire('update', frame);
			return true;
		};
		return _createClass(XrManager, [{
			key: "supported",
			get: function get() {
				return this._supported;
			}
		}, {
			key: "active",
			get: function get() {
				return !!this._session;
			}
		}, {
			key: "type",
			get: function get() {
				return this._type;
			}
		}, {
			key: "spaceType",
			get: function get() {
				return this._spaceType;
			}
		}, {
			key: "session",
			get: function get() {
				return this._session;
			}
		}, {
			key: "frameRate",
			get: function get() {
				var _this$_session$frameR, _this$_session2;
				return (_this$_session$frameR = (_this$_session2 = this._session) == null ? void 0 : _this$_session2.frameRate) != null ? _this$_session$frameR : null;
			}
		}, {
			key: "supportedFrameRates",
			get: function get() {
				return this._supportedFrameRates;
			}
		}, {
			key: "framebufferScaleFactor",
			get: function get() {
				return this._framebufferScaleFactor;
			}
		}, {
			key: "fixedFoveation",
			get: function get() {
				var _this$_baseLayer$fixe, _this$_baseLayer;
				return (_this$_baseLayer$fixe = (_this$_baseLayer = this._baseLayer) == null ? void 0 : _this$_baseLayer.fixedFoveation) != null ? _this$_baseLayer$fixe : null;
			},
			set: function set(value) {
				var _this$_baseLayer$fixe2, _this$_baseLayer2;
				if (((_this$_baseLayer$fixe2 = (_this$_baseLayer2 = this._baseLayer) == null ? void 0 : _this$_baseLayer2.fixedFoveation) != null ? _this$_baseLayer$fixe2 : null) !== null) {
					if (this.app.graphicsDevice.samples > 1) ;
					this._baseLayer.fixedFoveation = value;
				}
			}
		}, {
			key: "camera",
			get: function get() {
				return this._camera ? this._camera.entity : null;
			}
		}, {
			key: "visibilityState",
			get: function get() {
				if (!this._session) {
					return null;
				}
				return this._session.visibilityState;
			}
		}]);
	}(EventHandler);
	XrManager.EVENT_AVAILABLE = 'available';
	XrManager.EVENT_START = 'start';
	XrManager.EVENT_END = 'end';
	XrManager.EVENT_UPDATE = 'update';
	XrManager.EVENT_ERROR = 'error';

	var Application = function (_AppBase) {
		function Application(canvas, options) {
			var _options$graphicsDevi;
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _AppBase.call(this, canvas) || this;
			var appOptions = new AppOptions();
			appOptions.graphicsDevice = (_options$graphicsDevi = options.graphicsDevice) != null ? _options$graphicsDevi : _this.createDevice(canvas, options);
			_this.addComponentSystems(appOptions);
			_this.addResourceHandles(appOptions);
			appOptions.elementInput = options.elementInput;
			appOptions.keyboard = options.keyboard;
			appOptions.mouse = options.mouse;
			appOptions.touch = options.touch;
			appOptions.gamepads = options.gamepads;
			appOptions.scriptPrefix = options.scriptPrefix;
			appOptions.assetPrefix = options.assetPrefix;
			appOptions.scriptsOrder = options.scriptsOrder;
			appOptions.soundManager = new SoundManager();
			appOptions.lightmapper = Lightmapper;
			appOptions.batchManager = BatchManager;
			appOptions.xr = XrManager;
			_this.init(appOptions);
			return _this;
		}
		_inheritsLoose(Application, _AppBase);
		var _proto = Application.prototype;
		_proto.createDevice = function createDevice(canvas, options) {
			if (!options.graphicsDeviceOptions) {
				options.graphicsDeviceOptions = {};
			}
			if (platform.browser && !!navigator.xr) {
				options.graphicsDeviceOptions.xrCompatible = true;
			}
			options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
			return new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);
		};
		_proto.addComponentSystems = function addComponentSystems(appOptions) {
			appOptions.componentSystems = [RigidBodyComponentSystem, CollisionComponentSystem, JointComponentSystem, AnimationComponentSystem, AnimComponentSystem, ModelComponentSystem, RenderComponentSystem, CameraComponentSystem, LightComponentSystem, ScriptComponentSystem, SoundComponentSystem, AudioListenerComponentSystem, ParticleSystemComponentSystem, ScreenComponentSystem, ElementComponentSystem, ButtonComponentSystem, ScrollViewComponentSystem, ScrollbarComponentSystem, SpriteComponentSystem, LayoutGroupComponentSystem, LayoutChildComponentSystem, ZoneComponentSystem, GSplatComponentSystem];
		};
		_proto.addResourceHandles = function addResourceHandles(appOptions) {
			appOptions.resourceHandlers = [RenderHandler, AnimationHandler, AnimClipHandler, AnimStateGraphHandler, ModelHandler, MaterialHandler, TextureHandler, TextHandler, JsonHandler, AudioHandler, ScriptHandler, SceneHandler, CubemapHandler, HtmlHandler, CssHandler, ShaderHandler, HierarchyHandler, FolderHandler, FontHandler, BinaryHandler, TextureAtlasHandler, SpriteHandler, TemplateHandler, ContainerHandler, GSplatHandler];
		};
		return Application;
	}(AppBase);

	var AssetListLoader = function (_EventHandler) {
		function AssetListLoader(assetList, assetRegistry) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._assets = new Set();
			_this._loadingAssets = new Set();
			_this._waitingAssets = new Set();
			_this._loading = false;
			_this._loaded = false;
			_this._failed = [];
			_this._registry = assetRegistry;
			assetList.forEach(function (a) {
				if (a instanceof Asset) {
					if (!a.registry) {
						a.registry = assetRegistry;
					}
					_this._assets.add(a);
				} else {
					var asset = assetRegistry.get(a);
					if (asset) {
						_this._assets.add(asset);
					} else {
						_this._waitForAsset(a);
					}
				}
			});
			return _this;
		}
		_inheritsLoose(AssetListLoader, _EventHandler);
		var _proto = AssetListLoader.prototype;
		_proto.destroy = function destroy() {
			var _this2 = this;
			this._registry.off('load', this._onLoad);
			this._registry.off('error', this._onError);
			this._waitingAssets.forEach(function (id) {
				_this2._registry.off("add:" + id, _this2._onAddAsset);
			});
			this.off('progress');
			this.off('load');
		};
		_proto._assetHasDependencies = function _assetHasDependencies(asset) {
			var _asset$file;
			return asset.type === 'model' && ((_asset$file = asset.file) == null ? void 0 : _asset$file.url) && asset.file.url && asset.file.url.match(/.json$/g);
		};
		_proto.load = function load(done, scope) {
			var _this3 = this;
			if (this._loading) {
				return;
			}
			this._loading = true;
			this._callback = done;
			this._scope = scope;
			this._registry.on('load', this._onLoad, this);
			this._registry.on('error', this._onError, this);
			var loadingAssets = false;
			this._assets.forEach(function (asset) {
				if (!asset.loaded) {
					loadingAssets = true;
					if (_this3._assetHasDependencies(asset)) {
						_this3._registry.loadFromUrl(asset.file.url, asset.type, function (err, loadedAsset) {
							if (err) {
								_this3._onError(err, asset);
								return;
							}
							_this3._onLoad(asset);
						});
					}
					_this3._loadingAssets.add(asset);
					_this3._registry.add(asset);
				}
			});
			this._loadingAssets.forEach(function (asset) {
				if (!_this3._assetHasDependencies(asset)) {
					_this3._registry.load(asset);
				}
			});
			if (!loadingAssets && this._waitingAssets.size === 0) {
				this._loadingComplete();
			}
		};
		_proto.ready = function ready(done, scope) {
			if (scope === void 0) {
				scope = this;
			}
			if (this._loaded) {
				done.call(scope, Array.from(this._assets));
			} else {
				this.once('load', function (assets) {
					done.call(scope, assets);
				});
			}
		};
		_proto._loadingComplete = function _loadingComplete() {
			if (this._loaded) return;
			this._loaded = true;
			this._registry.off('load', this._onLoad, this);
			this._registry.off('error', this._onError, this);
			if (this._failed.length) {
				if (this._callback) {
					this._callback.call(this._scope, 'Failed to load some assets', this._failed);
				}
				this.fire('error', this._failed);
			} else {
				if (this._callback) {
					this._callback.call(this._scope);
				}
				this.fire('load', Array.from(this._assets));
			}
		};
		_proto._onLoad = function _onLoad(asset) {
			var _this4 = this;
			if (this._loadingAssets.has(asset)) {
				this.fire('progress', asset);
				this._loadingAssets.delete(asset);
			}
			if (this._loadingAssets.size === 0) {
				setTimeout(function () {
					_this4._loadingComplete();
				}, 0);
			}
		};
		_proto._onError = function _onError(err, asset) {
			var _this5 = this;
			if (this._loadingAssets.has(asset)) {
				this._failed.push(asset);
				this._loadingAssets.delete(asset);
			}
			if (this._loadingAssets.size === 0) {
				setTimeout(function () {
					_this5._loadingComplete();
				}, 0);
			}
		};
		_proto._onAddAsset = function _onAddAsset(asset) {
			this._waitingAssets.delete(asset);
			this._assets.add(asset);
			if (!asset.loaded) {
				this._loadingAssets.add(asset);
				this._registry.load(asset);
			}
		};
		_proto._waitForAsset = function _waitForAsset(assetId) {
			this._waitingAssets.add(assetId);
			this._registry.once("add:" + assetId, this._onAddAsset, this);
		};
		return AssetListLoader;
	}(EventHandler);

	var MAX_TEXTURE_SIZE = 4096;
	var DEFAULT_TEXTURE_SIZE = 512;
	var Atlas = function () {
		function Atlas(device, width, height, name) {
			this.canvas = document.createElement('canvas');
			this.canvas.width = width;
			this.canvas.height = height;
			this.texture = new Texture(device, {
				name: name,
				format: PIXELFORMAT_RGBA8,
				width: width,
				height: height,
				mipmaps: true,
				minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				levels: [this.canvas]
			});
			this.ctx = this.canvas.getContext('2d', {
				alpha: true
			});
		}
		var _proto = Atlas.prototype;
		_proto.destroy = function destroy() {
			this.texture.destroy();
		};
		_proto.clear = function clear(clearColor) {
			var _this$canvas = this.canvas,
				width = _this$canvas.width,
				height = _this$canvas.height;
			this.ctx.clearRect(0, 0, width, height);
			this.ctx.fillStyle = clearColor;
			this.ctx.fillRect(0, 0, width, height);
		};
		return Atlas;
	}();
	var CanvasFont = function (_EventHandler) {
		function CanvasFont(app, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _EventHandler.call(this) || this;
			_this.type = 'bitmap';
			_this.app = app;
			_this.intensity = 0;
			_this.fontWeight = options.fontWeight || 'normal';
			_this.fontSize = parseInt(options.fontSize, 10);
			_this.glyphSize = _this.fontSize;
			_this.fontName = options.fontName || 'Arial';
			_this.color = options.color || new Color(1, 1, 1);
			_this.padding = options.padding || 0;
			_this.width = Math.min(MAX_TEXTURE_SIZE, options.width || DEFAULT_TEXTURE_SIZE);
			_this.height = Math.min(MAX_TEXTURE_SIZE, options.height || DEFAULT_TEXTURE_SIZE);
			_this.atlases = [];
			_this.chars = '';
			_this.data = {};
			return _this;
		}
		_inheritsLoose(CanvasFont, _EventHandler);
		var _proto2 = CanvasFont.prototype;
		_proto2.createTextures = function createTextures(text) {
			var _chars = this._normalizeCharsSet(text);
			if (_chars.length !== this.chars.length) {
				this._renderAtlas(_chars);
				return;
			}
			for (var i = 0; i < _chars.length; i++) {
				if (_chars[i] !== this.chars[i]) {
					this._renderAtlas(_chars);
					return;
				}
			}
		};
		_proto2.updateTextures = function updateTextures(text) {
			var _chars = this._normalizeCharsSet(text);
			var newCharsSet = [];
			for (var i = 0; i < _chars.length; i++) {
				var _char = _chars[i];
				if (!this.data.chars[_char]) {
					newCharsSet.push(_char);
				}
			}
			if (newCharsSet.length > 0) {
				this._renderAtlas(this.chars.concat(newCharsSet));
			}
		};
		_proto2.destroy = function destroy() {
			this.atlases.forEach(function (atlas) {
				return atlas.destroy();
			});
			this.chars = null;
			this.color = null;
			this.data = null;
			this.fontName = null;
			this.fontSize = null;
			this.glyphSize = null;
			this.intensity = null;
			this.atlases = null;
			this.type = null;
			this.fontWeight = null;
		};
		_proto2._colorToRgbString = function _colorToRgbString(color, alpha) {
			var str;
			var r = Math.round(255 * color.r);
			var g = Math.round(255 * color.g);
			var b = Math.round(255 * color.b);
			if (alpha) {
				str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
			} else {
				str = "rgb(" + r + ", " + g + ", " + b + ")";
			}
			return str;
		};
		_proto2.renderCharacter = function renderCharacter(context, _char2, x, y, color) {
			context.fillStyle = color;
			context.fillText(_char2, x, y);
		};
		_proto2._getAtlas = function _getAtlas(index) {
			if (index >= this.atlases.length) {
				this.atlases[index] = new Atlas(this.app.graphicsDevice, this.width, this.height, "font-atlas-" + this.fontName + "-" + index);
			}
			return this.atlases[index];
		};
		_proto2._renderAtlas = function _renderAtlas(charsArray) {
			this.chars = charsArray;
			var w = this.width;
			var h = this.height;
			var color = this._colorToRgbString(this.color, false);
			var a = this.color.a;
			this.color.a = 1 / 255;
			var transparent = this._colorToRgbString(this.color, true);
			this.color.a = a;
			var TEXT_ALIGN = 'center';
			var TEXT_BASELINE = 'alphabetic';
			var atlasIndex = 0;
			var atlas = this._getAtlas(atlasIndex++);
			atlas.clear(transparent);
			this.data = this._createJson(this.chars, this.fontName, w, h);
			var symbols = string.getSymbols(this.chars.join(''));
			var maxHeight = 0;
			var maxDescent = 0;
			var metrics = {};
			for (var i = 0; i < symbols.length; i++) {
				var ch = symbols[i];
				metrics[ch] = this._getTextMetrics(ch);
				maxHeight = Math.max(maxHeight, metrics[ch].height);
				maxDescent = Math.max(maxDescent, metrics[ch].descent);
			}
			this.glyphSize = Math.max(this.glyphSize, maxHeight);
			var sx = this.glyphSize + this.padding * 2;
			var sy = this.glyphSize + this.padding * 2;
			var _xOffset = this.glyphSize / 2 + this.padding;
			var _yOffset = sy - maxDescent - this.padding;
			var _x = 0;
			var _y = 0;
			for (var _i = 0; _i < symbols.length; _i++) {
				var _ch = symbols[_i];
				var code = string.getCodePoint(symbols[_i]);
				var fs = this.fontSize;
				atlas.ctx.font = this.fontWeight + " " + fs.toString() + "px " + this.fontName;
				atlas.ctx.textAlign = TEXT_ALIGN;
				atlas.ctx.textBaseline = TEXT_BASELINE;
				var width = atlas.ctx.measureText(_ch).width;
				if (width > fs) {
					fs = this.fontSize * this.fontSize / width;
					atlas.ctx.font = this.fontWeight + " " + fs.toString() + "px " + this.fontName;
					width = this.fontSize;
				}
				this.renderCharacter(atlas.ctx, _ch, _x + _xOffset, _y + _yOffset, color);
				var xoffset = this.padding + (this.glyphSize - width) / 2;
				var yoffset = -this.padding + metrics[_ch].descent - maxDescent;
				var xadvance = width;
				this._addChar(this.data, _ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, atlasIndex - 1, w, h);
				_x += sx;
				if (_x + sx > w) {
					_x = 0;
					_y += sy;
					if (_y + sy > h) {
						atlas = this._getAtlas(atlasIndex++);
						atlas.clear(transparent);
						_y = 0;
					}
				}
			}
			this.atlases.splice(atlasIndex).forEach(function (atlas) {
				return atlas.destroy();
			});
			this.atlases.forEach(function (atlas) {
				return atlas.texture.upload();
			});
			this.fire('render');
		};
		_proto2._createJson = function _createJson(chars, fontName, width, height) {
			var base = {
				'version': 3,
				'intensity': this.intensity,
				'info': {
					'face': fontName,
					'width': width,
					'height': height,
					'maps': [{
						'width': width,
						'height': height
					}]
				},
				'chars': {}
			};
			return base;
		};
		_proto2._addChar = function _addChar(json, _char3, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
			if (json.info.maps.length < mapNum + 1) {
				json.info.maps.push({
					'width': mapW,
					'height': mapH
				});
			}
			var scale = this.fontSize / 32;
			json.chars[_char3] = {
				'id': charCode,
				'letter': _char3,
				'x': x,
				'y': y,
				'width': w,
				'height': h,
				'xadvance': xadvance / scale,
				'xoffset': xoffset / scale,
				'yoffset': (yoffset + this.padding) / scale,
				'scale': scale,
				'range': 1,
				'map': mapNum,
				'bounds': [0, 0, w / scale, h / scale]
			};
		};
		_proto2._normalizeCharsSet = function _normalizeCharsSet(text) {
			var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();
			if (unicodeConverterFunc) {
				text = unicodeConverterFunc(text);
			}
			var set = {};
			var symbols = string.getSymbols(text);
			for (var i = 0; i < symbols.length; i++) {
				var ch = symbols[i];
				if (set[ch]) continue;
				set[ch] = ch;
			}
			var chars = Object.keys(set);
			return chars.sort();
		};
		_proto2._getTextMetrics = function _getTextMetrics(text) {
			var textSpan = document.createElement('span');
			textSpan.id = 'content-span';
			textSpan.innerHTML = text;
			var block = document.createElement('div');
			block.id = 'content-block';
			block.style.display = 'inline-block';
			block.style.width = '1px';
			block.style.height = '0px';
			var div = document.createElement('div');
			div.appendChild(textSpan);
			div.appendChild(block);
			div.style.font = this.fontSize + "px " + this.fontName;
			var body = document.body;
			body.appendChild(div);
			var ascent = -1;
			var descent = -1;
			var height = -1;
			try {
				block.style['vertical-align'] = 'baseline';
				ascent = block.offsetTop - textSpan.offsetTop;
				block.style['vertical-align'] = 'bottom';
				height = block.offsetTop - textSpan.offsetTop;
				descent = height - ascent;
			} finally {
				document.body.removeChild(div);
			}
			return {
				ascent: ascent,
				descent: descent,
				height: height
			};
		};
		return _createClass(CanvasFont, [{
			key: "textures",
			get: function get() {
				return this.atlases.map(function (atlas) {
					return atlas.texture;
				});
			}
		}]);
	}(EventHandler);

	var tempMeshInstances$1 = [];
	var lights = [[], [], []];
	var RenderPassPicker = function (_RenderPass) {
		function RenderPassPicker(device, renderer) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.viewBindGroups = [];
			_this.renderer = renderer;
			return _this;
		}
		_inheritsLoose(RenderPassPicker, _RenderPass);
		var _proto = RenderPassPicker.prototype;
		_proto.destroy = function destroy() {
			this.viewBindGroups.forEach(function (bg) {
				bg.defaultUniformBuffer.destroy();
				bg.destroy();
			});
			this.viewBindGroups.length = 0;
		};
		_proto.update = function update(camera, scene, layers, mapping) {
			this.camera = camera;
			this.scene = scene;
			this.layers = layers;
			this.mapping = mapping;
		};
		_proto.execute = function execute() {
			var device = this.device;
			var renderer = this.renderer,
				camera = this.camera,
				scene = this.scene,
				layers = this.layers,
				mapping = this.mapping,
				renderTarget = this.renderTarget;
			var srcLayers = scene.layers.layerList;
			var subLayerEnabled = scene.layers.subLayerEnabled;
			var isTransparent = scene.layers.subLayerList;
			for (var i = 0; i < srcLayers.length; i++) {
				var srcLayer = srcLayers[i];
				if (layers && layers.indexOf(srcLayer) < 0) {
					continue;
				}
				if (srcLayer.enabled && subLayerEnabled[i]) {
					if (srcLayer.camerasSet.has(camera.camera)) {
						var transparent = isTransparent[i];
						if (srcLayer._clearDepthBuffer) {
							renderer.clear(camera.camera, false, true, false);
						}
						var meshInstances = srcLayer.meshInstances;
						for (var j = 0; j < meshInstances.length; j++) {
							var meshInstance = meshInstances[j];
							if (meshInstance.pick && meshInstance.transparent === transparent) {
								tempMeshInstances$1.push(meshInstance);
								mapping.set(meshInstance.id, meshInstance);
							}
						}
						if (tempMeshInstances$1.length > 0) {
							var clusteredLightingEnabled = scene.clusteredLightingEnabled;
							if (clusteredLightingEnabled) {
								var lightClusters = renderer.worldClustersAllocator.empty;
								lightClusters.activate();
							}
							renderer.setCameraUniforms(camera.camera, renderTarget);
							if (device.supportsUniformBuffers) {
								renderer.setupViewUniformBuffers(this.viewBindGroups, renderer.viewUniformFormat, renderer.viewBindGroupFormat, 1);
							}
							renderer.renderForward(camera.camera, renderTarget, tempMeshInstances$1, lights, SHADER_PICK, function (meshInstance) {
								device.setBlendState(BlendState.NOBLEND);
							});
							tempMeshInstances$1.length = 0;
						}
					}
				}
			}
		};
		return RenderPassPicker;
	}(RenderPass);

	var tempSet = new Set();
	var _rect = new Vec4();
	var Picker = function () {
		function Picker(app, width, height) {
			var _this = this;
			this.renderTarget = null;
			this.mapping = new Map();
			this.deviceValid = true;
			this.renderer = app.renderer;
			this.device = app.graphicsDevice;
			this.renderPass = new RenderPassPicker(this.device, app.renderer);
			this.width = 0;
			this.height = 0;
			this.resize(width, height);
			this.device.on('destroy', function () {
				_this.deviceValid = false;
			});
		}
		var _proto = Picker.prototype;
		_proto.getSelection = function getSelection(x, y, width, height) {
			if (width === void 0) {
				width = 1;
			}
			if (height === void 0) {
				height = 1;
			}
			var device = this.device;
			if (device.isWebGPU) {
				return [];
			}
			y = this.renderTarget.height - (y + height);
			var rect = this.sanitizeRect(x, y, width, height);
			device.setRenderTarget(this.renderTarget);
			device.updateBegin();
			var pixels = new Uint8Array(4 * rect.z * rect.w);
			device.readPixels(rect.x, rect.y, rect.z, rect.w, pixels);
			device.updateEnd();
			return this.decodePixels(pixels, this.mapping);
		};
		_proto.getSelectionAsync = function getSelectionAsync(x, y, width, height) {
			var _this$device,
				_this2 = this;
			if (width === void 0) {
				width = 1;
			}
			if (height === void 0) {
				height = 1;
			}
			if ((_this$device = this.device) != null && _this$device.isWebGL2) {
				y = this.renderTarget.height - (y + height);
			}
			var rect = this.sanitizeRect(x, y, width, height);
			return this.renderTarget.colorBuffer.read(rect.x, rect.y, rect.z, rect.w, {
				renderTarget: this.renderTarget,
				immediate: true
			}).then(function (pixels) {
				return _this2.decodePixels(pixels, _this2.mapping);
			});
		};
		_proto.sanitizeRect = function sanitizeRect(x, y, width, height) {
			var maxWidth = this.renderTarget.width;
			var maxHeight = this.renderTarget.height;
			x = math.clamp(Math.floor(x), 0, maxWidth - 1);
			y = math.clamp(Math.floor(y), 0, maxHeight - 1);
			width = Math.floor(Math.max(width, 1));
			width = Math.min(width, maxWidth - x);
			height = Math.floor(Math.max(height, 1));
			height = Math.min(height, maxHeight - y);
			return _rect.set(x, y, width, height);
		};
		_proto.decodePixels = function decodePixels(pixels, mapping) {
			var selection = [];
			if (this.deviceValid) {
				var count = pixels.length;
				for (var i = 0; i < count; i += 4) {
					var r = pixels[i + 0];
					var g = pixels[i + 1];
					var b = pixels[i + 2];
					var a = pixels[i + 3];
					var index = a << 24 | r << 16 | g << 8 | b;
					if (index !== -1) {
						tempSet.add(mapping.get(index));
					}
				}
				tempSet.forEach(function (meshInstance) {
					if (meshInstance) {
						selection.push(meshInstance);
					}
				});
				tempSet.clear();
			}
			return selection;
		};
		_proto.allocateRenderTarget = function allocateRenderTarget() {
			var colorBuffer = new Texture(this.device, {
				format: PIXELFORMAT_RGBA8,
				width: this.width,
				height: this.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				name: 'pick'
			});
			this.renderTarget = new RenderTarget({
				colorBuffer: colorBuffer,
				depth: true
			});
		};
		_proto.releaseRenderTarget = function releaseRenderTarget() {
			if (this.renderTarget) {
				this.renderTarget.destroyTextureBuffers();
				this.renderTarget.destroy();
				this.renderTarget = null;
			}
		};
		_proto.prepare = function prepare(camera, scene, layers) {
			if (layers instanceof Layer) {
				layers = [layers];
			}
			if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
				this.releaseRenderTarget();
				this.allocateRenderTarget();
			}
			this.mapping.clear();
			var renderPass = this.renderPass;
			renderPass.init(this.renderTarget);
			renderPass.colorOps.clearValue = Color.WHITE;
			renderPass.colorOps.clear = true;
			renderPass.depthStencilOps.clearDepth = true;
			renderPass.update(camera, scene, layers, this.mapping);
			renderPass.render();
		};
		_proto.resize = function resize(width, height) {
			this.width = Math.floor(width);
			this.height = Math.floor(height);
		};
		return Picker;
	}();

	var SceneSettingsHandler = function (_ResourceHandler) {
		function SceneSettingsHandler(app) {
			return _ResourceHandler.call(this, app, 'scenesettings') || this;
		}
		_inheritsLoose(SceneSettingsHandler, _ResourceHandler);
		var _proto = SceneSettingsHandler.prototype;
		_proto.load = function load(url, callback) {
			SceneUtils.load(url, this.maxRetries, callback);
		};
		_proto.open = function open(url, data) {
			return data.settings;
		};
		return SceneSettingsHandler;
	}(ResourceHandler);

	var targetX, targetY;
	var vecA = new Vec3();
	var vecB = new Vec3();
	var rayA = new Ray();
	var rayB = new Ray();
	var rayC = new Ray();
	rayA.end = new Vec3();
	rayB.end = new Vec3();
	rayC.end = new Vec3();
	var _pq = new Vec3();
	var _pa = new Vec3();
	var _pb = new Vec3();
	var _pc = new Vec3();
	var _pd = new Vec3();
	var _m = new Vec3();
	var _au = new Vec3();
	var _bv = new Vec3();
	var _cw = new Vec3();
	var _ir = new Vec3();
	var _sct = new Vec3();
	var _accumulatedScale = new Vec3();
	var _paddingTop = new Vec3();
	var _paddingBottom = new Vec3();
	var _paddingLeft = new Vec3();
	var _paddingRight = new Vec3();
	var _cornerBottomLeft = new Vec3();
	var _cornerBottomRight = new Vec3();
	var _cornerTopRight = new Vec3();
	var _cornerTopLeft = new Vec3();
	var ZERO_VEC4 = new Vec4();
	function scalarTriple(p1, p2, p3) {
		return _sct.cross(p1, p2).dot(p3);
	}
	function intersectLineQuad(p, q, corners) {
		_pq.sub2(q, p);
		_pa.sub2(corners[0], p);
		_pb.sub2(corners[1], p);
		_pc.sub2(corners[2], p);
		_m.cross(_pc, _pq);
		var v = _pa.dot(_m);
		var u;
		var w;
		if (v >= 0) {
			u = -_pb.dot(_m);
			if (u < 0) {
				return -1;
			}
			w = scalarTriple(_pq, _pb, _pa);
			if (w < 0) {
				return -1;
			}
			var denom = 1.0 / (u + v + w);
			_au.copy(corners[0]).mulScalar(u * denom);
			_bv.copy(corners[1]).mulScalar(v * denom);
			_cw.copy(corners[2]).mulScalar(w * denom);
			_ir.copy(_au).add(_bv).add(_cw);
		} else {
			_pd.sub2(corners[3], p);
			u = _pd.dot(_m);
			if (u < 0) {
				return -1;
			}
			w = scalarTriple(_pq, _pa, _pd);
			if (w < 0) {
				return -1;
			}
			v = -v;
			var _denom = 1.0 / (u + v + w);
			_au.copy(corners[0]).mulScalar(u * _denom);
			_bv.copy(corners[3]).mulScalar(v * _denom);
			_cw.copy(corners[2]).mulScalar(w * _denom);
			_ir.copy(_au).add(_bv).add(_cw);
		}
		if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;
		if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;
		return _ir.sub(p).lengthSq();
	}
	var ElementInputEvent = function () {
		function ElementInputEvent(event, element, camera) {
			this.event = event;
			this.element = element;
			this.camera = camera;
			this._stopPropagation = false;
		}
		var _proto = ElementInputEvent.prototype;
		_proto.stopPropagation = function stopPropagation() {
			this._stopPropagation = true;
			if (this.event) {
				this.event.stopImmediatePropagation();
				this.event.stopPropagation();
			}
		};
		return ElementInputEvent;
	}();
	var ElementMouseEvent = function (_ElementInputEvent) {
		function ElementMouseEvent(event, element, camera, x, y, lastX, lastY) {
			var _this;
			_this = _ElementInputEvent.call(this, event, element, camera) || this;
			_this.x = x;
			_this.y = y;
			_this.ctrlKey = event.ctrlKey || false;
			_this.altKey = event.altKey || false;
			_this.shiftKey = event.shiftKey || false;
			_this.metaKey = event.metaKey || false;
			_this.button = event.button;
			if (Mouse.isPointerLocked()) {
				_this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
				_this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
			} else {
				_this.dx = x - lastX;
				_this.dy = y - lastY;
			}
			_this.wheelDelta = 0;
			if (event.type === 'wheel') {
				if (event.deltaY > 0) {
					_this.wheelDelta = 1;
				} else if (event.deltaY < 0) {
					_this.wheelDelta = -1;
				}
			}
			return _this;
		}
		_inheritsLoose(ElementMouseEvent, _ElementInputEvent);
		return ElementMouseEvent;
	}(ElementInputEvent);
	var ElementTouchEvent = function (_ElementInputEvent2) {
		function ElementTouchEvent(event, element, camera, x, y, touch) {
			var _this2;
			_this2 = _ElementInputEvent2.call(this, event, element, camera) || this;
			_this2.touches = event.touches;
			_this2.changedTouches = event.changedTouches;
			_this2.x = x;
			_this2.y = y;
			_this2.touch = touch;
			return _this2;
		}
		_inheritsLoose(ElementTouchEvent, _ElementInputEvent2);
		return ElementTouchEvent;
	}(ElementInputEvent);
	var ElementSelectEvent = function (_ElementInputEvent3) {
		function ElementSelectEvent(event, element, camera, inputSource) {
			var _this3;
			_this3 = _ElementInputEvent3.call(this, event, element, camera) || this;
			_this3.inputSource = inputSource;
			return _this3;
		}
		_inheritsLoose(ElementSelectEvent, _ElementInputEvent3);
		return ElementSelectEvent;
	}(ElementInputEvent);
	var ElementInput = function () {
		function ElementInput(domElement, options) {
			this._app = null;
			this._attached = false;
			this._target = null;
			this._enabled = true;
			this._lastX = 0;
			this._lastY = 0;
			this._upHandler = this._handleUp.bind(this);
			this._downHandler = this._handleDown.bind(this);
			this._moveHandler = this._handleMove.bind(this);
			this._wheelHandler = this._handleWheel.bind(this);
			this._touchstartHandler = this._handleTouchStart.bind(this);
			this._touchendHandler = this._handleTouchEnd.bind(this);
			this._touchcancelHandler = this._touchendHandler;
			this._touchmoveHandler = this._handleTouchMove.bind(this);
			this._sortHandler = this._sortElements.bind(this);
			this._elements = [];
			this._hoveredElement = null;
			this._pressedElement = null;
			this._touchedElements = {};
			this._touchesForWhichTouchLeaveHasFired = {};
			this._selectedElements = {};
			this._selectedPressedElements = {};
			this._useMouse = !options || options.useMouse !== false;
			this._useTouch = !options || options.useTouch !== false;
			this._useXr = !options || options.useXr !== false;
			this._selectEventsAttached = false;
			if (platform.touch) {
				this._clickedEntities = {};
			}
			this.attach(domElement);
		}
		var _proto2 = ElementInput.prototype;
		_proto2.attach = function attach(domElement) {
			if (this._attached) {
				this._attached = false;
				this.detach();
			}
			this._target = domElement;
			this._attached = true;
			var opts = platform.passiveEvents ? {
				passive: true
			} : false;
			if (this._useMouse) {
				window.addEventListener('mouseup', this._upHandler, opts);
				window.addEventListener('mousedown', this._downHandler, opts);
				window.addEventListener('mousemove', this._moveHandler, opts);
				window.addEventListener('wheel', this._wheelHandler, opts);
			}
			if (this._useTouch && platform.touch) {
				this._target.addEventListener('touchstart', this._touchstartHandler, opts);
				this._target.addEventListener('touchend', this._touchendHandler, false);
				this._target.addEventListener('touchmove', this._touchmoveHandler, false);
				this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
			}
			this.attachSelectEvents();
		};
		_proto2.attachSelectEvents = function attachSelectEvents() {
			if (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
				if (!this._clickedEntities) {
					this._clickedEntities = {};
				}
				this._selectEventsAttached = true;
				this.app.xr.on('start', this._onXrStart, this);
			}
		};
		_proto2.detach = function detach() {
			if (!this._attached) return;
			this._attached = false;
			var opts = platform.passiveEvents ? {
				passive: true
			} : false;
			if (this._useMouse) {
				window.removeEventListener('mouseup', this._upHandler, opts);
				window.removeEventListener('mousedown', this._downHandler, opts);
				window.removeEventListener('mousemove', this._moveHandler, opts);
				window.removeEventListener('wheel', this._wheelHandler, opts);
			}
			if (this._useTouch) {
				this._target.removeEventListener('touchstart', this._touchstartHandler, opts);
				this._target.removeEventListener('touchend', this._touchendHandler, false);
				this._target.removeEventListener('touchmove', this._touchmoveHandler, false);
				this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
			}
			if (this._selectEventsAttached) {
				this._selectEventsAttached = false;
				this.app.xr.off('start', this._onXrStart, this);
				this.app.xr.off('end', this._onXrEnd, this);
				this.app.xr.off('update', this._onXrUpdate, this);
				this.app.xr.input.off('selectstart', this._onSelectStart, this);
				this.app.xr.input.off('selectend', this._onSelectEnd, this);
				this.app.xr.input.off('remove', this._onXrInputRemove, this);
			}
			this._target = null;
		};
		_proto2.addElement = function addElement(element) {
			if (this._elements.indexOf(element) === -1) {
				this._elements.push(element);
			}
		};
		_proto2.removeElement = function removeElement(element) {
			var idx = this._elements.indexOf(element);
			if (idx !== -1) {
				this._elements.splice(idx, 1);
			}
		};
		_proto2._handleUp = function _handleUp(event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked()) {
				return;
			}
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mouseup', event);
		};
		_proto2._handleDown = function _handleDown(event) {
			if (!this._enabled) return;
			if (Mouse.isPointerLocked()) {
				return;
			}
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mousedown', event);
		};
		_proto2._handleMove = function _handleMove(event) {
			if (!this._enabled) return;
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mousemove', event);
			this._lastX = targetX;
			this._lastY = targetY;
		};
		_proto2._handleWheel = function _handleWheel(event) {
			if (!this._enabled) return;
			this._calcMouseCoords(event);
			this._onElementMouseEvent('mousewheel', event);
		};
		_proto2._determineTouchedElements = function _determineTouchedElements(event) {
			var touchedElements = {};
			var cameras = this.app.systems.camera.cameras;
			for (var i = cameras.length - 1; i >= 0; i--) {
				var camera = cameras[i];
				var done = 0;
				var len = event.changedTouches.length;
				for (var j = 0; j < len; j++) {
					if (touchedElements[event.changedTouches[j].identifier]) {
						done++;
						continue;
					}
					var coords = getTouchTargetCoords(event.changedTouches[j]);
					var element = this._getTargetElementByCoords(camera, coords.x, coords.y);
					if (element) {
						done++;
						touchedElements[event.changedTouches[j].identifier] = {
							element: element,
							camera: camera,
							x: coords.x,
							y: coords.y
						};
					}
				}
				if (done === len) {
					break;
				}
			}
			return touchedElements;
		};
		_proto2._handleTouchStart = function _handleTouchStart(event) {
			if (!this._enabled) return;
			var newTouchedElements = this._determineTouchedElements(event);
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];
				if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
					this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));
					this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
				}
			}
			for (var touchId in newTouchedElements) {
				this._touchedElements[touchId] = newTouchedElements[touchId];
			}
		};
		_proto2._handleTouchEnd = function _handleTouchEnd(event) {
			if (!this._enabled) return;
			var cameras = this.app.systems.camera.cameras;
			for (var key in this._clickedEntities) {
				delete this._clickedEntities[key];
			}
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var touchInfo = this._touchedElements[touch.identifier];
				if (!touchInfo) {
					continue;
				}
				var element = touchInfo.element;
				var camera = touchInfo.camera;
				var x = touchInfo.x;
				var y = touchInfo.y;
				delete this._touchedElements[touch.identifier];
				delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];
				var coords = getTouchTargetCoords(touch);
				for (var c = cameras.length - 1; c >= 0; c--) {
					var hovered = this._getTargetElementByCoords(cameras[c], coords.x, coords.y);
					if (hovered === element) {
						if (!this._clickedEntities[element.entity.getGuid()]) {
							this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));
							this._clickedEntities[element.entity.getGuid()] = Date.now();
						}
					}
				}
				this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));
			}
		};
		_proto2._handleTouchMove = function _handleTouchMove(event) {
			event.preventDefault();
			if (!this._enabled) return;
			var newTouchedElements = this._determineTouchedElements(event);
			for (var i = 0, len = event.changedTouches.length; i < len; i++) {
				var touch = event.changedTouches[i];
				var newTouchInfo = newTouchedElements[touch.identifier];
				var oldTouchInfo = this._touchedElements[touch.identifier];
				if (oldTouchInfo) {
					var coords = getTouchTargetCoords(touch);
					if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
						this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
						this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
					}
					this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
				}
			}
		};
		_proto2._onElementMouseEvent = function _onElementMouseEvent(eventType, event) {
			var element = null;
			var lastHovered = this._hoveredElement;
			this._hoveredElement = null;
			var cameras = this.app.systems.camera.cameras;
			var camera;
			for (var i = cameras.length - 1; i >= 0; i--) {
				camera = cameras[i];
				element = this._getTargetElementByCoords(camera, targetX, targetY);
				if (element) {
					break;
				}
			}
			this._hoveredElement = element;
			if ((eventType === 'mousemove' || eventType === 'mouseup') && this._pressedElement) {
				this._fireEvent(eventType, new ElementMouseEvent(event, this._pressedElement, camera, targetX, targetY, this._lastX, this._lastY));
			} else if (element) {
				this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));
				if (eventType === 'mousedown') {
					this._pressedElement = element;
				}
			}
			if (lastHovered !== this._hoveredElement) {
				if (lastHovered) {
					this._fireEvent('mouseleave', new ElementMouseEvent(event, lastHovered, camera, targetX, targetY, this._lastX, this._lastY));
				}
				if (this._hoveredElement) {
					this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
				}
			}
			if (eventType === 'mouseup' && this._pressedElement) {
				if (this._pressedElement === this._hoveredElement) {
					var guid = this._hoveredElement.entity.getGuid();
					var fireClick = !this._clickedEntities;
					if (this._clickedEntities) {
						var lastTouchUp = this._clickedEntities[guid] || 0;
						var dt = Date.now() - lastTouchUp;
						fireClick = dt > 300;
						delete this._clickedEntities[guid];
					}
					if (fireClick) {
						this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
					}
				}
				this._pressedElement = null;
			}
		};
		_proto2._onXrStart = function _onXrStart() {
			this.app.xr.on('end', this._onXrEnd, this);
			this.app.xr.on('update', this._onXrUpdate, this);
			this.app.xr.input.on('selectstart', this._onSelectStart, this);
			this.app.xr.input.on('selectend', this._onSelectEnd, this);
			this.app.xr.input.on('remove', this._onXrInputRemove, this);
		};
		_proto2._onXrEnd = function _onXrEnd() {
			this.app.xr.off('update', this._onXrUpdate, this);
			this.app.xr.input.off('selectstart', this._onSelectStart, this);
			this.app.xr.input.off('selectend', this._onSelectEnd, this);
			this.app.xr.input.off('remove', this._onXrInputRemove, this);
		};
		_proto2._onXrUpdate = function _onXrUpdate() {
			if (!this._enabled) return;
			var inputSources = this.app.xr.input.inputSources;
			for (var i = 0; i < inputSources.length; i++) {
				this._onElementSelectEvent('selectmove', inputSources[i], null);
			}
		};
		_proto2._onXrInputRemove = function _onXrInputRemove(inputSource) {
			var hovered = this._selectedElements[inputSource.id];
			if (hovered) {
				inputSource._elementEntity = null;
				this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
			}
			delete this._selectedElements[inputSource.id];
			delete this._selectedPressedElements[inputSource.id];
		};
		_proto2._onSelectStart = function _onSelectStart(inputSource, event) {
			if (!this._enabled) return;
			this._onElementSelectEvent('selectstart', inputSource, event);
		};
		_proto2._onSelectEnd = function _onSelectEnd(inputSource, event) {
			if (!this._enabled) return;
			this._onElementSelectEvent('selectend', inputSource, event);
		};
		_proto2._onElementSelectEvent = function _onElementSelectEvent(eventType, inputSource, event) {
			var element;
			var hoveredBefore = this._selectedElements[inputSource.id];
			var hoveredNow;
			var cameras = this.app.systems.camera.cameras;
			var camera;
			if (inputSource.elementInput) {
				rayC.set(inputSource.getOrigin(), inputSource.getDirection());
				for (var i = cameras.length - 1; i >= 0; i--) {
					camera = cameras[i];
					element = this._getTargetElementByRay(rayC, camera);
					if (element) {
						break;
					}
				}
			}
			inputSource._elementEntity = element || null;
			if (element) {
				this._selectedElements[inputSource.id] = element;
				hoveredNow = element;
			} else {
				delete this._selectedElements[inputSource.id];
			}
			if (hoveredBefore !== hoveredNow) {
				if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
				if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}
			var pressed = this._selectedPressedElements[inputSource.id];
			if (eventType === 'selectmove' && pressed) {
				this._fireEvent('selectmove', new ElementSelectEvent(event, pressed, camera, inputSource));
			}
			if (eventType === 'selectstart') {
				this._selectedPressedElements[inputSource.id] = hoveredNow;
				if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
			}
			if (!inputSource.elementInput && pressed) {
				delete this._selectedPressedElements[inputSource.id];
				if (hoveredBefore) {
					this._fireEvent('selectend', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
			}
			if (eventType === 'selectend' && inputSource.elementInput) {
				delete this._selectedPressedElements[inputSource.id];
				if (pressed) {
					this._fireEvent('selectend', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
				if (pressed && pressed === hoveredBefore) {
					this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
				}
			}
		};
		_proto2._fireEvent = function _fireEvent(name, evt) {
			var element = evt.element;
			while (true) {
				element.fire(name, evt);
				if (evt._stopPropagation) {
					break;
				}
				if (!element.entity.parent) {
					break;
				}
				element = element.entity.parent.element;
				if (!element) {
					break;
				}
			}
		};
		_proto2._calcMouseCoords = function _calcMouseCoords(event) {
			var rect = this._target.getBoundingClientRect();
			var left = Math.floor(rect.left);
			var top = Math.floor(rect.top);
			targetX = event.clientX - left;
			targetY = event.clientY - top;
		};
		_proto2._sortElements = function _sortElements(a, b) {
			var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
			if (layerOrder !== 0) return layerOrder;
			if (a.screen && !b.screen) {
				return -1;
			}
			if (!a.screen && b.screen) {
				return 1;
			}
			if (!a.screen && !b.screen) {
				return 0;
			}
			if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) {
				return -1;
			}
			if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) {
				return 1;
			}
			return b.drawOrder - a.drawOrder;
		};
		_proto2._getTargetElementByCoords = function _getTargetElementByCoords(camera, x, y) {
			var rayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;
			var ray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;
			return this._getTargetElement(camera, rayScreen, ray3d);
		};
		_proto2._getTargetElementByRay = function _getTargetElementByRay(ray, camera) {
			rayA.origin.copy(ray.origin);
			rayA.direction.copy(ray.direction);
			rayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);
			var ray3d = rayA;
			var screenPos = camera.worldToScreen(ray3d.origin, vecA);
			var rayScreen = this._calculateRayScreen(screenPos.x, screenPos.y, camera, rayB) ? rayB : null;
			return this._getTargetElement(camera, rayScreen, ray3d);
		};
		_proto2._getTargetElement = function _getTargetElement(camera, rayScreen, ray3d) {
			var result = null;
			var closestDistance3d = Infinity;
			this._elements.sort(this._sortHandler);
			for (var i = 0, len = this._elements.length; i < len; i++) {
				var element = this._elements[i];
				if (!element.layers.some(function (v) {
					return camera.layersSet.has(v);
				})) {
					continue;
				}
				if (element.screen && element.screen.screen.screenSpace) {
					if (!rayScreen) {
						continue;
					}
					var currentDistance = this._checkElement(rayScreen, element, true);
					if (currentDistance >= 0) {
						result = element;
						break;
					}
				} else {
					if (!ray3d) {
						continue;
					}
					var _currentDistance = this._checkElement(ray3d, element, false);
					if (_currentDistance >= 0) {
						if (_currentDistance < closestDistance3d) {
							result = element;
							closestDistance3d = _currentDistance;
						}
						if (element.screen) {
							result = element;
							break;
						}
					}
				}
			}
			return result;
		};
		_proto2._calculateRayScreen = function _calculateRayScreen(x, y, camera, ray) {
			var sw = this.app.graphicsDevice.width;
			var sh = this.app.graphicsDevice.height;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;
			var _x = x * sw / this._target.clientWidth;
			var _y = y * sh / this._target.clientHeight;
			if (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - cameraTop) / cameraHeight;
				_y = sh - _y;
				ray.origin.set(_x, _y, 1);
				ray.direction.set(0, 0, -1);
				ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);
				return true;
			}
			return false;
		};
		_proto2._calculateRay3d = function _calculateRay3d(x, y, camera, ray) {
			var sw = this._target.clientWidth;
			var sh = this._target.clientHeight;
			var cameraWidth = camera.rect.z * sw;
			var cameraHeight = camera.rect.w * sh;
			var cameraLeft = camera.rect.x * sw;
			var cameraRight = cameraLeft + cameraWidth;
			var cameraBottom = (1 - camera.rect.y) * sh;
			var cameraTop = cameraBottom - cameraHeight;
			var _x = x;
			var _y = y;
			if (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {
				_x = sw * (_x - cameraLeft) / cameraWidth;
				_y = sh * (_y - cameraTop) / cameraHeight;
				camera.screenToWorld(_x, _y, camera.nearClip, vecA);
				camera.screenToWorld(_x, _y, camera.farClip, vecB);
				ray.origin.copy(vecA);
				ray.direction.set(0, 0, -1);
				ray.end.copy(vecB);
				return true;
			}
			return false;
		};
		_proto2._checkElement = function _checkElement(ray, element, screen) {
			if (element.maskedBy) {
				if (this._checkElement(ray, element.maskedBy.element, screen) < 0) {
					return -1;
				}
			}
			var scale;
			if (screen) {
				scale = ElementInput.calculateScaleToScreen(element);
			} else {
				scale = ElementInput.calculateScaleToWorld(element);
			}
			var corners = ElementInput.buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale);
			return intersectLineQuad(ray.origin, ray.end, corners);
		};
		ElementInput.buildHitCorners = function buildHitCorners(element, screenOrWorldCorners, scale) {
			var hitCorners = screenOrWorldCorners;
			var button = element.entity && element.entity.button;
			if (button) {
				var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;
				_paddingTop.copy(element.entity.up);
				_paddingBottom.copy(_paddingTop).mulScalar(-1);
				_paddingRight.copy(element.entity.right);
				_paddingLeft.copy(_paddingRight).mulScalar(-1);
				_paddingTop.mulScalar(hitPadding.w * scale.y);
				_paddingBottom.mulScalar(hitPadding.y * scale.y);
				_paddingRight.mulScalar(hitPadding.z * scale.x);
				_paddingLeft.mulScalar(hitPadding.x * scale.x);
				_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
				_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
				_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
				_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);
				hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
			}
			if (scale.x < 0) {
				var left = hitCorners[2].x;
				var right = hitCorners[0].x;
				hitCorners[0].x = left;
				hitCorners[1].x = right;
				hitCorners[2].x = right;
				hitCorners[3].x = left;
			}
			if (scale.y < 0) {
				var bottom = hitCorners[2].y;
				var top = hitCorners[0].y;
				hitCorners[0].y = bottom;
				hitCorners[1].y = bottom;
				hitCorners[2].y = top;
				hitCorners[3].y = top;
			}
			if (scale.z < 0) {
				var x = hitCorners[2].x;
				var y = hitCorners[2].y;
				var z = hitCorners[2].z;
				hitCorners[2].x = hitCorners[0].x;
				hitCorners[2].y = hitCorners[0].y;
				hitCorners[2].z = hitCorners[0].z;
				hitCorners[0].x = x;
				hitCorners[0].y = y;
				hitCorners[0].z = z;
			}
			return hitCorners;
		};
		ElementInput.calculateScaleToScreen = function calculateScaleToScreen(element) {
			var current = element.entity;
			var screenScale = element.screen.screen.scale;
			_accumulatedScale.set(screenScale, screenScale, screenScale);
			while (current && !current.screen) {
				_accumulatedScale.mul(current.getLocalScale());
				current = current.parent;
			}
			return _accumulatedScale;
		};
		ElementInput.calculateScaleToWorld = function calculateScaleToWorld(element) {
			var current = element.entity;
			_accumulatedScale.set(1, 1, 1);
			while (current) {
				_accumulatedScale.mul(current.getLocalScale());
				current = current.parent;
			}
			return _accumulatedScale;
		};
		return _createClass(ElementInput, [{
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				this._enabled = value;
			}
		}, {
			key: "app",
			get: function get() {
				return this._app || getApplication();
			},
			set: function set(value) {
				this._app = value;
			}
		}]);
	}();

	Vec2.prototype.scale = Vec2.prototype.mulScalar;
	Vec3.prototype.scale = Vec3.prototype.mulScalar;
	Vec4.prototype.scale = Vec4.prototype.mulScalar;
	var PIXELFORMAT_L8_A8 = PIXELFORMAT_LA8;
	var PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_RGB565;
	var PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_RGBA5551;
	var PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_RGBA4;
	var PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_RGB8;
	var PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_RGBA8;
	var PIXELFORMAT_SRGB = PIXELFORMAT_SRGB8;
	var PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA8;
	var BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT;
	var BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT;
	var BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT;
	var BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT;
	var _viewport = new Vec4();
	function createSphere(device, opts) {
		return Mesh.fromGeometry(device, new SphereGeometry(opts));
	}
	function createPlane(device, opts) {
		return Mesh.fromGeometry(device, new PlaneGeometry(opts));
	}
	function createBox(device, opts) {
		return Mesh.fromGeometry(device, new BoxGeometry(opts));
	}
	function createTorus(device, opts) {
		return Mesh.fromGeometry(device, new TorusGeometry(opts));
	}
	function createCapsule(device, opts) {
		return Mesh.fromGeometry(device, new CapsuleGeometry(opts));
	}
	function createCone(device, opts) {
		return Mesh.fromGeometry(device, new ConeGeometry(opts));
	}
	function createCylinder(device, opts) {
		return Mesh.fromGeometry(device, new CylinderGeometry(opts));
	}
	function createMesh(device, positions, opts) {
		if (opts === void 0) {
			opts = {};
		}
		var geom = new Geometry();
		geom.positions = positions;
		geom.normals = opts.normals;
		geom.tangents = opts.tangents;
		geom.colors = opts.colors;
		geom.uvs = opts.uvs;
		geom.uvs1 = opts.uvs1;
		geom.blendIndices = opts.blendIndices;
		geom.blendWeights = opts.blendWeights;
		geom.indices = opts.indices;
		return Mesh.fromGeometry(device, geom, opts);
	}
	function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
		var viewport;
		if (rect) {
			var w = target ? target.width : device.width;
			var h = target ? target.height : device.height;
			viewport = _viewport.set(rect.x * w, rect.y * h, rect.z * w, rect.w * h);
		}
		drawQuadWithShader(device, target, shader, viewport);
	}
	var deprecatedChunks = {
		'ambientPrefilteredCube.frag': 'ambientEnv.frag',
		'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',
		'dpAtlasQuad.frag': null,
		'genParaboloid.frag': null,
		'prefilterCubemap.frag': null,
		'reflectionDpAtlas.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',
		'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'
	};
	Object.keys(deprecatedChunks).forEach(function (chunkName) {
		Object.defineProperty(shaderChunks, chunkName, {
			get: function get() {
				return null;
			},
			set: function set() {}
		});
	});
	Object.defineProperties(RenderTarget.prototype, {
		_glFrameBuffer: {
			get: function get() {
				return this.impl._glFrameBuffer;
			},
			set: function set(rgbm) {}
		}
	});
	Object.defineProperty(VertexFormat, 'defaultInstancingFormat', {
		get: function get() {
			return null;
		}
	});
	Object.defineProperties(Texture.prototype, {
		rgbm: {
			get: function get() {
				return this.type === TEXTURETYPE_RGBM;
			},
			set: function set(rgbm) {
				this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
			}
		},
		swizzleGGGR: {
			get: function get() {
				return this.type === TEXTURETYPE_SWIZZLEGGGR;
			},
			set: function set(swizzleGGGR) {
				this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
			}
		},
		_glTexture: {
			get: function get() {
				return this.impl._glTexture;
			}
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'boneLimit', {
		get: function get() {
			return 1024;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'webgl2', {
		get: function get() {
			return this.isWebGL2;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'textureFloatHighPrecision', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'extBlendMinmax', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'extTextureHalfFloat', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'extTextureLod', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'textureHalfFloatFilterable', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'supportsMrt', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'supportsVolumeTextures', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'supportsInstancing', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'textureHalfFloatUpdatable', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'extTextureFloat', {
		get: function get() {
			return true;
		}
	});
	Object.defineProperty(GraphicsDevice.prototype, 'extStandardDerivatives', {
		get: function get() {
			return true;
		}
	});
	BlendState.DEFAULT = Object.freeze(new BlendState());
	var _tempBlendState = new BlendState();
	var _tempDepthState = new DepthState();
	GraphicsDevice.prototype.setBlendFunction = function (blendSrc, blendDst) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
		_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrc, blendDst);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setBlendFunctionSeparate = function (blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(currentBlendState.colorOp, blendSrc, blendDst);
		_tempBlendState.setAlphaBlend(currentBlendState.alphaOp, blendSrcAlpha, blendDstAlpha);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setBlendEquation = function (blendEquation) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
		_tempBlendState.setAlphaBlend(blendEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setBlendEquationSeparate = function (blendEquation, blendAlphaEquation) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorBlend(blendEquation, currentBlendState.colorSrcFactor, currentBlendState.colorDstFactor);
		_tempBlendState.setAlphaBlend(blendAlphaEquation, currentBlendState.alphaSrcFactor, currentBlendState.alphaDstFactor);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setColorWrite = function (redWrite, greenWrite, blueWrite, alphaWrite) {
		var currentBlendState = this.blendState;
		_tempBlendState.copy(currentBlendState);
		_tempBlendState.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.getBlending = function () {
		return this.blendState.blend;
	};
	GraphicsDevice.prototype.setBlending = function (blending) {
		_tempBlendState.copy(this.blendState);
		_tempBlendState.blend = blending;
		this.setBlendState(_tempBlendState);
	};
	GraphicsDevice.prototype.setDepthWrite = function (write) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.write = write;
		this.setDepthState(_tempDepthState);
	};
	GraphicsDevice.prototype.setDepthFunc = function (func) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.func = func;
		this.setDepthState(_tempDepthState);
	};
	GraphicsDevice.prototype.setDepthTest = function (test) {
		_tempDepthState.copy(this.depthState);
		_tempDepthState.test = test;
		this.setDepthState(_tempDepthState);
	};
	GraphicsDevice.prototype.getCullMode = function () {
		return this.cullMode;
	};
	var LitOptions = LitShaderOptions;
	Object.defineProperty(Scene.prototype, 'defaultMaterial', {
		get: function get() {
			return getDefaultMaterial(getApplication().graphicsDevice);
		}
	});
	Object.defineProperty(Scene.prototype, 'fogColor', {
		set: function set(value) {
			this.fog.color = value;
		},
		get: function get() {
			return this.fog.color;
		}
	});
	Object.defineProperty(Scene.prototype, 'fogEnd', {
		set: function set(value) {
			this.fog.end = value;
		},
		get: function get() {
			return this.fog.end;
		}
	});
	Object.defineProperty(Scene.prototype, 'fogStart', {
		set: function set(value) {
			this.fog.start = value;
		},
		get: function get() {
			return this.fog.start;
		}
	});
	Object.defineProperty(Scene.prototype, 'fogDensity', {
		set: function set(value) {
			this.fog.density = value;
		},
		get: function get() {
			return this.fog.density;
		}
	});
	Object.defineProperty(Scene.prototype, 'toneMapping', {
		set: function set(value) {},
		get: function get() {
			return undefined;
		}
	});
	Object.defineProperty(Scene.prototype, 'gammaCorrection', {
		set: function set(value) {},
		get: function get() {
			return undefined;
		}
	});
	Object.defineProperty(Scene.prototype, 'rendering', {
		set: function set(value) {},
		get: function get() {
			return undefined;
		}
	});
	Object.defineProperty(LayerComposition.prototype, '_meshInstances', {
		get: function get() {
			return null;
		}
	});
	Object.defineProperty(Scene.prototype, 'drawCalls', {
		get: function get() {
			return null;
		}
	});
	['128', '64', '32', '16', '8', '4'].forEach(function (size, index) {
		Object.defineProperty(Scene.prototype, "skyboxPrefiltered" + size, {
			get: function get() {
				return this._prefilteredCubemaps[index];
			},
			set: function set(value) {
				this._prefilteredCubemaps[index] = value;
				this.updateShaders = true;
			}
		});
	});
	Object.defineProperty(Scene.prototype, 'models', {
		get: function get() {
			if (!this._models) {
				this._models = [];
			}
			return this._models;
		}
	});
	function _removedClassProperty(targetClass, name, comment) {
		Object.defineProperty(targetClass.prototype, name, {
			set: function set(value) {},
			get: function get() {
				return undefined;
			}
		});
	}
	_removedClassProperty(Layer, 'renderTarget');
	_removedClassProperty(Layer, 'onPreCull');
	_removedClassProperty(Layer, 'onPreRender');
	_removedClassProperty(Layer, 'onPreRenderOpaque');
	_removedClassProperty(Layer, 'onPreRenderTransparent');
	_removedClassProperty(Layer, 'onPostCull');
	_removedClassProperty(Layer, 'onPostRender');
	_removedClassProperty(Layer, 'onPostRenderOpaque');
	_removedClassProperty(Layer, 'onPostRenderTransparent');
	_removedClassProperty(Layer, 'onDrawCall');
	_removedClassProperty(Layer, 'layerReference');
	_removedClassProperty(CameraComponent, 'onPreCull');
	_removedClassProperty(CameraComponent, 'onPostCull');
	_removedClassProperty(CameraComponent, 'onPreRender');
	_removedClassProperty(CameraComponent, 'onPostRender');
	_removedClassProperty(CameraComponent, 'onPreRenderLayer');
	_removedClassProperty(CameraComponent, 'onPostRenderLayer');
	ForwardRenderer.prototype.renderComposition = function (comp) {
		getApplication().renderComposition(comp);
	};
	MeshInstance.prototype.syncAabb = function () {};
	Morph.prototype.getTarget = function (index) {
		return this.targets[index];
	};
	GraphNode.prototype.getChildren = function () {
		return this.children;
	};
	GraphNode.prototype.getName = function () {
		return this.name;
	};
	GraphNode.prototype.getPath = function () {
		return this.path;
	};
	GraphNode.prototype.getRoot = function () {
		return this.root;
	};
	GraphNode.prototype.getParent = function () {
		return this.parent;
	};
	GraphNode.prototype.setName = function (name) {
		this.name = name;
	};
	Object.defineProperty(Material.prototype, 'shader', {
		set: function set(value) {},
		get: function get() {
			return null;
		}
	});
	Object.defineProperty(Material.prototype, 'blend', {
		set: function set(value) {
			this.blendState.blend = value;
		},
		get: function get() {
			return this.blendState.blend;
		}
	});
	Object.defineProperty(StandardMaterial.prototype, 'shininess', {
		get: function get() {
			return this.gloss * 100;
		},
		set: function set(value) {
			this.gloss = value * 0.01;
		}
	});
	Object.defineProperty(StandardMaterial.prototype, 'useGammaTonemap', {
		get: function get() {
			return this.useTonemap;
		},
		set: function set(value) {
			this.useTonemap = value;
		}
	});
	function _defineAlias(newName, oldName) {
		Object.defineProperty(StandardMaterial.prototype, oldName, {
			get: function get() {
				return this[newName];
			},
			set: function set(value) {
				this[newName] = value;
			}
		});
	}
	function _deprecateTint(name) {
		Object.defineProperty(StandardMaterial.prototype, name, {
			get: function get() {
				return true;
			},
			set: function set(value) {}
		});
	}
	_deprecateTint('sheenTint');
	_deprecateTint('diffuseTint');
	_deprecateTint('emissiveTint');
	_deprecateTint('ambientTint');
	_defineAlias('specularTint', 'specularMapTint');
	_defineAlias('aoVertexColor', 'aoMapVertexColor');
	_defineAlias('diffuseVertexColor', 'diffuseMapVertexColor');
	_defineAlias('specularVertexColor', 'specularMapVertexColor');
	_defineAlias('emissiveVertexColor', 'emissiveMapVertexColor');
	_defineAlias('metalnessVertexColor', 'metalnessMapVertexColor');
	_defineAlias('glossVertexColor', 'glossMapVertexColor');
	_defineAlias('opacityVertexColor', 'opacityMapVertexColor');
	_defineAlias('lightVertexColor', 'lightMapVertexColor');
	_defineAlias('sheenGloss', 'sheenGlossiess');
	_defineAlias('clearCoatGloss', 'clearCostGlossiness');
	function _defineOption(name, newName) {
		if (name !== 'pass') {
			Object.defineProperty(StandardMaterialOptions.prototype, name, {
				get: function get() {
					return this.litOptions[newName || name];
				},
				set: function set(value) {
					this.litOptions[newName || name] = value;
				}
			});
		}
	}
	_defineOption('refraction', 'useRefraction');
	var tempOptions = new LitShaderOptions();
	var litOptionProperties = Object.getOwnPropertyNames(tempOptions);
	for (var litOption in litOptionProperties) {
		_defineOption(litOptionProperties[litOption]);
	}
	AssetRegistry.prototype.getAssetById = function (id) {
		return this.get(id);
	};
	Object.defineProperty(XrInputSource.prototype, 'ray', {
		get: function get() {
			return this._rayLocal;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'position', {
		get: function get() {
			return this._localPosition;
		}
	});
	Object.defineProperty(XrInputSource.prototype, 'rotation', {
		get: function get() {
			return this._localRotation;
		}
	});
	Object.defineProperty(ElementInput.prototype, 'wheel', {
		get: function get() {
			return this.wheelDelta * -2;
		}
	});
	Object.defineProperty(MouseEvent.prototype, 'wheel', {
		get: function get() {
			return this.wheelDelta * -2;
		}
	});
	var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
	var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	AppBase.prototype.isFullscreen = function () {
		return !!document.fullscreenElement;
	};
	AppBase.prototype.enableFullscreen = function (element, success, error) {
		element = element || this.graphicsDevice.canvas;
		var _s = function s() {
			success();
			document.removeEventListener('fullscreenchange', _s);
		};
		var _e = function e() {
			error();
			document.removeEventListener('fullscreenerror', _e);
		};
		if (success) {
			document.addEventListener('fullscreenchange', _s, false);
		}
		if (error) {
			document.addEventListener('fullscreenerror', _e, false);
		}
		if (element.requestFullscreen) {
			element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
		} else {
			error();
		}
	};
	AppBase.prototype.disableFullscreen = function (success) {
		var _s2 = function s() {
			success();
			document.removeEventListener('fullscreenchange', _s2);
		};
		if (success) {
			document.addEventListener('fullscreenchange', _s2, false);
		}
		document.exitFullscreen();
	};
	AppBase.prototype.getSceneUrl = function (name) {
		var entry = this.scenes.find(name);
		if (entry) {
			return entry.url;
		}
		return null;
	};
	AppBase.prototype.loadScene = function (url, callback) {
		this.scenes.loadScene(url, callback);
	};
	AppBase.prototype.loadSceneHierarchy = function (url, callback) {
		this.scenes.loadSceneHierarchy(url, callback);
	};
	AppBase.prototype.loadSceneSettings = function (url, callback) {
		this.scenes.loadSceneSettings(url, callback);
	};
	ModelComponent.prototype.setVisible = function (visible) {
		this.enabled = visible;
	};
	Object.defineProperty(RigidBodyComponent.prototype, 'bodyType', {
		get: function get() {
			return this.type;
		},
		set: function set(type) {
			this.type = type;
		}
	});
	RigidBodyComponent.prototype.syncBodyToEntity = function () {
		this._updateDynamic();
	};
	RigidBodyComponentSystem.prototype.setGravity = function () {
		if (arguments.length === 1) {
			this.gravity.copy(arguments[0]);
		} else {
			this.gravity.set(arguments[0], arguments[1], arguments[2]);
		}
	};

	var CpuTimer = function () {
		function CpuTimer(app) {
			this._frameIndex = 0;
			this._frameTimings = [];
			this._timings = [];
			this._prevTimings = [];
			this.unitsName = 'ms';
			this.decimalPlaces = 1;
			this.enabled = true;
			app.on('frameupdate', this.begin.bind(this, 'update'));
			app.on('framerender', this.mark.bind(this, 'render'));
			app.on('frameend', this.mark.bind(this, 'other'));
		}
		var _proto = CpuTimer.prototype;
		_proto.begin = function begin(name) {
			if (!this.enabled) {
				return;
			}
			if (this._frameIndex < this._frameTimings.length) {
				this._frameTimings.splice(this._frameIndex);
			}
			var tmp = this._prevTimings;
			this._prevTimings = this._timings;
			this._timings = this._frameTimings;
			this._frameTimings = tmp;
			this._frameIndex = 0;
			this.mark(name);
		};
		_proto.mark = function mark(name) {
			if (!this.enabled) {
				return;
			}
			var timestamp = now();
			if (this._frameIndex > 0) {
				var prev = this._frameTimings[this._frameIndex - 1];
				prev[1] = timestamp - prev[1];
			} else if (this._timings.length > 0) {
				var _prev = this._timings[this._timings.length - 1];
				_prev[1] = timestamp - _prev[1];
			}
			if (this._frameIndex >= this._frameTimings.length) {
				this._frameTimings.push([name, timestamp]);
			} else {
				var timing = this._frameTimings[this._frameIndex];
				timing[0] = name;
				timing[1] = timestamp;
			}
			this._frameIndex++;
		};
		return _createClass(CpuTimer, [{
			key: "timings",
			get: function get() {
				return this._timings.slice(0, -1).map(function (v) {
					return v[1];
				});
			}
		}]);
	}();

	var GpuTimer = function () {
		function GpuTimer(device) {
			this.device = device;
			device.gpuProfiler.enabled = true;
			this.enabled = true;
			this.unitsName = 'ms';
			this.decimalPlaces = 1;
			this._timings = [];
		}
		return _createClass(GpuTimer, [{
			key: "timings",
			get: function get() {
				this._timings[0] = this.device.gpuProfiler._frameTime;
				return this._timings;
			}
		}]);
	}();

	var StatsTimer = function () {
		function StatsTimer(app, statNames, decimalPlaces, unitsName, multiplier) {
			var _this = this;
			this.app = app;
			this.values = [];
			this.statNames = statNames;
			if (this.statNames.length > 3) {
				this.statNames.length = 3;
			}
			this.unitsName = unitsName;
			this.decimalPlaces = decimalPlaces;
			this.multiplier = multiplier || 1;
			var resolve = function resolve(path, obj) {
				return path.split('.').reduce(function (prev, curr) {
					return prev ? prev[curr] : null;
				}, obj || _this);
			};
			app.on('frameupdate', function (ms) {
				for (var i = 0; i < _this.statNames.length; i++) {
					_this.values[i] = resolve(_this.statNames[i], _this.app.stats) * _this.multiplier;
				}
			});
		}
		return _createClass(StatsTimer, [{
			key: "timings",
			get: function get() {
				return this.values;
			}
		}]);
	}();

	var Graph = function () {
		function Graph(name, app, watermark, textRefreshRate, timer) {
			this.app = app;
			this.name = name;
			this.device = app.graphicsDevice;
			this.timer = timer;
			this.watermark = watermark;
			this.enabled = false;
			this.textRefreshRate = textRefreshRate;
			this.avgTotal = 0;
			this.avgTimer = 0;
			this.avgCount = 0;
			this.timingText = '';
			this.texture = null;
			this.yOffset = 0;
			this.cursor = 0;
			this.sample = new Uint8ClampedArray(4);
			this.sample.set([0, 0, 0, 255]);
			this.counter = 0;
			this.app.on('frameupdate', this.update, this);
		}
		var _proto = Graph.prototype;
		_proto.destroy = function destroy() {
			this.app.off('frameupdate', this.update, this);
		};
		_proto.loseContext = function loseContext() {
			if (this.timer && typeof this.timer.loseContext === 'function') {
				this.timer.loseContext();
			}
		};
		_proto.update = function update(ms) {
			var timings = this.timer.timings;
			var total = timings.reduce(function (a, v) {
				return a + v;
			}, 0);
			this.avgTotal += total;
			this.avgTimer += ms;
			this.avgCount++;
			if (this.avgTimer > this.textRefreshRate) {
				this.timingText = (this.avgTotal / this.avgCount).toFixed(this.timer.decimalPlaces);
				this.avgTimer = 0;
				this.avgTotal = 0;
				this.avgCount = 0;
			}
			if (this.enabled) {
				var value = 0;
				var range = 1.5 * this.watermark;
				for (var i = 0; i < timings.length; ++i) {
					value += Math.floor(timings[i] / range * 255);
					this.sample[i] = value;
				}
				this.sample[3] = this.watermark / range * 255;
				var data = this.texture.lock();
				data.set(this.sample, (this.cursor + this.yOffset * this.texture.width) * 4);
				this.texture.unlock();
				this.cursor++;
				if (this.cursor === this.texture.width) {
					this.cursor = 0;
				}
			}
		};
		_proto.render = function render(render2d, x, y, w, h) {
			render2d.quad(x + w, y, -w, h, this.enabled ? this.cursor : 0, this.enabled ? 0.5 + this.yOffset : this.texture.height - 1, -w, 0, this.texture, 0);
		};
		return Graph;
	}();

	var WordAtlas = function () {
		function WordAtlas(device, words) {
			var initContext = function initContext(context) {
				context.font = '10px "Lucida Console", Monaco, monospace';
				context.textAlign = 'left';
				context.textBaseline = 'alphabetic';
			};
			var isNumber = function isNumber(word) {
				return word === '.' || word.length === 1 && word.charCodeAt(0) >= 48 && word.charCodeAt(0) <= 57;
			};
			var canvas = document.createElement('canvas');
			var context = canvas.getContext('2d', {
				alpha: true
			});
			initContext(context);
			var placements = new Map();
			var padding = 5;
			var width = 512;
			var x = padding;
			var y = padding;
			words.forEach(function (word) {
				var measurement = context.measureText(word);
				var l = Math.ceil(-measurement.actualBoundingBoxLeft);
				var r = Math.ceil(measurement.actualBoundingBoxRight);
				var a = Math.ceil(measurement.actualBoundingBoxAscent);
				var d = Math.ceil(measurement.actualBoundingBoxDescent);
				var w = l + r;
				var h = a + d;
				if (x + w + padding >= width) {
					x = padding;
					y += 16;
				}
				placements.set(word, {
					l: l,
					r: r,
					a: a,
					d: d,
					w: w,
					h: h,
					x: x,
					y: y
				});
				x += w + padding;
			});
			canvas.width = 512;
			canvas.height = math.nextPowerOfTwo(y + 16 + padding);
			initContext(context);
			context.fillStyle = 'rgb(0, 0, 0)';
			context.fillRect(0, 0, canvas.width, canvas.height);
			placements.forEach(function (m, word) {
				context.fillStyle = isNumber(word) ? 'rgb(255, 255, 255)' : 'rgb(170, 170, 170)';
				context.fillText(word, m.x - m.l, m.y + m.a);
			});
			this.placements = placements;
			var data = context.getImageData(0, 0, canvas.width, canvas.height).data;
			for (var i = 0; i < data.length; i += 4) {
				data[i + 3] = data[i + 0];
				data[i + 0] = 255;
				data[i + 1] = 255;
				data[i + 2] = 255;
			}
			this.texture = new Texture(device, {
				name: 'mini-stats-word-atlas',
				width: canvas.width,
				height: canvas.height,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				levels: [data]
			});
		}
		var _proto = WordAtlas.prototype;
		_proto.destroy = function destroy() {
			this.texture.destroy();
			this.texture = null;
		};
		_proto.render = function render(render2d, word, x, y) {
			var p = this.placements.get(word);
			if (p) {
				var padding = 1;
				render2d.quad(x + p.l - padding, y - p.d + padding, p.w + padding * 2, p.h + padding * 2, p.x - padding, this.texture.height - p.y - p.h - padding, undefined, undefined, this.texture, 1);
				return p.w;
			}
			return 0;
		};
		return WordAtlas;
	}();

	var vertexShader = "\nattribute vec3 vertex_position;\nattribute vec4 vertex_texCoord0;\nvarying vec4 uv0;\nvarying float wordFlag;\nvoid main(void) {\n\tgl_Position = vec4(vertex_position.xy * 2.0 - 1.0, 0.5, 1.0);\n\tuv0 = vertex_texCoord0;\n\twordFlag = vertex_position.z;\n}";
	var fragmentShader$1 = "\nvarying vec4 uv0;\nvarying float wordFlag;\nuniform vec4 clr;\nuniform sampler2D graphTex;\nuniform sampler2D wordsTex;\nvoid main (void) {\n\tvec4 graphSample = texture2D(graphTex, uv0.xy);\n\tvec4 graph;\n\tif (uv0.w < graphSample.r)\n\t\tgraph = vec4(0.7, 0.2, 0.2, 1.0);\n\telse if (uv0.w < graphSample.g)\n\t\tgraph = vec4(0.2, 0.7, 0.2, 1.0);\n\telse if (uv0.w < graphSample.b)\n\t\tgraph = vec4(0.2, 0.2, 0.7, 1.0);\n\telse\n\t\tgraph = vec4(0.0, 0.0, 0.0, 1.0 - 0.25 * sin(uv0.w * 3.14159));\n\tvec4 words = texture2D(wordsTex, vec2(uv0.x, 1.0 - uv0.y));\n\tgl_FragColor = mix(graph, words, wordFlag) * clr;\n}";
	var Render2d = function () {
		function Render2d(device, maxQuads) {
			if (maxQuads === void 0) {
				maxQuads = 512;
			}
			var format = new VertexFormat(device, [{
				semantic: SEMANTIC_POSITION,
				components: 3,
				type: TYPE_FLOAT32
			}, {
				semantic: SEMANTIC_TEXCOORD0,
				components: 4,
				type: TYPE_FLOAT32
			}]);
			var indices = new Uint16Array(maxQuads * 6);
			for (var i = 0; i < maxQuads; ++i) {
				indices[i * 6 + 0] = i * 4;
				indices[i * 6 + 1] = i * 4 + 1;
				indices[i * 6 + 2] = i * 4 + 2;
				indices[i * 6 + 3] = i * 4;
				indices[i * 6 + 4] = i * 4 + 2;
				indices[i * 6 + 5] = i * 4 + 3;
			}
			this.device = device;
			this.buffer = new VertexBuffer(device, format, maxQuads * 4, {
				usage: BUFFER_STREAM
			});
			this.data = new Float32Array(this.buffer.numBytes / 4);
			this.indexBuffer = new IndexBuffer(device, INDEXFORMAT_UINT16, maxQuads * 6, BUFFER_STATIC, indices);
			this.prim = {
				type: PRIMITIVE_TRIANGLES,
				indexed: true,
				base: 0,
				count: 0
			};
			this.quads = 0;
			this.mesh = new Mesh(device);
			this.mesh.vertexBuffer = this.buffer;
			this.mesh.indexBuffer[0] = this.indexBuffer;
			this.mesh.primitive = [this.prim];
			var material = new ShaderMaterial({
				uniqueName: 'MiniStats',
				vertexCode: vertexShader,
				fragmentCode: fragmentShader$1
			});
			this.material = material;
			material.cull = CULLFACE_NONE;
			material.depthState = DepthState.NODEPTH;
			material.blendState = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
			material.update();
			this.meshInstance = new MeshInstance(this.mesh, material, new GraphNode('MiniStatsMesh'));
			this.uniforms = {
				clr: new Float32Array(4)
			};
			this.targetSize = {
				width: device.width,
				height: device.height
			};
		}
		var _proto = Render2d.prototype;
		_proto.quad = function quad(x, y, w, h, u, v, uw, uh, texture, wordFlag) {
			if (wordFlag === void 0) {
				wordFlag = 0;
			}
			var rw = this.targetSize.width;
			var rh = this.targetSize.height;
			var x0 = x / rw;
			var y0 = y / rh;
			var x1 = (x + w) / rw;
			var y1 = (y + h) / rh;
			var tw = texture.width;
			var th = texture.height;
			var u0 = u / tw;
			var v0 = v / th;
			var u1 = (u + (uw != null ? uw : w)) / tw;
			var v1 = (v + (uh != null ? uh : h)) / th;
			this.data.set([x0, y0, wordFlag, u0, v0, 0, 0, x1, y0, wordFlag, u1, v0, 1, 0, x1, y1, wordFlag, u1, v1, 1, 1, x0, y1, wordFlag, u0, v1, 0, 1], 4 * 7 * this.quads);
			this.quads++;
			this.prim.count += 6;
		};
		_proto.startFrame = function startFrame() {
			this.quads = 0;
			this.prim.count = 0;
			this.targetSize.width = this.device.canvas.scrollWidth;
			this.targetSize.height = this.device.canvas.scrollHeight;
		};
		_proto.render = function render(app, layer, graphTexture, wordsTexture, clr, height) {
			this.buffer.setData(this.data.buffer);
			this.uniforms.clr.set(clr, 0);
			this.material.setParameter('clr', this.uniforms.clr);
			this.material.setParameter('graphTex', graphTexture);
			this.material.setParameter('wordsTex', wordsTexture);
			app.drawMeshInstance(this.meshInstance, layer);
		};
		return Render2d;
	}();

	var MiniStats = function () {
		function MiniStats(app, options) {
			var _this = this;
			var device = app.graphicsDevice;
			options = options || MiniStats.getDefaultOptions();
			this.initGraphs(app, device, options);
			var words = new Set(['', 'ms', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.'].concat(this.graphs.map(function (graph) {
				return graph.name;
			})).concat(options.stats ? options.stats.map(function (stat) {
				return stat.unitsName;
			}) : []).filter(function (item) {
				return !!item;
			}));
			this.wordAtlas = new WordAtlas(device, words);
			this.sizes = options.sizes;
			this._activeSizeIndex = options.startSizeIndex;
			var div = document.createElement('div');
			div.setAttribute('id', 'mini-stats');
			div.style.cssText = 'position:fixed;bottom:0;left:0;background:transparent;';
			document.body.appendChild(div);
			div.addEventListener('mouseenter', function (event) {
				_this.opacity = 1.0;
			});
			div.addEventListener('mouseleave', function (event) {
				_this.opacity = 0.7;
			});
			div.addEventListener('click', function (event) {
				event.preventDefault();
				if (_this._enabled) {
					_this.activeSizeIndex = (_this.activeSizeIndex + 1) % _this.sizes.length;
					_this.resize(_this.sizes[_this.activeSizeIndex].width, _this.sizes[_this.activeSizeIndex].height, _this.sizes[_this.activeSizeIndex].graphs);
				}
			});
			device.on('resizecanvas', this.updateDiv, this);
			device.on('losecontext', this.loseContext, this);
			app.on('postrender', this.postRender, this);
			this.app = app;
			this.drawLayer = app.scene.layers.getLayerById(LAYERID_UI);
			this.device = device;
			this.render2d = new Render2d(device);
			this.div = div;
			this.width = 0;
			this.height = 0;
			this.gspacing = 2;
			this.clr = [1, 1, 1, 0.5];
			this._enabled = true;
			this.activeSizeIndex = this._activeSizeIndex;
		}
		var _proto = MiniStats.prototype;
		_proto.destroy = function destroy() {
			this.device.off('resizecanvas', this.updateDiv, this);
			this.device.off('losecontext', this.loseContext, this);
			this.app.off('postrender', this.postRender, this);
			this.graphs.forEach(function (graph) {
				return graph.destroy();
			});
			this.wordAtlas.destroy();
			this.texture.destroy();
		};
		MiniStats.getDefaultOptions = function getDefaultOptions() {
			return {
				sizes: [{
					width: 100,
					height: 16,
					spacing: 0,
					graphs: false
				}, {
					width: 128,
					height: 32,
					spacing: 2,
					graphs: true
				}, {
					width: 256,
					height: 64,
					spacing: 2,
					graphs: true
				}],
				startSizeIndex: 0,
				textRefreshRate: 500,
				cpu: {
					enabled: true,
					watermark: 33
				},
				gpu: {
					enabled: true,
					watermark: 33
				},
				stats: [{
					name: 'Frame',
					stats: ['frame.ms'],
					decimalPlaces: 1,
					unitsName: 'ms',
					watermark: 33
				}, {
					name: 'DrawCalls',
					stats: ['drawCalls.total'],
					watermark: 1000
				}]
			};
		};
		_proto.initGraphs = function initGraphs(app, device, options) {
			var _this2 = this;
			this.graphs = [];
			if (options.cpu.enabled) {
				var timer = new CpuTimer(app);
				var graph = new Graph('CPU', app, options.cpu.watermark, options.textRefreshRate, timer);
				this.graphs.push(graph);
			}
			if (options.gpu.enabled) {
				var _timer = new GpuTimer(device);
				var _graph = new Graph('GPU', app, options.gpu.watermark, options.textRefreshRate, _timer);
				this.graphs.push(_graph);
			}
			if (options.stats) {
				options.stats.forEach(function (entry) {
					var timer = new StatsTimer(app, entry.stats, entry.decimalPlaces, entry.unitsName, entry.multiplier);
					var graph = new Graph(entry.name, app, entry.watermark, options.textRefreshRate, timer);
					_this2.graphs.push(graph);
				});
			}
			var maxWidth = options.sizes.reduce(function (max, v) {
				return v.width > max ? v.width : max;
			}, 0);
			this.texture = new Texture(device, {
				name: 'mini-stats-graph-texture',
				width: math.nextPowerOfTwo(maxWidth),
				height: math.nextPowerOfTwo(this.graphs.length),
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_REPEAT,
				addressV: ADDRESS_REPEAT
			});
			this.graphs.forEach(function (graph, i) {
				graph.texture = _this2.texture;
				graph.yOffset = i;
			});
		};
		_proto.render = function render() {
			var graphs = this.graphs;
			var wordAtlas = this.wordAtlas;
			var render2d = this.render2d;
			var width = this.width;
			var height = this.height;
			var gspacing = this.gspacing;
			render2d.startFrame();
			for (var i = 0; i < graphs.length; ++i) {
				var graph = graphs[i];
				var y = i * (height + gspacing);
				graph.render(render2d, 0, y, width, height);
				var x = 1;
				y += height - 13;
				x += wordAtlas.render(render2d, graph.name, x, y) + 10;
				var timingText = graph.timingText;
				for (var j = 0; j < timingText.length; ++j) {
					x += wordAtlas.render(render2d, timingText[j], x, y);
				}
				if (graph.timer.unitsName) {
					x += 3;
					wordAtlas.render(render2d, graph.timer.unitsName, x, y);
				}
			}
			render2d.render(this.app, this.drawLayer, this.texture, this.wordAtlas.texture, this.clr, height);
		};
		_proto.resize = function resize(width, height, showGraphs) {
			var graphs = this.graphs;
			for (var i = 0; i < graphs.length; ++i) {
				graphs[i].enabled = showGraphs;
			}
			this.width = width;
			this.height = height;
			this.updateDiv();
		};
		_proto.updateDiv = function updateDiv() {
			var rect = this.device.canvas.getBoundingClientRect();
			this.div.style.left = rect.left + "px";
			this.div.style.bottom = window.innerHeight - rect.bottom + "px";
			this.div.style.width = this.width + "px";
			this.div.style.height = this.overallHeight + "px";
		};
		_proto.loseContext = function loseContext() {
			this.graphs.forEach(function (graph) {
				return graph.loseContext();
			});
		};
		_proto.postRender = function postRender() {
			if (this._enabled) {
				this.render();
			}
		};
		return _createClass(MiniStats, [{
			key: "activeSizeIndex",
			get: function get() {
				return this._activeSizeIndex;
			},
			set: function set(value) {
				this._activeSizeIndex = value;
				this.gspacing = this.sizes[value].spacing;
				this.resize(this.sizes[value].width, this.sizes[value].height, this.sizes[value].graphs);
			}
		}, {
			key: "opacity",
			get: function get() {
				return this.clr[3];
			},
			set: function set(value) {
				this.clr[3] = value;
			}
		}, {
			key: "overallHeight",
			get: function get() {
				var graphs = this.graphs;
				var spacing = this.gspacing;
				return this.height * graphs.length + spacing * (graphs.length - 1);
			}
		}, {
			key: "enabled",
			get: function get() {
				return this._enabled;
			},
			set: function set(value) {
				if (value !== this._enabled) {
					this._enabled = value;
					for (var i = 0; i < this.graphs.length; ++i) {
						this.graphs[i].enabled = value;
						this.graphs[i].timer.enabled = value;
					}
				}
			}
		}]);
	}();

	var shaderOutlineExtendPS = "\n\tvarying vec2 vUv0;\n\tuniform vec2 uOffset;\n\tuniform float uSrcMultiplier;\n\tuniform sampler2D source;\n\tvoid main(void)\n\t{\n\t\tvec4 pixel;\n\t\tvec4 texel = texture2D(source, vUv0);\n\t\tvec4 firstTexel = texel;\n\t\tfloat diff = texel.a * uSrcMultiplier;\n\t\tpixel = texture2D(source, vUv0 + uOffset * -2.0);\n\t\ttexel = max(texel, pixel);\n\t\tdiff = max(diff, length(firstTexel.rgb - pixel.rgb));\n\t\tpixel = texture2D(source, vUv0 + uOffset * -1.0);\n\t\ttexel = max(texel, pixel);\n\t\tdiff = max(diff, length(firstTexel.rgb - pixel.rgb));\n\t\tpixel = texture2D(source, vUv0 + uOffset * 1.0);\n\t\ttexel = max(texel, pixel);\n\t\tdiff = max(diff, length(firstTexel.rgb - pixel.rgb));\n\t\tpixel = texture2D(source, vUv0 + uOffset * 2.0);\n\t\ttexel = max(texel, pixel);\n\t\tdiff = max(diff, length(firstTexel.rgb - pixel.rgb));\n\t   gl_FragColor = vec4(texel.rgb, min(diff, 1.0));\n\t}\n";
	var _tempFloatArray = new Float32Array(2);
	var _tempColor = new Color();
	var OutlineRenderer = function () {
		function OutlineRenderer(app, renderingLayer, priority) {
			var _this = this;
			if (priority === void 0) {
				priority = -1;
			}
			this.app = app;
			this.renderingLayer = renderingLayer != null ? renderingLayer : app.scene.layers.getLayerByName('Immediate');
			this.rt = this.createRenderTarget('OutlineTexture', 1, 1, true);
			this.outlineCameraEntity = new Entity('OutlineCamera');
			this.outlineCameraEntity.addComponent('camera', {
				layers: [this.renderingLayer.id],
				priority: priority,
				clearColor: new Color(0, 0, 0, 0),
				renderTarget: this.rt
			});
			this.outlineShaderPass = this.outlineCameraEntity.camera.setShaderPass('OutlineShaderPass');
			app.scene.on('postrender', function (cameraComponent) {
				if (_this.outlineCameraEntity.camera === cameraComponent) {
					_this.onPostRender();
				}
			});
			this.app.root.addChild(this.outlineCameraEntity);
			this.tempRt = this.createRenderTarget('OutlineTempTexture', 1, 1, false);
			this.blendState = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA);
			var device = this.app.graphicsDevice;
			this.shaderExtend = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderOutlineExtendPS, 'OutlineExtendShader');
			this.shaderBlend = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.outputTex2DPS, 'OutlineBlendShader');
			this.quadRenderer = new QuadRender(this.shaderBlend);
			this.whiteTex = new Texture(device, {
				name: 'OutlineWhiteTexture',
				width: 1,
				height: 1,
				format: PIXELFORMAT_SRGBA8,
				mipmaps: false
			});
			var pixels = this.whiteTex.lock();
			pixels.set(new Uint8Array([255, 255, 255, 255]));
			this.whiteTex.unlock();
		}
		var _proto = OutlineRenderer.prototype;
		_proto.destroy = function destroy() {
			var _this$quadRenderer;
			this.whiteTex.destroy();
			this.whiteTex = null;
			this.outlineCameraEntity.destroy();
			this.outlineCameraEntity = null;
			this.rt.destroyTextureBuffers();
			this.rt.destroy();
			this.rt = null;
			this.tempRt.destroyTextureBuffers();
			this.tempRt.destroy();
			this.tempRt = null;
			(_this$quadRenderer = this.quadRenderer) == null || _this$quadRenderer.destroy();
			this.quadRenderer = null;
		};
		_proto.getMeshInstances = function getMeshInstances(entity, recursive) {
			var meshInstances = [];
			var renders = recursive ? entity.findComponents('render') : entity.render ? [entity.render] : [];
			renders.forEach(function (render) {
				if (render.entity.enabled && render.enabled) {
					meshInstances.push.apply(meshInstances, render.meshInstances);
				}
			});
			var models = recursive ? entity.findComponents('model') : entity.model ? [entity.model] : [];
			models.forEach(function (model) {
				if (model.entity.enabled && model.enabled) {
					meshInstances.push.apply(meshInstances, model.meshInstances);
				}
			});
			return meshInstances;
		};
		_proto.addEntity = function addEntity(entity, color, recursive) {
			var _this2 = this;
			if (recursive === void 0) {
				recursive = true;
			}
			var meshInstances = this.getMeshInstances(entity, recursive);
			meshInstances.forEach(function (meshInstance) {
				if (meshInstance.material instanceof StandardMaterial) {
					var outlineShaderPass = _this2.outlineShaderPass;
					meshInstance.material.onUpdateShader = function (options) {
						if (options.pass === outlineShaderPass) {
							var opts = new StandardMaterialOptions();
							opts.opacityMap = options.opacityMap;
							opts.opacityMapUv = options.opacityMapUv;
							opts.opacityMapChannel = options.opacityMapChannel;
							opts.opacityMapTransform = options.opacityMapTransform;
							opts.opacityVertexColor = options.opacityVertexColor;
							opts.opacityVertexColorChannel = options.opacityVertexColorChannel;
							opts.litOptions.vertexColors = options.litOptions.vertexColors;
							opts.litOptions.alphaTest = options.litOptions.alphaTest;
							opts.litOptions.skin = options.litOptions.skin;
							return opts;
						}
						return options;
					};
					_tempColor.linear(color);
					var colArray = new Float32Array([_tempColor.r, _tempColor.g, _tempColor.b]);
					meshInstance.setParameter('material_emissive', colArray, 1 << _this2.outlineShaderPass);
					meshInstance.setParameter('texture_emissiveMap', _this2.whiteTex, 1 << _this2.outlineShaderPass);
				}
			});
			this.renderingLayer.addMeshInstances(meshInstances, true);
		};
		_proto.removeEntity = function removeEntity(entity, recursive) {
			if (recursive === void 0) {
				recursive = true;
			}
			var meshInstances = this.getMeshInstances(entity, recursive);
			this.renderingLayer.removeMeshInstances(meshInstances);
			meshInstances.forEach(function (meshInstance) {
				if (meshInstance.material instanceof StandardMaterial) {
					meshInstance.material.onUpdateShader = null;
					meshInstance.deleteParameter('material_emissive');
				}
			});
		};
		_proto.removeAllEntities = function removeAllEntities() {
			this.renderingLayer.clearMeshInstances();
		};
		_proto.blendOutlines = function blendOutlines() {
			var device = this.app.graphicsDevice;
			device.scope.resolve('source').setValue(this.rt.colorBuffer);
			device.setDepthState(DepthState.NODEPTH);
			device.setCullMode(CULLFACE_NONE);
			device.setBlendState(this.blendState);
			this.quadRenderer.render();
		};
		_proto.onPostRender = function onPostRender() {
			var device = this.app.graphicsDevice;
			var uOffset = device.scope.resolve('uOffset');
			var uColorBuffer = device.scope.resolve('source');
			var uSrcMultiplier = device.scope.resolve('uSrcMultiplier');
			var rt = this.rt,
				tempRt = this.tempRt,
				shaderExtend = this.shaderExtend;
			var width = rt.width,
				height = rt.height;
			_tempFloatArray[0] = 1.0 / width / 2.0;
			_tempFloatArray[1] = 0;
			uOffset.setValue(_tempFloatArray);
			uColorBuffer.setValue(rt.colorBuffer);
			uSrcMultiplier.setValue(0.0);
			drawQuadWithShader(device, tempRt, shaderExtend);
			_tempFloatArray[0] = 0;
			_tempFloatArray[1] = 1.0 / height / 2.0;
			uOffset.setValue(_tempFloatArray);
			uColorBuffer.setValue(tempRt.colorBuffer);
			uSrcMultiplier.setValue(1.0);
			drawQuadWithShader(device, rt, shaderExtend);
		};
		_proto.createRenderTarget = function createRenderTarget(name, width, height, depth) {
			var texture = new Texture(this.app.graphicsDevice, {
				name: name,
				width: width,
				height: height,
				format: PIXELFORMAT_SRGBA8,
				mipmaps: false,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE,
				minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
				magFilter: FILTER_LINEAR
			});
			return new RenderTarget({
				colorBuffer: texture,
				depth: depth,
				flipY: this.app.graphicsDevice.isWebGPU
			});
		};
		_proto.updateRenderTarget = function updateRenderTarget(sceneCamera) {
			var _sceneCamera$renderTa, _sceneCamera$renderTa2, _sceneCamera$renderTa3, _sceneCamera$renderTa4;
			var width = (_sceneCamera$renderTa = (_sceneCamera$renderTa2 = sceneCamera.renderTarget) == null ? void 0 : _sceneCamera$renderTa2.width) != null ? _sceneCamera$renderTa : this.app.graphicsDevice.width;
			var height = (_sceneCamera$renderTa3 = (_sceneCamera$renderTa4 = sceneCamera.renderTarget) == null ? void 0 : _sceneCamera$renderTa4.height) != null ? _sceneCamera$renderTa3 : this.app.graphicsDevice.height;
			var outlineCamera = this.outlineCameraEntity.camera;
			if (!outlineCamera.renderTarget || outlineCamera.renderTarget.width !== width || outlineCamera.renderTarget.height !== height) {
				this.rt.resize(width, height);
				this.tempRt.resize(width, height);
			}
		};
		_proto.frameUpdate = function frameUpdate(sceneCameraEntity, blendLayer, blendLayerTransparent) {
			var _this3 = this;
			var sceneCamera = sceneCameraEntity.camera;
			this.updateRenderTarget(sceneCamera);
			var evt = this.app.scene.on('prerender:layer', function (cameraComponent, layer, transparent) {
				if (sceneCamera === cameraComponent && transparent === blendLayerTransparent && layer === blendLayer) {
					_this3.blendOutlines();
					evt.off();
				}
			});
			this.outlineCameraEntity.setLocalPosition(sceneCameraEntity.getPosition());
			this.outlineCameraEntity.setLocalRotation(sceneCameraEntity.getRotation());
			var outlineCamera = this.outlineCameraEntity.camera;
			outlineCamera.projection = sceneCamera.projection;
			outlineCamera.horizontalFov = sceneCamera.horizontalFov;
			outlineCamera.fov = sceneCamera.fov;
			outlineCamera.orthoHeight = sceneCamera.orthoHeight;
			outlineCamera.nearClip = sceneCamera.nearClip;
			outlineCamera.farClip = sceneCamera.farClip;
		};
		return OutlineRenderer;
	}();

	var textureBlitVertexShader = "\n\tattribute vec2 vertex_position;\n\tvarying vec2 uv0;\n\tvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t}";
	var textureBlitFragmentShader = "\n\tvarying vec2 uv0;\n\tuniform sampler2D blitTexture;\n\tvoid main(void) {\n\t\tgl_FragColor = texture2D(blitTexture, uv0);\n\t}";
	var CoreExporter = function () {
		function CoreExporter() {}
		var _proto = CoreExporter.prototype;
		_proto.textureToCanvas = function textureToCanvas(texture, options) {
			if (options === void 0) {
				options = {};
			}
			var image = texture.getSource();
			if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
				var _this$calcTextureSize = this.calcTextureSize(image.width, image.height, options.maxTextureSize),
					_width = _this$calcTextureSize.width,
					_height = _this$calcTextureSize.height;
				var canvas = document.createElement('canvas');
				canvas.width = _width;
				canvas.height = _height;
				var context = canvas.getContext('2d');
				if (context === null) {
					return Promise.resolve(undefined);
				}
				context.drawImage(image, 0, 0, canvas.width, canvas.height);
				if (options.color) {
					var _options$color = options.color,
						r = _options$color.r,
						g = _options$color.g,
						b = _options$color.b;
					var imagedata = context.getImageData(0, 0, _width, _height);
					var data = imagedata.data;
					for (var i = 0; i < data.length; i += 4) {
						data[i + 0] = data[i + 0] * r;
						data[i + 1] = data[i + 1] * g;
						data[i + 2] = data[i + 2] * b;
					}
					context.putImageData(imagedata, 0, 0);
				}
				return Promise.resolve(canvas);
			}
			var device = texture.device;
			var _this$calcTextureSize2 = this.calcTextureSize(texture.width, texture.height, options.maxTextureSize),
				width = _this$calcTextureSize2.width,
				height = _this$calcTextureSize2.height;
			var format = isCompressedPixelFormat(texture.format) ? PIXELFORMAT_RGBA8 : texture.format;
			var dstTexture = new Texture(device, {
				name: 'ExtractedTexture',
				width: width,
				height: height,
				format: format,
				cubemap: false,
				mipmaps: false,
				minFilter: FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			var renderTarget = new RenderTarget({
				colorBuffer: dstTexture,
				depth: false
			});
			var shader = createShaderFromCode(device, textureBlitVertexShader, textureBlitFragmentShader, 'ShaderCoreExporterBlit');
			device.scope.resolve('blitTexture').setValue(texture);
			device.setBlendState(BlendState.NOBLEND);
			drawQuadWithShader(device, renderTarget, shader);
			return dstTexture.read(0, 0, width, height, {
				renderTarget: renderTarget,
				immediate: true
			}).then(function (textureData) {
				dstTexture.destroy();
				renderTarget.destroy();
				var pixels = new Uint8ClampedArray(width * height * 4);
				pixels.set(textureData);
				var newImage = new ImageData(pixels, width, height);
				var canvas = document.createElement('canvas');
				canvas.width = width;
				canvas.height = height;
				var newContext = canvas.getContext('2d');
				if (!newContext) {
					return Promise.resolve(undefined);
				}
				newContext.putImageData(newImage, 0, 0);
				return Promise.resolve(canvas);
			});
		};
		_proto.calcTextureSize = function calcTextureSize(width, height, maxTextureSize) {
			if (maxTextureSize) {
				var scale = Math.min(maxTextureSize / Math.max(width, height), 1);
				width = Math.round(width * scale);
				height = Math.round(height * scale);
			}
			return {
				width: width,
				height: height
			};
		};
		return CoreExporter;
	}();

	var u8 = Uint8Array,
		u16 = Uint16Array,
		i32 = Int32Array;
	var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
	var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
	var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
	var freb = function freb(eb, start) {
		var b = new u16(31);
		for (var i = 0; i < 31; ++i) {
			b[i] = start += 1 << eb[i - 1];
		}
		var r = new i32(b[30]);
		for (var i = 1; i < 30; ++i) {
			for (var j = b[i]; j < b[i + 1]; ++j) {
				r[j] = j - b[i] << 5 | i;
			}
		}
		return {
			b: b,
			r: r
		};
	};
	var _a = freb(fleb, 2),
		fl = _a.b,
		revfl = _a.r;
	fl[28] = 258, revfl[258] = 28;
	var _b = freb(fdeb, 0),
		revfd = _b.r;
	var rev = new u16(32768);
	for (var i = 0; i < 32768; ++i) {
		var x = (i & 0xAAAA) >> 1 | (i & 0x5555) << 1;
		x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2;
		x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4;
		rev[i] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1;
	}
	var hMap = function hMap(cd, mb, r) {
		var s = cd.length;
		var i = 0;
		var l = new u16(mb);
		for (; i < s; ++i) {
			if (cd[i]) ++l[cd[i] - 1];
		}
		var le = new u16(mb);
		for (i = 1; i < mb; ++i) {
			le[i] = le[i - 1] + l[i - 1] << 1;
		}
		var co;
		if (r) {
			co = new u16(1 << mb);
			var rvb = 15 - mb;
			for (i = 0; i < s; ++i) {
				if (cd[i]) {
					var sv = i << 4 | cd[i];
					var r_1 = mb - cd[i];
					var v = le[cd[i] - 1]++ << r_1;
					for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
						co[rev[v] >> rvb] = sv;
					}
				}
			}
		} else {
			co = new u16(s);
			for (i = 0; i < s; ++i) {
				if (cd[i]) {
					co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
				}
			}
		}
		return co;
	};
	var flt = new u8(288);
	for (var i = 0; i < 144; ++i) flt[i] = 8;
	for (var i = 144; i < 256; ++i) flt[i] = 9;
	for (var i = 256; i < 280; ++i) flt[i] = 7;
	for (var i = 280; i < 288; ++i) flt[i] = 8;
	var fdt = new u8(32);
	for (var i = 0; i < 32; ++i) fdt[i] = 5;
	var flm = hMap(flt, 9, 0);
		hMap(flt, 9, 1);
	var fdm = hMap(fdt, 5, 0);
		hMap(fdt, 5, 1);
	var shft = function shft(p) {
		return (p + 7) / 8 | 0;
	};
	var slc = function slc(v, s, e) {
		if (e == null || e > v.length) e = v.length;
		return new u8(v.subarray(s, e));
	};
	var ec = ['unexpected EOF', 'invalid block type', 'invalid length/literal', 'invalid distance', 'stream finished', 'no stream handler',, 'no callback', 'invalid UTF-8 data', 'extra field too long', 'date not in range 1980-2099', 'filename too long', 'stream finishing', 'invalid zip data'];
	var _err = function err(ind, msg, nt) {
		var e = new Error(msg || ec[ind]);
		e.code = ind;
		if (Error.captureStackTrace) Error.captureStackTrace(e, _err);
		if (!nt) throw e;
		return e;
	};
	var wbits = function wbits(d, p, v) {
		v <<= p & 7;
		var o = p / 8 | 0;
		d[o] |= v;
		d[o + 1] |= v >> 8;
	};
	var wbits16 = function wbits16(d, p, v) {
		v <<= p & 7;
		var o = p / 8 | 0;
		d[o] |= v;
		d[o + 1] |= v >> 8;
		d[o + 2] |= v >> 16;
	};
	var hTree = function hTree(d, mb) {
		var t = [];
		for (var i = 0; i < d.length; ++i) {
			if (d[i]) t.push({
				s: i,
				f: d[i]
			});
		}
		var s = t.length;
		var t2 = t.slice();
		if (!s) return {
			t: et,
			l: 0
		};
		if (s == 1) {
			var v = new u8(t[0].s + 1);
			v[t[0].s] = 1;
			return {
				t: v,
				l: 1
			};
		}
		t.sort(function (a, b) {
			return a.f - b.f;
		});
		t.push({
			s: -1,
			f: 25001
		});
		var l = t[0],
			r = t[1],
			i0 = 0,
			i1 = 1,
			i2 = 2;
		t[0] = {
			s: -1,
			f: l.f + r.f,
			l: l,
			r: r
		};
		while (i1 != s - 1) {
			l = t[t[i0].f < t[i2].f ? i0++ : i2++];
			r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
			t[i1++] = {
				s: -1,
				f: l.f + r.f,
				l: l,
				r: r
			};
		}
		var maxSym = t2[0].s;
		for (var i = 1; i < s; ++i) {
			if (t2[i].s > maxSym) maxSym = t2[i].s;
		}
		var tr = new u16(maxSym + 1);
		var mbt = _ln(t[i1 - 1], tr, 0);
		if (mbt > mb) {
			var i = 0,
				dt = 0;
			var lft = mbt - mb,
				cst = 1 << lft;
			t2.sort(function (a, b) {
				return tr[b.s] - tr[a.s] || a.f - b.f;
			});
			for (; i < s; ++i) {
				var i2_1 = t2[i].s;
				if (tr[i2_1] > mb) {
					dt += cst - (1 << mbt - tr[i2_1]);
					tr[i2_1] = mb;
				} else break;
			}
			dt >>= lft;
			while (dt > 0) {
				var i2_2 = t2[i].s;
				if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;else ++i;
			}
			for (; i >= 0 && dt; --i) {
				var i2_3 = t2[i].s;
				if (tr[i2_3] == mb) {
					--tr[i2_3];
					++dt;
				}
			}
			mbt = mb;
		}
		return {
			t: new u8(tr),
			l: mbt
		};
	};
	var _ln = function ln(n, l, d) {
		return n.s == -1 ? Math.max(_ln(n.l, l, d + 1), _ln(n.r, l, d + 1)) : l[n.s] = d;
	};
	var lc = function lc(c) {
		var s = c.length;
		while (s && !c[--s]);
		var cl = new u16(++s);
		var cli = 0,
			cln = c[0],
			cls = 1;
		var w = function w(v) {
			cl[cli++] = v;
		};
		for (var i = 1; i <= s; ++i) {
			if (c[i] == cln && i != s) ++cls;else {
				if (!cln && cls > 2) {
					for (; cls > 138; cls -= 138) w(32754);
					if (cls > 2) {
						w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
						cls = 0;
					}
				} else if (cls > 3) {
					w(cln), --cls;
					for (; cls > 6; cls -= 6) w(8304);
					if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
				}
				while (cls--) w(cln);
				cls = 1;
				cln = c[i];
			}
		}
		return {
			c: cl.subarray(0, cli),
			n: s
		};
	};
	var clen = function clen(cf, cl) {
		var l = 0;
		for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];
		return l;
	};
	var wfblk = function wfblk(out, pos, dat) {
		var s = dat.length;
		var o = shft(pos + 2);
		out[o] = s & 255;
		out[o + 1] = s >> 8;
		out[o + 2] = out[o] ^ 255;
		out[o + 3] = out[o + 1] ^ 255;
		for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];
		return (o + 4 + s) * 8;
	};
	var wblk = function wblk(dat, out, _final2, syms, lf, df, eb, li, bs, bl, p) {
		wbits(out, p++, _final2);
		++lf[256];
		var _a = hTree(lf, 15),
			dlt = _a.t,
			mlb = _a.l;
		var _b = hTree(df, 15),
			ddt = _b.t,
			mdb = _b.l;
		var _c = lc(dlt),
			lclt = _c.c,
			nlc = _c.n;
		var _d = lc(ddt),
			lcdt = _d.c,
			ndc = _d.n;
		var lcfreq = new u16(19);
		for (var i = 0; i < lclt.length; ++i) ++lcfreq[lclt[i] & 31];
		for (var i = 0; i < lcdt.length; ++i) ++lcfreq[lcdt[i] & 31];
		var _e = hTree(lcfreq, 7),
			lct = _e.t,
			mlcb = _e.l;
		var nlcc = 19;
		for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
		var flen = bl + 5 << 3;
		var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
		var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
		if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
		var lm, ll, dm, dl;
		wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
		if (dtlen < ftlen) {
			lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
			var llm = hMap(lct, mlcb, 0);
			wbits(out, p, nlc - 257);
			wbits(out, p + 5, ndc - 1);
			wbits(out, p + 10, nlcc - 4);
			p += 14;
			for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);
			p += 3 * nlcc;
			var lcts = [lclt, lcdt];
			for (var it = 0; it < 2; ++it) {
				var clct = lcts[it];
				for (var i = 0; i < clct.length; ++i) {
					var len = clct[i] & 31;
					wbits(out, p, llm[len]), p += lct[len];
					if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
				}
			}
		} else {
			lm = flm, ll = flt, dm = fdm, dl = fdt;
		}
		for (var i = 0; i < li; ++i) {
			var sym = syms[i];
			if (sym > 255) {
				var len = sym >> 18 & 31;
				wbits16(out, p, lm[len + 257]), p += ll[len + 257];
				if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];
				var dst = sym & 31;
				wbits16(out, p, dm[dst]), p += dl[dst];
				if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
			} else {
				wbits16(out, p, lm[sym]), p += ll[sym];
			}
		}
		wbits16(out, p, lm[256]);
		return p + ll[256];
	};
	var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
	var et = new u8(0);
	var dflt = function dflt(dat, lvl, plvl, pre, post, st) {
		var s = st.z || dat.length;
		var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
		var w = o.subarray(pre, o.length - post);
		var lst = st.l;
		var pos = (st.r || 0) & 7;
		if (lvl) {
			if (pos) w[0] = st.r >> 3;
			var opt = deo[lvl - 1];
			var n = opt >> 13,
				c = opt & 8191;
			var msk_1 = (1 << plvl) - 1;
			var prev = st.p || new u16(32768),
				head = st.h || new u16(msk_1 + 1);
			var bs1_1 = Math.ceil(plvl / 3),
				bs2_1 = 2 * bs1_1;
			var hsh = function hsh(i) {
				return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
			};
			var syms = new i32(25000);
			var lf = new u16(288),
				df = new u16(32);
			var lc_1 = 0,
				eb = 0,
				i = st.i || 0,
				li = 0,
				wi = st.w || 0,
				bs = 0;
			for (; i + 2 < s; ++i) {
				var hv = hsh(i);
				var imod = i & 32767,
					pimod = head[hv];
				prev[imod] = pimod;
				head[hv] = imod;
				if (wi <= i) {
					var rem = s - i;
					if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
						pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
						li = lc_1 = eb = 0, bs = i;
						for (var j = 0; j < 286; ++j) lf[j] = 0;
						for (var j = 0; j < 30; ++j) df[j] = 0;
					}
					var l = 2,
						d = 0,
						ch_1 = c,
						dif = imod - pimod & 32767;
					if (rem > 2 && hv == hsh(i - dif)) {
						var maxn = Math.min(n, rem) - 1;
						var maxd = Math.min(32767, i);
						var ml = Math.min(258, rem);
						while (dif <= maxd && --ch_1 && imod != pimod) {
							if (dat[i + l] == dat[i + l - dif]) {
								var nl = 0;
								for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
								if (nl > l) {
									l = nl, d = dif;
									if (nl > maxn) break;
									var mmd = Math.min(dif, nl - 2);
									var md = 0;
									for (var j = 0; j < mmd; ++j) {
										var ti = i - dif + j & 32767;
										var pti = prev[ti];
										var cd = ti - pti & 32767;
										if (cd > md) md = cd, pimod = ti;
									}
								}
							}
							imod = pimod, pimod = prev[imod];
							dif += imod - pimod & 32767;
						}
					}
					if (d) {
						syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
						var lin = revfl[l] & 31,
							din = revfd[d] & 31;
						eb += fleb[lin] + fdeb[din];
						++lf[257 + lin];
						++df[din];
						wi = i + l;
						++lc_1;
					} else {
						syms[li++] = dat[i];
						++lf[dat[i]];
					}
				}
			}
			for (i = Math.max(i, wi); i < s; ++i) {
				syms[li++] = dat[i];
				++lf[dat[i]];
			}
			pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
			if (!lst) {
				st.r = pos & 7 | w[pos / 8 | 0] << 3;
				pos -= 7;
				st.h = head, st.p = prev, st.i = i, st.w = wi;
			}
		} else {
			for (var i = st.w || 0; i < s + lst; i += 65535) {
				var e = i + 65535;
				if (e >= s) {
					w[pos / 8 | 0] = lst;
					e = s;
				}
				pos = wfblk(w, pos + 1, dat.subarray(i, e));
			}
			st.i = s;
		}
		return slc(o, 0, pre + shft(pos) + post);
	};
	var crct = function () {
		var t = new Int32Array(256);
		for (var i = 0; i < 256; ++i) {
			var c = i,
				k = 9;
			while (--k) c = (c & 1 && -306674912) ^ c >>> 1;
			t[i] = c;
		}
		return t;
	}();
	var crc = function crc() {
		var c = -1;
		return {
			p: function p(d) {
				var cr = c;
				for (var i = 0; i < d.length; ++i) cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
				c = cr;
			},
			d: function d() {
				return ~c;
			}
		};
	};
	var dopt = function dopt(dat, opt, pre, post, st) {
		if (!st) {
			st = {
				l: 1
			};
			if (opt.dictionary) {
				var dict = opt.dictionary.subarray(-32768);
				var newDat = new u8(dict.length + dat.length);
				newDat.set(dict);
				newDat.set(dat, dict.length);
				dat = newDat;
				st.w = dict.length;
			}
		}
		return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
	};
	var mrg = function mrg(a, b) {
		var o = {};
		for (var k in a) o[k] = a[k];
		for (var k in b) o[k] = b[k];
		return o;
	};
	var wbytes = function wbytes(d, b, v) {
		for (; v; ++b) d[b] = v, v >>>= 8;
	};
	function deflateSync(data, opts) {
		return dopt(data, opts || {}, 0, 0);
	}
	var _fltn = function fltn(d, p, t, o) {
		for (var k in d) {
			var val = d[k],
				n = p + k,
				op = o;
			if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];
			if (val instanceof u8) t[n] = [val, op];else {
				t[n += '/'] = [new u8(0), op];
				_fltn(val, n, t, o);
			}
		}
	};
	var te = typeof TextEncoder != 'undefined' && new TextEncoder();
	var td = typeof TextDecoder != 'undefined' && new TextDecoder();
	var tds = 0;
	try {
		td.decode(et, {
			stream: true
		});
		tds = 1;
	} catch (e) {}
	function strToU8(str, latin1) {
		var i; 
		if (te) return te.encode(str);
		var l = str.length;
		var ar = new u8(str.length + (str.length >> 1));
		var ai = 0;
		var w = function w(v) {
			ar[ai++] = v;
		};
		for (var i = 0; i < l; ++i) {
			if (ai + 5 > ar.length) {
				var n = new u8(ai + 8 + (l - i << 1));
				n.set(ar);
				ar = n;
			}
			var c = str.charCodeAt(i);
			if (c < 128 || latin1) w(c);else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
		}
		return slc(ar, 0, ai);
	}
	var exfl = function exfl(ex) {
		var le = 0;
		if (ex) {
			for (var k in ex) {
				var l = ex[k].length;
				if (l > 65535) _err(9);
				le += l + 4;
			}
		}
		return le;
	};
	var wzh = function wzh(d, b, f, fn, u, c, ce, co) {
		var fl = fn.length,
			ex = f.extra,
			col = co && co.length;
		var exl = exfl(ex);
		wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
		if (ce != null) d[b++] = 20, d[b++] = f.os;
		d[b] = 20, b += 2;
		d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
		d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
		var dt = new Date(f.mtime == null ? Date.now() : f.mtime),
			y = dt.getFullYear() - 1980;
		if (y < 0 || y > 119) _err(10);
		wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
		if (c != -1) {
			wbytes(d, b, f.crc);
			wbytes(d, b + 4, c < 0 ? -c - 2 : c);
			wbytes(d, b + 8, f.size);
		}
		wbytes(d, b + 12, fl);
		wbytes(d, b + 14, exl), b += 16;
		if (ce != null) {
			wbytes(d, b, col);
			wbytes(d, b + 6, f.attrs);
			wbytes(d, b + 10, ce), b += 14;
		}
		d.set(fn, b);
		b += fl;
		if (exl) {
			for (var k in ex) {
				var exf = ex[k],
					l = exf.length;
				wbytes(d, b, +k);
				wbytes(d, b + 2, l);
				d.set(exf, b + 4), b += 4 + l;
			}
		}
		if (col) d.set(co, b), b += col;
		return b;
	};
	var wzf = function wzf(o, b, c, d, e) {
		wbytes(o, b, 0x6054B50);
		wbytes(o, b + 8, c);
		wbytes(o, b + 10, c);
		wbytes(o, b + 12, d);
		wbytes(o, b + 16, e);
	};
	function zipSync(data, opts) {
		if (!opts) opts = {};
		var r = {};
		var files = [];
		_fltn(data, '', r, opts);
		var o = 0;
		var tot = 0;
		for (var fn in r) {
			var _a = r[fn],
				file = _a[0],
				p = _a[1];
			var compression = p.level == 0 ? 0 : 8;
			var f = strToU8(fn),
				s = f.length;
			var com = p.comment,
				m = com && strToU8(com),
				ms = m && m.length;
			var exl = exfl(p.extra);
			if (s > 65535) _err(11);
			var d = compression ? deflateSync(file, p) : file,
				l = d.length;
			var c = crc();
			c.p(file);
			files.push(mrg(p, {
				size: file.length,
				crc: c.d(),
				c: d,
				f: f,
				m: m,
				u: s != fn.length || m && com.length != ms,
				o: o,
				compression: compression
			}));
			o += 30 + s + exl + l;
			tot += 76 + 2 * (s + exl) + (ms || 0) + l;
		}
		var out = new u8(tot + 22),
			oe = o,
			cdl = tot - o;
		for (var i = 0; i < files.length; ++i) {
			var f = files[i];
			wzh(out, f.o, f, f.f, f.u, f.c.length);
			var badd = 30 + f.f.length + exfl(f.extra);
			out.set(f.c, f.o + badd);
			wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
		}
		wzf(out, o, files.length, cdl, oe);
		return out;
	}

	var ROOT_FILE_NAME = 'root';
	var header = "#usda 1.0\n(\n    customLayerData = {\n        string creator = \"PlayCanvas UsdzExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n";
	var materialListTemplate = function materialListTemplate(materials) {
		return "\ndef \"Materials\"\n{\n    " + materials.join('\n') + "\n}\n";
	};
	var meshTemplate = function meshTemplate(faceVertexCounts, indices, normals, positions, uv0, uv1) {
		return "\ndef \"Mesh\"\n{\n    def Mesh \"Mesh\"\n    {\n        int[] faceVertexCounts = [" + faceVertexCounts + "]\n        int[] faceVertexIndices = [" + indices + "]\n        normal3f[] normals = [" + normals + "] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [" + positions + "]\n        texCoord2f[] primvars:st = [" + uv0 + "] (\n            interpolation = \"vertex\"\n        )\n        texCoord2f[] primvars:st1 = [" + uv1 + "] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n}\n";
	};
	var meshInstanceTemplate = function meshInstanceTemplate(nodeName, meshRefPath, worldMatrix, materialRefPath) {
		return "\ndef Xform \"" + nodeName + "\" (\n    prepend references = " + meshRefPath + "\n)\n{\n    matrix4d xformOp:transform = " + worldMatrix + "\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    rel material:binding = " + materialRefPath + "\n}\n";
	};
	var materialValueTemplate = function materialValueTemplate(type, name, value) {
		return "                    " + type + " inputs:" + name + " = " + value;
	};
	var UsdzExporter = function (_CoreExporter) {
		function UsdzExporter() {
			var _this;
			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			_this = _CoreExporter.call.apply(_CoreExporter, [this].concat(args)) || this;
			_this.meshMap = void 0;
			_this.materialMap = void 0;
			_this.materials = void 0;
			_this.textureMap = void 0;
			_this.nodeNames = void 0;
			_this.files = void 0;
			return _this;
		}
		_inheritsLoose(UsdzExporter, _CoreExporter);
		var _proto = UsdzExporter.prototype;
		_proto.init = function init() {
			this.meshMap = new Map();
			this.textureMap = new Map();
			this.materialMap = new Map();
			this.materials = [];
			this.files = {};
			this.nodeNames = new Set();
		};
		_proto.done = function done() {
			this.meshMap = null;
			this.textureMap = null;
			this.materialMap = null;
			this.materials = null;
			this.files = null;
			this.nodeNames = null;
		};
		_proto.build = function build(entity, options) {
			var _this2 = this;
			if (options === void 0) {
				options = {};
			}
			this.init();
			this.addFile(null, ROOT_FILE_NAME);
			var allMeshInstances = [];
			if (entity) {
				var renders = entity.findComponents('render');
				renders.forEach(function (render) {
					allMeshInstances.push.apply(allMeshInstances, render.meshInstances);
				});
			}
			var rootContent = '';
			allMeshInstances.forEach(function (meshInstance) {
				rootContent += _this2.buildMeshInstance(meshInstance);
			});
			rootContent += materialListTemplate(this.materials);
			this.addFile(null, ROOT_FILE_NAME, '', rootContent);
			var textureOptions = {
				maxTextureSize: options.maxTextureSize
			};
			var textureArray = Array.from(this.textureMap.keys());
			var promises = [];
			var _loop = function _loop() {
				var mimeType = 'image/png' ;
				var texture = textureArray[i];
				var texturePromise = _this2.textureToCanvas(texture, textureOptions).then(function (canvas) {
					if (canvas) {
						return new Promise(function (resolve) {
							return canvas.toBlob(resolve, mimeType, 1);
						}).then(function (blob) {
							return blob.arrayBuffer();
						});
					}
					console.warn("Export of texture " + texture.name + " is not currently supported.");
					return new Promise(function (resolve) {
						return resolve(null);
					});
				});
				promises.push(texturePromise);
			};
			for (var i = 0; i < textureArray.length; i++) {
				_loop();
			}
			var finalData = Promise.all(promises).then(function (values) {
				values.forEach(function (textureArrayBuffer, index) {
					var texture = textureArray[index];
					var ids = _this2.getTextureFileIds(texture);
					_this2.files[ids.fileName] = new Uint8Array(textureArrayBuffer);
				});
				_this2.alignFiles();
				var arraybuffer = zipSync(_this2.files, {
					level: 0
				});
				_this2.done();
				return arraybuffer;
			});
			return finalData;
		};
		_proto.alignFiles = function alignFiles() {
			var offset = 0;
			for (var filename in this.files) {
				var file = this.files[filename];
				var headerSize = 34 + filename.length;
				offset += headerSize;
				var offsetMod64 = offset & 63;
				if (offsetMod64 !== 4) {
					var padLength = 64 - offsetMod64;
					var padding = new Uint8Array(padLength);
					this.files[filename] = [file, {
						extra: {
							12345: padding
						}
					}];
				}
				offset = file.length;
			}
		};
		_proto.getFileIds = function getFileIds(category, name, ref, extension) {
			if (extension === void 0) {
				extension = 'usda';
			}
			var fileName = "" + (category ? category + "/" : '') + name + "." + extension;
			var refName = "@./" + fileName + "@</" + ref + ">";
			return {
				name: name,
				fileName: fileName,
				refName: refName
			};
		};
		_proto.getTextureFileIds = function getTextureFileIds(texture) {
			return this.getFileIds('texture', "Texture_" + texture.id, 'Texture', 'png');
		};
		_proto.addFile = function addFile(category, uniqueId, refName, content) {
			if (refName === void 0) {
				refName = '';
			}
			if (content === void 0) {
				content = '';
			}
			var contentU8 = null;
			if (content) {
				content = header + "\n" + content;
				contentU8 = strToU8(content);
			}
			var ids = this.getFileIds(category, uniqueId, refName);
			this.files[ids.fileName] = contentU8;
			return ids.refName;
		};
		_proto.getMaterialRef = function getMaterialRef(material) {
			var materialRef = this.materialMap.get(material);
			if (!materialRef) {
				materialRef = this.buildMaterial(material);
				this.materialMap.set(material, materialRef);
			}
			return materialRef;
		};
		_proto.getMeshRef = function getMeshRef(mesh) {
			var meshRef = this.meshMap.get(mesh);
			if (!meshRef) {
				meshRef = this.buildMesh(mesh);
				this.meshMap.set(mesh, meshRef);
			}
			return meshRef;
		};
		_proto.buildArray2 = function buildArray2(array) {
			var components = [];
			var count = array.length;
			for (var i = 0; i < count; i += 2) {
				components.push("(" + array[i] + ", " + (1 - array[i + 1]) + ")");
			}
			return components.join(', ');
		};
		_proto.buildArray3 = function buildArray3(array) {
			var components = [];
			var count = array.length;
			for (var i = 0; i < count; i += 3) {
				components.push("(" + array[i] + ", " + array[i + 1] + ", " + array[i + 2] + ")");
			}
			return components.join(', ');
		};
		_proto.buildMat4 = function buildMat4(mat) {
			var data = mat.data;
			var vectors = [];
			for (var i = 0; i < 16; i += 4) {
				vectors.push("(" + data[i] + ", " + data[i + 1] + ", " + data[i + 2] + ", " + data[i + 3] + ")");
			}
			return "( " + vectors.join(', ') + " )";
		};
		_proto.buildMaterial = function buildMaterial(material) {
			var _this3 = this;
			var materialName = "Material_" + material.id;
			var materialPath = "/Materials/" + materialName;
			var materialPropertyPath = function materialPropertyPath(property) {
				return "<" + materialPath + property + ">";
			};
			var buildTexture = function buildTexture(texture, textureIds, mapType, uvChannel, tiling, offset, rotation, tintColor) {
				return "\n                def Shader \"Transform2d_" + mapType + "\" (\n                    sdrMetadata = {\n                        string role = \"math\"\n                    }\n                )\n                {\n                    uniform token info:id = \"UsdTransform2d\"\n                    float2 inputs:in.connect = " + materialPropertyPath("/uvReader_" + uvChannel + ".outputs:result") + "\n                    float inputs:rotation = " + rotation + "\n                    float2 inputs:scale = (" + tiling.x + ", " + tiling.y + ")\n                    float2 inputs:translation = (" + offset.x + ", " + offset.y + ")\n                    float2 outputs:result\n                }\n\n                def Shader \"Texture_" + texture.id + "_" + mapType + "\"\n                {\n                    uniform token info:id = \"UsdUVTexture\"\n                    asset inputs:file = @" + textureIds.fileName + "@\n                    float2 inputs:st.connect = " + materialPropertyPath("/Transform2d_" + mapType + ".outputs:result") + "\n                    token inputs:wrapS = \"repeat\"\n                    token inputs:wrapT = \"repeat\"\n                    float4 inputs:scale = (" + tintColor.r + ", " + tintColor.g + ", " + tintColor.b + ", " + tintColor.a + ")\n                    float outputs:r\n                    float outputs:g\n                    float outputs:b\n                    float3 outputs:rgb\n                    float outputs:a\n                }\n            ";
			};
			var inputs = [];
			var samplers = [];
			var addTexture = function addTexture(textureSlot, uniform, propType, propName, valueName, handleOpacity, tintTexture) {
				if (handleOpacity === void 0) {
					handleOpacity = false;
				}
				if (tintTexture === void 0) {
					tintTexture = false;
				}
				var texture = material[textureSlot];
				if (texture) {
					var textureIds = _this3.getTextureFileIds(texture);
					_this3.textureMap.set(texture, textureIds.refName);
					var channel = material[textureSlot + "Channel"] || 'rgb';
					var textureValue = materialPropertyPath("/" + textureIds.name + "_" + valueName + ".outputs:" + channel);
					inputs.push(materialValueTemplate(propType, propName + ".connect", textureValue));
					if (handleOpacity) {
						if (material.alphaTest > 0.0) ;
					}
					var tiling = material[textureSlot + "Tiling"];
					var offset = material[textureSlot + "Offset"];
					var rotation = material[textureSlot + "Rotation"];
					var uvChannel = material[textureSlot + "Uv"] === 1 ? 'st1' : 'st';
					var tintColor = tintTexture && uniform ? uniform : Color.WHITE;
					samplers.push(buildTexture(texture, textureIds, valueName, uvChannel, tiling, offset, rotation, tintColor));
				} else if (uniform) {
					var value = propType === 'float' ? "" + uniform : "(" + uniform.r + ", " + uniform.g + ", " + uniform.b + ")";
					inputs.push(materialValueTemplate(propType, propName, value));
				}
			};
			addTexture('diffuseMap', material.diffuse, 'color3f', 'diffuseColor', 'diffuse', false, true);
			if (material.transparent || material.alphaTest > 0.0) {
				addTexture('opacityMap', material.opacity, 'float', 'opacity', 'opacity', true);
			}
			addTexture('normalMap', null, 'normal3f', 'normal', 'normal');
			addTexture('emissiveMap', material.emissive, 'color3f', 'emissiveColor', 'emissive', false, true);
			addTexture('aoMap', null, 'float', 'occlusion', 'occlusion');
			addTexture('metalnessMap', material.metalness, 'float', 'metallic', 'metallic');
			addTexture('glossMap', material.gloss, 'float', 'roughness', 'roughness');
			var materialObject = "\n            def Material \"" + materialName + "\"\n            {\n                def Shader \"PreviewSurface\"\n                {\n                    uniform token info:id = \"UsdPreviewSurface\"\n" + inputs.join('\n') + "\n                    int inputs:useSpecularWorkflow = 0\n                    token outputs:surface\n                }\n\n                token outputs:surface.connect = " + materialPropertyPath('/PreviewSurface.outputs:surface') + "\n\n                def Shader \"uvReader_st\"\n                {\n                    uniform token info:id = \"UsdPrimvarReader_float2\"\n                    token inputs:varname = \"st\"\n                    float2 inputs:fallback = (0.0, 0.0)\n                    float2 outputs:result\n                }\n\n                def Shader \"uvReader_st1\"\n                {\n                    uniform token info:id = \"UsdPrimvarReader_float2\"\n                    token inputs:varname = \"st1\"\n                    float2 inputs:fallback = (0.0, 0.0)\n                    float2 outputs:result\n                }\n\n                " + samplers.join('\n') + "\n            }\n        ";
			this.materials.push(materialObject);
			return materialPropertyPath('');
		};
		_proto.buildMesh = function buildMesh(mesh) {
			var positions = [];
			var indices = [];
			var normals = [];
			var uv0 = [];
			var uv1 = [];
			mesh.getVertexStream(SEMANTIC_POSITION, positions);
			mesh.getVertexStream(SEMANTIC_NORMAL, normals);
			mesh.getVertexStream(SEMANTIC_TEXCOORD0, uv0);
			mesh.getVertexStream(SEMANTIC_TEXCOORD1, uv1);
			mesh.getIndices(indices);
			var indicesCount = indices.length || positions.length;
			var faceVertexCounts = Array(indicesCount / 3).fill(3).join(', ');
			if (!indices.length) {
				for (var i = 0; i < indicesCount; i++) {
					indices[i] = i;
				}
			}
			var numVerts = positions.length / 3;
			normals = normals.length ? normals : Array(numVerts * 3).fill(0);
			uv0 = uv0.length ? uv0 : Array(numVerts * 2).fill(0);
			uv1 = uv1.length ? uv1 : Array(numVerts * 2).fill(0);
			positions = this.buildArray3(positions);
			normals = this.buildArray3(normals);
			uv0 = this.buildArray2(uv0);
			uv1 = this.buildArray2(uv1);
			var meshObject = meshTemplate(faceVertexCounts, indices, normals, positions, uv0, uv1);
			var refPath = this.addFile('mesh', "Mesh_" + mesh.id, 'Mesh', meshObject);
			return refPath;
		};
		_proto.buildMeshInstance = function buildMeshInstance(meshInstance) {
			var meshRefPath = this.getMeshRef(meshInstance.mesh);
			var materialRefPath = this.getMaterialRef(meshInstance.material);
			var worldMatrix = this.buildMat4(meshInstance.node.getWorldTransform());
			var name = meshInstance.node.name.replace(/[^a-z0-9]/gi, '_');
			var nodeName = name;
			while (this.nodeNames.has(nodeName)) {
				nodeName = name + "_" + Math.random().toString(36).slice(2, 7);
			}
			this.nodeNames.add(nodeName);
			return meshInstanceTemplate(nodeName, meshRefPath, worldMatrix, materialRefPath);
		};
		return UsdzExporter;
	}(CoreExporter);

	var ARRAY_BUFFER = 34962;
	var ELEMENT_ARRAY_BUFFER = 34963;
	var getIndexComponentType = function getIndexComponentType(indexFormat) {
		switch (indexFormat) {
			case INDEXFORMAT_UINT8:
				return 5121;
			case INDEXFORMAT_UINT16:
				return 5123;
			case INDEXFORMAT_UINT32:
				return 5125;
		}
		return 0;
	};
	var getComponentType = function getComponentType(dataType) {
		switch (dataType) {
			case TYPE_INT8:
				return 5120;
			case TYPE_UINT8:
				return 5121;
			case TYPE_INT16:
				return 5122;
			case TYPE_UINT16:
				return 5123;
			case TYPE_INT32:
				return 5124;
			case TYPE_UINT32:
				return 5125;
			case TYPE_FLOAT32:
				return 5126;
		}
		return 0;
	};
	var getAccessorType = function getAccessorType(componentCount) {
		switch (componentCount) {
			case 1:
				return 'SCALAR';
			case 2:
				return 'VEC2';
			case 3:
				return 'VEC3';
			case 4:
				return 'VEC4';
		}
		return 0;
	};
	var getSemantic = function getSemantic(engineSemantic) {
		switch (engineSemantic) {
			case SEMANTIC_POSITION:
				return 'POSITION';
			case SEMANTIC_NORMAL:
				return 'NORMAL';
			case SEMANTIC_TANGENT:
				return 'TANGENT';
			case SEMANTIC_COLOR:
				return 'COLOR_0';
			case SEMANTIC_BLENDINDICES:
				return 'JOINTS_0';
			case SEMANTIC_BLENDWEIGHT:
				return 'WEIGHTS_0';
			case SEMANTIC_TEXCOORD0:
				return 'TEXCOORD_0';
			case SEMANTIC_TEXCOORD1:
				return 'TEXCOORD_1';
			case SEMANTIC_TEXCOORD2:
				return 'TEXCOORD_2';
			case SEMANTIC_TEXCOORD3:
				return 'TEXCOORD_3';
			case SEMANTIC_TEXCOORD4:
				return 'TEXCOORD_4';
			case SEMANTIC_TEXCOORD5:
				return 'TEXCOORD_5';
			case SEMANTIC_TEXCOORD6:
				return 'TEXCOORD_6';
			case SEMANTIC_TEXCOORD7:
				return 'TEXCOORD_7';
		}
		return '';
	};
	var getFilter = function getFilter(filter) {
		switch (filter) {
			case FILTER_NEAREST:
				return 9728;
			case FILTER_LINEAR:
				return 9729;
			case FILTER_NEAREST_MIPMAP_NEAREST:
				return 9984;
			case FILTER_LINEAR_MIPMAP_NEAREST:
				return 9985;
			case FILTER_NEAREST_MIPMAP_LINEAR:
				return 9986;
			case FILTER_LINEAR_MIPMAP_LINEAR:
				return 9987;
		}
		return 0;
	};
	var getWrap = function getWrap(wrap) {
		switch (wrap) {
			case ADDRESS_CLAMP_TO_EDGE:
				return 33071;
			case ADDRESS_MIRRORED_REPEAT:
				return 33648;
			case ADDRESS_REPEAT:
				return 10497;
		}
		return 0;
	};
	function isCanvasTransparent(canvas) {
		var context = canvas.getContext('2d');
		var pixelData = context.getImageData(0, 0, canvas.width, canvas.height).data;
		for (var i = 3; i < pixelData.length; i += 4) {
			if (pixelData[i] < 255) {
				return true;
			}
		}
		return false;
	}
	var textureSemantics = ['diffuseMap', 'colorMap', 'normalMap', 'metalnessMap', 'emissiveMap'];
	var GltfExporter = function (_CoreExporter) {
		function GltfExporter() {
			return _CoreExporter.apply(this, arguments) || this;
		}
		_inheritsLoose(GltfExporter, _CoreExporter);
		var _proto = GltfExporter.prototype;
		_proto.collectResources = function collectResources(root) {
			var resources = {
				buffers: [],
				cameras: [],
				entities: [],
				materials: [],
				skins: [],
				textures: [],
				entityMeshInstances: [],
				bufferViewMap: new Map(),
				compressableTexture: new Set()
			};
			var materials = resources.materials,
				buffers = resources.buffers,
				entityMeshInstances = resources.entityMeshInstances,
				textures = resources.textures;
			root.forEach(function (entity) {
				resources.entities.push(entity);
			});
			var collectMeshInstances = function collectMeshInstances(meshInstances) {
				meshInstances.forEach(function (meshInstance) {
					var material = meshInstance.material;
					if (materials.indexOf(material) < 0) {
						resources.materials.push(material);
						textureSemantics.forEach(function (semantic) {
							var texture = material[semantic];
							if (texture && textures.indexOf(texture) < 0) {
								if (semantic !== 'normalMap') {
									resources.compressableTexture.add(texture);
								}
								textures.push(texture);
							}
						});
					}
					var node = meshInstance.node;
					var nodeMeshInstances = entityMeshInstances.find(function (e) {
						return e.node === node;
					});
					if (!nodeMeshInstances) {
						nodeMeshInstances = {
							node: node,
							meshInstances: []
						};
						entityMeshInstances.push(nodeMeshInstances);
					}
					nodeMeshInstances.meshInstances.push(meshInstance);
					var mesh = meshInstance.mesh;
					var vertexBuffer = mesh.vertexBuffer;
					if (buffers.indexOf(vertexBuffer) < 0) {
						buffers.unshift(vertexBuffer);
					}
					var indexBuffer = mesh.indexBuffer[0];
					if (buffers.indexOf(indexBuffer) < 0) {
						buffers.push(indexBuffer);
					}
					if (mesh.skin && resources.skins.indexOf(mesh.skin) < 0) {
						resources.skins.push(mesh.skin);
					}
				});
			};
			resources.entities.forEach(function (entity) {
				if (entity.camera) {
					resources.cameras.push(entity.camera);
				}
				if (entity.render && entity.render.enabled) {
					collectMeshInstances(entity.render.meshInstances);
				}
				if (entity.model && entity.model.enabled && entity.model.meshInstances) {
					collectMeshInstances(entity.model.meshInstances);
				}
			});
			return resources;
		};
		_proto.writeBufferViews = function writeBufferViews(resources, json) {
			json.bufferViews = [];
			for (var _iterator = _createForOfIteratorHelperLoose(resources.buffers), _step; !(_step = _iterator()).done;) {
				var buffer = _step.value;
				GltfExporter.writeBufferView(resources, json, buffer);
			}
		};
		GltfExporter.writeBufferView = function writeBufferView(resources, json, buffer) {
			var _json$buffers, _json$buffers$;
			json.buffers = (_json$buffers = json.buffers) != null ? _json$buffers : [];
			json.buffers[0] = (_json$buffers$ = json.buffers[0]) != null ? _json$buffers$ : {
				byteLength: 0
			};
			var bufferInfo = json.buffers[0];
			bufferInfo.byteLength = math.roundUp(bufferInfo.byteLength, 4);
			var offset = bufferInfo.byteLength;
			var addBufferView = function addBufferView(target, byteLength, byteOffset, byteStride) {
				var bufferView = {
					buffer: 0,
					byteLength: byteLength,
					byteOffset: byteOffset
				};
				if (target === ARRAY_BUFFER || target === ELEMENT_ARRAY_BUFFER) {
					bufferView.target = target;
				}
				if (byteStride !== undefined) {
					bufferView.byteStride = byteStride;
				}
				return json.bufferViews.push(bufferView) - 1;
			};
			var arrayBuffer;
			if (buffer instanceof VertexBuffer) {
				arrayBuffer = buffer.lock();
				var format = buffer.getFormat();
				if (format.interleaved) {
					var bufferViewIndex = addBufferView(ARRAY_BUFFER, arrayBuffer.byteLength, offset, format.size);
					resources.bufferViewMap.set(buffer, [bufferViewIndex]);
				} else {
					var bufferViewIndices = [];
					for (var _iterator2 = _createForOfIteratorHelperLoose(format.elements), _step2; !(_step2 = _iterator2()).done;) {
						var element = _step2.value;
						var _bufferViewIndex = addBufferView(ARRAY_BUFFER, element.size * format.vertexCount, offset + element.offset, element.size);
						bufferViewIndices.push(_bufferViewIndex);
					}
					resources.bufferViewMap.set(buffer, bufferViewIndices);
				}
			} else if (buffer instanceof IndexBuffer) {
				arrayBuffer = buffer.lock();
				var _bufferViewIndex2 = addBufferView(ELEMENT_ARRAY_BUFFER, arrayBuffer.byteLength, offset);
				resources.bufferViewMap.set(buffer, [_bufferViewIndex2]);
			} else {
				arrayBuffer = buffer;
				var _bufferViewIndex3 = addBufferView(undefined, arrayBuffer.byteLength, offset);
				resources.bufferViewMap.set(buffer, [_bufferViewIndex3]);
			}
			bufferInfo.byteLength += arrayBuffer.byteLength;
		};
		_proto.writeCameras = function writeCameras(resources, json) {
			if (resources.cameras.length > 0) {
				json.cameras = resources.cameras.map(function (cam) {
					var projection = cam.projection;
					var nearClip = cam.nearClip;
					var farClip = cam.farClip;
					var camera = {};
					if (projection === PROJECTION_ORTHOGRAPHIC) {
						camera.type = 'orthographic';
						camera.orthographic = {
							xmag: 1,
							ymag: 1,
							znear: nearClip,
							zfar: farClip
						};
					} else {
						var fov = cam.fov;
						camera.type = 'perspective';
						camera.perspective = {
							yfov: fov * Math.PI / 180,
							znear: nearClip,
							zfar: farClip
						};
					}
					return camera;
				});
			}
		};
		_proto.attachTexture = function attachTexture(resources, material, destination, name, textureSemantic, json) {
			var texture = material[textureSemantic];
			if (texture) {
				var textureIndex = resources.textures.indexOf(texture);
				if (textureIndex < 0) console.warn("Texture " + texture.name + " wasn't collected.");
				destination[name] = {
					index: textureIndex
				};
				var scale = material[textureSemantic + "Tiling"];
				var offset = material[textureSemantic + "Offset"];
				var rotation = material[textureSemantic + "Rotation"];
				if (scale && !scale.equals(Vec2.ONE) || offset && !offset.equals(Vec2.ZERO) || rotation !== 0) {
					var _json$extensionsUsed, _json$extensionsRequi;
					destination[name].extensions = {
						KHR_texture_transform: {}
					};
					json.extensionsUsed = (_json$extensionsUsed = json.extensionsUsed) != null ? _json$extensionsUsed : [];
					if (json.extensionsUsed.indexOf('KHR_texture_transform') < 0) {
						json.extensionsUsed.push('KHR_texture_transform');
					}
					json.extensionsRequired = (_json$extensionsRequi = json.extensionsRequired) != null ? _json$extensionsRequi : [];
					if (json.extensionsRequired.indexOf('KHR_texture_transform') < 0) {
						json.extensionsRequired.push('KHR_texture_transform');
					}
					if (scale && !scale.equals(Vec2.ONE)) {
						destination[name].extensions.KHR_texture_transform.scale = [scale.x, scale.y];
					}
					if (offset && !offset.equals(Vec2.ZERO)) {
						destination[name].extensions.KHR_texture_transform.offset = [offset.x, offset.y - 1 + scale.y];
					}
					if (rotation !== 0) {
						destination[name].extensions.KHR_texture_transform.rotation = rotation * math.DEG_TO_RAD;
					}
				}
			}
		};
		_proto.writeStandardMaterial = function writeStandardMaterial(resources, mat, output, json) {
			var diffuse = mat.diffuse,
				emissive = mat.emissive,
				opacity = mat.opacity,
				metalness = mat.metalness,
				gloss = mat.gloss,
				glossInvert = mat.glossInvert;
			var pbr = output.pbrMetallicRoughness;
			if (!diffuse.equals(Color.WHITE) || opacity !== 1) {
				pbr.baseColorFactor = [diffuse.r, diffuse.g, diffuse.b, opacity];
			}
			if (metalness !== 1) {
				pbr.metallicFactor = metalness;
			}
			var roughness = glossInvert ? gloss : 1 - gloss;
			if (roughness !== 1) {
				pbr.roughnessFactor = roughness;
			}
			this.attachTexture(resources, mat, pbr, 'baseColorTexture', 'diffuseMap', json);
			this.attachTexture(resources, mat, pbr, 'metallicRoughnessTexture', 'metalnessMap', json);
			if (!emissive.equals(Color.BLACK)) {
				output.emissiveFactor = [emissive.r, emissive.g, emissive.b];
			}
		};
		_proto.writeMaterials = function writeMaterials(resources, json) {
			var _this = this;
			if (resources.materials.length > 0) {
				json.materials = resources.materials.map(function (mat) {
					var name = mat.name,
						blendType = mat.blendType,
						cull = mat.cull,
						alphaTest = mat.alphaTest;
					var material = {
						pbrMetallicRoughness: {}
					};
					if (name && name.length > 0) {
						material.name = name;
					}
					if (mat instanceof StandardMaterial) {
						_this.writeStandardMaterial(resources, mat, material, json);
					}
					if (blendType === BLEND_NORMAL) {
						material.alphaMode = 'BLEND';
					} else if (blendType === BLEND_NONE) {
						if (alphaTest !== 0) {
							material.alphaMode = 'MASK';
							material.alphaCutoff = alphaTest;
						}
					}
					if (cull === CULLFACE_NONE) {
						material.doubleSided = true;
					}
					_this.attachTexture(resources, mat, material, 'normalTexture', 'normalMap', json);
					_this.attachTexture(resources, mat, material, 'occlusionTexture', 'aoMap', json);
					_this.attachTexture(resources, mat, material, 'emissiveTexture', 'emissiveMap', json);
					return material;
				});
			}
		};
		_proto.writeNodes = function writeNodes(resources, json) {
			if (resources.entities.length > 0) {
				json.nodes = resources.entities.map(function (entity) {
					var name = entity.name;
					var t = entity.getLocalPosition();
					var r = entity.getLocalRotation();
					var s = entity.getLocalScale();
					var node = {};
					if (name && name.length > 0) {
						node.name = name;
					}
					if (!t.equals(Vec3.ZERO)) {
						node.translation = [t.x, t.y, t.z];
					}
					if (!r.equals(Quat.IDENTITY)) {
						node.rotation = [r.x, r.y, r.z, r.w];
					}
					if (!s.equals(Vec3.ONE)) {
						node.scale = [s.x, s.y, s.z];
					}
					if (entity.camera && entity.camera.enabled) {
						node.camera = resources.cameras.indexOf(entity.camera);
					}
					var entityMeshInstance = resources.entityMeshInstances.find(function (e) {
						return e.node === entity;
					});
					if (entityMeshInstance) {
						node.mesh = resources.entityMeshInstances.indexOf(entityMeshInstance);
						var meshInstance = entityMeshInstance.meshInstances[0];
						if (meshInstance && meshInstance.mesh.skin) {
							node.skin = resources.skins.indexOf(meshInstance.mesh.skin);
						}
					}
					if (entity.children.length > 0) {
						node.children = [];
						entity.children.forEach(function (child) {
							node.children.push(resources.entities.indexOf(child));
						});
					}
					return node;
				});
			}
		};
		_proto.writeMeshes = function writeMeshes(resources, json, options) {
			if (resources.entityMeshInstances.length > 0) {
				json.accessors = [];
				json.meshes = [];
				resources.entityMeshInstances.forEach(function (entityMeshInstances) {
					var mesh = {
						primitives: []
					};
					var meshInstances = entityMeshInstances.meshInstances;
					meshInstances.forEach(function (meshInstance) {
						var primitive = GltfExporter.createPrimitive(resources, json, meshInstance.mesh, options);
						primitive.material = resources.materials.indexOf(meshInstance.material);
						mesh.primitives.push(primitive);
					});
					json.meshes.push(mesh);
				});
			}
		};
		GltfExporter.createPrimitive = function createPrimitive(resources, json, mesh, options) {
			if (options === void 0) {
				options = {};
			}
			var primitive = {
				attributes: {}
			};
			var vertexBuffer = mesh.vertexBuffer;
			var format = vertexBuffer.format;
			var interleaved = format.interleaved,
				elements = format.elements;
			var numVertices = vertexBuffer.getNumVertices();
			elements.forEach(function (element, elementIndex) {
				var semantic = getSemantic(element.name);
				if (options.stripUnusedAttributes) {
					var isUsed = true;
					if (semantic.startsWith('TEXCOORD_')) {
						var texCoordIndex = parseInt(semantic.split('_')[1], 10);
						isUsed = resources.materials.some(function (material) {
							return textureSemantics.some(function (texSemantic) {
								var _material;
								var texture = material[texSemantic];
								return texture && (texCoordIndex === 0 || ((_material = material[texSemantic + "Tiling"]) == null ? void 0 : _material.uv) === texCoordIndex);
							});
						});
					}
					if (semantic === 'COLOR_0') {
						isUsed = resources.materials.some(function (material) {
							return material.vertexColors;
						});
					}
					if (semantic === 'TANGENT') {
						isUsed = resources.materials.some(function (material) {
							return material.normalMap;
						});
					}
					if (semantic === 'JOINTS_0' || semantic === 'WEIGHTS_0') {
						isUsed = resources.entityMeshInstances.some(function (emi) {
							return emi.meshInstances.some(function (mi) {
								return mi.mesh.skin;
							});
						});
					}
					if (!isUsed) {
						return;
					}
				}
				var bufferView = resources.bufferViewMap.get(vertexBuffer);
				if (!bufferView) {
					GltfExporter.writeBufferView(resources, json, vertexBuffer);
					resources.buffers.push(vertexBuffer);
					bufferView = resources.bufferViewMap.get(vertexBuffer);
				}
				var viewIndex = bufferView[interleaved ? 0 : elementIndex];
				var accessor = {
					bufferView: viewIndex,
					byteOffset: interleaved ? element.offset : 0,
					componentType: getComponentType(element.dataType),
					type: getAccessorType(element.numComponents),
					count: numVertices
				};
				var idx = json.accessors.push(accessor) - 1;
				primitive.attributes[semantic] = idx;
				if (element.name === SEMANTIC_POSITION) {
					var positions = [];
					mesh.getPositions(positions);
					var min = new Vec3();
					var max = new Vec3();
					BoundingBox.computeMinMax(positions, min, max);
					accessor.min = [min.x, min.y, min.z];
					accessor.max = [max.x, max.y, max.z];
				}
			});
			var indexBuffer = mesh.indexBuffer[0];
			if (indexBuffer) {
				var bufferView = resources.bufferViewMap.get(indexBuffer);
				if (!bufferView) {
					GltfExporter.writeBufferView(resources, json, indexBuffer);
					resources.buffers.push(indexBuffer);
					bufferView = resources.bufferViewMap.get(indexBuffer);
				}
				var viewIndex = bufferView[0];
				var accessor = {
					bufferView: viewIndex,
					componentType: getIndexComponentType(indexBuffer.getFormat()),
					count: indexBuffer.getNumIndices(),
					type: 'SCALAR'
				};
				var idx = json.accessors.push(accessor) - 1;
				primitive.indices = idx;
			}
			return primitive;
		};
		_proto.writeSkins = function writeSkins(resources, json) {
			if (resources.skins.length > 0) {
				json.skins = resources.skins.map(function (skin) {
					var matrices = new Float32Array(skin.inverseBindPose.length * 16);
					for (var i = 0; i < skin.inverseBindPose.length; i++) {
						var ibm = skin.inverseBindPose[i];
						matrices.set(ibm.data, i * 16);
					}
					var matrixBuffer = matrices.buffer;
					GltfExporter.writeBufferView(resources, json, matrixBuffer);
					resources.buffers.push(matrixBuffer);
					var bufferView = resources.bufferViewMap.get(matrixBuffer);
					var accessor = {
						bufferView: bufferView[0],
						componentType: getComponentType(TYPE_FLOAT32),
						count: skin.inverseBindPose.length,
						type: 'MAT4'
					};
					var accessorIndex = json.accessors.push(accessor) - 1;
					var joints = skin.boneNames.map(function (boneName) {
						var node = resources.entities.find(function (entity) {
							return entity.name === boneName;
						});
						return resources.entities.indexOf(node);
					});
					return {
						inverseBindMatrices: accessorIndex,
						joints: joints
					};
				});
			}
		};
		_proto.convertTextures = function convertTextures(srcTextures, options) {
			var _this2 = this;
			var textureOptions = {
				maxTextureSize: options.maxTextureSize
			};
			var promises = [];
			srcTextures.forEach(function (srcTexture) {
				var promise = _this2.textureToCanvas(srcTexture, textureOptions);
				promise.then(function (canvas) {
					return new Promise(function (resolve) {
						return resolve(canvas);
					});
				});
				promises.push(promise);
			});
			return promises;
		};
		_proto.writeTextures = function writeTextures(resources, textureCanvases, json, options) {
			var _this3 = this;
			var textures = resources.textures;
			var promises = [];
			var _loop = function _loop(i) {
				var texture = textures[i];
				var canvas = textureCanvases[i];
				var isRGBA = isCanvasTransparent(canvas) || !resources.compressableTexture.has(texture);
				var mimeType = isRGBA ? 'image/png' : 'image/jpeg';
				promises.push(_this3.getBlob(canvas, mimeType).then(function (blob) {
					var reader = new FileReader();
					reader.readAsArrayBuffer(blob);
					return new Promise(function (resolve) {
						reader.onloadend = function () {
							resolve(reader);
						};
					});
				}).then(function (reader) {
					var buffer = _this3.getPaddedArrayBuffer(reader.result);
					GltfExporter.writeBufferView(resources, json, buffer);
					resources.buffers.push(buffer);
					var bufferView = resources.bufferViewMap.get(buffer);
					json.images[i] = {
						mimeType: mimeType,
						bufferView: bufferView[0]
					};
					json.samplers[i] = {
						minFilter: getFilter(texture.minFilter),
						magFilter: getFilter(texture.magFilter),
						wrapS: getWrap(texture.addressU),
						wrapT: getWrap(texture.addressV)
					};
					json.textures[i] = {
						sampler: i,
						source: i
					};
				}));
			};
			for (var i = 0; i < textureCanvases.length; i++) {
				_loop(i);
			}
			return Promise.all(promises);
		};
		_proto.getBlob = function getBlob(canvas, mimeType) {
			if (canvas.toBlob !== undefined) {
				return new Promise(function (resolve) {
					canvas.toBlob(resolve, mimeType);
				});
			}
			var quality = 1.0;
			if (mimeType === 'image/jpeg') {
				quality = 0.92;
			}
			return canvas.convertToBlob({
				type: mimeType,
				quality: quality
			});
		};
		_proto.getPaddedArrayBuffer = function getPaddedArrayBuffer(arrayBuffer, paddingByte) {
			if (paddingByte === void 0) {
				paddingByte = 0;
			}
			var paddedLength = math.roundUp(arrayBuffer.byteLength, 4);
			if (paddedLength !== arrayBuffer.byteLength) {
				var array = new Uint8Array(paddedLength);
				array.set(new Uint8Array(arrayBuffer));
				if (paddingByte !== 0) {
					for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {
						array[i] = paddingByte;
					}
				}
				return array.buffer;
			}
			return arrayBuffer;
		};
		_proto.buildJson = function buildJson(resources, options) {
			var _this4 = this;
			var promises = this.convertTextures(resources.textures, options);
			return Promise.all(promises).then(function () {
				var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(textureCanvases) {
					var json;
					return _regeneratorRuntime().wrap(function _callee$(_context) {
						while (1) switch (_context.prev = _context.next) {
							case 0:
								json = {
									asset: {
										version: '2.0',
										generator: 'PlayCanvas GltfExporter'
									},
									scenes: [{
										nodes: [0]
									}],
									images: [],
									samplers: [],
									textures: [],
									scene: 0
								};
								_this4.writeBufferViews(resources, json);
								_this4.writeCameras(resources, json);
								_this4.writeMeshes(resources, json, options);
								_this4.writeMaterials(resources, json);
								_this4.writeNodes(resources, json, options);
								_this4.writeSkins(resources, json);
								_context.next = 9;
								return _this4.writeTextures(resources, textureCanvases, json, options);
							case 9:
								if (!json.images.length) delete json.images;
								if (!json.samplers.length) delete json.samplers;
								if (!json.textures.length) delete json.textures;
								return _context.abrupt("return", json);
							case 13:
							case "end":
								return _context.stop();
						}
					}, _callee);
				}));
				return function (_x) {
					return _ref.apply(this, arguments);
				};
			}());
		};
		_proto.build = function build(entity, options) {
			if (options === void 0) {
				options = {};
			}
			var resources = this.collectResources(entity);
			return this.buildJson(resources, options).then(function (json) {
				var encoder = new TextEncoder();
				var jsonData = encoder.encode(JSON.stringify(json));
				var headerLength = 12;
				var jsonHeaderLength = 8;
				var jsonDataLength = jsonData.length;
				var jsonPaddingLength = 4 - (jsonDataLength & 3) & 3;
				var binaryHeaderLength = 8;
				var binaryDataLength = json.buffers.reduce(function (total, buffer) {
					return math.roundUp(total + buffer.byteLength, 4);
				}, 0);
				var totalLength = headerLength + jsonHeaderLength + jsonDataLength + jsonPaddingLength;
				if (binaryDataLength > 0) {
					totalLength += binaryHeaderLength + binaryDataLength;
				}
				var glbBuffer = new ArrayBuffer(totalLength);
				var glbView = new DataView(glbBuffer);
				glbView.setUint32(0, 0x46546C67, true);
				glbView.setUint32(4, 2, true);
				glbView.setUint32(8, totalLength, true);
				glbView.setUint32(12, jsonDataLength + jsonPaddingLength, true);
				glbView.setUint32(16, 0x4E4F534A, true);
				var offset = headerLength + jsonHeaderLength;
				new Uint8Array(glbBuffer, offset, jsonDataLength).set(jsonData);
				offset += jsonDataLength;
				for (var i = 0; i < jsonPaddingLength; i++) {
					glbView.setUint8(offset + i, 0x20);
				}
				offset += jsonPaddingLength;
				if (binaryDataLength > 0) {
					glbView.setUint32(offset, binaryDataLength, true);
					glbView.setUint32(offset + 4, 0x004E4942, true);
					offset += binaryHeaderLength;
					resources.buffers.forEach(function (buffer) {
						var src;
						var bufferViewId = resources.bufferViewMap.get(buffer)[0];
						var bufferOffset = json.bufferViews[bufferViewId].byteOffset;
						if (buffer instanceof ArrayBuffer) {
							src = new Uint8Array(buffer);
						} else {
							var srcBuffer = buffer.lock();
							if (srcBuffer instanceof ArrayBuffer) {
								src = new Uint8Array(srcBuffer);
							} else {
								src = new Uint8Array(srcBuffer.buffer, srcBuffer.byteOffset, srcBuffer.byteLength);
							}
						}
						var dst = new Uint8Array(glbBuffer, offset + bufferOffset, src.byteLength);
						dst.set(src);
					});
				}
				return Promise.resolve(glbBuffer);
			});
		};
		return GltfExporter;
	}(CoreExporter);

	var SSAOTYPE_NONE = 'none';
	var SSAOTYPE_LIGHTING = 'lighting';
	var SSAOTYPE_COMBINE = 'combine';

	var RenderPassDownsample = function (_RenderPassShaderQuad) {
		function RenderPassDownsample(device, sourceTexture, options) {
			var _options$boxFilter, _options$premultiplyS;
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _RenderPassShaderQuad.call(this, device) || this;
			_this.sourceTexture = sourceTexture;
			_this.premultiplyTexture = options.premultiplyTexture;
			var boxFilter = (_options$boxFilter = options.boxFilter) != null ? _options$boxFilter : false;
			var key = (boxFilter ? 'Box' : '') + "-" + (options.premultiplyTexture ? 'Premultiply' : '') + "-" + ((_options$premultiplyS = options.premultiplySrcChannel) != null ? _options$premultiplyS : '') + "}";
			_this.shader = _this.createQuadShader("DownSampleShader:" + key, "\n\t\t\t" + (boxFilter ? '#define BOXFILTER' : '') + "\n\t\t\t" + (options.premultiplyTexture ? '#define PREMULTIPLY' : '') + "\n\t\t\tuniform sampler2D sourceTexture;\n\t\t\tuniform vec2 sourceInvResolution;\n\t\t\tvarying vec2 uv0;\n\t\t\t#ifdef PREMULTIPLY\n\t\t\t\tuniform sampler2D premultiplyTexture;\n\t\t\t#endif\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvec3 e = texture2D (sourceTexture, vec2 (uv0.x, uv0.y)).rgb;\n\t\t\t\t#ifdef BOXFILTER\n\t\t\t\t\tvec3 value = e;\n\t\t\t\t\t#ifdef PREMULTIPLY\n\t\t\t\t\t\tfloat premultiply = texture2D(premultiplyTexture, vec2 (uv0.x, uv0.y))." + options.premultiplySrcChannel + ";\n\t\t\t\t\t\tvalue *= vec3(premultiply);\n\t\t\t\t\t#endif\n\t\t\t\t#else\n\t\t\t\t\tfloat x = sourceInvResolution.x;\n\t\t\t\t\tfloat y = sourceInvResolution.y;\n\t\t\t\t\tvec3 a = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y + 2.0 * y)).rgb;\n\t\t\t\t\tvec3 b = texture2D(sourceTexture, vec2 (uv0.x,\t\t   uv0.y + 2.0 * y)).rgb;\n\t\t\t\t\tvec3 c = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y + 2.0 * y)).rgb;\n\t\t\t\t\tvec3 d = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y)).rgb;\n\t\t\t\t\tvec3 f = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y)).rgb;\n\t\t\t\t\tvec3 g = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y - 2.0 * y)).rgb;\n\t\t\t\t\tvec3 h = texture2D(sourceTexture, vec2 (uv0.x,\t\t   uv0.y - 2.0 * y)).rgb;\n\t\t\t\t\tvec3 i = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y - 2.0 * y)).rgb;\n\t\t\t\t\tvec3 j = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;\n\t\t\t\t\tvec3 k = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;\n\t\t\t\t\tvec3 l = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;\n\t\t\t\t\tvec3 m = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;\n\t\t\t\t\tvec3 value = e * 0.125;\n\t\t\t\t\tvalue += (a + c + g + i) * 0.03125;\n\t\t\t\t\tvalue += (b + d + f + h) * 0.0625;\n\t\t\t\t\tvalue += (j + k + l + m) * 0.125;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4(value, 1.0);\n\t\t\t}");
			_this.sourceTextureId = device.scope.resolve('sourceTexture');
			_this.premultiplyTextureId = device.scope.resolve('premultiplyTexture');
			_this.sourceInvResolutionId = device.scope.resolve('sourceInvResolution');
			_this.sourceInvResolutionValue = new Float32Array(2);
			return _this;
		}
		_inheritsLoose(RenderPassDownsample, _RenderPassShaderQuad);
		var _proto = RenderPassDownsample.prototype;
		_proto.setSourceTexture = function setSourceTexture(value) {
			this._sourceTexture = value;
			this.options.resizeSource = value;
		};
		_proto.execute = function execute() {
			this.sourceTextureId.setValue(this.sourceTexture);
			if (this.premultiplyTexture) {
				this.premultiplyTextureId.setValue(this.premultiplyTexture);
			}
			this.sourceInvResolutionValue[0] = 1.0 / this.sourceTexture.width;
			this.sourceInvResolutionValue[1] = 1.0 / this.sourceTexture.height;
			this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
			_RenderPassShaderQuad.prototype.execute.call(this);
		};
		return RenderPassDownsample;
	}(RenderPassShaderQuad);

	var RenderPassUpsample = function (_RenderPassShaderQuad) {
		function RenderPassUpsample(device, sourceTexture) {
			var _this;
			_this = _RenderPassShaderQuad.call(this, device) || this;
			_this.sourceTexture = sourceTexture;
			_this.shader = _this.createQuadShader('UpSampleShader', "\n\t\t\tuniform sampler2D sourceTexture;\n\t\t\tuniform vec2 sourceInvResolution;\n\t\t\tvarying vec2 uv0;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tfloat x = sourceInvResolution.x;\n\t\t\t\tfloat y = sourceInvResolution.y;\n\t\t\t\tvec3 a = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;\n\t\t\t\tvec3 b = texture2D (sourceTexture, vec2 (uv0.x,\t uv0.y + y)).rgb;\n\t\t\t\tvec3 c = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;\n\t\t\t\tvec3 d = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y)).rgb;\n\t\t\t\tvec3 e = texture2D (sourceTexture, vec2 (uv0.x,\t uv0.y)).rgb;\n\t\t\t\tvec3 f = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y)).rgb;\n\t\t\t\tvec3 g = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;\n\t\t\t\tvec3 h = texture2D (sourceTexture, vec2 (uv0.x,\t uv0.y - y)).rgb;\n\t\t\t\tvec3 i = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;\n\t\t\t\tvec3 value = e * 4.0;\n\t\t\t\tvalue += (b + d + f + h) * 2.0;\n\t\t\t\tvalue += (a + c + g + i);\n\t\t\t\tvalue *= 1.0 / 16.0;\n\t\t\t\tgl_FragColor = vec4(value, 1.0);\n\t\t\t}");
			_this.sourceTextureId = device.scope.resolve('sourceTexture');
			_this.sourceInvResolutionId = device.scope.resolve('sourceInvResolution');
			_this.sourceInvResolutionValue = new Float32Array(2);
			return _this;
		}
		_inheritsLoose(RenderPassUpsample, _RenderPassShaderQuad);
		var _proto = RenderPassUpsample.prototype;
		_proto.execute = function execute() {
			this.sourceTextureId.setValue(this.sourceTexture);
			this.sourceInvResolutionValue[0] = 1.0 / this.sourceTexture.width;
			this.sourceInvResolutionValue[1] = 1.0 / this.sourceTexture.height;
			this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
			_RenderPassShaderQuad.prototype.execute.call(this);
		};
		return RenderPassUpsample;
	}(RenderPassShaderQuad);

	var RenderPassBloom = function (_RenderPass) {
		function RenderPassBloom(device, sourceTexture, format) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.bloomTexture = void 0;
			_this.blurLevel = 16;
			_this.bloomRenderTarget = void 0;
			_this.textureFormat = void 0;
			_this.renderTargets = [];
			_this._sourceTexture = sourceTexture;
			_this.textureFormat = format;
			_this.bloomRenderTarget = _this.createRenderTarget(0);
			_this.bloomTexture = _this.bloomRenderTarget.colorBuffer;
			return _this;
		}
		_inheritsLoose(RenderPassBloom, _RenderPass);
		var _proto = RenderPassBloom.prototype;
		_proto.destroy = function destroy() {
			this.destroyRenderPasses();
			this.destroyRenderTargets();
		};
		_proto.destroyRenderTargets = function destroyRenderTargets(startIndex) {
			if (startIndex === void 0) {
				startIndex = 0;
			}
			for (var i = startIndex; i < this.renderTargets.length; i++) {
				var rt = this.renderTargets[i];
				rt.destroyTextureBuffers();
				rt.destroy();
			}
			this.renderTargets.length = 0;
		};
		_proto.destroyRenderPasses = function destroyRenderPasses() {
			for (var i = 0; i < this.beforePasses.length; i++) {
				this.beforePasses[i].destroy();
			}
			this.beforePasses.length = 0;
		};
		_proto.createRenderTarget = function createRenderTarget(index) {
			return new RenderTarget({
				depth: false,
				colorBuffer: new Texture(this.device, {
					name: "BloomTexture" + index,
					width: 1,
					height: 1,
					format: this.textureFormat,
					mipmaps: false,
					minFilter: FILTER_LINEAR,
					magFilter: FILTER_LINEAR,
					addressU: ADDRESS_CLAMP_TO_EDGE,
					addressV: ADDRESS_CLAMP_TO_EDGE
				})
			});
		};
		_proto.createRenderTargets = function createRenderTargets(count) {
			for (var i = 0; i < count; i++) {
				var rt = i === 0 ? this.bloomRenderTarget : this.createRenderTarget(i);
				this.renderTargets.push(rt);
			}
		};
		_proto.calcMipLevels = function calcMipLevels(width, height, minSize) {
			var min = Math.min(width, height);
			return Math.floor(Math.log2(min) - Math.log2(minSize));
		};
		_proto.createRenderPasses = function createRenderPasses(numPasses) {
			var device = this.device;
			var passSourceTexture = this._sourceTexture;
			for (var i = 0; i < numPasses; i++) {
				var pass = new RenderPassDownsample(device, passSourceTexture);
				var rt = this.renderTargets[i];
				pass.init(rt, {
					resizeSource: passSourceTexture,
					scaleX: 0.5,
					scaleY: 0.5
				});
				pass.setClearColor(Color.BLACK);
				this.beforePasses.push(pass);
				passSourceTexture = rt.colorBuffer;
			}
			passSourceTexture = this.renderTargets[numPasses - 1].colorBuffer;
			for (var _i = numPasses - 2; _i >= 0; _i--) {
				var _pass = new RenderPassUpsample(device, passSourceTexture);
				var _rt = this.renderTargets[_i];
				_pass.init(_rt);
				_pass.blendState = BlendState.ADDBLEND;
				this.beforePasses.push(_pass);
				passSourceTexture = _rt.colorBuffer;
			}
		};
		_proto.onDisable = function onDisable() {
			var _this$renderTargets$;
			(_this$renderTargets$ = this.renderTargets[0]) == null || _this$renderTargets$.resize(1, 1);
			this.destroyRenderPasses();
			this.destroyRenderTargets(1);
		};
		_proto.frameUpdate = function frameUpdate() {
			_RenderPass.prototype.frameUpdate.call(this);
			var maxNumPasses = this.calcMipLevels(this._sourceTexture.width, this._sourceTexture.height, 1);
			var numPasses = math.clamp(maxNumPasses, 1, this.blurLevel);
			if (this.renderTargets.length !== numPasses) {
				this.destroyRenderPasses();
				this.destroyRenderTargets(1);
				this.createRenderTargets(numPasses);
				this.createRenderPasses(numPasses);
			}
		};
		return RenderPassBloom;
	}(RenderPass);

	var fragmentShader = "\n\t#include \"tonemappingPS\"\n\t#include \"decodePS\"\n\t#include \"gamma2_2PS\"\n\tvarying vec2 uv0;\n\tuniform sampler2D sceneTexture;\n\tuniform vec2 sceneTextureInvRes;\n\t#ifdef BLOOM\n\t\tuniform sampler2D bloomTexture;\n\t\tuniform float bloomIntensity;\n\t#endif\n\t#ifdef DOF\n\t\tuniform sampler2D cocTexture;\n\t\tuniform sampler2D blurTexture;\n\t\tvec3 dofBlur(vec2 uv, out vec2 coc) {\n\t\t\tcoc = texture2DLod(cocTexture, uv, 0.0).rg;\n\t\t\t#if DOF_UPSCALE\n\t\t\t\tvec2 blurTexelSize = 1.0 / vec2(textureSize(blurTexture, 0));\n\t\t\t\tvec3 bilinearBlur = vec3(0.0);\n\t\t\t\tfloat totalWeight = 0.0;\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\t\tvec2 offset = vec2(i, j) * blurTexelSize;\n\t\t\t\t\t\tvec2 cocSample = texture2DLod(cocTexture, uv + offset, 0.0).rg;\n\t\t\t\t\t\tvec3 blurSample = texture2DLod(blurTexture, uv + offset, 0.0).rgb;\n\t\t\t\t\t\tfloat cocWeight = clamp(cocSample.r + cocSample.g, 0.0, 1.0);\n\t\t\t\t\t\tbilinearBlur += blurSample * cocWeight;\n\t\t\t\t\t\ttotalWeight += cocWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (totalWeight > 0.0) {\n\t\t\t\t\tbilinearBlur /= totalWeight;\n\t\t\t\t}\n\t\t\t\treturn bilinearBlur;\n\t\t\t#else\n\t\t\t\treturn texture2DLod(blurTexture, uv, 0.0).rgb;\n\t\t\t#endif\n\t\t}\n\t#endif\n\t#ifdef SSAO\n\t\t#define SSAO_TEXTURE\n\t#endif\n\t#if DEBUG_COMPOSE == ssao\n\t\t#define SSAO_TEXTURE\n\t#endif\n\t#ifdef SSAO_TEXTURE\n\t\tuniform sampler2D ssaoTexture;\n\t#endif\n\t#ifdef GRADING\n\t\tuniform vec3 brightnessContrastSaturation;\n\t\tuniform vec3 tint;\n\t\tvec3 colorGradingHDR(vec3 color, float brt, float sat, float con)\n\t\t{\n\t\t\tcolor *= tint;\n\t\t\tcolor = color * brt;\n\t\t\tfloat grey = dot(color, vec3(0.3, 0.59, 0.11));\n\t\t\tgrey = grey / max(1.0, max(color.r, max(color.g, color.b)));\n\t\t\tcolor = mix(vec3(grey), color, sat);\n\t\t\treturn mix(vec3(0.5), color, con);\n\t\t}\n\t\n\t#endif\n\t#ifdef VIGNETTE\n\t\tuniform vec4 vignetterParams;\n\t\tfloat vignette(vec2 uv) {\n\t\t\tfloat inner = vignetterParams.x;\n\t\t\tfloat outer = vignetterParams.y;\n\t\t\tfloat curvature = vignetterParams.z;\n\t\t\tfloat intensity = vignetterParams.w;\n\t\t\tvec2 curve = pow(abs(uv * 2.0 -1.0), vec2(1.0 / curvature));\n\t\t\tfloat edge = pow(length(curve), curvature);\n\t\t\treturn 1.0 - intensity * smoothstep(inner, outer, edge);\n\t\t}\t\t\n\t#endif\n\t#ifdef FRINGING\n\t\tuniform float fringingIntensity;\n\t\tvec3 fringing(vec2 uv, vec3 color) {\n\t\t\tvec2 centerDistance = uv0 - 0.5;\n\t\t\tvec2 offset = fringingIntensity * pow(centerDistance, vec2(2.0, 2.0));\n\t\t\tcolor.r = texture2D(sceneTexture, uv0 - offset).r;\n\t\t\tcolor.b = texture2D(sceneTexture, uv0 + offset).b;\n\t\t\treturn color;\n\t\t}\n\t#endif\n\t#ifdef CAS\n\t\tuniform float sharpness;\n\t\tfloat maxComponent(float x, float y, float z) { return max(x, max(y, z)); }\n\t\tvec3 toSDR(vec3 c) { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }\n\t\tvec3 toHDR(vec3 c) { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }\n\t\tvec3 cas(vec3 color, vec2 uv, float sharpness) {\n\t\t\tfloat x = sceneTextureInvRes.x;\n\t\t\tfloat y = sceneTextureInvRes.y;\n\t\t\tvec3 a = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, -y), 0.0).rgb);\n\t\t\tvec3 b = toSDR(texture2DLod(sceneTexture, uv + vec2(-x, 0.0), 0.0).rgb);\n\t\t\tvec3 c = toSDR(color.rgb);\n\t\t\tvec3 d = toSDR(texture2DLod(sceneTexture, uv + vec2(x, 0.0), 0.0).rgb);\n\t\t\tvec3 e = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, y), 0.0).rgb);\n\t\t\tfloat min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));\n\t\t\tfloat max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));\n\t\t\tfloat sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);\n\t\t\tfloat w = sharpening_amount * sharpness;\n\t\t\tvec3 res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);\n\t\t\tres = max(res, 0.0);\n\t\t\treturn toHDR(res);\n\t\t}\n\t#endif\n\tvoid main() {\n\t\tvec2 uv = uv0;\n\t\t#ifdef TAA\n\t\t#ifdef WEBGPU\n\t\t\tuv.y = 1.0 - uv.y;\n\t\t#endif\n\t\t#endif\n\t\tvec4 scene = texture2DLod(sceneTexture, uv, 0.0);\n\t\tvec3 result = scene.rgb;\n\t\t#ifdef CAS\n\t\t\tresult = cas(result, uv, sharpness);\n\t\t#endif\n\t\t#ifdef DOF\n\t\t\tvec2 coc;\n\t\t\tvec3 blur = dofBlur(uv, coc);\n\t\t\tresult = mix(result, blur, coc.r + coc.g);\n\t\t#endif\n\t\t#ifdef SSAO_TEXTURE\n\t\t\tmediump float ssao = texture2DLod(ssaoTexture, uv0, 0.0).r;\n\t\t#endif\n\t\t#ifdef SSAO\n\t\t\tresult *= ssao;\n\t\t#endif\n\t\t#ifdef FRINGING\n\t\t\tresult = fringing(uv, result);\n\t\t#endif\n\t\t#ifdef BLOOM\n\t\t\tvec3 bloom = texture2DLod(bloomTexture, uv, 0.0).rgb;\n\t\t\tresult += bloom * bloomIntensity;\n\t\t#endif\n\t\t#ifdef GRADING\n\t\t\tresult = colorGradingHDR(result, brightnessContrastSaturation.x, brightnessContrastSaturation.z, brightnessContrastSaturation.y);\n\t\t#endif\n\t\tresult = toneMap(result);\n\t\t#ifdef VIGNETTE\n\t\t\tmediump float vig = vignette(uv);\n\t\t\tresult *= vig;\n\t\t#endif\n\t\t#ifdef DEBUG_COMPOSE\n\t\t\t#ifdef BLOOM\n\t\t\t\t#if DEBUG_COMPOSE == bloom\n\t\t\t\t\tresult = bloom * bloomIntensity;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t\t#ifdef DOF\n\t\t\t\t#ifdef DEBUG_COMPOSE == dofcoc\n\t\t\t\t\tresult = vec3(coc, 0.0);\n\t\t\t\t#endif\n\t\t\t\t#ifdef DEBUG_COMPOSE == dofblur\n\t\t\t\t\tresult = blur;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t\t#if DEBUG_COMPOSE == ssao\n\t\t\t\tresult = vec3(ssao);\n\t\t\t#endif\n\t\t\t#if DEBUG_COMPOSE == vignette\n\t\t\t\tresult = vec3(vig);\n\t\t\t#endif\n\t\t\t#if DEBUG_COMPOSE == scene\n\t\t\t\tresult = scene.rgb;\n\t\t\t#endif\n\t\t#endif\n\t\t#ifdef GAMMA_CORRECT_OUTPUT\n\t\t\tresult = gammaCorrectOutput(result);\n\t\t#endif\n\t\tgl_FragColor = vec4(result, scene.a);\n\t}\n";
	var RenderPassCompose = function (_RenderPassShaderQuad) {
		function RenderPassCompose(graphicsDevice) {
			var _this;
			_this = _RenderPassShaderQuad.call(this, graphicsDevice) || this;
			_this.sceneTexture = null;
			_this.bloomIntensity = 0.01;
			_this._bloomTexture = null;
			_this._cocTexture = null;
			_this.blurTexture = null;
			_this.blurTextureUpscale = false;
			_this._ssaoTexture = null;
			_this._toneMapping = TONEMAP_LINEAR;
			_this._gradingEnabled = false;
			_this.gradingSaturation = 1;
			_this.gradingContrast = 1;
			_this.gradingBrightness = 1;
			_this.gradingTint = new Color(1, 1, 1, 1);
			_this._shaderDirty = true;
			_this._vignetteEnabled = false;
			_this.vignetteInner = 0.5;
			_this.vignetteOuter = 1.0;
			_this.vignetteCurvature = 0.5;
			_this.vignetteIntensity = 0.3;
			_this._fringingEnabled = false;
			_this.fringingIntensity = 10;
			_this._taaEnabled = false;
			_this._sharpness = 0.5;
			_this._srgb = false;
			_this._key = '';
			_this._debug = null;
			var scope = graphicsDevice.scope;
			_this.sceneTextureId = scope.resolve('sceneTexture');
			_this.bloomTextureId = scope.resolve('bloomTexture');
			_this.cocTextureId = scope.resolve('cocTexture');
			_this.ssaoTextureId = scope.resolve('ssaoTexture');
			_this.blurTextureId = scope.resolve('blurTexture');
			_this.bloomIntensityId = scope.resolve('bloomIntensity');
			_this.bcsId = scope.resolve('brightnessContrastSaturation');
			_this.tintId = scope.resolve('tint');
			_this.vignetterParamsId = scope.resolve('vignetterParams');
			_this.fringingIntensityId = scope.resolve('fringingIntensity');
			_this.sceneTextureInvResId = scope.resolve('sceneTextureInvRes');
			_this.sceneTextureInvResValue = new Float32Array(2);
			_this.sharpnessId = scope.resolve('sharpness');
			return _this;
		}
		_inheritsLoose(RenderPassCompose, _RenderPassShaderQuad);
		var _proto = RenderPassCompose.prototype;
		_proto.postInit = function postInit() {
			this.setClearColor(Color.BLACK);
			this.setClearDepth(1.0);
			this.setClearStencil(0);
		};
		_proto.frameUpdate = function frameUpdate() {
			var _this$renderTarget;
			var rt = (_this$renderTarget = this.renderTarget) != null ? _this$renderTarget : this.device.backBuffer;
			var srgb = rt.isColorBufferSrgb(0);
			if (this._srgb !== srgb) {
				this._srgb = srgb;
				this._shaderDirty = true;
			}
			if (this._shaderDirty) {
				var _this$_debug;
				this._shaderDirty = false;
				var key = "" + this.toneMapping + ("-" + (this.bloomTexture ? 'bloom' : 'nobloom')) + ("-" + (this.cocTexture ? 'dof' : 'nodof')) + ("-" + (this.blurTextureUpscale ? 'dofupscale' : '')) + ("-" + (this.ssaoTexture ? 'ssao' : 'nossao')) + ("-" + (this.gradingEnabled ? 'grading' : 'nograding')) + ("-" + (this.vignetteEnabled ? 'vignette' : 'novignette')) + ("-" + (this.fringingEnabled ? 'fringing' : 'nofringing')) + ("-" + (this.taaEnabled ? 'taa' : 'notaa')) + ("-" + (this.isSharpnessEnabled ? 'cas' : 'nocas')) + ("-" + (this._srgb ? 'srgb' : 'linear')) + ("-" + ((_this$_debug = this._debug) != null ? _this$_debug : ''));
				if (this._key !== key) {
					this._key = key;
					var defines = new Map();
					defines.set('TONEMAP', tonemapNames[this.toneMapping]);
					if (this.bloomTexture) defines.set('BLOOM', true);
					if (this.cocTexture) defines.set('DOF', true);
					if (this.blurTextureUpscale) defines.set('DOF_UPSCALE', true);
					if (this.ssaoTexture) defines.set('SSAO', true);
					if (this.gradingEnabled) defines.set('GRADING', true);
					if (this.vignetteEnabled) defines.set('VIGNETTE', true);
					if (this.fringingEnabled) defines.set('FRINGING', true);
					if (this.taaEnabled) defines.set('TAA', true);
					if (this.isSharpnessEnabled) defines.set('CAS', true);
					if (!this._srgb) defines.set('GAMMA_CORRECT_OUTPUT', true);
					if (this._debug) defines.set('DEBUG_COMPOSE', this._debug);
					var includes = new Map(Object.entries(shaderChunks));
					this.shader = this.createQuadShader("ComposeShader-" + key, fragmentShader, {
						fragmentIncludes: includes,
						fragmentDefines: defines
					});
				}
			}
		};
		_proto.execute = function execute() {
			this.sceneTextureId.setValue(this.sceneTexture);
			this.sceneTextureInvResValue[0] = 1.0 / this.sceneTexture.width;
			this.sceneTextureInvResValue[1] = 1.0 / this.sceneTexture.height;
			this.sceneTextureInvResId.setValue(this.sceneTextureInvResValue);
			if (this._bloomTexture) {
				this.bloomTextureId.setValue(this._bloomTexture);
				this.bloomIntensityId.setValue(this.bloomIntensity);
			}
			if (this._cocTexture) {
				this.cocTextureId.setValue(this._cocTexture);
				this.blurTextureId.setValue(this.blurTexture);
			}
			if (this._ssaoTexture) {
				this.ssaoTextureId.setValue(this._ssaoTexture);
			}
			if (this._gradingEnabled) {
				this.bcsId.setValue([this.gradingBrightness, this.gradingContrast, this.gradingSaturation]);
				this.tintId.setValue([this.gradingTint.r, this.gradingTint.g, this.gradingTint.b]);
			}
			if (this._vignetteEnabled) {
				this.vignetterParamsId.setValue([this.vignetteInner, this.vignetteOuter, this.vignetteCurvature, this.vignetteIntensity]);
			}
			if (this._fringingEnabled) {
				this.fringingIntensityId.setValue(this.fringingIntensity / 1024);
			}
			if (this.isSharpnessEnabled) {
				this.sharpnessId.setValue(math.lerp(-0.125, -0.2, this.sharpness));
			}
			_RenderPassShaderQuad.prototype.execute.call(this);
		};
		return _createClass(RenderPassCompose, [{
			key: "debug",
			get: function get() {
				return this._debug;
			},
			set: function set(value) {
				if (this._debug !== value) {
					this._debug = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "bloomTexture",
			get: function get() {
				return this._bloomTexture;
			},
			set: function set(value) {
				if (this._bloomTexture !== value) {
					this._bloomTexture = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "cocTexture",
			get: function get() {
				return this._cocTexture;
			},
			set: function set(value) {
				if (this._cocTexture !== value) {
					this._cocTexture = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "ssaoTexture",
			get: function get() {
				return this._ssaoTexture;
			},
			set: function set(value) {
				if (this._ssaoTexture !== value) {
					this._ssaoTexture = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "taaEnabled",
			get: function get() {
				return this._taaEnabled;
			},
			set: function set(value) {
				if (this._taaEnabled !== value) {
					this._taaEnabled = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "gradingEnabled",
			get: function get() {
				return this._gradingEnabled;
			},
			set: function set(value) {
				if (this._gradingEnabled !== value) {
					this._gradingEnabled = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "vignetteEnabled",
			get: function get() {
				return this._vignetteEnabled;
			},
			set: function set(value) {
				if (this._vignetteEnabled !== value) {
					this._vignetteEnabled = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "fringingEnabled",
			get: function get() {
				return this._fringingEnabled;
			},
			set: function set(value) {
				if (this._fringingEnabled !== value) {
					this._fringingEnabled = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "toneMapping",
			get: function get() {
				return this._toneMapping;
			},
			set: function set(value) {
				if (this._toneMapping !== value) {
					this._toneMapping = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "sharpness",
			get: function get() {
				return this._sharpness;
			},
			set: function set(value) {
				if (this._sharpness !== value) {
					this._sharpness = value;
					this._shaderDirty = true;
				}
			}
		}, {
			key: "isSharpnessEnabled",
			get: function get() {
				return this._sharpness > 0;
			}
		}]);
	}(RenderPassShaderQuad);

	var fs$1 = "\n\tuniform sampler2D sourceTexture;\n\tuniform sampler2D historyTexture;\n\tuniform mat4 matrix_viewProjectionPrevious;\n\tuniform mat4 matrix_viewProjectionInverse;\n\tuniform vec4 jitters;\n\tuniform vec2 textureSize;\n\tvarying vec2 uv0;\n\tvec2 reproject(vec2 uv, float depth) {\n\t\t#ifndef WEBGPU\n\t\t\tdepth = depth * 2.0 - 1.0;\n\t\t#endif\n\t\tvec4 ndc = vec4(uv * 2.0 - 1.0, depth, 1.0);\n\t\tndc.xy -= jitters.xy;\n\t\tvec4 worldPosition = matrix_viewProjectionInverse * ndc;\n\t\tworldPosition /= worldPosition.w;\n\t\n\t\tvec4 screenPrevious = matrix_viewProjectionPrevious * worldPosition;\n\t\treturn (screenPrevious.xy / screenPrevious.w) * 0.5 + 0.5;\n\t}\n\tvec4 colorClamp(vec2 uv, vec4 historyColor) {\n\t\tvec3 minColor = vec3(9999.0);\n\t\tvec3 maxColor = vec3(-9999.0);\n \n\t\tfor(float x = -1.0; x <= 1.0; ++x)\n\t\t{\n\t\t\tfor(float y = -1.0; y <= 1.0; ++y)\n\t\t\t{\n\t\t\t\tvec3 color = texture2D(sourceTexture, uv + vec2(x, y) / textureSize).rgb;\n\t\t\t\tminColor = min(minColor, color);\n\t\t\t\tmaxColor = max(maxColor, color);\n\t\t\t}\n\t\t}\n \n\t\tvec3 clamped = clamp(historyColor.rgb, minColor, maxColor);\n\t\treturn vec4(clamped, historyColor.a);\n\t}\n\tvoid main()\n\t{\n\t\tvec2 uv = uv0;\n\t\t#ifdef WEBGPU\n\t\t\tuv.y = 1.0 - uv.y;\n\t\t#endif\n\t\tvec4 srcColor = texture2D(sourceTexture, uv);\n\t\tfloat linearDepth = getLinearScreenDepth(uv0);\n\t\tfloat depth = delinearizeDepth(linearDepth);\n\t\tvec2 historyUv = reproject(uv0, depth);\n\t\t#ifdef QUALITY_HIGH\n\t\t\tvec4 historyColor = SampleTextureCatmullRom(TEXTURE_PASS(historyTexture), historyUv, textureSize);\n\t\t#else\n\t\t\tvec4 historyColor = texture2D(historyTexture, historyUv);\n\t\t#endif\n\t\tvec4 historyColorClamped = colorClamp(uv, historyColor);\n\t\tfloat mixFactor = (historyUv.x < 0.0 || historyUv.x > 1.0 || historyUv.y < 0.0 || historyUv.y > 1.0) ?\n\t\t\t1.0 : 0.05;\n\t\tgl_FragColor = mix(historyColorClamped, srcColor, mixFactor);\n\t}\n";
	var RenderPassTAA = function (_RenderPassShaderQuad) {
		function RenderPassTAA(device, sourceTexture, cameraComponent) {
			var _this;
			_this = _RenderPassShaderQuad.call(this, device) || this;
			_this.historyIndex = 0;
			_this.historyTexture = null;
			_this.historyTextures = [];
			_this.historyRenderTargets = [];
			_this.sourceTexture = sourceTexture;
			_this.cameraComponent = cameraComponent;
			var defines = "\n\t\t\t#define QUALITY_HIGH\n\t\t";
			var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
			var fsChunks = shaderChunks.sampleCatmullRomPS + screenDepth;
			_this.shader = _this.createQuadShader('TaaResolveShader', defines + fsChunks + fs$1);
			var scope = device.scope;
			_this.sourceTextureId = scope.resolve('sourceTexture');
			_this.textureSizeId = scope.resolve('textureSize');
			_this.textureSize = new Float32Array(2);
			_this.historyTextureId = scope.resolve('historyTexture');
			_this.viewProjPrevId = scope.resolve('matrix_viewProjectionPrevious');
			_this.viewProjInvId = scope.resolve('matrix_viewProjectionInverse');
			_this.jittersId = scope.resolve('jitters');
			_this.cameraParams = new Float32Array(4);
			_this.cameraParamsId = scope.resolve('camera_params');
			_this.setup();
			return _this;
		}
		_inheritsLoose(RenderPassTAA, _RenderPassShaderQuad);
		var _proto = RenderPassTAA.prototype;
		_proto.destroy = function destroy() {
			if (this.renderTarget) {
				this.renderTarget.destroyTextureBuffers();
				this.renderTarget.destroy();
				this.renderTarget = null;
			}
		};
		_proto.setup = function setup() {
			for (var i = 0; i < 2; ++i) {
				this.historyTextures[i] = new Texture(this.device, {
					name: "TAA-History-" + i,
					width: 4,
					height: 4,
					format: this.sourceTexture.format,
					mipmaps: false,
					minFilter: FILTER_LINEAR,
					magFilter: FILTER_LINEAR,
					addressU: ADDRESS_CLAMP_TO_EDGE,
					addressV: ADDRESS_CLAMP_TO_EDGE
				});
				this.historyRenderTargets[i] = new RenderTarget({
					colorBuffer: this.historyTextures[i],
					depth: false
				});
			}
			this.historyTexture = this.historyTextures[0];
			this.init(this.historyRenderTargets[0], {
				resizeSource: this.sourceTexture
			});
		};
		_proto.before = function before() {
			this.sourceTextureId.setValue(this.sourceTexture);
			this.historyTextureId.setValue(this.historyTextures[1 - this.historyIndex]);
			this.textureSize[0] = this.sourceTexture.width;
			this.textureSize[1] = this.sourceTexture.height;
			this.textureSizeId.setValue(this.textureSize);
			var camera = this.cameraComponent.camera;
			this.viewProjPrevId.setValue(camera._viewProjPrevious.data);
			this.viewProjInvId.setValue(camera._viewProjInverse.data);
			this.jittersId.setValue(camera._jitters);
			var f = camera._farClip;
			this.cameraParams[0] = 1 / f;
			this.cameraParams[1] = f;
			this.cameraParams[2] = camera._nearClip;
			this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
			this.cameraParamsId.setValue(this.cameraParams);
		};
		_proto.update = function update() {
			this.historyIndex = 1 - this.historyIndex;
			this.historyTexture = this.historyTextures[this.historyIndex];
			this.renderTarget = this.historyRenderTargets[this.historyIndex];
			return this.historyTexture;
		};
		return RenderPassTAA;
	}(RenderPassShaderQuad);

	var RenderPassCoC = function (_RenderPassShaderQuad) {
		function RenderPassCoC(device, cameraComponent, nearBlur) {
			var _this;
			_this = _RenderPassShaderQuad.call(this, device) || this;
			_this.focusDistance = void 0;
			_this.focusRange = void 0;
			_this.cameraComponent = cameraComponent;
			var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
			_this.shader = _this.createQuadShader("CocShader-" + nearBlur, "\n\t\t\t" + (nearBlur ? '#define NEAR_BLUR' : '') + "\n\t\t\t" + screenDepth + "\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform vec3 params;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tfloat depth = getLinearScreenDepth(uv0);\n\t\t\t\tfloat focusDistance = params.x;\n\t\t\t\tfloat focusRange = params.y;\n\t\t\t\tfloat invRange = params.z;\n\t\t\t\tfloat farRange = focusDistance + focusRange * 0.5;\n\t\t\t\t\n\t\t\t\tfloat cocFar = min((depth - farRange) * invRange, 1.0);\n\t\t\t\t#ifdef NEAR_BLUR\n\t\t\t\t\tfloat nearRange = focusDistance - focusRange * 0.5;\n\t\t\t\t\tfloat cocNear = min((nearRange - depth) * invRange, 1.0);\n\t\t\t\t#else\n\t\t\t\t\tfloat cocNear = 0.0;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4(cocFar, cocNear, 0.0, 0.0);\n\t\t\t}");
			_this.paramsId = device.scope.resolve('params');
			_this.paramsValue = new Float32Array(3);
			_this.cameraParams = new Float32Array(4);
			_this.cameraParamsId = device.scope.resolve('camera_params');
			return _this;
		}
		_inheritsLoose(RenderPassCoC, _RenderPassShaderQuad);
		var _proto = RenderPassCoC.prototype;
		_proto.execute = function execute() {
			var paramsValue = this.paramsValue,
				focusRange = this.focusRange;
			paramsValue[0] = this.focusDistance + 0.001;
			paramsValue[1] = focusRange;
			paramsValue[2] = 1 / focusRange;
			this.paramsId.setValue(paramsValue);
			var camera = this.cameraComponent.camera;
			var f = camera._farClip;
			this.cameraParams[0] = 1 / f;
			this.cameraParams[1] = f;
			this.cameraParams[2] = camera._nearClip;
			this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
			this.cameraParamsId.setValue(this.cameraParams);
			_RenderPassShaderQuad.prototype.execute.call(this);
		};
		return RenderPassCoC;
	}(RenderPassShaderQuad);

	var RenderPassDofBlur = function (_RenderPassShaderQuad) {
		function RenderPassDofBlur(device, nearTexture, farTexture, cocTexture) {
			var _this;
			_this = _RenderPassShaderQuad.call(this, device) || this;
			_this.blurRadiusNear = 1;
			_this.blurRadiusFar = 1;
			_this._blurRings = 3;
			_this._blurRingPoints = 3;
			_this.nearTexture = nearTexture;
			_this.farTexture = farTexture;
			_this.cocTexture = cocTexture;
			var scope = device.scope;
			_this.kernelId = scope.resolve('kernel[0]');
			_this.kernelCountId = scope.resolve('kernelCount');
			_this.blurRadiusNearId = scope.resolve('blurRadiusNear');
			_this.blurRadiusFarId = scope.resolve('blurRadiusFar');
			_this.nearTextureId = scope.resolve('nearTexture');
			_this.farTextureId = scope.resolve('farTexture');
			_this.cocTextureId = scope.resolve('cocTexture');
			return _this;
		}
		_inheritsLoose(RenderPassDofBlur, _RenderPassShaderQuad);
		var _proto = RenderPassDofBlur.prototype;
		_proto.createShader = function createShader() {
			this.kernel = new Float32Array(Kernel.concentric(this.blurRings, this.blurRingPoints));
			var kernelCount = this.kernel.length >> 1;
			var nearBlur = this.nearTexture !== null;
			var shaderName = "DofBlurShader-" + kernelCount + "-" + (nearBlur ? 'nearBlur' : 'noNearBlur');
			this.shader = this.createQuadShader(shaderName, "\n\t\t\t" + (nearBlur ? '#define NEAR_BLUR' : '') + "\n\t\t\t#if defined(NEAR_BLUR)\n\t\t\t\tuniform sampler2D nearTexture;\n\t\t\t#endif\n\t\t\tuniform sampler2D farTexture;\n\t\t\tuniform sampler2D cocTexture;\n\t\t\tuniform float blurRadiusNear;\n\t\t\tuniform float blurRadiusFar;\n\t\t\tuniform vec2 kernel[" + kernelCount + "];\n\t\t\tvarying vec2 uv0;\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvec2 coc = texture2D(cocTexture, uv0).rg;\n\t\t\t\tfloat cocFar = coc.r;\n\t\t\t\tvec3 sum = vec3(0.0, 0.0, 0.0);\n\t\t\t\t#if defined(NEAR_BLUR)\n\t\t\t\t\tfloat cocNear = coc.g;\n\t\t\t\t\tif (cocNear > 0.0001) {\n\t\t\t\t\t\tivec2 nearTextureSize = textureSize(nearTexture, 0);\n\t\t\t\t\t\tvec2 step = cocNear * blurRadiusNear / vec2(nearTextureSize);\n\t\t\t\t\t\tfor (int i = 0; i < " + kernelCount + "; i++) {\n\t\t\t\t\t\t\tvec2 uv = uv0 + step * kernel[i];\n\t\t\t\t\t\t\tvec3 tap = texture2DLod(nearTexture, uv, 0.0).rgb;\n\t\t\t\t\t\t\tsum += tap.rgb;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum *= " + 1.0 / kernelCount + ";\n\t\t\t\t\t} else\n\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tif (cocFar > 0.0001) {\n\t\t\t\t\tivec2 farTextureSize = textureSize(farTexture, 0);\n\t\t\t\t\tvec2 step = cocFar * blurRadiusFar / vec2(farTextureSize);\n\t\t\t\t\tfloat sumCoC = 0.0; \n\t\t\t\t\tfor (int i = 0; i < " + kernelCount + "; i++) {\n\t\t\t\t\t\tvec2 uv = uv0 + step * kernel[i];\n\t\t\t\t\t\tvec3 tap = texture2DLod(farTexture, uv, 0.0).rgb;\n\t\t\t\t\t\tfloat cocThis = texture2DLod(cocTexture, uv, 0.0).r;\n\t\t\t\t\t\ttap *= cocThis;\n\t\t\t\t\t\tsumCoC += cocThis;\n\t\t\t\t\t\tsum += tap.rgb;\n\t\t\t\t\t}\n\t\t\t\t\tif (sumCoC > 0.0)\n\t\t\t\t\t\tsum /= sumCoC;\n\t\t\t\t\tsum /= cocFar;\n\t\t\t\t}\n\t\t\t\tpcFragColor0 = vec4(sum, 1.0);\n\t\t\t}");
		};
		_proto.execute = function execute() {
			if (!this.shader) {
				this.createShader();
			}
			this.nearTextureId.setValue(this.nearTexture);
			this.farTextureId.setValue(this.farTexture);
			this.cocTextureId.setValue(this.cocTexture);
			this.kernelId.setValue(this.kernel);
			this.kernelCountId.setValue(this.kernel.length >> 1);
			this.blurRadiusNearId.setValue(this.blurRadiusNear);
			this.blurRadiusFarId.setValue(this.blurRadiusFar);
			_RenderPassShaderQuad.prototype.execute.call(this);
		};
		return _createClass(RenderPassDofBlur, [{
			key: "blurRings",
			get: function get() {
				return this._blurRings;
			},
			set: function set(value) {
				if (this._blurRings !== value) {
					this._blurRings = value;
					this.shader = null;
				}
			}
		}, {
			key: "blurRingPoints",
			get: function get() {
				return this._blurRingPoints;
			},
			set: function set(value) {
				if (this._blurRingPoints !== value) {
					this._blurRingPoints = value;
					this.shader = null;
				}
			}
		}]);
	}(RenderPassShaderQuad);

	var RenderPassDof = function (_RenderPass) {
		function RenderPassDof(device, cameraComponent, sceneTexture, sceneTextureHalf, highQuality, nearBlur) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.focusDistance = 100;
			_this.focusRange = 50;
			_this.blurRadius = 1;
			_this.blurRings = 3;
			_this.blurRingPoints = 3;
			_this.highQuality = true;
			_this.cocTexture = null;
			_this.blurTexture = null;
			_this.cocPass = null;
			_this.farPass = null;
			_this.blurPass = null;
			_this.highQuality = highQuality;
			_this.cocPass = _this.setupCocPass(device, cameraComponent, sceneTexture, nearBlur);
			_this.beforePasses.push(_this.cocPass);
			var sourceTexture = highQuality ? sceneTexture : sceneTextureHalf;
			_this.farPass = _this.setupFarPass(device, sourceTexture, 0.5);
			_this.beforePasses.push(_this.farPass);
			_this.blurPass = _this.setupBlurPass(device, sceneTextureHalf, nearBlur, highQuality ? 2 : 0.5);
			_this.beforePasses.push(_this.blurPass);
			return _this;
		}
		_inheritsLoose(RenderPassDof, _RenderPass);
		var _proto = RenderPassDof.prototype;
		_proto.destroy = function destroy() {
			this.destroyRenderPasses();
			this.cocPass = null;
			this.farPass = null;
			this.blurPass = null;
			this.destroyRT(this.cocRT);
			this.destroyRT(this.farRt);
			this.destroyRT(this.blurRt);
			this.cocRT = null;
			this.farRt = null;
			this.blurRt = null;
		};
		_proto.destroyRenderPasses = function destroyRenderPasses() {
			for (var i = 0; i < this.beforePasses.length; i++) {
				this.beforePasses[i].destroy();
			}
			this.beforePasses.length = 0;
		};
		_proto.destroyRT = function destroyRT(rt) {
			if (rt) {
				rt.destroyTextureBuffers();
				rt.destroy();
			}
		};
		_proto.setupCocPass = function setupCocPass(device, cameraComponent, sourceTexture, nearBlur) {
			var format = nearBlur ? PIXELFORMAT_RG8 : PIXELFORMAT_R8;
			this.cocRT = this.createRenderTarget('CoCTexture', format);
			this.cocTexture = this.cocRT.colorBuffer;
			var cocPass = new RenderPassCoC(device, cameraComponent, nearBlur);
			cocPass.init(this.cocRT, {
				resizeSource: sourceTexture
			});
			cocPass.setClearColor(Color.BLACK);
			return cocPass;
		};
		_proto.setupFarPass = function setupFarPass(device, sourceTexture, scale) {
			this.farRt = this.createRenderTarget('FarDofTexture', sourceTexture.format);
			var farPass = new RenderPassDownsample(device, sourceTexture, {
				boxFilter: true,
				premultiplyTexture: this.cocTexture,
				premultiplySrcChannel: 'r'
			});
			farPass.init(this.farRt, {
				resizeSource: sourceTexture,
				scaleX: scale,
				scaleY: scale
			});
			farPass.setClearColor(Color.BLACK);
			return farPass;
		};
		_proto.setupBlurPass = function setupBlurPass(device, nearTexture, nearBlur, scale) {
			var _this$farRt;
			var farTexture = (_this$farRt = this.farRt) == null ? void 0 : _this$farRt.colorBuffer;
			this.blurRt = this.createRenderTarget('DofBlurTexture', nearTexture.format);
			this.blurTexture = this.blurRt.colorBuffer;
			var blurPass = new RenderPassDofBlur(device, nearBlur ? nearTexture : null, farTexture, this.cocTexture);
			blurPass.init(this.blurRt, {
				resizeSource: nearTexture,
				scaleX: scale,
				scaleY: scale
			});
			blurPass.setClearColor(Color.BLACK);
			return blurPass;
		};
		_proto.createTexture = function createTexture(name, format) {
			return new Texture(this.device, {
				name: name,
				width: 1,
				height: 1,
				format: format,
				mipmaps: false,
				minFilter: FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
		};
		_proto.createRenderTarget = function createRenderTarget(name, format) {
			return new RenderTarget({
				colorBuffer: this.createTexture(name, format),
				depth: false,
				stencil: false
			});
		};
		_proto.frameUpdate = function frameUpdate() {
			_RenderPass.prototype.frameUpdate.call(this);
			this.cocPass.focusDistance = this.focusDistance;
			this.cocPass.focusRange = this.focusRange;
			this.blurPass.blurRadiusNear = this.blurRadius;
			this.blurPass.blurRadiusFar = this.blurRadius * (this.highQuality ? 1 : 0.5);
			this.blurPass.blurRings = this.blurRings;
			this.blurPass.blurRingPoints = this.blurRingPoints;
		};
		return RenderPassDof;
	}(RenderPass);

	var tempMeshInstances = [];
	var DEPTH_UNIFORM_NAME = 'uSceneDepthMap';
	var RenderPassPrepass = function (_RenderPass) {
		function RenderPassPrepass(device, scene, renderer, camera, options) {
			var _this;
			_this = _RenderPass.call(this, device) || this;
			_this.viewBindGroups = [];
			_this.linearDepthTexture = void 0;
			_this.linearDepthClearValue = new Color(0, 0, 0, 0);
			_this.scene = scene;
			_this.renderer = renderer;
			_this.camera = camera;
			_this.setupRenderTarget(options);
			return _this;
		}
		_inheritsLoose(RenderPassPrepass, _RenderPass);
		var _proto = RenderPassPrepass.prototype;
		_proto.destroy = function destroy() {
			var _this$renderTarget, _this$linearDepthText;
			_RenderPass.prototype.destroy.call(this);
			(_this$renderTarget = this.renderTarget) == null || _this$renderTarget.destroy();
			this.renderTarget = null;
			(_this$linearDepthText = this.linearDepthTexture) == null || _this$linearDepthText.destroy();
			this.linearDepthTexture = null;
			this.viewBindGroups.forEach(function (bg) {
				bg.defaultUniformBuffer.destroy();
				bg.destroy();
			});
			this.viewBindGroups.length = 0;
		};
		_proto.setupRenderTarget = function setupRenderTarget(options) {
			var device = this.device;
			this.linearDepthFormat = device.textureFloatRenderable ? PIXELFORMAT_R32F : PIXELFORMAT_RGBA8;
			this.linearDepthTexture = new Texture(device, {
				name: 'SceneLinearDepthTexture',
				width: 1,
				height: 1,
				format: this.linearDepthFormat,
				mipmaps: false,
				minFilter: FILTER_NEAREST,
				magFilter: FILTER_NEAREST,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			var renderTarget = new RenderTarget({
				name: 'PrepassRT',
				colorBuffer: this.linearDepthTexture,
				depth: true,
				samples: 1
			});
			this.camera.shaderParams.sceneDepthMapLinear = true;
			this.init(renderTarget, options);
		};
		_proto.after = function after() {
			this.device.scope.resolve(DEPTH_UNIFORM_NAME).setValue(this.linearDepthTexture);
		};
		_proto.execute = function execute() {
			var renderer = this.renderer,
				scene = this.scene,
				renderTarget = this.renderTarget;
			var camera = this.camera.camera;
			var layers = scene.layers.layerList;
			var subLayerEnabled = scene.layers.subLayerEnabled;
			var isTransparent = scene.layers.subLayerList;
			for (var i = 0; i < layers.length; i++) {
				var layer = layers[i];
				if (layer.id === LAYERID_DEPTH) {
					break;
				}
				if (layer.enabled && subLayerEnabled[i]) {
					if (layer.camerasSet.has(camera)) {
						var culledInstances = layer.getCulledInstances(camera);
						var meshInstances = isTransparent[i] ? culledInstances.transparent : culledInstances.opaque;
						for (var j = 0; j < meshInstances.length; j++) {
							var _meshInstance$materia;
							var meshInstance = meshInstances[j];
							if ((_meshInstance$materia = meshInstance.material) != null && _meshInstance$materia.depthWrite) {
								tempMeshInstances.push(meshInstance);
							}
						}
						renderer.renderForwardLayer(camera, renderTarget, null, undefined, SHADER_PREPASS, this.viewBindGroups, {
							meshInstances: tempMeshInstances
						});
						tempMeshInstances.length = 0;
					}
				}
			}
		};
		_proto.frameUpdate = function frameUpdate() {
			_RenderPass.prototype.frameUpdate.call(this);
			var camera = this.camera;
			this.setClearDepth(camera.clearDepthBuffer ? 1 : undefined);
			var clearValue;
			if (camera.clearDepthBuffer) {
				var farClip = camera.farClip - Number.MIN_VALUE;
				clearValue = this.linearDepthClearValue;
				if (this.linearDepthFormat === PIXELFORMAT_R32F) {
					clearValue.r = farClip;
				} else {
					FloatPacking.float2RGBA8(farClip, clearValue);
				}
			}
			this.setClearColor(clearValue);
		};
		return RenderPassPrepass;
	}(RenderPass);

	var RenderPassDepthAwareBlur = function (_RenderPassShaderQuad) {
		function RenderPassDepthAwareBlur(device, sourceTexture, cameraComponent, horizontal) {
			var _this;
			_this = _RenderPassShaderQuad.call(this, device) || this;
			_this.sourceTexture = sourceTexture;
			var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
			_this.shader = _this.createQuadShader("DepthAware" + (horizontal ? 'Horizontal' : 'Vertical') + "BlurShader", screenDepth + "\n\t\t\t" + (horizontal ? '#define HORIZONTAL' : '') + "\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform sampler2D sourceTexture;\n\t\t\tuniform vec2 sourceInvResolution;\n\t\t\tuniform int filterSize;\n\t\t\tfloat random(const highp vec2 w) {\n\t\t\t\tconst vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\t\t\treturn fract(m.z * fract(dot(w, m.xy)));\n\t\t\t}\n\t\t\tmediump float bilateralWeight(in mediump float depth, in mediump float sampleDepth) {\n\t\t\t\tmediump float diff = (sampleDepth - depth);\n\t\t\t\treturn max(0.0, 1.0 - diff * diff);\n\t\t\t}\n\t\t\tvoid tap(inout float sum, inout float totalWeight, float weight, float depth, vec2 position) {\n\t\t\t\tmediump float color = texture2D(sourceTexture, position).r;\n\t\t\t\tmediump float textureDepth = -getLinearScreenDepth(position);\n\t\t\t\n\t\t\t\tmediump float bilateral = bilateralWeight(depth, textureDepth);\n\t\t\t\tbilateral *= weight;\n\t\t\t\tsum += color * bilateral;\n\t\t\t\ttotalWeight += bilateral;\n\t\t\t}\n\t\t\tvoid main() {\n\t\t\t\tmediump float depth = -getLinearScreenDepth(uv0);\n\t\t\t\tmediump float totalWeight = 1.0;\n\t\t\t\tmediump float color = texture2D(sourceTexture, uv0 ).r;\n\t\t\t\tmediump float sum = color * totalWeight;\n\t\t\t\tfor (mediump int i = -filterSize; i <= filterSize; i++) {\n\t\t\t\t\tmediump float weight = 1.0;\n\t\t\t\t\t#ifdef HORIZONTAL\n\t\t\t\t\t\tvec2 offset = vec2(i, 0) * sourceInvResolution;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec2 offset = vec2(0, i) * sourceInvResolution;\n\t\t\t\t\t#endif\n\t\t\t\t\ttap(sum, totalWeight, weight, depth, uv0 + offset);\n\t\t\t\t}\n\t\t\t\tmediump float ao = sum / totalWeight;\n\t\t\t\tgl_FragColor.r = ao;\n\t\t\t}\n\t\t");
			var scope = _this.device.scope;
			_this.sourceTextureId = scope.resolve('sourceTexture');
			_this.sourceInvResolutionId = scope.resolve('sourceInvResolution');
			_this.sourceInvResolutionValue = new Float32Array(2);
			_this.filterSizeId = scope.resolve('filterSize');
			return _this;
		}
		_inheritsLoose(RenderPassDepthAwareBlur, _RenderPassShaderQuad);
		var _proto = RenderPassDepthAwareBlur.prototype;
		_proto.execute = function execute() {
			this.filterSizeId.setValue(4);
			this.sourceTextureId.setValue(this.sourceTexture);
			var _this$sourceTexture = this.sourceTexture,
				width = _this$sourceTexture.width,
				height = _this$sourceTexture.height;
			this.sourceInvResolutionValue[0] = 1.0 / width;
			this.sourceInvResolutionValue[1] = 1.0 / height;
			this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);
			_RenderPassShaderQuad.prototype.execute.call(this);
		};
		return RenderPassDepthAwareBlur;
	}(RenderPassShaderQuad);

	var fs = "\n\tvarying vec2 uv0;\n\tuniform vec2 uInvResolution;\n\tuniform float uAspect;\n\t#define saturate(x) clamp(x,0.0,1.0)\n\thighp float getWFromProjectionMatrix(const mat4 p, const vec3 v) {\n\t\treturn -v.z;\n\t}\n\thighp float getViewSpaceZFromW(const mat4 p, const float w) {\n\t\treturn -w;\n\t}\n\tconst float kLog2LodRate = 3.0;\n\tfloat random(const highp vec2 w) {\n\t\tconst vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\treturn fract(m.z * fract(dot(w, m.xy)));\n\t}\n\thighp vec2 getFragCoord() {\n\t\treturn gl_FragCoord.xy;\n\t}\n\thighp vec3 computeViewSpacePositionFromDepth(highp vec2 uv, highp float linearDepth) {\n\t\treturn vec3((0.5 - uv) * vec2(uAspect, 1.0) * linearDepth, linearDepth);\n\t}\n\thighp vec3 faceNormal(highp vec3 dpdx, highp vec3 dpdy) {\n\t\treturn normalize(cross(dpdx, dpdy));\n\t}\n\thighp vec3 computeViewSpaceNormal(const highp vec3 position) {\n\t\treturn faceNormal(dFdx(position), dFdy(position));\n\t}\n\thighp vec3 computeViewSpaceNormal(const highp vec3 position, const highp vec2 uv) {\n\t\thighp vec2 uvdx = uv + vec2(uInvResolution.x, 0.0);\n\t\thighp vec2 uvdy = uv + vec2(0.0, uInvResolution.y);\n\t\thighp vec3 px = computeViewSpacePositionFromDepth(uvdx, -getLinearScreenDepth(uvdx));\n\t\thighp vec3 py = computeViewSpacePositionFromDepth(uvdy, -getLinearScreenDepth(uvdy));\n\t\thighp vec3 dpdx = px - position;\n\t\thighp vec3 dpdy = py - position;\n\t\treturn faceNormal(dpdx, dpdy);\n\t}\n\tuniform vec2 uSampleCount;\n\tuniform float uSpiralTurns;\n\t#define PI (3.14159)\n\tmediump vec3 tapLocation(mediump float i, const mediump float noise) {\n\t\tmediump float offset = ((2.0 * PI) * 2.4) * noise;\n\t\tmediump float angle = ((i * uSampleCount.y) * uSpiralTurns) * (2.0 * PI) + offset;\n\t\tmediump float radius = (i + noise + 0.5) * uSampleCount.y;\n\t\treturn vec3(cos(angle), sin(angle), radius * radius);\n\t}\n\thighp vec2 startPosition(const float noise) {\n\t\tfloat angle = ((2.0 * PI) * 2.4) * noise;\n\t\treturn vec2(cos(angle), sin(angle));\n\t}\n\tuniform vec2 uAngleIncCosSin;\n\thighp mat2 tapAngleStep() {\n\t\thighp vec2 t = uAngleIncCosSin;\n\t\treturn mat2(t.x, t.y, -t.y, t.x);\n\t}\n\tmediump vec3 tapLocationFast(mediump float i, mediump vec2 p, const mediump float noise) {\n\t\tmediump float radius = (i + noise + 0.5) * uSampleCount.y;\n\t\treturn vec3(p, radius * radius);\n\t}\n\tuniform float uMaxLevel;\n\tuniform float uInvRadiusSquared;\n\tuniform float uMinHorizonAngleSineSquared;\n\tuniform float uBias;\n\tuniform float uPeak2;\n\tvoid computeAmbientOcclusionSAO(inout mediump float occlusion, mediump float i, mediump float ssDiskRadius,\n\t\t\tconst highp vec2 uv, const highp vec3 origin, const mediump vec3 normal,\n\t\t\tconst mediump vec2 tapPosition, const float noise) {\n\t\tmediump vec3 tap = tapLocationFast(i, tapPosition, noise);\n\t\tmediump float ssRadius = max(1.0, tap.z * ssDiskRadius);\n\t\tmediump vec2 uvSamplePos = uv + vec2(ssRadius * tap.xy) * uInvResolution;\n\t\tmediump float level = clamp(floor(log2(ssRadius)) - kLog2LodRate, 0.0, float(uMaxLevel));\n\t\thighp float occlusionDepth = -getLinearScreenDepth(uvSamplePos);\n\t\thighp vec3 p = computeViewSpacePositionFromDepth(uvSamplePos, occlusionDepth);\n\t\tvec3 v = p - origin;\n\t\tfloat vv = dot(v, v);\n\t\tfloat vn = dot(v, normal);\n\t\tmediump float w = max(0.0, 1.0 - vv * uInvRadiusSquared);\n\t\tw = w * w;\n\t\tw *= step(vv * uMinHorizonAngleSineSquared, vn * vn);\n\t\tocclusion += w * max(0.0, vn + origin.z * uBias) / (vv + uPeak2);\n\t}\n\tuniform float uProjectionScaleRadius;\n\tuniform float uIntensity;\n\tuniform float uRandomize;\n\tfloat scalableAmbientObscurance(highp vec2 uv, highp vec3 origin, vec3 normal) {\n\t\tfloat noise = random(getFragCoord()) + uRandomize;\n\t\thighp vec2 tapPosition = startPosition(noise);\n\t\thighp mat2 angleStep = tapAngleStep();\n\t\tfloat ssDiskRadius = -(uProjectionScaleRadius / origin.z);\n\t\tfloat occlusion = 0.0;\n\t\tfor (float i = 0.0; i < uSampleCount.x; i += 1.0) {\n\t\t\tcomputeAmbientOcclusionSAO(occlusion, i, ssDiskRadius, uv, origin, normal, tapPosition, noise);\n\t\t\ttapPosition = angleStep * tapPosition;\n\t\t}\n\t\treturn occlusion;\n\t}\n\tuniform float uPower;\n\tvoid main() {\n\t\thighp vec2 uv = uv0;\n\t\thighp float depth = -getLinearScreenDepth(uv0);\n\t\thighp vec3 origin = computeViewSpacePositionFromDepth(uv, depth);\n\t\tvec3 normal = computeViewSpaceNormal(origin, uv);\n\t\tfloat occlusion = 0.0;\n\t\tif (uIntensity > 0.0) {\n\t\t\tocclusion = scalableAmbientObscurance(uv, origin, normal);\n\t\t}\n\t\tfloat ao = max(0.0, 1.0 - occlusion * uIntensity);\n\t\tao = pow(ao, uPower);\n\t\tgl_FragColor = vec4(ao, ao, ao, 1.0);\n\t}\n";
	var RenderPassSsao = function (_RenderPassShaderQuad) {
		function RenderPassSsao(device, sourceTexture, cameraComponent, blurEnabled) {
			var _this;
			_this = _RenderPassShaderQuad.call(this, device) || this;
			_this.radius = 5;
			_this.intensity = 1;
			_this.power = 1;
			_this.sampleCount = 10;
			_this.minAngle = 5;
			_this.randomize = false;
			_this.ssaoTexture = void 0;
			_this._scale = 1;
			_this._blueNoise = new BlueNoise(19);
			_this.sourceTexture = sourceTexture;
			_this.cameraComponent = cameraComponent;
			var screenDepth = ChunkUtils.getScreenDepthChunk(device, cameraComponent.shaderParams);
			_this.shader = _this.createQuadShader('SsaoShader', screenDepth + fs);
			var rt = _this.createRenderTarget('SsaoFinalTexture');
			_this.ssaoTexture = rt.colorBuffer;
			_this.init(rt, {
				resizeSource: _this.sourceTexture
			});
			var clearColor = new Color(0, 0, 0, 0);
			_this.setClearColor(clearColor);
			if (blurEnabled) {
				var blurRT = _this.createRenderTarget('SsaoTempTexture');
				var blurPassHorizontal = new RenderPassDepthAwareBlur(device, rt.colorBuffer, cameraComponent, true);
				blurPassHorizontal.init(blurRT, {
					resizeSource: rt.colorBuffer
				});
				blurPassHorizontal.setClearColor(clearColor);
				var blurPassVertical = new RenderPassDepthAwareBlur(device, blurRT.colorBuffer, cameraComponent, false);
				blurPassVertical.init(rt, {
					resizeSource: rt.colorBuffer
				});
				blurPassVertical.setClearColor(clearColor);
				_this.afterPasses.push(blurPassHorizontal);
				_this.afterPasses.push(blurPassVertical);
			}
			_this.ssaoTextureId = device.scope.resolve('ssaoTexture');
			_this.ssaoTextureSizeInvId = device.scope.resolve('ssaoTextureSizeInv');
			return _this;
		}
		_inheritsLoose(RenderPassSsao, _RenderPassShaderQuad);
		var _proto = RenderPassSsao.prototype;
		_proto.destroy = function destroy() {
			var _this$renderTarget, _this$renderTarget2;
			(_this$renderTarget = this.renderTarget) == null || _this$renderTarget.destroyTextureBuffers();
			(_this$renderTarget2 = this.renderTarget) == null || _this$renderTarget2.destroy();
			this.renderTarget = null;
			if (this.afterPasses.length > 0) {
				var blurRt = this.afterPasses[0].renderTarget;
				blurRt == null || blurRt.destroyTextureBuffers();
				blurRt == null || blurRt.destroy();
			}
			this.afterPasses.forEach(function (pass) {
				return pass.destroy();
			});
			this.afterPasses.length = 0;
			_RenderPassShaderQuad.prototype.destroy.call(this);
		};
		_proto.createRenderTarget = function createRenderTarget(name) {
			return new RenderTarget({
				depth: false,
				colorBuffer: new Texture(this.device, {
					name: name,
					width: 1,
					height: 1,
					format: PIXELFORMAT_R8,
					mipmaps: false,
					minFilter: FILTER_NEAREST,
					magFilter: FILTER_NEAREST,
					addressU: ADDRESS_CLAMP_TO_EDGE,
					addressV: ADDRESS_CLAMP_TO_EDGE
				})
			});
		};
		_proto.execute = function execute() {
			var device = this.device,
				sourceTexture = this.sourceTexture,
				sampleCount = this.sampleCount,
				minAngle = this.minAngle,
				scale = this.scale;
			var _this$renderTarget$co = this.renderTarget.colorBuffer,
				width = _this$renderTarget$co.width,
				height = _this$renderTarget$co.height;
			var scope = device.scope;
			scope.resolve('uAspect').setValue(width / height);
			scope.resolve('uInvResolution').setValue([1.0 / width, 1.0 / height]);
			scope.resolve('uSampleCount').setValue([sampleCount, 1.0 / sampleCount]);
			var minAngleSin = Math.sin(minAngle * Math.PI / 180.0);
			scope.resolve('uMinHorizonAngleSineSquared').setValue(minAngleSin * minAngleSin);
			var spiralTurns = 10.0;
			var step = 1.0 / (sampleCount - 0.5) * spiralTurns * 2.0 * 3.141;
			var radius = this.radius / scale;
			var bias = 0.001;
			var peak = 0.1 * radius;
			var intensity = 2 * (peak * 2.0 * 3.141) * this.intensity / sampleCount;
			var projectionScale = 0.5 * sourceTexture.height;
			scope.resolve('uSpiralTurns').setValue(spiralTurns);
			scope.resolve('uAngleIncCosSin').setValue([Math.cos(step), Math.sin(step)]);
			scope.resolve('uMaxLevel').setValue(0.0);
			scope.resolve('uInvRadiusSquared').setValue(1.0 / (radius * radius));
			scope.resolve('uBias').setValue(bias);
			scope.resolve('uPeak2').setValue(peak * peak);
			scope.resolve('uIntensity').setValue(intensity);
			scope.resolve('uPower').setValue(this.power);
			scope.resolve('uProjectionScaleRadius').setValue(projectionScale * radius);
			scope.resolve('uRandomize').setValue(this.randomize ? this._blueNoise.value() : 0);
			_RenderPassShaderQuad.prototype.execute.call(this);
		};
		_proto.after = function after() {
			this.ssaoTextureId.setValue(this.ssaoTexture);
			var srcTexture = this.sourceTexture;
			this.ssaoTextureSizeInvId.setValue([1.0 / srcTexture.width, 1.0 / srcTexture.height]);
		};
		return _createClass(RenderPassSsao, [{
			key: "scale",
			get: function get() {
				return this._scale;
			},
			set: function set(value) {
				this._scale = value;
				this.scaleX = value;
				this.scaleY = value;
			}
		}]);
	}(RenderPassShaderQuad);

	var CameraFrameOptions = function CameraFrameOptions() {
		this.formats = void 0;
		this.stencil = false;
		this.samples = 1;
		this.sceneColorMap = false;
		this.lastGrabLayerId = LAYERID_SKYBOX;
		this.lastGrabLayerIsTransparent = false;
		this.lastSceneLayerId = LAYERID_IMMEDIATE;
		this.lastSceneLayerIsTransparent = true;
		this.taaEnabled = false;
		this.bloomEnabled = false;
		this.ssaoType = SSAOTYPE_NONE;
		this.ssaoBlurEnabled = true;
		this.prepassEnabled = false;
		this.dofEnabled = false;
		this.dofNearBlur = false;
		this.dofHighQuality = true;
	};
	var _defaultOptions = new CameraFrameOptions();
	var RenderPassCameraFrame = function (_RenderPass) {
		function RenderPassCameraFrame(app, cameraComponent, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _RenderPass.call(this, app.graphicsDevice) || this;
			_this.app = void 0;
			_this.prePass = void 0;
			_this.scenePass = void 0;
			_this.composePass = void 0;
			_this.bloomPass = void 0;
			_this.ssaoPass = void 0;
			_this.taaPass = void 0;
			_this.scenePassHalf = void 0;
			_this.dofPass = void 0;
			_this._renderTargetScale = 1;
			_this.rt = null;
			_this.app = app;
			_this.cameraComponent = cameraComponent;
			_this.options = _this.sanitizeOptions(options);
			_this.setupRenderPasses(_this.options);
			return _this;
		}
		_inheritsLoose(RenderPassCameraFrame, _RenderPass);
		var _proto = RenderPassCameraFrame.prototype;
		_proto.destroy = function destroy() {
			this.reset();
		};
		_proto.reset = function reset() {
			this.sceneTexture = null;
			this.sceneTextureHalf = null;
			if (this.rt) {
				this.rt.destroyTextureBuffers();
				this.rt.destroy();
				this.rt = null;
			}
			if (this.rtHalf) {
				this.rtHalf.destroyTextureBuffers();
				this.rtHalf.destroy();
				this.rtHalf = null;
			}
			this.beforePasses.forEach(function (pass) {
				return pass.destroy();
			});
			this.beforePasses.length = 0;
			this.prePass = null;
			this.scenePass = null;
			this.scenePassTransparent = null;
			this.colorGrabPass = null;
			this.composePass = null;
			this.bloomPass = null;
			this.ssaoPass = null;
			this.taaPass = null;
			this.afterPass = null;
			this.scenePassHalf = null;
			this.dofPass = null;
		};
		_proto.sanitizeOptions = function sanitizeOptions(options) {
			options = Object.assign({}, _defaultOptions, options);
			if (options.taaEnabled || options.ssaoType !== SSAOTYPE_NONE || options.dofEnabled) {
				options.prepassEnabled = true;
			}
			return options;
		};
		_proto.needsReset = function needsReset(options) {
			var currentOptions = this.options;
			var arraysNotEqual = function arraysNotEqual(arr1, arr2) {
				return arr1 !== arr2 && (!(Array.isArray(arr1) && Array.isArray(arr2)) || arr1.length !== arr2.length || !arr1.every(function (value, index) {
					return value === arr2[index];
				}));
			};
			return options.ssaoType !== currentOptions.ssaoType || options.ssaoBlurEnabled !== currentOptions.ssaoBlurEnabled || options.taaEnabled !== currentOptions.taaEnabled || options.samples !== currentOptions.samples || options.stencil !== currentOptions.stencil || options.bloomEnabled !== currentOptions.bloomEnabled || options.prepassEnabled !== currentOptions.prepassEnabled || options.sceneColorMap !== currentOptions.sceneColorMap || options.dofEnabled !== currentOptions.dofEnabled || options.dofNearBlur !== currentOptions.dofNearBlur || options.dofHighQuality !== currentOptions.dofHighQuality || arraysNotEqual(options.formats, currentOptions.formats);
		};
		_proto.update = function update(options) {
			options = this.sanitizeOptions(options);
			if (this.needsReset(options)) {
				this.reset();
			}
			this.options = options;
			if (!this.sceneTexture) {
				this.setupRenderPasses(this.options);
			}
		};
		_proto.createRenderTarget = function createRenderTarget(name, depth, stencil, samples, flipY) {
			var texture = new Texture(this.device, {
				name: name,
				width: 4,
				height: 4,
				format: this.hdrFormat,
				mipmaps: false,
				minFilter: FILTER_LINEAR,
				magFilter: FILTER_LINEAR,
				addressU: ADDRESS_CLAMP_TO_EDGE,
				addressV: ADDRESS_CLAMP_TO_EDGE
			});
			return new RenderTarget({
				colorBuffer: texture,
				depth: depth,
				stencil: stencil,
				samples: samples,
				flipY: flipY
			});
		};
		_proto.setupRenderPasses = function setupRenderPasses(options) {
			var device = this.device;
			var cameraComponent = this.cameraComponent;
			var targetRenderTarget = cameraComponent.renderTarget;
			this.hdrFormat = device.getRenderableHdrFormat(options.formats, true, options.samples) || PIXELFORMAT_RGBA8;
			this._bloomEnabled = options.bloomEnabled && this.hdrFormat !== PIXELFORMAT_RGBA8;
			this._sceneHalfEnabled = this._bloomEnabled || options.dofEnabled;
			cameraComponent.gammaCorrection = GAMMA_NONE;
			cameraComponent.toneMapping = TONEMAP_NONE;
			cameraComponent.shaderParams.ssaoEnabled = options.ssaoType === SSAOTYPE_LIGHTING;
			var flipY = !!(targetRenderTarget != null && targetRenderTarget.flipY);
			this.rt = this.createRenderTarget('SceneColor', true, options.stencil, options.samples, flipY);
			this.sceneTexture = this.rt.colorBuffer;
			if (this._sceneHalfEnabled) {
				this.rtHalf = this.createRenderTarget('SceneColorHalf', false, false, 1, flipY);
				this.sceneTextureHalf = this.rtHalf.colorBuffer;
			}
			this.sceneOptions = {
				resizeSource: targetRenderTarget,
				scaleX: this.renderTargetScale,
				scaleY: this.renderTargetScale
			};
			this.createPasses(options);
			var allPasses = this.collectPasses();
			this.beforePasses = allPasses.filter(function (element) {
				return element !== undefined && element !== null;
			});
		};
		_proto.collectPasses = function collectPasses() {
			return [this.prePass, this.ssaoPass, this.scenePass, this.colorGrabPass, this.scenePassTransparent, this.taaPass, this.scenePassHalf, this.bloomPass, this.dofPass, this.composePass, this.afterPass];
		};
		_proto.createPasses = function createPasses(options) {
			this.setupScenePrepass(options);
			this.setupSsaoPass(options);
			var scenePassesInfo = this.setupScenePass(options);
			var sceneTextureWithTaa = this.setupTaaPass(options);
			this.setupSceneHalfPass(options, sceneTextureWithTaa);
			this.setupBloomPass(options, this.sceneTextureHalf);
			this.setupDofPass(options, this.sceneTexture, this.sceneTextureHalf);
			this.setupComposePass(options);
			this.setupAfterPass(options, scenePassesInfo);
		};
		_proto.setupScenePrepass = function setupScenePrepass(options) {
			if (options.prepassEnabled) {
				var app = this.app,
					device = this.device,
					cameraComponent = this.cameraComponent;
				var scene = app.scene,
					renderer = app.renderer;
				this.prePass = new RenderPassPrepass(device, scene, renderer, cameraComponent, this.sceneOptions);
			}
		};
		_proto.setupScenePass = function setupScenePass(options) {
			var app = this.app,
				device = this.device,
				cameraComponent = this.cameraComponent;
			var scene = app.scene,
				renderer = app.renderer;
			var composition = scene.layers;
			this.scenePass = new RenderPassForward(device, composition, scene, renderer);
			this.scenePass.init(this.rt, this.sceneOptions);
			var lastLayerId = options.sceneColorMap ? options.lastGrabLayerId : options.lastSceneLayerId;
			var lastLayerIsTransparent = options.sceneColorMap ? options.lastGrabLayerIsTransparent : options.lastSceneLayerIsTransparent;
			var ret = {
				lastAddedIndex: 0,
				clearRenderTarget: true
			};
			ret.lastAddedIndex = this.scenePass.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, lastLayerId, lastLayerIsTransparent);
			ret.clearRenderTarget = false;
			if (options.sceneColorMap) {
				this.colorGrabPass = new RenderPassColorGrab(device);
				this.colorGrabPass.source = this.rt;
				this.scenePassTransparent = new RenderPassForward(device, composition, scene, renderer);
				this.scenePassTransparent.init(this.rt);
				ret.lastAddedIndex = this.scenePassTransparent.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, options.lastSceneLayerId, options.lastSceneLayerIsTransparent);
				if (!this.scenePassTransparent.rendersAnything) {
					this.scenePassTransparent.destroy();
					this.scenePassTransparent = null;
				}
				if (this.scenePassTransparent) {
					if (options.prepassEnabled) {
						this.scenePassTransparent.depthStencilOps.storeDepth = true;
					}
				}
			}
			return ret;
		};
		_proto.setupSsaoPass = function setupSsaoPass(options) {
			var ssaoBlurEnabled = options.ssaoBlurEnabled,
				ssaoType = options.ssaoType;
			var device = this.device,
				cameraComponent = this.cameraComponent;
			if (ssaoType !== SSAOTYPE_NONE) {
				this.ssaoPass = new RenderPassSsao(device, this.sceneTexture, cameraComponent, ssaoBlurEnabled);
			}
		};
		_proto.setupSceneHalfPass = function setupSceneHalfPass(options, sourceTexture) {
			if (this._sceneHalfEnabled) {
				this.scenePassHalf = new RenderPassDownsample(this.device, this.sceneTexture, {
					boxFilter: true
				});
				this.scenePassHalf.name = 'RenderPassSceneHalf';
				this.scenePassHalf.init(this.rtHalf, {
					resizeSource: sourceTexture,
					scaleX: 0.5,
					scaleY: 0.5
				});
				this.scenePassHalf.setClearColor(Color.BLACK);
			}
		};
		_proto.setupBloomPass = function setupBloomPass(options, inputTexture) {
			if (this._bloomEnabled) {
				this.bloomPass = new RenderPassBloom(this.device, inputTexture, this.hdrFormat);
			}
		};
		_proto.setupDofPass = function setupDofPass(options, inputTexture, inputTextureHalf) {
			if (options.dofEnabled) {
				this.dofPass = new RenderPassDof(this.device, this.cameraComponent, inputTexture, inputTextureHalf, options.dofHighQuality, options.dofNearBlur);
			}
		};
		_proto.setupTaaPass = function setupTaaPass(options) {
			var textureWithTaa = this.sceneTexture;
			if (options.taaEnabled) {
				this.taaPass = new RenderPassTAA(this.device, this.sceneTexture, this.cameraComponent);
				textureWithTaa = this.taaPass.historyTexture;
			}
			return textureWithTaa;
		};
		_proto.setupComposePass = function setupComposePass(options) {
			var _this$bloomPass, _this$dofPass, _this$dofPass2, _this$dofPass3;
			this.composePass = new RenderPassCompose(this.device);
			this.composePass.bloomTexture = (_this$bloomPass = this.bloomPass) == null ? void 0 : _this$bloomPass.bloomTexture;
			this.composePass.taaEnabled = options.taaEnabled;
			this.composePass.cocTexture = (_this$dofPass = this.dofPass) == null ? void 0 : _this$dofPass.cocTexture;
			this.composePass.blurTexture = (_this$dofPass2 = this.dofPass) == null ? void 0 : _this$dofPass2.blurTexture;
			this.composePass.blurTextureUpscale = !((_this$dofPass3 = this.dofPass) != null && _this$dofPass3.highQuality);
			var cameraComponent = this.cameraComponent;
			var targetRenderTarget = cameraComponent.renderTarget;
			this.composePass.init(targetRenderTarget);
			this.composePass.ssaoTexture = options.ssaoType === SSAOTYPE_COMBINE ? this.ssaoPass.ssaoTexture : null;
		};
		_proto.setupAfterPass = function setupAfterPass(options, scenePassesInfo) {
			var app = this.app,
				cameraComponent = this.cameraComponent;
			var scene = app.scene,
				renderer = app.renderer;
			var composition = scene.layers;
			var targetRenderTarget = cameraComponent.renderTarget;
			this.afterPass = new RenderPassForward(this.device, composition, scene, renderer);
			this.afterPass.init(targetRenderTarget);
			this.afterPass.addLayers(composition, cameraComponent, scenePassesInfo.lastAddedIndex, scenePassesInfo.clearRenderTarget);
		};
		_proto.frameUpdate = function frameUpdate() {
			var _this$taaPass$update, _this$taaPass, _this$scenePassHalf;
			_RenderPass.prototype.frameUpdate.call(this);
			var sceneTexture = (_this$taaPass$update = (_this$taaPass = this.taaPass) == null ? void 0 : _this$taaPass.update()) != null ? _this$taaPass$update : this.rt.colorBuffer;
			this.composePass.sceneTexture = sceneTexture;
			(_this$scenePassHalf = this.scenePassHalf) == null || _this$scenePassHalf.setSourceTexture(sceneTexture);
		};
		return _createClass(RenderPassCameraFrame, [{
			key: "renderTargetScale",
			get: function get() {
				return this._renderTargetScale;
			},
			set: function set(value) {
				this._renderTargetScale = value;
				if (this.scenePass) {
					this.scenePass.scaleX = value;
					this.scenePass.scaleY = value;
				}
			}
		}]);
	}(RenderPass);

	var CameraFrame = function () {
		function CameraFrame(app, cameraComponent) {
			this.rendering = {
				renderFormats: [PIXELFORMAT_111110F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F],
				stencil: false,
				renderTargetScale: 1.0,
				samples: 1,
				sceneColorMap: false,
				sceneDepthMap: false,
				toneMapping: 0,
				sharpness: 0.0
			};
			this.ssao = {
				type: SSAOTYPE_NONE,
				blurEnabled: true,
				randomize: false,
				intensity: 0.5,
				radius: 30,
				samples: 12,
				power: 6,
				minAngle: 10,
				scale: 1
			};
			this.bloom = {
				intensity: 0,
				blurLevel: 16
			};
			this.grading = {
				enabled: false,
				brightness: 1,
				contrast: 1,
				saturation: 1,
				tint: new Color(1, 1, 1, 1)
			};
			this.vignette = {
				intensity: 0,
				inner: 0.5,
				outer: 1,
				curvature: 0.5
			};
			this.taa = {
				enabled: false,
				jitter: 1
			};
			this.fringing = {
				intensity: 0
			};
			this.dof = {
				enabled: false,
				nearBlur: false,
				focusDistance: 100,
				focusRange: 10,
				blurRadius: 3,
				blurRings: 4,
				blurRingPoints: 5,
				highQuality: true
			};
			this.debug = null;
			this.options = new CameraFrameOptions();
			this.renderPassCamera = null;
			this.app = app;
			this.cameraComponent = cameraComponent;
			this.updateOptions();
			this.enabled = true;
		}
		var _proto = CameraFrame.prototype;
		_proto.destroy = function destroy() {
			this.disable();
		};
		_proto.enable = function enable() {
			if (!this.renderPassCamera) {
				var cameraComponent = this.cameraComponent;
				this.renderPassCamera = new RenderPassCameraFrame(this.app, cameraComponent, this.options);
				cameraComponent.renderPasses = [this.renderPassCamera];
			}
		};
		_proto.disable = function disable() {
			if (this.renderPassCamera) {
				var _cameraComponent$rend;
				var cameraComponent = this.cameraComponent;
				(_cameraComponent$rend = cameraComponent.renderPasses) == null || _cameraComponent$rend.forEach(function (renderPass) {
					renderPass.destroy();
				});
				cameraComponent.renderPasses = [];
				cameraComponent.rendering = null;
				cameraComponent.jitter = 0;
			}
		};
		_proto.updateOptions = function updateOptions() {
			var options = this.options,
				rendering = this.rendering,
				bloom = this.bloom,
				taa = this.taa,
				ssao = this.ssao;
			options.stencil = rendering.stencil;
			options.samples = rendering.samples;
			options.sceneColorMap = rendering.sceneColorMap;
			options.prepassEnabled = rendering.sceneDepthMap;
			options.bloomEnabled = bloom.intensity > 0;
			options.taaEnabled = taa.enabled;
			options.ssaoType = ssao.type;
			options.ssaoBlurEnabled = ssao.blurEnabled;
			options.formats = rendering.renderFormats.slice();
			options.dofEnabled = this.dof.enabled;
			options.dofNearBlur = this.dof.nearBlur;
			options.dofHighQuality = this.dof.highQuality;
		};
		_proto.update = function update() {
			if (!this.enabled) return;
			var cameraComponent = this.cameraComponent;
			var options = this.options,
				renderPassCamera = this.renderPassCamera,
				rendering = this.rendering,
				bloom = this.bloom,
				grading = this.grading,
				vignette = this.vignette,
				fringing = this.fringing,
				taa = this.taa,
				ssao = this.ssao;
			this.updateOptions();
			renderPassCamera.update(options);
			var composePass = renderPassCamera.composePass,
				bloomPass = renderPassCamera.bloomPass,
				ssaoPass = renderPassCamera.ssaoPass,
				dofPass = renderPassCamera.dofPass;
			renderPassCamera.renderTargetScale = math.clamp(rendering.renderTargetScale, 0.1, 1);
			composePass.toneMapping = rendering.toneMapping;
			composePass.sharpness = rendering.sharpness;
			if (options.bloomEnabled && bloomPass) {
				composePass.bloomIntensity = bloom.intensity;
				bloomPass.blurLevel = bloom.blurLevel;
			}
			if (options.dofEnabled) {
				dofPass.focusDistance = this.dof.focusDistance;
				dofPass.focusRange = this.dof.focusRange;
				dofPass.blurRadius = this.dof.blurRadius;
				dofPass.blurRings = this.dof.blurRings;
				dofPass.blurRingPoints = this.dof.blurRingPoints;
			}
			if (options.ssaoType !== SSAOTYPE_NONE) {
				ssaoPass.intensity = ssao.intensity;
				ssaoPass.power = ssao.power;
				ssaoPass.radius = ssao.radius;
				ssaoPass.sampleCount = ssao.samples;
				ssaoPass.minAngle = ssao.minAngle;
				ssaoPass.scale = ssao.scale;
				ssaoPass.randomize = ssao.randomize;
			}
			composePass.gradingEnabled = grading.enabled;
			if (grading.enabled) {
				composePass.gradingSaturation = grading.saturation;
				composePass.gradingBrightness = grading.brightness;
				composePass.gradingContrast = grading.contrast;
				composePass.gradingTint = grading.tint;
			}
			composePass.vignetteEnabled = vignette.intensity > 0;
			if (composePass.vignetteEnabled) {
				composePass.vignetteInner = vignette.inner;
				composePass.vignetteOuter = vignette.outer;
				composePass.vignetteCurvature = vignette.curvature;
				composePass.vignetteIntensity = vignette.intensity;
			}
			composePass.fringingEnabled = fringing.intensity > 0;
			if (composePass.fringingEnabled) {
				composePass.fringingIntensity = fringing.intensity;
			}
			cameraComponent.jitter = taa.enabled ? taa.jitter : 0;
			composePass.debug = this.debug;
			if (composePass.debug === 'ssao' && options.ssaoType === SSAOTYPE_NONE) composePass.debug = null;
			if (composePass.debug === 'vignette' && !composePass.vignetteEnabled) composePass.debug = null;
		};
		return _createClass(CameraFrame, [{
			key: "enabled",
			get: function get() {
				return this.renderPassCamera !== null;
			},
			set: function set(value) {
				if (value) {
					this.enable();
				} else {
					this.disable();
				}
			}
		}]);
	}();

	var GIZMOSPACE_LOCAL = 'local';
	var GIZMOSPACE_WORLD = 'world';
	var GIZMOAXIS_X = 'x';
	var GIZMOAXIS_Y = 'y';
	var GIZMOAXIS_Z = 'z';
	var GIZMOAXIS_YZ = 'yz';
	var GIZMOAXIS_XZ = 'xz';
	var GIZMOAXIS_XY = 'xy';
	var GIZMOAXIS_XYZ = 'xyz';
	var GIZMOAXIS_FACE = 'face';

	var tmpV1$8 = new Vec3();
	var tmpV2$8 = new Vec3();
	var tmpM1$2 = new Mat4();
	var tmpM2 = new Mat4();
	var tmpR1$1 = new Ray();
	var LAYER_NAME = 'Gizmo';
	var MIN_SCALE = 1e-4;
	var PERS_SCALE_RATIO = 0.3;
	var ORTHO_SCALE_RATIO = 0.32;
	var UPDATE_EPSILON$1 = 1e-6;
	var Gizmo = function (_EventHandler) {
		function Gizmo(camera, layer) {
			var _this;
			_this = _EventHandler.call(this) || this;
			_this._size = 1;
			_this._scale = 1;
			_this._coordSpace = GIZMOSPACE_WORLD;
			_this._app = void 0;
			_this._device = void 0;
			_this._camera = void 0;
			_this._layer = void 0;
			_this.nodes = [];
			_this.root = void 0;
			_this.intersectShapes = [];
			_this._camera = camera;
			_this._app = camera.system.app;
			_this._device = _this._app.graphicsDevice;
			_this._layer = layer;
			camera.layers = camera.layers.concat(layer.id);
			_this.root = new Entity('gizmo');
			_this._app.root.addChild(_this.root);
			_this.root.enabled = false;
			_this._updateScale();
			_this._onPointerDown = _this._onPointerDown.bind(_this);
			_this._onPointerMove = _this._onPointerMove.bind(_this);
			_this._onPointerUp = _this._onPointerUp.bind(_this);
			_this._device.canvas.addEventListener('pointerdown', _this._onPointerDown);
			_this._device.canvas.addEventListener('pointermove', _this._onPointerMove);
			_this._device.canvas.addEventListener('pointerup', _this._onPointerUp);
			_this._app.on('update', function () {
				_this._updatePosition();
				_this._updateRotation();
				_this._updateScale();
			});
			_this._app.on('destroy', function () {
				return _this.destroy();
			});
			return _this;
		}
		_inheritsLoose(Gizmo, _EventHandler);
		Gizmo.createLayer = function createLayer(app, layerName, layerIndex) {
			if (layerName === void 0) {
				layerName = LAYER_NAME;
			}
			var layer = new Layer({
				name: layerName,
				clearDepthBuffer: true,
				opaqueSortMode: SORTMODE_NONE,
				transparentSortMode: SORTMODE_NONE
			});
			app.scene.layers.insert(layer, layerIndex != null ? layerIndex : app.scene.layers.layerList.length);
			return layer;
		};
		var _proto = Gizmo.prototype;
		_proto._onPointerDown = function _onPointerDown(e) {
			if (!this.root.enabled || document.pointerLockElement) {
				return;
			}
			var selection = this._getSelection(e.offsetX, e.offsetY);
			if (selection[0]) {
				e.preventDefault();
				e.stopPropagation();
			}
			var canvas = this._device.canvas;
			canvas.setPointerCapture(e.pointerId);
			this.fire(Gizmo.EVENT_POINTERDOWN, e.offsetX, e.offsetY, selection[0]);
		};
		_proto._onPointerMove = function _onPointerMove(e) {
			if (!this.root.enabled || document.pointerLockElement) {
				return;
			}
			var selection = this._getSelection(e.offsetX, e.offsetY);
			if (selection[0]) {
				e.preventDefault();
				e.stopPropagation();
			}
			this.fire(Gizmo.EVENT_POINTERMOVE, e.offsetX, e.offsetY, selection[0]);
		};
		_proto._onPointerUp = function _onPointerUp(e) {
			if (!this.root.enabled || document.pointerLockElement) {
				return;
			}
			var selection = this._getSelection(e.offsetX, e.offsetY);
			if (selection[0]) {
				e.preventDefault();
				e.stopPropagation();
			}
			var canvas = this._device.canvas;
			canvas.releasePointerCapture(e.pointerId);
			this.fire(Gizmo.EVENT_POINTERUP, e.offsetX, e.offsetY, selection[0]);
		};
		_proto._updatePosition = function _updatePosition() {
			tmpV1$8.set(0, 0, 0);
			for (var i = 0; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				tmpV1$8.add(node.getPosition());
			}
			tmpV1$8.mulScalar(1.0 / (this.nodes.length || 1));
			if (tmpV1$8.distance(this.root.getPosition()) < UPDATE_EPSILON$1) {
				return;
			}
			this.root.setPosition(tmpV1$8);
			this.fire(Gizmo.EVENT_POSITIONUPDATE, tmpV1$8);
		};
		_proto._updateRotation = function _updateRotation() {
			tmpV1$8.set(0, 0, 0);
			if (this._coordSpace === GIZMOSPACE_LOCAL && this.nodes.length !== 0) {
				tmpV1$8.copy(this.nodes[this.nodes.length - 1].getEulerAngles());
			}
			if (tmpV1$8.distance(this.root.getEulerAngles()) < UPDATE_EPSILON$1) {
				return;
			}
			this.root.setEulerAngles(tmpV1$8);
			this.fire(Gizmo.EVENT_ROTATIONUPDATE, tmpV1$8);
		};
		_proto._updateScale = function _updateScale() {
			if (this._camera.projection === PROJECTION_PERSPECTIVE) {
				var gizmoPos = this.root.getPosition();
				var cameraPos = this._camera.entity.getPosition();
				var dist = gizmoPos.distance(cameraPos);
				this._scale = Math.tan(0.5 * this._camera.fov * math.DEG_TO_RAD) * dist * PERS_SCALE_RATIO;
			} else {
				this._scale = this._camera.orthoHeight * ORTHO_SCALE_RATIO;
			}
			this._scale = Math.max(this._scale * this._size, MIN_SCALE);
			if (Math.abs(this._scale - this.root.getLocalScale().x) < UPDATE_EPSILON$1) {
				return;
			}
			this.root.setLocalScale(this._scale, this._scale, this._scale);
			this.fire(Gizmo.EVENT_SCALEUPDATE, this._scale);
		};
		_proto._getSelection = function _getSelection(x, y) {
			var start = this._camera.screenToWorld(x, y, 0);
			var end = this._camera.screenToWorld(x, y, this._camera.farClip - this._camera.nearClip);
			var dir = tmpV1$8.copy(end).sub(start).normalize();
			var selection = [];
			for (var i = 0; i < this.intersectShapes.length; i++) {
				var shape = this.intersectShapes[i];
				if (shape.disabled || !shape.entity.enabled) {
					continue;
				}
				var parentTM = shape.entity.getWorldTransform();
				for (var j = 0; j < shape.triData.length; j++) {
					var _shape$triData$j = shape.triData[j],
						tris = _shape$triData$j.tris,
						transform = _shape$triData$j.transform,
						priority = _shape$triData$j.priority;
					var triWTM = tmpM1$2.copy(parentTM).mul(transform);
					var invTriWTM = tmpM2.copy(triWTM).invert();
					var ray = tmpR1$1;
					invTriWTM.transformPoint(start, ray.origin);
					invTriWTM.transformVector(dir, ray.direction);
					ray.direction.normalize();
					for (var k = 0; k < tris.length; k++) {
						if (tris[k].intersectsRay(ray, tmpV1$8)) {
							selection.push({
								dist: triWTM.transformPoint(tmpV1$8).sub(start).length(),
								meshInstances: shape.meshInstances,
								priority: priority
							});
						}
					}
				}
			}
			if (selection.length) {
				selection.sort(function (s0, s1) {
					if (s0.priority !== 0 && s1.priority !== 0) {
						return s1.priority - s0.priority;
					}
					return s0.dist - s1.dist;
				});
				return selection[0].meshInstances;
			}
			return [];
		};
		_proto.attach = function attach(nodes) {
			if (nodes === void 0) {
				nodes = [];
			}
			if (Array.isArray(nodes)) {
				if (nodes.length === 0) {
					return;
				}
				this.nodes = nodes;
			} else {
				this.nodes = [nodes];
			}
			this._updatePosition();
			this._updateRotation();
			this._updateScale();
			this.fire(Gizmo.EVENT_NODESATTACH);
			this.root.enabled = true;
			this.fire(Gizmo.EVENT_RENDERUPDATE);
		};
		_proto.detach = function detach() {
			this.root.enabled = false;
			this.fire(Gizmo.EVENT_RENDERUPDATE);
			this.fire(Gizmo.EVENT_NODESDETACH);
			this.nodes = [];
		};
		_proto.destroy = function destroy() {
			this.detach();
			this._device.canvas.removeEventListener('pointerdown', this._onPointerDown);
			this._device.canvas.removeEventListener('pointermove', this._onPointerMove);
			this._device.canvas.removeEventListener('pointerup', this._onPointerUp);
			this.root.destroy();
		};
		return _createClass(Gizmo, [{
			key: "layer",
			get: function get() {
				return this._layer;
			}
		}, {
			key: "coordSpace",
			get: function get() {
				return this._coordSpace;
			},
			set: function set(value) {
				this._coordSpace = value != null ? value : GIZMOSPACE_WORLD;
				this._updateRotation();
			}
		}, {
			key: "size",
			get: function get() {
				return this._size;
			},
			set: function set(value) {
				this._size = value;
				this._updateScale();
			}
		}, {
			key: "facing",
			get: function get() {
				if (this._camera.projection === PROJECTION_PERSPECTIVE) {
					var gizmoPos = this.root.getPosition();
					var cameraPos = this._camera.entity.getPosition();
					return tmpV2$8.sub2(cameraPos, gizmoPos).normalize();
				}
				return tmpV2$8.copy(this._camera.entity.forward).mulScalar(-1);
			}
		}]);
	}(EventHandler);
	Gizmo.EVENT_POINTERDOWN = 'pointer:down';
	Gizmo.EVENT_POINTERMOVE = 'pointer:move';
	Gizmo.EVENT_POINTERUP = 'pointer:up';
	Gizmo.EVENT_POSITIONUPDATE = 'position:update';
	Gizmo.EVENT_ROTATIONUPDATE = 'rotation:update';
	Gizmo.EVENT_SCALEUPDATE = 'scale:update';
	Gizmo.EVENT_NODESATTACH = 'nodes:attach';
	Gizmo.EVENT_NODESDETACH = 'nodes:detach';
	Gizmo.EVENT_RENDERUPDATE = 'render:update';

	var COLOR_RED = Object.freeze(new Color(1, 0.3, 0.3));
	var COLOR_GREEN = Object.freeze(new Color(0.3, 1, 0.3));
	var COLOR_BLUE = Object.freeze(new Color(0.3, 0.3, 1));
	var COLOR_YELLOW = Object.freeze(new Color(1, 1, 0.5));
	var COLOR_GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 0.5));
	var color3from4 = function color3from4(color) {
		return new Color(color.r, color.g, color.b);
	};
	var color4from3 = function color4from3(color, a) {
		return new Color(color.r, color.g, color.b, a);
	};

	var tmpV1$7 = new Vec3();
	var tmpV2$7 = new Vec3();
	var tmpQ1$5 = new Quat();
	var tmpR1 = new Ray();
	var tmpP1 = new Plane();
	var VEC3_AXES = Object.keys(tmpV1$7);
	var TransformGizmo = function (_Gizmo) {
		function TransformGizmo(camera, layer) {
			var _this;
			_this = _Gizmo.call(this, camera, layer) || this;
			_this._colorAlpha = 0.6;
			_this._meshColors = {
				axis: {
					x: _this._colorSemi(COLOR_RED),
					y: _this._colorSemi(COLOR_GREEN),
					z: _this._colorSemi(COLOR_BLUE),
					xyz: _this._colorSemi(Color.WHITE),
					f: _this._colorSemi(Color.WHITE)
				},
				hover: {
					x: COLOR_RED.clone(),
					y: COLOR_GREEN.clone(),
					z: COLOR_BLUE.clone(),
					xyz: Color.WHITE.clone(),
					f: COLOR_YELLOW.clone()
				},
				disabled: COLOR_GRAY.clone()
			};
			_this._guideColors = {
				x: COLOR_RED.clone(),
				y: COLOR_GREEN.clone(),
				z: COLOR_BLUE.clone(),
				f: COLOR_YELLOW.clone()
			};
			_this._pointDelta = new Vec3();
			_this._rootStartPos = new Vec3();
			_this._rootStartRot = new Quat();
			_this._shading = false;
			_this._shapes = {};
			_this._shapeMap = new Map();
			_this._hoverShape = null;
			_this._hoverAxis = '';
			_this._hoverIsPlane = false;
			_this._noSelection = false;
			_this._selectedAxis = '';
			_this._selectedIsPlane = false;
			_this._selectionStartPoint = new Vec3();
			_this._selectionStartAngle = 0;
			_this._dragging = false;
			_this._snap = false;
			_this.snapIncrement = 1;
			_this._app.on('prerender', function () {
				if (!_this.root.enabled) {
					return;
				}
				_this._drawGuideLines();
			});
			_this.on(Gizmo.EVENT_POINTERDOWN, function (x, y, meshInstance) {
				var shape = _this._shapeMap.get(meshInstance);
				if (shape != null && shape.disabled) {
					return;
				}
				if (_this._dragging) {
					return;
				}
				if (!meshInstance) {
					_this._noSelection = true;
					return;
				}
				_this._selectedAxis = _this._getAxis(meshInstance);
				_this._selectedIsPlane = _this._getIsPlane(meshInstance);
				_this._rootStartPos.copy(_this.root.getPosition());
				_this._rootStartRot.copy(_this.root.getRotation());
				var pointInfo = _this._screenToPoint(x, y);
				_this._selectionStartPoint.copy(pointInfo.point);
				_this._selectionStartAngle = pointInfo.angle;
				_this._dragging = true;
				_this.fire(TransformGizmo.EVENT_TRANSFORMSTART);
			});
			_this.on(Gizmo.EVENT_POINTERMOVE, function (x, y, meshInstance) {
				var shape = _this._shapeMap.get(meshInstance);
				if (shape != null && shape.disabled) {
					return;
				}
				if (!_this._noSelection) {
					_this._hover(meshInstance);
				}
				if (!_this._dragging) {
					return;
				}
				var pointInfo = _this._screenToPoint(x, y);
				_this._pointDelta.copy(pointInfo.point).sub(_this._selectionStartPoint);
				var angleDelta = pointInfo.angle - _this._selectionStartAngle;
				_this.fire(TransformGizmo.EVENT_TRANSFORMMOVE, _this._pointDelta, angleDelta);
				_this._hoverAxis = '';
				_this._hoverIsPlane = false;
			});
			_this.on(Gizmo.EVENT_POINTERUP, function (x, y, meshInstance) {
				_this._noSelection = false;
				_this._hover(meshInstance);
				if (!_this._dragging) {
					return;
				}
				_this._dragging = false;
				_this.fire(TransformGizmo.EVENT_TRANSFORMEND);
				_this._selectedAxis = '';
				_this._selectedIsPlane = false;
			});
			_this.on(Gizmo.EVENT_NODESDETACH, function () {
				_this.snap = false;
				_this._hoverAxis = '';
				_this._hoverIsPlane = false;
				_this._hover();
				_this.fire(Gizmo.EVENT_POINTERUP);
			});
			return _this;
		}
		_inheritsLoose(TransformGizmo, _Gizmo);
		var _proto = TransformGizmo.prototype;
		_proto._colorSemi = function _colorSemi(color) {
			return color4from3(color, this._colorAlpha);
		};
		_proto._updateAxisColor = function _updateAxisColor(axis, value) {
			var color3 = color3from4(value);
			var color4 = this._colorSemi(value);
			this._guideColors[axis].copy(color3);
			this._meshColors.axis[axis].copy(color4);
			this._meshColors.hover[axis].copy(color3);
			for (var name in this._shapes) {
				this._shapes[name].hover(!!this._hoverAxis);
			}
		};
		_proto._getAxis = function _getAxis(meshInstance) {
			if (!meshInstance) {
				return '';
			}
			return meshInstance.node.name.split(':')[1];
		};
		_proto._getIsPlane = function _getIsPlane(meshInstance) {
			if (!meshInstance) {
				return false;
			}
			return meshInstance.node.name.indexOf('plane') !== -1;
		};
		_proto._hover = function _hover(meshInstance) {
			var _this$_shapeMap$get;
			if (this._dragging) {
				return;
			}
			this._hoverAxis = this._getAxis(meshInstance);
			this._hoverIsPlane = this._getIsPlane(meshInstance);
			var shape = meshInstance ? (_this$_shapeMap$get = this._shapeMap.get(meshInstance)) != null ? _this$_shapeMap$get : null : null;
			if (shape === this._hoverShape) {
				return;
			}
			if (this._hoverShape) {
				this._hoverShape.hover(false);
				this._hoverShape = null;
			}
			if (shape) {
				shape.hover(true);
				this._hoverShape = shape;
			}
			this.fire(Gizmo.EVENT_RENDERUPDATE);
		};
		_proto._createRay = function _createRay(mouseWPos) {
			if (this._camera.projection === PROJECTION_PERSPECTIVE) {
				tmpR1.origin.copy(this._camera.entity.getPosition());
				tmpR1.direction.sub2(mouseWPos, tmpR1.origin).normalize();
				return tmpR1;
			}
			var orthoDepth = this._camera.farClip - this._camera.nearClip;
			tmpR1.origin.sub2(mouseWPos, tmpV1$7.copy(this._camera.entity.forward).mulScalar(orthoDepth));
			tmpR1.direction.copy(this._camera.entity.forward);
			return tmpR1;
		};
		_proto._createPlane = function _createPlane(axis, isFacing, isLine) {
			var facingDir = tmpV1$7.copy(this.facing);
			var normal = tmpP1.normal.set(0, 0, 0);
			if (isFacing) {
				normal.copy(facingDir);
			} else {
				normal[axis] = 1;
				this._rootStartRot.transformVector(normal, normal);
				if (isLine) {
					tmpV2$7.cross(normal, facingDir).normalize();
					normal.cross(tmpV2$7, normal).normalize();
				}
			}
			return tmpP1.setFromPointNormal(this._rootStartPos, normal);
		};
		_proto._projectToAxis = function _projectToAxis(point, axis) {
			tmpV1$7.set(0, 0, 0);
			tmpV1$7[axis] = 1;
			point.copy(tmpV1$7.mulScalar(tmpV1$7.dot(point)));
			var v = point[axis];
			point.set(0, 0, 0);
			point[axis] = v;
		};
		_proto._screenToPoint = function _screenToPoint(x, y, isFacing, isLine) {
			if (isFacing === void 0) {
				isFacing = false;
			}
			if (isLine === void 0) {
				isLine = false;
			}
			var mouseWPos = this._camera.screenToWorld(x, y, 1);
			var axis = this._selectedAxis;
			var ray = this._createRay(mouseWPos);
			var plane = this._createPlane(axis, isFacing, isLine);
			var point = new Vec3();
			var angle = 0;
			plane.intersectsRay(ray, point);
			return {
				point: point,
				angle: angle
			};
		};
		_proto._drawGuideLines = function _drawGuideLines() {
			var gizmoPos = this.root.getPosition();
			var gizmoRot = tmpQ1$5.copy(this.root.getRotation());
			var checkAxis = this._hoverAxis || this._selectedAxis;
			var checkIsPlane = this._hoverIsPlane || this._selectedIsPlane;
			for (var i = 0; i < VEC3_AXES.length; i++) {
				var axis = VEC3_AXES[i];
				if (checkAxis === GIZMOAXIS_XYZ) {
					this._drawSpanLine(gizmoPos, gizmoRot, axis);
					continue;
				}
				if (checkIsPlane) {
					if (axis !== checkAxis) {
						this._drawSpanLine(gizmoPos, gizmoRot, axis);
					}
				} else {
					if (axis === checkAxis) {
						this._drawSpanLine(gizmoPos, gizmoRot, axis);
					}
				}
			}
		};
		_proto._drawSpanLine = function _drawSpanLine(pos, rot, axis) {
			tmpV1$7.set(0, 0, 0);
			tmpV1$7[axis] = 1;
			tmpV1$7.mulScalar(this._camera.farClip - this._camera.nearClip);
			tmpV2$7.copy(tmpV1$7).mulScalar(-1);
			rot.transformVector(tmpV1$7, tmpV1$7);
			rot.transformVector(tmpV2$7, tmpV2$7);
			this._app.drawLine(tmpV1$7.add(pos), tmpV2$7.add(pos), this._guideColors[axis], true);
		};
		_proto._createTransform = function _createTransform() {
			for (var key in this._shapes) {
				var shape = this._shapes[key];
				this.root.addChild(shape.entity);
				this.intersectShapes.push(shape);
				for (var i = 0; i < shape.meshInstances.length; i++) {
					this._shapeMap.set(shape.meshInstances[i], shape);
				}
			}
		};
		_proto.enableShape = function enableShape(shapeAxis, enabled) {
			if (!this._shapes.hasOwnProperty(shapeAxis)) {
				return;
			}
			this._shapes[shapeAxis].disabled = !enabled;
		};
		_proto.isShapeEnabled = function isShapeEnabled(shapeAxis) {
			if (!this._shapes.hasOwnProperty(shapeAxis)) {
				return false;
			}
			return !this._shapes[shapeAxis].disabled;
		};
		_proto.destroy = function destroy() {
			_Gizmo.prototype.destroy.call(this);
			for (var key in this._shapes) {
				this._shapes[key].destroy();
			}
		};
		return _createClass(TransformGizmo, [{
			key: "shading",
			get: function get() {
				return this._shading;
			},
			set: function set(value) {
				this._shading = this.root.enabled && value;
				for (var name in this._shapes) {
					this._shapes[name].shading = this._shading;
				}
			}
		}, {
			key: "snap",
			get: function get() {
				return this._snap;
			},
			set: function set(value) {
				this._snap = this.root.enabled && value;
			}
		}, {
			key: "xAxisColor",
			get: function get() {
				return this._meshColors.axis.x;
			},
			set: function set(value) {
				this._updateAxisColor(GIZMOAXIS_X, value);
			}
		}, {
			key: "yAxisColor",
			get: function get() {
				return this._meshColors.axis.y;
			},
			set: function set(value) {
				this._updateAxisColor(GIZMOAXIS_Y, value);
			}
		}, {
			key: "zAxisColor",
			get: function get() {
				return this._meshColors.axis.z;
			},
			set: function set(value) {
				this._updateAxisColor(GIZMOAXIS_Z, value);
			}
		}, {
			key: "colorAlpha",
			get: function get() {
				return this._colorAlpha;
			},
			set: function set(value) {
				this._colorAlpha = math.clamp(value, 0, 1);
				this._meshColors.axis.x.copy(this._colorSemi(this._meshColors.axis.x));
				this._meshColors.axis.y.copy(this._colorSemi(this._meshColors.axis.y));
				this._meshColors.axis.z.copy(this._colorSemi(this._meshColors.axis.z));
				this._meshColors.axis.xyz.copy(this._colorSemi(this._meshColors.axis.xyz));
				this._meshColors.axis.f.copy(this._colorSemi(this._meshColors.axis.f));
				for (var name in this._shapes) {
					this._shapes[name].hover(!!this._hoverAxis);
				}
			}
		}]);
	}(Gizmo);
	TransformGizmo.EVENT_TRANSFORMSTART = 'transform:start';
	TransformGizmo.EVENT_TRANSFORMMOVE = 'transform:move';
	TransformGizmo.EVENT_TRANSFORMEND = 'transform:end';

	var tmpV1$6 = new Vec3();
	var tmpV2$6 = new Vec3();
	var tmpV3$1 = new Vec3();
	var TriData = function () {
		function TriData(geometry, priority) {
			if (priority === void 0) {
				priority = 0;
			}
			this._priority = 0;
			this._transform = new Mat4();
			this.tris = [];
			this.fromGeometry(geometry);
			this._priority = priority;
		}
		var _proto = TriData.prototype;
		_proto.setTransform = function setTransform(pos, rot, scale) {
			if (pos === void 0) {
				pos = new Vec3();
			}
			if (rot === void 0) {
				rot = new Quat();
			}
			if (scale === void 0) {
				scale = new Vec3();
			}
			this.transform.setTRS(pos, rot, scale);
		};
		_proto.fromGeometry = function fromGeometry(geometry) {
			var _geometry$positions, _geometry$indices;
			if (!geometry || !(geometry instanceof Geometry)) {
				throw new Error('No geometry provided.');
			}
			var positions = (_geometry$positions = geometry.positions) != null ? _geometry$positions : [];
			var indices = (_geometry$indices = geometry.indices) != null ? _geometry$indices : [];
			this.tris = [];
			for (var k = 0; k < indices.length; k += 3) {
				var i1 = indices[k];
				var i2 = indices[k + 1];
				var i3 = indices[k + 2];
				tmpV1$6.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
				tmpV2$6.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
				tmpV3$1.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
				var tri = new Tri(tmpV1$6, tmpV2$6, tmpV3$1);
				this.tris.push(tri);
			}
		};
		return _createClass(TriData, [{
			key: "transform",
			get: function get() {
				return this._transform;
			}
		}, {
			key: "priority",
			get: function get() {
				return this._priority;
			}
		}]);
	}();

	var SHADING_DAMP_SCALE = 0.25;
	var SHADING_DAMP_OFFSET = 0.75;
	var LIGHT_DIR = new Vec3(1, 2, 3);
	var GEOMETRIES = {
		box: BoxGeometry,
		cone: ConeGeometry,
		cylinder: CylinderGeometry,
		plane: PlaneGeometry,
		sphere: SphereGeometry,
		torus: TorusGeometry
	};
	var shaderDesc = {
		uniqueName: 'axis-shape',
		attributes: {
			vertex_position: SEMANTIC_POSITION,
			vertex_color: SEMANTIC_COLOR
		},
		vertexCode: "\n\t\tattribute vec3 vertex_position;\n\t\tattribute vec4 vertex_color;\n\t\tvarying vec4 vColor;\n\t\tuniform mat4 matrix_model;\n\t\tuniform mat4 matrix_viewProjection;\n\t\tvoid main(void) {\n\t\t\tgl_Position = matrix_viewProjection * matrix_model * vec4(vertex_position, 1.0);\n\t\t\tgl_Position.z = clamp(gl_Position.z, -abs(gl_Position.w), abs(gl_Position.w));\n\t\t\tvColor = vertex_color;\n\t\t}\n\t",
		fragmentCode: "\n\t\tprecision highp float;\n\t\tvarying vec4 vColor;\n\t\tvoid main(void) {\n\t\t\tgl_FragColor = vec4(gammaCorrectOutput(decodeGamma(vColor)), vColor.w);\n\t\t}\n\t"
	};
	var shadingMeshMap = new Map();
	var tmpV1$5 = new Vec3();
	var tmpV2$5 = new Vec3();
	var tmpM1$1 = new Mat4();
	var tmpG = new Geometry();
	tmpG.positions = [];
	tmpG.normals = [];
	var applyShadowColor = function applyShadowColor(geom, color, transform) {
		if (!geom.normals || !geom.positions) {
			return [];
		}
		var localLightDir;
		if (transform) {
			localLightDir = tmpM1$1.copy(transform).invert().transformVector(tmpV1$5.copy(LIGHT_DIR), tmpV1$5).normalize();
		}
		geom.colors = [];
		var shading = [];
		var numVertices = geom.positions.length / 3;
		for (var i = 0; i < numVertices; i++) {
			var strength = 1;
			if (localLightDir) {
				var x = geom.normals[i * 3];
				var y = geom.normals[i * 3 + 1];
				var z = geom.normals[i * 3 + 2];
				var normal = tmpV2$5.set(x, y, z);
				var dot = localLightDir.dot(normal);
				strength = dot * SHADING_DAMP_SCALE + SHADING_DAMP_OFFSET;
			}
			shading.push(strength);
			geom.colors.push(strength * color.r * 0xFF, strength * color.g * 0xFF, strength * color.b * 0xFF, color.a * 0xFF);
		}
		return shading;
	};
	var setMeshColor = function setMeshColor(mesh, color) {
		var shading = shadingMeshMap.get(mesh);
		var colors = [];
		for (var i = 0; i < shading.length; i++) {
			colors.push(shading[i] * color.r * 0xFF, shading[i] * color.g * 0xFF, shading[i] * color.b * 0xFF, color.a * 0xFF);
		}
		mesh.setColors32(colors);
		mesh.update();
	};
	var Shape = function () {
		function Shape(device, options) {
			var _options$axis, _options$position, _options$rotation, _options$scale, _options$disabled, _options$layers, _options$shading;
			this._position = void 0;
			this._rotation = void 0;
			this._scale = void 0;
			this._layers = [];
			this._shading = true;
			this._disabled = void 0;
			this._defaultColor = Color.WHITE;
			this._hoverColor = Color.BLACK;
			this._disabledColor = COLOR_GRAY;
			this._cull = CULLFACE_BACK;
			this.device = void 0;
			this.axis = void 0;
			this.entity = void 0;
			this.triData = [];
			this.meshInstances = [];
			this.device = device;
			this.axis = (_options$axis = options.axis) != null ? _options$axis : 'x';
			this._position = (_options$position = options.position) != null ? _options$position : new Vec3();
			this._rotation = (_options$rotation = options.rotation) != null ? _options$rotation : new Vec3();
			this._scale = (_options$scale = options.scale) != null ? _options$scale : new Vec3(1, 1, 1);
			this._disabled = (_options$disabled = options.disabled) != null ? _options$disabled : false;
			this._layers = (_options$layers = options.layers) != null ? _options$layers : this._layers;
			this._shading = (_options$shading = options.shading) != null ? _options$shading : this._shading;
			if (options.defaultColor instanceof Color) {
				this._defaultColor = options.defaultColor;
			}
			if (options.hoverColor instanceof Color) {
				this._hoverColor = options.hoverColor;
			}
			if (options.disabledColor instanceof Color) {
				this._disabledColor = options.disabledColor;
			}
		}
		var _proto = Shape.prototype;
		_proto._createRoot = function _createRoot(name) {
			this.entity = new Entity(name + ":" + this.axis);
			this.entity.setLocalPosition(this._position);
			this.entity.setLocalEulerAngles(this._rotation);
			this.entity.setLocalScale(this._scale);
		};
		_proto._createMesh = function _createMesh(geom, shading) {
			if (shading === void 0) {
				shading = true;
			}
			var color = this._disabled ? this._disabledColor : this._defaultColor;
			var shadow = applyShadowColor(geom, color, shading ? this.entity.getWorldTransform() : undefined);
			var mesh = Mesh.fromGeometry(this.device, geom);
			shadingMeshMap.set(mesh, shadow);
			return mesh;
		};
		_proto._createRenderComponent = function _createRenderComponent(entity, meshes) {
			var material = new ShaderMaterial(shaderDesc);
			material.cull = this._cull;
			material.blendType = BLEND_NORMAL;
			material.update();
			var meshInstances = [];
			for (var i = 0; i < meshes.length; i++) {
				var mi = new MeshInstance(meshes[i], material);
				mi.cull = false;
				meshInstances.push(mi);
				this.meshInstances.push(mi);
			}
			entity.addComponent('render', {
				meshInstances: meshInstances,
				layers: this._layers,
				castShadows: false
			});
		};
		_proto._addRenderMesh = function _addRenderMesh(entity, type, shading) {
			var Geometry = GEOMETRIES[type];
			if (!Geometry) {
				throw new Error('Invalid primitive type.');
			}
			this._createRenderComponent(entity, [this._createMesh(new Geometry(), shading)]);
		};
		_proto.hover = function hover(state) {
			if (this._disabled) {
				return;
			}
			for (var i = 0; i < this.meshInstances.length; i++) {
				var color = state ? this._hoverColor : this._defaultColor;
				var mesh = this.meshInstances[i].mesh;
				setMeshColor(mesh, color);
			}
		};
		_proto.destroy = function destroy() {
			this.entity.destroy();
		};
		return _createClass(Shape, [{
			key: "disabled",
			get: function get() {
				return this._disabled;
			},
			set: function set(value) {
				for (var i = 0; i < this.meshInstances.length; i++) {
					setMeshColor(this.meshInstances[i].mesh, value ? this._disabledColor : this._defaultColor);
				}
				this._disabled = value != null ? value : false;
			}
		}, {
			key: "shading",
			get: function get() {
				return this._shading;
			},
			set: function set(value) {
				this._shading = value != null ? value : true;
				var color = this._disabled ? this._disabledColor : this._defaultColor;
				for (var i = 0; i < this.meshInstances.length; i++) {
					var mesh = this.meshInstances[i].mesh;
					mesh.getPositions(tmpG.positions);
					mesh.getNormals(tmpG.normals);
					var shadow = applyShadowColor(tmpG, color, this._shading ? this.entity.getWorldTransform() : undefined);
					shadingMeshMap.set(mesh, shadow);
					setMeshColor(mesh, color);
				}
			}
		}]);
	}();

	var UPDATE_EPSILON = 1e-6;
	var PlaneShape = function (_Shape) {
		function PlaneShape(device, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _Shape.call(this, device, options) || this;
			_this._cull = CULLFACE_NONE;
			_this._size = 0.2;
			_this._gap = 0.1;
			_this._flipped = new Vec3();
			_this.triData = [new TriData(new PlaneGeometry())];
			_this._createPlane();
			return _this;
		}
		_inheritsLoose(PlaneShape, _Shape);
		var _proto = PlaneShape.prototype;
		_proto._getPosition = function _getPosition() {
			var offset = this._size / 2 + this._gap;
			var position = new Vec3(this._flipped.x ? -offset : offset, this._flipped.y ? -offset : offset, this._flipped.z ? -offset : offset);
			position[this.axis] = 0;
			return position;
		};
		_proto._createPlane = function _createPlane() {
			this._createRoot('plane');
			this._updateTransform();
			this._addRenderMesh(this.entity, 'plane', this._shading);
		};
		_proto._updateTransform = function _updateTransform() {
			this.entity.setLocalPosition(this._getPosition());
			this.entity.setLocalEulerAngles(this._rotation);
			this.entity.setLocalScale(this._size, this._size, this._size);
		};
		return _createClass(PlaneShape, [{
			key: "size",
			get: function get() {
				return this._size;
			},
			set: function set(value) {
				this._size = value != null ? value : 1;
				this._updateTransform();
			}
		}, {
			key: "gap",
			get: function get() {
				return this._gap;
			},
			set: function set(value) {
				this._gap = value != null ? value : 0;
				this._updateTransform();
			}
		}, {
			key: "flipped",
			get: function get() {
				return this._flipped;
			},
			set: function set(value) {
				if (this._flipped.distance(value) < UPDATE_EPSILON) {
					return;
				}
				this._flipped.copy(value);
				this.entity.setLocalPosition(this._getPosition());
			}
		}]);
	}(Shape);

	var tmpV1$4 = new Vec3();
	var tmpV2$4 = new Vec3();
	var tmpQ1$4 = new Quat();
	var ArrowShape = function (_Shape) {
		function ArrowShape(device, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _Shape.call(this, device, options) || this;
			_this._gap = 0;
			_this._lineThickness = 0.02;
			_this._lineLength = 0.5;
			_this._arrowThickness = 0.12;
			_this._arrowLength = 0.18;
			_this._tolerance = 0.1;
			_this._head = void 0;
			_this._line = void 0;
			_this._flipped = false;
			_this.triData = [new TriData(new ConeGeometry()), new TriData(new CylinderGeometry(), 1)];
			_this._createArrow();
			return _this;
		}
		_inheritsLoose(ArrowShape, _Shape);
		var _proto = ArrowShape.prototype;
		_proto._createArrow = function _createArrow() {
			this._createRoot('arrow');
			this._head = new Entity("head:" + this.axis);
			this.entity.addChild(this._head);
			this._updateHead();
			this._addRenderMesh(this._head, 'cone', this._shading);
			this._line = new Entity("line:" + this.axis);
			this.entity.addChild(this._line);
			this._updateLine();
			this._addRenderMesh(this._line, 'cylinder', this._shading);
		};
		_proto._updateHead = function _updateHead() {
			tmpV1$4.set(0, this._gap + this._arrowLength * 0.5 + this._lineLength, 0);
			tmpQ1$4.set(0, 0, 0, 1);
			tmpV2$4.set(this._arrowThickness, this._arrowLength, this._arrowThickness);
			this.triData[0].setTransform(tmpV1$4, tmpQ1$4, tmpV2$4);
			this._head.setLocalPosition(0, this._gap + this._arrowLength * 0.5 + this._lineLength, 0);
			this._head.setLocalScale(this._arrowThickness, this._arrowLength, this._arrowThickness);
		};
		_proto._updateLine = function _updateLine() {
			tmpV1$4.set(0, this._gap + this._lineLength * 0.5, 0);
			tmpQ1$4.set(0, 0, 0, 1);
			tmpV2$4.set(this._lineThickness + this._tolerance, this._lineLength, this._lineThickness + this._tolerance);
			this.triData[1].setTransform(tmpV1$4, tmpQ1$4, tmpV2$4);
			this._line.setLocalPosition(0, this._gap + this._lineLength * 0.5, 0);
			this._line.setLocalScale(this._lineThickness, this._lineLength, this._lineThickness);
		};
		return _createClass(ArrowShape, [{
			key: "gap",
			get: function get() {
				return this._gap;
			},
			set: function set(value) {
				this._gap = value != null ? value : 0;
				this._updateHead();
				this._updateLine();
			}
		}, {
			key: "lineThickness",
			get: function get() {
				return this._lineThickness;
			},
			set: function set(value) {
				this._lineThickness = value != null ? value : 1;
				this._updateHead();
				this._updateLine();
			}
		}, {
			key: "lineLength",
			get: function get() {
				return this._lineLength;
			},
			set: function set(value) {
				this._lineLength = value != null ? value : 1;
				this._updateHead();
				this._updateLine();
			}
		}, {
			key: "arrowThickness",
			get: function get() {
				return this._arrowThickness;
			},
			set: function set(value) {
				this._arrowThickness = value != null ? value : 1;
				this._updateHead();
			}
		}, {
			key: "arrowLength",
			get: function get() {
				return this._arrowLength;
			},
			set: function set(value) {
				this._arrowLength = value != null ? value : 1;
				this._updateHead();
			}
		}, {
			key: "tolerance",
			get: function get() {
				return this._tolerance;
			},
			set: function set(value) {
				this._tolerance = value;
				this._updateLine();
			}
		}, {
			key: "flipped",
			get: function get() {
				return this._flipped;
			},
			set: function set(value) {
				if (this._flipped === value) {
					return;
				}
				this._flipped = value;
				if (this._rotation.equals(Vec3.ZERO)) {
					tmpV1$4.set(0, 0, this._flipped ? 180 : 0);
				} else {
					tmpV1$4.copy(this._rotation).mulScalar(this._flipped ? -1 : 1);
				}
				this._line.enabled = !this._flipped;
				this.entity.setLocalEulerAngles(tmpV1$4);
			}
		}]);
	}(Shape);

	var SphereShape = function (_Shape) {
		function SphereShape(device, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _Shape.call(this, device, options) || this;
			_this._size = 0.12;
			_this._tolerance = 0.05;
			_this.triData = [new TriData(new SphereGeometry(), 2)];
			_this._createCenter();
			return _this;
		}
		_inheritsLoose(SphereShape, _Shape);
		var _proto = SphereShape.prototype;
		_proto._createCenter = function _createCenter() {
			this._createRoot('sphereCenter');
			this._updateTransform();
			this._addRenderMesh(this.entity, 'sphere', this._shading);
		};
		_proto._updateTransform = function _updateTransform() {
			this.entity.setLocalScale(this._size, this._size, this._size);
		};
		return _createClass(SphereShape, [{
			key: "size",
			get: function get() {
				return this._size;
			},
			set: function set(value) {
				this._size = value != null ? value : 1;
				this._updateTransform();
			}
		}, {
			key: "tolerance",
			get: function get() {
				return this._tolerance;
			},
			set: function set(value) {
				this._tolerance = value;
				this._updateTransform();
			}
		}]);
	}(Shape);

	var tmpV1$3 = new Vec3();
	var tmpV2$3 = new Vec3();
	var tmpQ1$3 = new Quat();
	var GLANCE_EPSILON$1 = 0.98;
	var TranslateGizmo = function (_TransformGizmo) {
		function TranslateGizmo(camera, layer) {
			var _this;
			_this = _TransformGizmo.call(this, camera, layer) || this;
			_this._shapes = {
				face: new SphereShape(_this._device, {
					axis: GIZMOAXIS_FACE,
					layers: [_this._layer.id],
					shading: _this._shading,
					defaultColor: _this._meshColors.axis.xyz,
					hoverColor: _this._meshColors.hover.xyz
				}),
				yz: new PlaneShape(_this._device, {
					axis: GIZMOAXIS_X,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, -90),
					defaultColor: _this._meshColors.axis.x,
					hoverColor: _this._meshColors.hover.x
				}),
				xz: new PlaneShape(_this._device, {
					axis: GIZMOAXIS_Y,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, 0),
					defaultColor: _this._meshColors.axis.y,
					hoverColor: _this._meshColors.hover.y
				}),
				xy: new PlaneShape(_this._device, {
					axis: GIZMOAXIS_Z,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(90, 0, 0),
					defaultColor: _this._meshColors.axis.z,
					hoverColor: _this._meshColors.hover.z
				}),
				x: new ArrowShape(_this._device, {
					axis: GIZMOAXIS_X,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, -90),
					defaultColor: _this._meshColors.axis.x,
					hoverColor: _this._meshColors.hover.x
				}),
				y: new ArrowShape(_this._device, {
					axis: GIZMOAXIS_Y,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, 0),
					defaultColor: _this._meshColors.axis.y,
					hoverColor: _this._meshColors.hover.y
				}),
				z: new ArrowShape(_this._device, {
					axis: GIZMOAXIS_Z,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(90, 0, 0),
					defaultColor: _this._meshColors.axis.z,
					hoverColor: _this._meshColors.hover.z
				})
			};
			_this._nodeLocalPositions = new Map();
			_this._nodePositions = new Map();
			_this.snapIncrement = 1;
			_this.flipShapes = true;
			_this._createTransform();
			_this.on(TransformGizmo.EVENT_TRANSFORMSTART, function () {
				_this._storeNodePositions();
			});
			_this.on(TransformGizmo.EVENT_TRANSFORMMOVE, function (pointDelta) {
				if (_this.snap) {
					pointDelta.mulScalar(1 / _this.snapIncrement);
					pointDelta.round();
					pointDelta.mulScalar(_this.snapIncrement);
				}
				_this._setNodePositions(pointDelta);
			});
			_this.on(TransformGizmo.EVENT_NODESDETACH, function () {
				_this._nodeLocalPositions.clear();
				_this._nodePositions.clear();
			});
			_this._app.on('prerender', function () {
				_this._shapesLookAtCamera();
			});
			return _this;
		}
		_inheritsLoose(TranslateGizmo, _TransformGizmo);
		var _proto = TranslateGizmo.prototype;
		_proto._setArrowProp = function _setArrowProp(prop, value) {
			this._shapes.x[prop] = value;
			this._shapes.y[prop] = value;
			this._shapes.z[prop] = value;
		};
		_proto._setPlaneProp = function _setPlaneProp(prop, value) {
			this._shapes.yz[prop] = value;
			this._shapes.xz[prop] = value;
			this._shapes.xy[prop] = value;
		};
		_proto._shapesLookAtCamera = function _shapesLookAtCamera() {
			var facingDir = this.facing;
			var dot = facingDir.dot(this.root.right);
			this._shapes.x.entity.enabled = Math.abs(dot) < GLANCE_EPSILON$1;
			if (this.flipShapes) {
				this._shapes.x.flipped = dot < 0;
			}
			dot = facingDir.dot(this.root.up);
			this._shapes.y.entity.enabled = Math.abs(dot) < GLANCE_EPSILON$1;
			if (this.flipShapes) {
				this._shapes.y.flipped = dot < 0;
			}
			dot = facingDir.dot(this.root.forward);
			this._shapes.z.entity.enabled = Math.abs(dot) < GLANCE_EPSILON$1;
			if (this.flipShapes) {
				this._shapes.z.flipped = dot > 0;
			}
			tmpV1$3.cross(facingDir, this.root.right);
			this._shapes.yz.entity.enabled = tmpV1$3.length() < GLANCE_EPSILON$1;
			if (this.flipShapes) {
				this._shapes.yz.flipped = tmpV2$3.set(0, +(tmpV1$3.dot(this.root.forward) < 0), +(tmpV1$3.dot(this.root.up) < 0));
			}
			tmpV1$3.cross(facingDir, this.root.forward);
			this._shapes.xy.entity.enabled = tmpV1$3.length() < GLANCE_EPSILON$1;
			if (this.flipShapes) {
				this._shapes.xy.flipped = tmpV2$3.set(+(tmpV1$3.dot(this.root.up) < 0), +(tmpV1$3.dot(this.root.right) > 0), 0);
			}
			tmpV1$3.cross(facingDir, this.root.up);
			this._shapes.xz.entity.enabled = tmpV1$3.length() < GLANCE_EPSILON$1;
			if (this.flipShapes) {
				this._shapes.xz.flipped = tmpV2$3.set(+(tmpV1$3.dot(this.root.forward) > 0), 0, +(tmpV1$3.dot(this.root.right) > 0));
			}
		};
		_proto._storeNodePositions = function _storeNodePositions() {
			for (var i = 0; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				this._nodeLocalPositions.set(node, node.getLocalPosition().clone());
				this._nodePositions.set(node, node.getPosition().clone());
			}
		};
		_proto._setNodePositions = function _setNodePositions(pointDelta) {
			for (var i = 0; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				if (this._coordSpace === GIZMOSPACE_LOCAL) {
					var _node$parent;
					var pos = this._nodeLocalPositions.get(node);
					if (!pos) {
						continue;
					}
					tmpV1$3.copy(pointDelta);
					(_node$parent = node.parent) == null || _node$parent.getWorldTransform().getScale(tmpV2$3);
					tmpV2$3.x = 1 / tmpV2$3.x;
					tmpV2$3.y = 1 / tmpV2$3.y;
					tmpV2$3.z = 1 / tmpV2$3.z;
					tmpQ1$3.copy(node.getLocalRotation()).transformVector(tmpV1$3, tmpV1$3);
					tmpV1$3.mul(tmpV2$3);
					node.setLocalPosition(tmpV1$3.add(pos));
				} else {
					var _pos = this._nodePositions.get(node);
					if (!_pos) {
						continue;
					}
					node.setPosition(tmpV1$3.copy(pointDelta).add(_pos));
				}
			}
			this._updatePosition();
		};
		_proto._screenToPoint = function _screenToPoint(x, y) {
			var mouseWPos = this._camera.screenToWorld(x, y, 1);
			var axis = this._selectedAxis;
			var isPlane = this._selectedIsPlane;
			var ray = this._createRay(mouseWPos);
			var plane = this._createPlane(axis, axis === GIZMOAXIS_FACE, !isPlane);
			var point = new Vec3();
			var angle = 0;
			plane.intersectsRay(ray, point);
			tmpQ1$3.copy(this._rootStartRot).invert().transformVector(point, point);
			if (!isPlane && axis !== GIZMOAXIS_FACE) {
				this._projectToAxis(point, axis);
			}
			return {
				point: point,
				angle: angle
			};
		};
		return _createClass(TranslateGizmo, [{
			key: "axisGap",
			get: function get() {
				return this._shapes.x.gap;
			},
			set: function set(value) {
				this._setArrowProp('gap', value);
			}
		}, {
			key: "axisLineThickness",
			get: function get() {
				return this._shapes.x.lineThickness;
			},
			set: function set(value) {
				this._setArrowProp('lineThickness', value);
			}
		}, {
			key: "axisLineLength",
			get: function get() {
				return this._shapes.x.lineLength;
			},
			set: function set(value) {
				this._setArrowProp('lineLength', value);
			}
		}, {
			key: "axisLineTolerance",
			get: function get() {
				return this._shapes.x.tolerance;
			},
			set: function set(value) {
				this._setArrowProp('tolerance', value);
			}
		}, {
			key: "axisArrowThickness",
			get: function get() {
				return this._shapes.x.arrowThickness;
			},
			set: function set(value) {
				this._setArrowProp('arrowThickness', value);
			}
		}, {
			key: "axisArrowLength",
			get: function get() {
				return this._shapes.x.arrowLength;
			},
			set: function set(value) {
				this._setArrowProp('arrowLength', value);
			}
		}, {
			key: "axisPlaneSize",
			get: function get() {
				return this._shapes.yz.size;
			},
			set: function set(value) {
				this._setPlaneProp('size', value);
			}
		}, {
			key: "axisPlaneGap",
			get: function get() {
				return this._shapes.yz.gap;
			},
			set: function set(value) {
				this._setPlaneProp('gap', value);
			}
		}, {
			key: "axisCenterSize",
			get: function get() {
				return this._shapes.face.size;
			},
			set: function set(value) {
				this._shapes.face.size = value;
			}
		}, {
			key: "axisCenterTolerance",
			get: function get() {
				return this._shapes.face.tolerance;
			},
			set: function set(value) {
				this._shapes.face.tolerance = value;
			}
		}]);
	}(TransformGizmo);

	var TORUS_RENDER_SEGMENTS = 80;
	var TORUS_INTERSECT_SEGMENTS = 20;
	var ArcShape = function (_Shape) {
		function ArcShape(device, options) {
			var _options$tubeRadius, _options$ringRadius, _options$sectorAngle;
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _Shape.call(this, device, options) || this;
			_this._tubeRadius = 0.01;
			_this._ringRadius = 0.5;
			_this._sectorAngle = void 0;
			_this._lightDir = void 0;
			_this._tolerance = 0.05;
			_this._tubeRadius = (_options$tubeRadius = options.tubeRadius) != null ? _options$tubeRadius : _this._tubeRadius;
			_this._ringRadius = (_options$ringRadius = options.ringRadius) != null ? _options$ringRadius : _this._ringRadius;
			_this._sectorAngle = (_options$sectorAngle = options.sectorAngle) != null ? _options$sectorAngle : _this._sectorAngle;
			_this.triData = [new TriData(_this._createTorusGeometry())];
			_this._createDisk();
			return _this;
		}
		_inheritsLoose(ArcShape, _Shape);
		var _proto = ArcShape.prototype;
		_proto._createTorusGeometry = function _createTorusGeometry() {
			return new TorusGeometry({
				tubeRadius: this._tubeRadius + this._tolerance,
				ringRadius: this._ringRadius,
				sectorAngle: this._sectorAngle,
				segments: TORUS_INTERSECT_SEGMENTS
			});
		};
		_proto._createTorusMesh = function _createTorusMesh(sectorAngle) {
			var geom = new TorusGeometry({
				tubeRadius: this._tubeRadius,
				ringRadius: this._ringRadius,
				sectorAngle: sectorAngle,
				segments: TORUS_RENDER_SEGMENTS
			});
			return this._createMesh(geom, this._shading);
		};
		_proto._createDisk = function _createDisk() {
			this._createRoot('disk');
			this._createRenderComponent(this.entity, [this._createTorusMesh(this._sectorAngle), this._createTorusMesh(360)]);
			this.drag(false);
		};
		_proto._updateTransform = function _updateTransform() {
			this.triData[0].fromGeometry(this._createTorusGeometry());
			this.meshInstances[0].mesh = this._createTorusMesh(this._sectorAngle);
			this.meshInstances[1].mesh = this._createTorusMesh(360);
		};
		_proto.drag = function drag(state) {
			this.meshInstances[0].visible = !state;
			this.meshInstances[1].visible = state;
		};
		_proto.hide = function hide(state) {
			if (state) {
				this.meshInstances[0].visible = false;
				this.meshInstances[1].visible = false;
				return;
			}
			this.drag(false);
		};
		return _createClass(ArcShape, [{
			key: "tubeRadius",
			get: function get() {
				return this._tubeRadius;
			},
			set: function set(value) {
				this._tubeRadius = value != null ? value : 0.1;
				this._updateTransform();
			}
		}, {
			key: "ringRadius",
			get: function get() {
				return this._ringRadius;
			},
			set: function set(value) {
				this._ringRadius = value != null ? value : 0.1;
				this._updateTransform();
			}
		}, {
			key: "tolerance",
			get: function get() {
				return this._tolerance;
			},
			set: function set(value) {
				this._tolerance = value;
				this._updateTransform();
			}
		}]);
	}(Shape);

	var tmpV1$2 = new Vec3();
	var tmpV2$2 = new Vec3();
	var tmpV3 = new Vec3();
	var tmpV4 = new Vec3();
	var tmpM1 = new Mat4();
	var tmpQ1$2 = new Quat();
	var tmpQ2 = new Quat();
	var FACING_THRESHOLD = 0.9;
	var GUIDE_ANGLE_COLOR = new Color(0, 0, 0, 0.3);
	var RotateGizmo = function (_TransformGizmo) {
		function RotateGizmo(camera, layer) {
			var _this;
			_this = _TransformGizmo.call(this, camera, layer) || this;
			_this._shapes = {
				z: new ArcShape(_this._device, {
					axis: GIZMOAXIS_Z,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(90, 0, 90),
					defaultColor: _this._meshColors.axis.z,
					hoverColor: _this._meshColors.hover.z,
					sectorAngle: 180
				}),
				x: new ArcShape(_this._device, {
					axis: GIZMOAXIS_X,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, -90),
					defaultColor: _this._meshColors.axis.x,
					hoverColor: _this._meshColors.hover.x,
					sectorAngle: 180
				}),
				y: new ArcShape(_this._device, {
					axis: GIZMOAXIS_Y,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, 0),
					defaultColor: _this._meshColors.axis.y,
					hoverColor: _this._meshColors.hover.y,
					sectorAngle: 180
				}),
				face: new ArcShape(_this._device, {
					axis: GIZMOAXIS_FACE,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: _this._getLookAtEulerAngles(_this._camera.entity.getPosition()),
					defaultColor: _this._meshColors.axis.f,
					hoverColor: _this._meshColors.hover.f,
					ringRadius: 0.55
				})
			};
			_this._nodeLocalRotations = new Map();
			_this._nodeRotations = new Map();
			_this._nodeOffsets = new Map();
			_this._guideAngleStartColor = GUIDE_ANGLE_COLOR.clone();
			_this._guideAngleStart = new Vec3();
			_this._guideAngleEnd = new Vec3();
			_this.snapIncrement = 5;
			_this._createTransform();
			_this.on(TransformGizmo.EVENT_TRANSFORMSTART, function () {
				_this._storeNodeRotations();
				_this._storeGuidePoints();
				_this._drag(true);
			});
			_this.on(TransformGizmo.EVENT_TRANSFORMMOVE, function (pointDelta, angleDelta) {
				var axis = _this._selectedAxis;
				if (_this.snap) {
					angleDelta = Math.round(angleDelta / _this.snapIncrement) * _this.snapIncrement;
				}
				_this._setNodeRotations(axis, angleDelta);
				_this._updateGuidePoints(angleDelta);
			});
			_this.on(TransformGizmo.EVENT_TRANSFORMEND, function () {
				_this._drag(false);
			});
			_this.on(TransformGizmo.EVENT_NODESDETACH, function () {
				_this._nodeLocalRotations.clear();
				_this._nodeRotations.clear();
				_this._nodeOffsets.clear();
			});
			_this._app.on('prerender', function () {
				_this._shapesLookAtCamera();
				if (_this._dragging) {
					var gizmoPos = _this.root.getPosition();
					_this._drawGuideAngleLine(gizmoPos, _this._selectedAxis, _this._guideAngleStart, _this._guideAngleStartColor);
					_this._drawGuideAngleLine(gizmoPos, _this._selectedAxis, _this._guideAngleEnd);
				}
			});
			return _this;
		}
		_inheritsLoose(RotateGizmo, _TransformGizmo);
		var _proto = RotateGizmo.prototype;
		_proto._setDiskProp = function _setDiskProp(prop, value) {
			this._shapes.x[prop] = value;
			this._shapes.y[prop] = value;
			this._shapes.z[prop] = value;
		};
		_proto._storeGuidePoints = function _storeGuidePoints() {
			var gizmoPos = this.root.getPosition();
			var axis = this._selectedAxis;
			var isFacing = axis === GIZMOAXIS_FACE;
			var scale = isFacing ? this.faceRingRadius : this.xyzRingRadius;
			this._guideAngleStart.copy(this._selectionStartPoint).sub(gizmoPos).normalize();
			this._guideAngleStart.mulScalar(scale);
			this._guideAngleEnd.copy(this._guideAngleStart);
		};
		_proto._updateGuidePoints = function _updateGuidePoints(angleDelta) {
			var axis = this._selectedAxis;
			var isFacing = axis === GIZMOAXIS_FACE;
			if (isFacing) {
				tmpV1$2.copy(this.facing);
			} else {
				tmpV1$2.set(0, 0, 0);
				tmpV1$2[axis] = 1;
				this._rootStartRot.transformVector(tmpV1$2, tmpV1$2);
			}
			tmpQ1$2.setFromAxisAngle(tmpV1$2, angleDelta);
			tmpQ1$2.transformVector(this._guideAngleStart, this._guideAngleEnd);
		};
		_proto._drawGuideAngleLine = function _drawGuideAngleLine(pos, axis, point, color) {
			if (color === void 0) {
				color = this._guideColors[axis];
			}
			tmpV1$2.set(0, 0, 0);
			tmpV2$2.copy(point).mulScalar(this._scale);
			this._app.drawLine(tmpV1$2.add(pos), tmpV2$2.add(pos), color, false, this._layer);
		};
		_proto._getLookAtEulerAngles = function _getLookAtEulerAngles(position) {
			tmpV1$2.set(0, 0, 0);
			tmpM1.setLookAt(tmpV1$2, position, Vec3.UP);
			tmpQ1$2.setFromMat4(tmpM1);
			tmpQ1$2.getEulerAngles(tmpV1$2);
			tmpV1$2.x += 90;
			return tmpV1$2;
		};
		_proto._shapesLookAtCamera = function _shapesLookAtCamera() {
			if (this._camera.projection === PROJECTION_PERSPECTIVE) {
				this._shapes.face.entity.lookAt(this._camera.entity.getPosition());
				this._shapes.face.entity.rotateLocal(90, 0, 0);
			} else {
				tmpQ1$2.copy(this._camera.entity.getRotation()).getEulerAngles(tmpV1$2);
				this._shapes.face.entity.setEulerAngles(tmpV1$2);
				this._shapes.face.entity.rotateLocal(-90, 0, 0);
			}
			var facingDir = tmpV1$2.copy(this.facing);
			tmpQ1$2.copy(this.root.getRotation()).invert().transformVector(facingDir, facingDir);
			var angle = Math.atan2(facingDir.z, facingDir.y) * math.RAD_TO_DEG;
			this._shapes.x.entity.setLocalEulerAngles(0, angle - 90, -90);
			angle = Math.atan2(facingDir.x, facingDir.z) * math.RAD_TO_DEG;
			this._shapes.y.entity.setLocalEulerAngles(0, angle, 0);
			angle = Math.atan2(facingDir.y, facingDir.x) * math.RAD_TO_DEG;
			this._shapes.z.entity.setLocalEulerAngles(90, 0, angle + 90);
		};
		_proto._drag = function _drag(state) {
			for (var axis in this._shapes) {
				var shape = this._shapes[axis];
				if (axis === this._selectedAxis) {
					shape.drag(state);
				} else {
					shape.hide(state);
				}
			}
			this.fire(TransformGizmo.EVENT_RENDERUPDATE);
		};
		_proto._storeNodeRotations = function _storeNodeRotations() {
			var gizmoPos = this.root.getPosition();
			for (var i = 0; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				this._nodeLocalRotations.set(node, node.getLocalRotation().clone());
				this._nodeRotations.set(node, node.getRotation().clone());
				this._nodeOffsets.set(node, node.getPosition().clone().sub(gizmoPos));
			}
		};
		_proto._setNodeRotations = function _setNodeRotations(axis, angleDelta) {
			var gizmoPos = this.root.getPosition();
			var isFacing = axis === GIZMOAXIS_FACE;
			for (var i = 0; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				if (isFacing) {
					tmpV1$2.copy(this._camera.entity.forward).mulScalar(-1);
				} else {
					tmpV1$2.set(0, 0, 0);
					tmpV1$2[axis] = 1;
				}
				tmpQ1$2.setFromAxisAngle(tmpV1$2, angleDelta);
				if (!isFacing && this._coordSpace === GIZMOSPACE_LOCAL) {
					var rot = this._nodeLocalRotations.get(node);
					if (!rot) {
						continue;
					}
					tmpQ2.copy(rot).mul(tmpQ1$2);
					node.setLocalRotation(tmpQ2);
				} else {
					var _rot = this._nodeRotations.get(node);
					if (!_rot) {
						continue;
					}
					var offset = this._nodeOffsets.get(node);
					if (!offset) {
						continue;
					}
					tmpV1$2.copy(offset);
					tmpQ1$2.transformVector(tmpV1$2, tmpV1$2);
					tmpQ2.copy(tmpQ1$2).mul(_rot);
					node.setEulerAngles(tmpQ2.getEulerAngles());
					node.setPosition(tmpV1$2.add(gizmoPos));
				}
			}
			if (this._coordSpace === GIZMOSPACE_LOCAL) {
				this._updateRotation();
			}
		};
		_proto._screenToPoint = function _screenToPoint(x, y) {
			var gizmoPos = this.root.getPosition();
			var mouseWPos = this._camera.screenToWorld(x, y, 1);
			var axis = this._selectedAxis;
			var ray = this._createRay(mouseWPos);
			var plane = this._createPlane(axis, axis === GIZMOAXIS_FACE, false);
			var point = new Vec3();
			var angle = 0;
			plane.intersectsRay(ray, point);
			var facingDir = tmpV2$2.copy(this.facing);
			var facingDot = plane.normal.dot(facingDir);
			if (Math.abs(facingDot) > FACING_THRESHOLD) {
				tmpV1$2.sub2(point, gizmoPos);
				tmpQ1$2.copy(this._camera.entity.getRotation()).invert().transformVector(tmpV1$2, tmpV1$2);
				angle = Math.sign(facingDot) * Math.atan2(tmpV1$2.y, tmpV1$2.x) * math.RAD_TO_DEG;
			} else {
				tmpV1$2.copy(gizmoPos);
				tmpV2$2.cross(plane.normal, facingDir).normalize().add(gizmoPos);
				this._camera.worldToScreen(tmpV1$2, tmpV3);
				this._camera.worldToScreen(tmpV2$2, tmpV4);
				tmpV1$2.sub2(tmpV4, tmpV3).normalize();
				tmpV2$2.set(x, y, 0);
				angle = tmpV1$2.dot(tmpV2$2);
			}
			return {
				point: point,
				angle: angle
			};
		};
		return _createClass(RotateGizmo, [{
			key: "xyzTubeRadius",
			get: function get() {
				return this._shapes.x.tubeRadius;
			},
			set: function set(value) {
				this._setDiskProp('tubeRadius', value);
			}
		}, {
			key: "xyzRingRadius",
			get: function get() {
				return this._shapes.x.ringRadius;
			},
			set: function set(value) {
				this._setDiskProp('ringRadius', value);
			}
		}, {
			key: "faceTubeRadius",
			get: function get() {
				return this._shapes.face.tubeRadius;
			},
			set: function set(value) {
				this._shapes.face.tubeRadius = value;
			}
		}, {
			key: "faceRingRadius",
			get: function get() {
				return this._shapes.face.ringRadius;
			},
			set: function set(value) {
				this._shapes.face.ringRadius = value;
			}
		}, {
			key: "ringTolerance",
			get: function get() {
				return this._shapes.x.tolerance;
			},
			set: function set(value) {
				this._setDiskProp('tolerance', value);
				this._shapes.face.tolerance = value;
			}
		}]);
	}(TransformGizmo);

	var BoxShape = function (_Shape) {
		function BoxShape(device, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _Shape.call(this, device, options) || this;
			_this._size = 0.12;
			_this._tolerance = 0.05;
			_this.triData = [new TriData(new BoxGeometry(), 2)];
			_this._createCenter();
			return _this;
		}
		_inheritsLoose(BoxShape, _Shape);
		var _proto = BoxShape.prototype;
		_proto._createCenter = function _createCenter() {
			this._createRoot('boxCenter');
			this._updateTransform();
			this._addRenderMesh(this.entity, 'box', this._shading);
		};
		_proto._updateTransform = function _updateTransform() {
			this.entity.setLocalScale(this._size, this._size, this._size);
		};
		return _createClass(BoxShape, [{
			key: "size",
			get: function get() {
				return this._size;
			},
			set: function set(value) {
				this._size = value != null ? value : 1;
				this._updateTransform();
			}
		}, {
			key: "tolerance",
			get: function get() {
				return this._tolerance;
			},
			set: function set(value) {
				this._tolerance = value;
				this._updateTransform();
			}
		}]);
	}(Shape);

	var tmpV1$1 = new Vec3();
	var tmpV2$1 = new Vec3();
	var tmpQ1$1 = new Quat();
	var BoxLineShape = function (_Shape) {
		function BoxLineShape(device, options) {
			var _this;
			if (options === void 0) {
				options = {};
			}
			_this = _Shape.call(this, device, options) || this;
			_this._gap = 0;
			_this._lineThickness = 0.02;
			_this._lineLength = 0.5;
			_this._boxSize = 0.12;
			_this._tolerance = 0.1;
			_this._box = void 0;
			_this._line = void 0;
			_this._flipped = false;
			_this.triData = [new TriData(new BoxGeometry()), new TriData(new CylinderGeometry(), 1)];
			_this._createBoxLine();
			return _this;
		}
		_inheritsLoose(BoxLineShape, _Shape);
		var _proto = BoxLineShape.prototype;
		_proto._createBoxLine = function _createBoxLine() {
			this._createRoot('boxLine');
			this._box = new Entity("box:" + this.axis);
			this.entity.addChild(this._box);
			this._updateBox();
			this._addRenderMesh(this._box, 'box', this._shading);
			this._line = new Entity("line:" + this.axis);
			this.entity.addChild(this._line);
			this._updateLine();
			this._addRenderMesh(this._line, 'cylinder', this._shading);
		};
		_proto._updateBox = function _updateBox() {
			tmpV1$1.set(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
			tmpQ1$1.set(0, 0, 0, 1);
			tmpV2$1.set(this._boxSize, this._boxSize, this._boxSize);
			this.triData[0].setTransform(tmpV1$1, tmpQ1$1, tmpV2$1);
			this._box.setLocalPosition(0, this._gap + this._boxSize * 0.5 + this._lineLength, 0);
			this._box.setLocalScale(this._boxSize, this._boxSize, this._boxSize);
		};
		_proto._updateLine = function _updateLine() {
			tmpV1$1.set(0, this._gap + this._lineLength * 0.5, 0);
			tmpQ1$1.set(0, 0, 0, 1);
			tmpV2$1.set(this._lineThickness + this._tolerance, this._lineLength, this._lineThickness + this._tolerance);
			this.triData[1].setTransform(tmpV1$1, tmpQ1$1, tmpV2$1);
			this._line.setLocalPosition(0, this._gap + this._lineLength * 0.5, 0);
			this._line.setLocalScale(this._lineThickness, this._lineLength, this._lineThickness);
		};
		return _createClass(BoxLineShape, [{
			key: "gap",
			get: function get() {
				return this._gap;
			},
			set: function set(value) {
				this._gap = value != null ? value : 0;
				this._updateLine();
				this._updateBox();
			}
		}, {
			key: "lineThickness",
			get: function get() {
				return this._lineThickness;
			},
			set: function set(value) {
				this._lineThickness = value != null ? value : 1;
				this._updateLine();
				this._updateBox();
			}
		}, {
			key: "lineLength",
			get: function get() {
				return this._lineLength;
			},
			set: function set(value) {
				this._lineLength = value != null ? value : 1;
				this._updateLine();
				this._updateBox();
			}
		}, {
			key: "boxSize",
			get: function get() {
				return this._boxSize;
			},
			set: function set(value) {
				this._boxSize = value != null ? value : 1;
				this._updateBox();
			}
		}, {
			key: "tolerance",
			get: function get() {
				return this._tolerance;
			},
			set: function set(value) {
				this._tolerance = value;
				this._updateLine();
			}
		}, {
			key: "flipped",
			get: function get() {
				return this._flipped;
			},
			set: function set(value) {
				if (this._flipped === value) {
					return;
				}
				this._flipped = value;
				if (this._rotation.equals(Vec3.ZERO)) {
					tmpV1$1.set(0, 0, this._flipped ? 180 : 0);
				} else {
					tmpV1$1.copy(this._rotation).mulScalar(this._flipped ? -1 : 1);
				}
				this._line.enabled = !this._flipped;
				this.entity.setLocalEulerAngles(tmpV1$1);
			}
		}]);
	}(Shape);

	var tmpV1 = new Vec3();
	var tmpV2 = new Vec3();
	var tmpQ1 = new Quat();
	var GLANCE_EPSILON = 0.98;
	var ScaleGizmo = function (_TransformGizmo) {
		function ScaleGizmo(camera, layer) {
			var _this;
			_this = _TransformGizmo.call(this, camera, layer) || this;
			_this._shapes = {
				xyz: new BoxShape(_this._device, {
					axis: GIZMOAXIS_XYZ,
					layers: [_this._layer.id],
					shading: _this._shading,
					defaultColor: _this._meshColors.axis.xyz,
					hoverColor: _this._meshColors.hover.xyz
				}),
				yz: new PlaneShape(_this._device, {
					axis: GIZMOAXIS_X,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, -90),
					defaultColor: _this._meshColors.axis.x,
					hoverColor: _this._meshColors.hover.x
				}),
				xz: new PlaneShape(_this._device, {
					axis: GIZMOAXIS_Y,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, 0),
					defaultColor: _this._meshColors.axis.y,
					hoverColor: _this._meshColors.hover.y
				}),
				xy: new PlaneShape(_this._device, {
					axis: GIZMOAXIS_Z,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(90, 0, 0),
					defaultColor: _this._meshColors.axis.z,
					hoverColor: _this._meshColors.hover.z
				}),
				x: new BoxLineShape(_this._device, {
					axis: GIZMOAXIS_X,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, -90),
					defaultColor: _this._meshColors.axis.x,
					hoverColor: _this._meshColors.hover.x
				}),
				y: new BoxLineShape(_this._device, {
					axis: GIZMOAXIS_Y,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(0, 0, 0),
					defaultColor: _this._meshColors.axis.y,
					hoverColor: _this._meshColors.hover.y
				}),
				z: new BoxLineShape(_this._device, {
					axis: GIZMOAXIS_Z,
					layers: [_this._layer.id],
					shading: _this._shading,
					rotation: new Vec3(90, 0, 0),
					defaultColor: _this._meshColors.axis.z,
					hoverColor: _this._meshColors.hover.z
				})
			};
			_this._coordSpace = GIZMOSPACE_LOCAL;
			_this._nodeScales = new Map();
			_this._useUniformScaling = false;
			_this.snapIncrement = 1;
			_this.flipShapes = true;
			_this.lowerBoundScale = new Vec3(-Infinity, -Infinity, -Infinity);
			_this._createTransform();
			_this.on(TransformGizmo.EVENT_TRANSFORMSTART, function () {
				_this._storeNodeScales();
			});
			_this.on(TransformGizmo.EVENT_TRANSFORMMOVE, function (pointDelta) {
				if (_this.snap) {
					pointDelta.mulScalar(1 / _this.snapIncrement);
					pointDelta.round();
					pointDelta.mulScalar(_this.snapIncrement);
				}
				pointDelta.mulScalar(1 / _this._scale);
				_this._setNodeScales(pointDelta.add(Vec3.ONE));
			});
			_this.on(TransformGizmo.EVENT_NODESDETACH, function () {
				_this._nodeScales.clear();
			});
			_this._app.on('prerender', function () {
				_this._shapesLookAtCamera();
			});
			return _this;
		}
		_inheritsLoose(ScaleGizmo, _TransformGizmo);
		var _proto = ScaleGizmo.prototype;
		_proto._setArrowProp = function _setArrowProp(prop, value) {
			this._shapes.x[prop] = value;
			this._shapes.y[prop] = value;
			this._shapes.z[prop] = value;
		};
		_proto._setPlaneProp = function _setPlaneProp(prop, value) {
			this._shapes.yz[prop] = value;
			this._shapes.xz[prop] = value;
			this._shapes.xy[prop] = value;
		};
		_proto._shapesLookAtCamera = function _shapesLookAtCamera() {
			var facingDir = this.facing;
			var dot = facingDir.dot(this.root.right);
			this._shapes.x.entity.enabled = Math.abs(dot) < GLANCE_EPSILON;
			if (this.flipShapes) {
				this._shapes.x.flipped = dot < 0;
			}
			dot = facingDir.dot(this.root.up);
			this._shapes.y.entity.enabled = Math.abs(dot) < GLANCE_EPSILON;
			if (this.flipShapes) {
				this._shapes.y.flipped = dot < 0;
			}
			dot = facingDir.dot(this.root.forward);
			this._shapes.z.entity.enabled = Math.abs(dot) < GLANCE_EPSILON;
			if (this.flipShapes) {
				this._shapes.z.flipped = dot > 0;
			}
			tmpV1.cross(facingDir, this.root.right);
			this._shapes.yz.entity.enabled = tmpV1.length() < GLANCE_EPSILON;
			if (this.flipShapes) {
				this._shapes.yz.flipped = tmpV2.set(0, +(tmpV1.dot(this.root.forward) < 0), +(tmpV1.dot(this.root.up) < 0));
			}
			tmpV1.cross(facingDir, this.root.forward);
			this._shapes.xy.entity.enabled = tmpV1.length() < GLANCE_EPSILON;
			if (this.flipShapes) {
				this._shapes.xy.flipped = tmpV2.set(+(tmpV1.dot(this.root.up) < 0), +(tmpV1.dot(this.root.right) > 0), 0);
			}
			tmpV1.cross(facingDir, this.root.up);
			this._shapes.xz.entity.enabled = tmpV1.length() < GLANCE_EPSILON;
			if (this.flipShapes) {
				this._shapes.xz.flipped = tmpV2.set(+(tmpV1.dot(this.root.forward) > 0), 0, +(tmpV1.dot(this.root.right) > 0));
			}
		};
		_proto._storeNodeScales = function _storeNodeScales() {
			for (var i = 0; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				this._nodeScales.set(node, node.getLocalScale().clone());
			}
		};
		_proto._setNodeScales = function _setNodeScales(pointDelta) {
			for (var i = 0; i < this.nodes.length; i++) {
				var node = this.nodes[i];
				var scale = this._nodeScales.get(node);
				if (!scale) {
					continue;
				}
				node.setLocalScale(tmpV1.copy(scale).mul(pointDelta).max(this.lowerBoundScale));
			}
		};
		_proto._screenToPoint = function _screenToPoint(x, y) {
			var gizmoPos = this.root.getPosition();
			var mouseWPos = this._camera.screenToWorld(x, y, 1);
			var axis = this._selectedAxis;
			var isPlane = this._selectedIsPlane;
			var isScaleUniform = this._useUniformScaling && isPlane || axis === GIZMOAXIS_XYZ;
			var ray = this._createRay(mouseWPos);
			var plane = this._createPlane(axis, isScaleUniform, !isPlane);
			var point = new Vec3();
			var angle = 0;
			plane.intersectsRay(ray, point);
			if (isScaleUniform) {
				switch (axis) {
					case GIZMOAXIS_X:
						tmpV1.copy(this.root.up);
						tmpV2.copy(this.root.forward).mulScalar(-1);
						break;
					case GIZMOAXIS_Y:
						tmpV1.copy(this.root.right);
						tmpV2.copy(this.root.forward).mulScalar(-1);
						break;
					case GIZMOAXIS_Z:
						tmpV1.copy(this.root.up);
						tmpV2.copy(this.root.right);
						break;
					default:
						tmpV1.copy(this._camera.entity.up);
						tmpV2.copy(this._camera.entity.right);
						break;
				}
				tmpV2.add(tmpV1).normalize();
				tmpV1.sub2(point, gizmoPos);
				var length = tmpV1.length();
				var v = length * tmpV1.normalize().dot(tmpV2);
				point.set(v, v, v);
				if (axis !== GIZMOAXIS_XYZ) {
					point[axis] = 1;
				}
				return {
					point: point,
					angle: angle
				};
			}
			tmpQ1.copy(this._rootStartRot).invert().transformVector(point, point);
			if (!isPlane) {
				this._projectToAxis(point, axis);
			}
			return {
				point: point,
				angle: angle
			};
		};
		return _createClass(ScaleGizmo, [{
			key: "coordSpace",
			get: function get() {
				return this._coordSpace;
			},
			set: function set(value) {}
		}, {
			key: "uniform",
			get: function get() {
				return this._useUniformScaling;
			},
			set: function set(value) {
				this._useUniformScaling = value != null ? value : true;
			}
		}, {
			key: "axisGap",
			get: function get() {
				return this._shapes.x.gap;
			},
			set: function set(value) {
				this._setArrowProp('gap', value);
			}
		}, {
			key: "axisLineThickness",
			get: function get() {
				return this._shapes.x.lineThickness;
			},
			set: function set(value) {
				this._setArrowProp('lineThickness', value);
			}
		}, {
			key: "axisLineLength",
			get: function get() {
				return this._shapes.x.lineLength;
			},
			set: function set(value) {
				this._setArrowProp('lineLength', value);
			}
		}, {
			key: "axisLineTolerance",
			get: function get() {
				return this._shapes.x.tolerance;
			},
			set: function set(value) {
				this._setArrowProp('tolerance', value);
			}
		}, {
			key: "axisBoxSize",
			get: function get() {
				return this._shapes.x.boxSize;
			},
			set: function set(value) {
				this._setArrowProp('boxSize', value);
			}
		}, {
			key: "axisPlaneSize",
			get: function get() {
				return this._shapes.yz.size;
			},
			set: function set(value) {
				this._setPlaneProp('size', value);
			}
		}, {
			key: "axisPlaneGap",
			get: function get() {
				return this._shapes.yz.gap;
			},
			set: function set(value) {
				this._setPlaneProp('gap', value);
			}
		}, {
			key: "axisCenterSize",
			get: function get() {
				return this._shapes.xyz.size;
			},
			set: function set(value) {
				this._shapes.xyz.size = value;
			}
		}, {
			key: "axisCenterTolerance",
			get: function get() {
				return this._shapes.xyz.tolerance;
			},
			set: function set(value) {
				this._shapes.xyz.tolerance = value;
			}
		}]);
	}(TransformGizmo);

	exports.ABSOLUTE_URL = ABSOLUTE_URL;
	exports.ACTION_GAMEPAD = ACTION_GAMEPAD;
	exports.ACTION_KEYBOARD = ACTION_KEYBOARD;
	exports.ACTION_MOUSE = ACTION_MOUSE;
	exports.ADDRESS_CLAMP_TO_EDGE = ADDRESS_CLAMP_TO_EDGE;
	exports.ADDRESS_MIRRORED_REPEAT = ADDRESS_MIRRORED_REPEAT;
	exports.ADDRESS_REPEAT = ADDRESS_REPEAT;
	exports.ANIM_BLEND_1D = ANIM_BLEND_1D;
	exports.ANIM_BLEND_2D_CARTESIAN = ANIM_BLEND_2D_CARTESIAN;
	exports.ANIM_BLEND_2D_DIRECTIONAL = ANIM_BLEND_2D_DIRECTIONAL;
	exports.ANIM_BLEND_DIRECT = ANIM_BLEND_DIRECT;
	exports.ANIM_CONTROL_STATES = ANIM_CONTROL_STATES;
	exports.ANIM_EQUAL_TO = ANIM_EQUAL_TO;
	exports.ANIM_GREATER_THAN = ANIM_GREATER_THAN;
	exports.ANIM_GREATER_THAN_EQUAL_TO = ANIM_GREATER_THAN_EQUAL_TO;
	exports.ANIM_INTERRUPTION_NEXT = ANIM_INTERRUPTION_NEXT;
	exports.ANIM_INTERRUPTION_NEXT_PREV = ANIM_INTERRUPTION_NEXT_PREV;
	exports.ANIM_INTERRUPTION_NONE = ANIM_INTERRUPTION_NONE;
	exports.ANIM_INTERRUPTION_PREV = ANIM_INTERRUPTION_PREV;
	exports.ANIM_INTERRUPTION_PREV_NEXT = ANIM_INTERRUPTION_PREV_NEXT;
	exports.ANIM_LAYER_ADDITIVE = ANIM_LAYER_ADDITIVE;
	exports.ANIM_LAYER_OVERWRITE = ANIM_LAYER_OVERWRITE;
	exports.ANIM_LESS_THAN = ANIM_LESS_THAN;
	exports.ANIM_LESS_THAN_EQUAL_TO = ANIM_LESS_THAN_EQUAL_TO;
	exports.ANIM_NOT_EQUAL_TO = ANIM_NOT_EQUAL_TO;
	exports.ANIM_PARAMETER_BOOLEAN = ANIM_PARAMETER_BOOLEAN;
	exports.ANIM_PARAMETER_FLOAT = ANIM_PARAMETER_FLOAT;
	exports.ANIM_PARAMETER_INTEGER = ANIM_PARAMETER_INTEGER;
	exports.ANIM_PARAMETER_TRIGGER = ANIM_PARAMETER_TRIGGER;
	exports.ANIM_STATE_ANY = ANIM_STATE_ANY;
	exports.ANIM_STATE_END = ANIM_STATE_END;
	exports.ANIM_STATE_START = ANIM_STATE_START;
	exports.ASPECT_AUTO = ASPECT_AUTO;
	exports.ASPECT_MANUAL = ASPECT_MANUAL;
	exports.ASSET_ANIMATION = ASSET_ANIMATION;
	exports.ASSET_AUDIO = ASSET_AUDIO;
	exports.ASSET_CONTAINER = ASSET_CONTAINER;
	exports.ASSET_CSS = ASSET_CSS;
	exports.ASSET_CUBEMAP = ASSET_CUBEMAP;
	exports.ASSET_HTML = ASSET_HTML;
	exports.ASSET_IMAGE = ASSET_IMAGE;
	exports.ASSET_JSON = ASSET_JSON;
	exports.ASSET_MATERIAL = ASSET_MATERIAL;
	exports.ASSET_MODEL = ASSET_MODEL;
	exports.ASSET_SCRIPT = ASSET_SCRIPT;
	exports.ASSET_SHADER = ASSET_SHADER;
	exports.ASSET_TEXT = ASSET_TEXT;
	exports.ASSET_TEXTURE = ASSET_TEXTURE;
	exports.ASSET_TEXTUREATLAS = ASSET_TEXTUREATLAS;
	exports.AXIS_KEY = AXIS_KEY;
	exports.AXIS_MOUSE_X = AXIS_MOUSE_X;
	exports.AXIS_MOUSE_Y = AXIS_MOUSE_Y;
	exports.AXIS_PAD_L_X = AXIS_PAD_L_X;
	exports.AXIS_PAD_L_Y = AXIS_PAD_L_Y;
	exports.AXIS_PAD_R_X = AXIS_PAD_R_X;
	exports.AXIS_PAD_R_Y = AXIS_PAD_R_Y;
	exports.AnimBinder = AnimBinder;
	exports.AnimClip = AnimClip;
	exports.AnimClipHandler = AnimClipHandler;
	exports.AnimComponent = AnimComponent;
	exports.AnimComponentLayer = AnimComponentLayer;
	exports.AnimComponentSystem = AnimComponentSystem;
	exports.AnimController = AnimController;
	exports.AnimCurve = AnimCurve;
	exports.AnimData = AnimData;
	exports.AnimEvaluator = AnimEvaluator;
	exports.AnimEvents = AnimEvents;
	exports.AnimSnapshot = AnimSnapshot;
	exports.AnimStateGraph = AnimStateGraph;
	exports.AnimStateGraphHandler = AnimStateGraphHandler;
	exports.AnimTarget = AnimTarget;
	exports.AnimTrack = AnimTrack;
	exports.Animation = Animation;
	exports.AnimationComponent = AnimationComponent;
	exports.AnimationComponentSystem = AnimationComponentSystem;
	exports.AnimationHandler = AnimationHandler;
	exports.AppBase = AppBase;
	exports.AppOptions = AppOptions;
	exports.Application = Application;
	exports.Asset = Asset;
	exports.AssetListLoader = AssetListLoader;
	exports.AssetReference = AssetReference;
	exports.AssetRegistry = AssetRegistry;
	exports.AudioHandler = AudioHandler;
	exports.AudioListenerComponent = AudioListenerComponent;
	exports.AudioListenerComponentSystem = AudioListenerComponentSystem;
	exports.BAKE_COLOR = BAKE_COLOR;
	exports.BAKE_COLORDIR = BAKE_COLORDIR;
	exports.BINDGROUP_MESH = BINDGROUP_MESH;
	exports.BINDGROUP_MESH_UB = BINDGROUP_MESH_UB;
	exports.BINDGROUP_VIEW = BINDGROUP_VIEW;
	exports.BLENDEQUATION_ADD = BLENDEQUATION_ADD;
	exports.BLENDEQUATION_MAX = BLENDEQUATION_MAX;
	exports.BLENDEQUATION_MIN = BLENDEQUATION_MIN;
	exports.BLENDEQUATION_REVERSE_SUBTRACT = BLENDEQUATION_REVERSE_SUBTRACT;
	exports.BLENDEQUATION_SUBTRACT = BLENDEQUATION_SUBTRACT;
	exports.BLENDMODE_CONSTANT = BLENDMODE_CONSTANT;
	exports.BLENDMODE_CONSTANT_ALPHA = BLENDMODE_CONSTANT_ALPHA;
	exports.BLENDMODE_CONSTANT_COLOR = BLENDMODE_CONSTANT_COLOR;
	exports.BLENDMODE_DST_ALPHA = BLENDMODE_DST_ALPHA;
	exports.BLENDMODE_DST_COLOR = BLENDMODE_DST_COLOR;
	exports.BLENDMODE_ONE = BLENDMODE_ONE;
	exports.BLENDMODE_ONE_MINUS_CONSTANT = BLENDMODE_ONE_MINUS_CONSTANT;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_ALPHA = BLENDMODE_ONE_MINUS_CONSTANT_ALPHA;
	exports.BLENDMODE_ONE_MINUS_CONSTANT_COLOR = BLENDMODE_ONE_MINUS_CONSTANT_COLOR;
	exports.BLENDMODE_ONE_MINUS_DST_ALPHA = BLENDMODE_ONE_MINUS_DST_ALPHA;
	exports.BLENDMODE_ONE_MINUS_DST_COLOR = BLENDMODE_ONE_MINUS_DST_COLOR;
	exports.BLENDMODE_ONE_MINUS_SRC_ALPHA = BLENDMODE_ONE_MINUS_SRC_ALPHA;
	exports.BLENDMODE_ONE_MINUS_SRC_COLOR = BLENDMODE_ONE_MINUS_SRC_COLOR;
	exports.BLENDMODE_SRC_ALPHA = BLENDMODE_SRC_ALPHA;
	exports.BLENDMODE_SRC_ALPHA_SATURATE = BLENDMODE_SRC_ALPHA_SATURATE;
	exports.BLENDMODE_SRC_COLOR = BLENDMODE_SRC_COLOR;
	exports.BLENDMODE_ZERO = BLENDMODE_ZERO;
	exports.BLEND_ADDITIVE = BLEND_ADDITIVE;
	exports.BLEND_ADDITIVEALPHA = BLEND_ADDITIVEALPHA;
	exports.BLEND_MAX = BLEND_MAX;
	exports.BLEND_MIN = BLEND_MIN;
	exports.BLEND_MULTIPLICATIVE = BLEND_MULTIPLICATIVE;
	exports.BLEND_MULTIPLICATIVE2X = BLEND_MULTIPLICATIVE2X;
	exports.BLEND_NONE = BLEND_NONE;
	exports.BLEND_NORMAL = BLEND_NORMAL;
	exports.BLEND_PREMULTIPLIED = BLEND_PREMULTIPLIED;
	exports.BLEND_SCREEN = BLEND_SCREEN;
	exports.BLEND_SUBTRACTIVE = BLEND_SUBTRACTIVE;
	exports.BLUR_BOX = BLUR_BOX;
	exports.BLUR_GAUSSIAN = BLUR_GAUSSIAN;
	exports.BODYFLAG_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
	exports.BODYFLAG_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
	exports.BODYFLAG_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
	exports.BODYGROUP_DEFAULT = BODYGROUP_DEFAULT;
	exports.BODYGROUP_DYNAMIC = BODYGROUP_DYNAMIC;
	exports.BODYGROUP_ENGINE_1 = BODYGROUP_ENGINE_1;
	exports.BODYGROUP_ENGINE_2 = BODYGROUP_ENGINE_2;
	exports.BODYGROUP_ENGINE_3 = BODYGROUP_ENGINE_3;
	exports.BODYGROUP_KINEMATIC = BODYGROUP_KINEMATIC;
	exports.BODYGROUP_NONE = BODYGROUP_NONE;
	exports.BODYGROUP_STATIC = BODYGROUP_STATIC;
	exports.BODYGROUP_TRIGGER = BODYGROUP_TRIGGER;
	exports.BODYGROUP_USER_1 = BODYGROUP_USER_1;
	exports.BODYGROUP_USER_2 = BODYGROUP_USER_2;
	exports.BODYGROUP_USER_3 = BODYGROUP_USER_3;
	exports.BODYGROUP_USER_4 = BODYGROUP_USER_4;
	exports.BODYGROUP_USER_5 = BODYGROUP_USER_5;
	exports.BODYGROUP_USER_6 = BODYGROUP_USER_6;
	exports.BODYGROUP_USER_7 = BODYGROUP_USER_7;
	exports.BODYGROUP_USER_8 = BODYGROUP_USER_8;
	exports.BODYMASK_ALL = BODYMASK_ALL;
	exports.BODYMASK_NONE = BODYMASK_NONE;
	exports.BODYMASK_NOT_STATIC = BODYMASK_NOT_STATIC;
	exports.BODYMASK_NOT_STATIC_KINEMATIC = BODYMASK_NOT_STATIC_KINEMATIC;
	exports.BODYMASK_STATIC = BODYMASK_STATIC;
	exports.BODYSTATE_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
	exports.BODYSTATE_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
	exports.BODYSTATE_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
	exports.BODYSTATE_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
	exports.BODYSTATE_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
	exports.BODYTYPE_DYNAMIC = BODYTYPE_DYNAMIC;
	exports.BODYTYPE_KINEMATIC = BODYTYPE_KINEMATIC;
	exports.BODYTYPE_STATIC = BODYTYPE_STATIC;
	exports.BUFFERUSAGE_COPY_DST = BUFFERUSAGE_COPY_DST;
	exports.BUFFERUSAGE_COPY_SRC = BUFFERUSAGE_COPY_SRC;
	exports.BUFFERUSAGE_INDEX = BUFFERUSAGE_INDEX;
	exports.BUFFERUSAGE_INDIRECT = BUFFERUSAGE_INDIRECT;
	exports.BUFFERUSAGE_READ = BUFFERUSAGE_READ;
	exports.BUFFERUSAGE_STORAGE = BUFFERUSAGE_STORAGE;
	exports.BUFFERUSAGE_UNIFORM = BUFFERUSAGE_UNIFORM;
	exports.BUFFERUSAGE_VERTEX = BUFFERUSAGE_VERTEX;
	exports.BUFFERUSAGE_WRITE = BUFFERUSAGE_WRITE;
	exports.BUFFER_DYNAMIC = BUFFER_DYNAMIC;
	exports.BUFFER_GPUDYNAMIC = BUFFER_GPUDYNAMIC;
	exports.BUFFER_STATIC = BUFFER_STATIC;
	exports.BUFFER_STREAM = BUFFER_STREAM;
	exports.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = BUTTON_TRANSITION_MODE_SPRITE_CHANGE;
	exports.BUTTON_TRANSITION_MODE_TINT = BUTTON_TRANSITION_MODE_TINT;
	exports.Batch = Batch;
	exports.BatchGroup = BatchGroup;
	exports.BatchManager = BatchManager;
	exports.BinaryHandler = BinaryHandler;
	exports.BindGroupFormat = BindGroupFormat;
	exports.BindStorageBufferFormat = BindStorageBufferFormat;
	exports.BindStorageTextureFormat = BindStorageTextureFormat;
	exports.BindTextureFormat = BindTextureFormat;
	exports.BindUniformBufferFormat = BindUniformBufferFormat;
	exports.BlendState = BlendState;
	exports.BoundingBox = BoundingBox;
	exports.BoundingSphere = BoundingSphere;
	exports.BoxGeometry = BoxGeometry;
	exports.Bundle = Bundle;
	exports.BundleHandler = BundleHandler;
	exports.BundleRegistry = BundleRegistry;
	exports.ButtonComponent = ButtonComponent;
	exports.ButtonComponentSystem = ButtonComponentSystem;
	exports.CHUNKAPI_1_51 = CHUNKAPI_1_51;
	exports.CHUNKAPI_1_55 = CHUNKAPI_1_55;
	exports.CHUNKAPI_1_56 = CHUNKAPI_1_56;
	exports.CHUNKAPI_1_57 = CHUNKAPI_1_57;
	exports.CHUNKAPI_1_58 = CHUNKAPI_1_58;
	exports.CHUNKAPI_1_60 = CHUNKAPI_1_60;
	exports.CHUNKAPI_1_62 = CHUNKAPI_1_62;
	exports.CHUNKAPI_1_65 = CHUNKAPI_1_65;
	exports.CHUNKAPI_1_70 = CHUNKAPI_1_70;
	exports.CHUNKAPI_2_1 = CHUNKAPI_2_1;
	exports.CHUNKAPI_2_3 = CHUNKAPI_2_3;
	exports.CLEARFLAG_COLOR = CLEARFLAG_COLOR;
	exports.CLEARFLAG_DEPTH = CLEARFLAG_DEPTH;
	exports.CLEARFLAG_STENCIL = CLEARFLAG_STENCIL;
	exports.CUBEFACE_NEGX = CUBEFACE_NEGX;
	exports.CUBEFACE_NEGY = CUBEFACE_NEGY;
	exports.CUBEFACE_NEGZ = CUBEFACE_NEGZ;
	exports.CUBEFACE_POSX = CUBEFACE_POSX;
	exports.CUBEFACE_POSY = CUBEFACE_POSY;
	exports.CUBEFACE_POSZ = CUBEFACE_POSZ;
	exports.CUBEPROJ_BOX = CUBEPROJ_BOX;
	exports.CUBEPROJ_NONE = CUBEPROJ_NONE;
	exports.CULLFACE_BACK = CULLFACE_BACK;
	exports.CULLFACE_FRONT = CULLFACE_FRONT;
	exports.CULLFACE_FRONTANDBACK = CULLFACE_FRONTANDBACK;
	exports.CULLFACE_NONE = CULLFACE_NONE;
	exports.CURVE_LINEAR = CURVE_LINEAR;
	exports.CURVE_SMOOTHSTEP = CURVE_SMOOTHSTEP;
	exports.CURVE_SPLINE = CURVE_SPLINE;
	exports.CURVE_STEP = CURVE_STEP;
	exports.Camera = Camera;
	exports.CameraComponent = CameraComponent;
	exports.CameraComponentSystem = CameraComponentSystem;
	exports.CameraFrame = CameraFrame;
	exports.CameraFrameOptions = CameraFrameOptions;
	exports.CameraShaderParams = CameraShaderParams;
	exports.CanvasFont = CanvasFont;
	exports.CapsuleGeometry = CapsuleGeometry;
	exports.ChunkBuilder = ChunkBuilder;
	exports.ChunkUtils = ChunkUtils;
	exports.CollisionComponent = CollisionComponent;
	exports.CollisionComponentSystem = CollisionComponentSystem;
	exports.Color = Color;
	exports.Component = Component;
	exports.ComponentSystem = ComponentSystem;
	exports.ComponentSystemRegistry = ComponentSystemRegistry;
	exports.Compute = Compute;
	exports.ConeGeometry = ConeGeometry;
	exports.ContactPoint = ContactPoint;
	exports.ContactResult = ContactResult;
	exports.ContainerHandler = ContainerHandler;
	exports.ContainerResource = ContainerResource;
	exports.Controller = Controller;
	exports.CssHandler = CssHandler;
	exports.CubemapHandler = CubemapHandler;
	exports.Curve = Curve;
	exports.CurveSet = CurveSet;
	exports.CylinderGeometry = CylinderGeometry;
	exports.DETAILMODE_ADD = DETAILMODE_ADD;
	exports.DETAILMODE_MAX = DETAILMODE_MAX;
	exports.DETAILMODE_MIN = DETAILMODE_MIN;
	exports.DETAILMODE_MUL = DETAILMODE_MUL;
	exports.DETAILMODE_OVERLAY = DETAILMODE_OVERLAY;
	exports.DETAILMODE_SCREEN = DETAILMODE_SCREEN;
	exports.DEVICETYPE_NULL = DEVICETYPE_NULL;
	exports.DEVICETYPE_WEBGL2 = DEVICETYPE_WEBGL2;
	exports.DEVICETYPE_WEBGPU = DEVICETYPE_WEBGPU;
	exports.DISPLAYFORMAT_HDR = DISPLAYFORMAT_HDR;
	exports.DISPLAYFORMAT_LDR = DISPLAYFORMAT_LDR;
	exports.DISPLAYFORMAT_LDR_SRGB = DISPLAYFORMAT_LDR_SRGB;
	exports.DISTANCE_EXPONENTIAL = DISTANCE_EXPONENTIAL;
	exports.DISTANCE_INVERSE = DISTANCE_INVERSE;
	exports.DISTANCE_LINEAR = DISTANCE_LINEAR;
	exports.DITHER_BAYER8 = DITHER_BAYER8;
	exports.DITHER_BLUENOISE = DITHER_BLUENOISE;
	exports.DITHER_IGNNOISE = DITHER_IGNNOISE;
	exports.DITHER_NONE = DITHER_NONE;
	exports.DefaultAnimBinder = DefaultAnimBinder;
	exports.DepthState = DepthState;
	exports.DomeGeometry = DomeGeometry;
	exports.ELEMENTTYPE_GROUP = ELEMENTTYPE_GROUP;
	exports.ELEMENTTYPE_IMAGE = ELEMENTTYPE_IMAGE;
	exports.ELEMENTTYPE_TEXT = ELEMENTTYPE_TEXT;
	exports.EMITTERSHAPE_BOX = EMITTERSHAPE_BOX;
	exports.EMITTERSHAPE_SPHERE = EMITTERSHAPE_SPHERE;
	exports.EVENT_GAMEPADCONNECTED = EVENT_GAMEPADCONNECTED;
	exports.EVENT_GAMEPADDISCONNECTED = EVENT_GAMEPADDISCONNECTED;
	exports.EVENT_KEYDOWN = EVENT_KEYDOWN;
	exports.EVENT_KEYUP = EVENT_KEYUP;
	exports.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
	exports.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
	exports.EVENT_MOUSEUP = EVENT_MOUSEUP;
	exports.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;
	exports.EVENT_POSTCULL = EVENT_POSTCULL;
	exports.EVENT_POSTRENDER = EVENT_POSTRENDER;
	exports.EVENT_POSTRENDER_LAYER = EVENT_POSTRENDER_LAYER;
	exports.EVENT_PRECULL = EVENT_PRECULL;
	exports.EVENT_PRERENDER = EVENT_PRERENDER;
	exports.EVENT_PRERENDER_LAYER = EVENT_PRERENDER_LAYER;
	exports.EVENT_SELECT = EVENT_SELECT;
	exports.EVENT_SELECTEND = EVENT_SELECTEND;
	exports.EVENT_SELECTSTART = EVENT_SELECTSTART;
	exports.EVENT_TOUCHCANCEL = EVENT_TOUCHCANCEL;
	exports.EVENT_TOUCHEND = EVENT_TOUCHEND;
	exports.EVENT_TOUCHMOVE = EVENT_TOUCHMOVE;
	exports.EVENT_TOUCHSTART = EVENT_TOUCHSTART;
	exports.ElementComponent = ElementComponent;
	exports.ElementComponentSystem = ElementComponentSystem;
	exports.ElementDragHelper = ElementDragHelper;
	exports.ElementInput = ElementInput;
	exports.ElementInputEvent = ElementInputEvent;
	exports.ElementMouseEvent = ElementMouseEvent;
	exports.ElementSelectEvent = ElementSelectEvent;
	exports.ElementTouchEvent = ElementTouchEvent;
	exports.Entity = Entity;
	exports.EntityReference = EntityReference;
	exports.EnvLighting = EnvLighting;
	exports.EventHandle = EventHandle;
	exports.EventHandler = EventHandler;
	exports.FILLMODE_FILL_WINDOW = FILLMODE_FILL_WINDOW;
	exports.FILLMODE_KEEP_ASPECT = FILLMODE_KEEP_ASPECT;
	exports.FILLMODE_NONE = FILLMODE_NONE;
	exports.FILTER_LINEAR = FILTER_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_LINEAR = FILTER_LINEAR_MIPMAP_LINEAR;
	exports.FILTER_LINEAR_MIPMAP_NEAREST = FILTER_LINEAR_MIPMAP_NEAREST;
	exports.FILTER_NEAREST = FILTER_NEAREST;
	exports.FILTER_NEAREST_MIPMAP_LINEAR = FILTER_NEAREST_MIPMAP_LINEAR;
	exports.FILTER_NEAREST_MIPMAP_NEAREST = FILTER_NEAREST_MIPMAP_NEAREST;
	exports.FITMODE_CONTAIN = FITMODE_CONTAIN;
	exports.FITMODE_COVER = FITMODE_COVER;
	exports.FITMODE_STRETCH = FITMODE_STRETCH;
	exports.FITTING_BOTH = FITTING_BOTH;
	exports.FITTING_NONE = FITTING_NONE;
	exports.FITTING_SHRINK = FITTING_SHRINK;
	exports.FITTING_STRETCH = FITTING_STRETCH;
	exports.FOG_EXP = FOG_EXP;
	exports.FOG_EXP2 = FOG_EXP2;
	exports.FOG_LINEAR = FOG_LINEAR;
	exports.FOG_NONE = FOG_NONE;
	exports.FONT_BITMAP = FONT_BITMAP;
	exports.FONT_MSDF = FONT_MSDF;
	exports.FRESNEL_NONE = FRESNEL_NONE;
	exports.FRESNEL_SCHLICK = FRESNEL_SCHLICK;
	exports.FUNC_ALWAYS = FUNC_ALWAYS;
	exports.FUNC_EQUAL = FUNC_EQUAL;
	exports.FUNC_GREATER = FUNC_GREATER;
	exports.FUNC_GREATEREQUAL = FUNC_GREATEREQUAL;
	exports.FUNC_LESS = FUNC_LESS;
	exports.FUNC_LESSEQUAL = FUNC_LESSEQUAL;
	exports.FUNC_NEVER = FUNC_NEVER;
	exports.FUNC_NOTEQUAL = FUNC_NOTEQUAL;
	exports.FloatPacking = FloatPacking;
	exports.FogParams = FogParams;
	exports.FolderHandler = FolderHandler;
	exports.Font = Font;
	exports.FontHandler = FontHandler;
	exports.ForwardRenderer = ForwardRenderer;
	exports.Frustum = Frustum;
	exports.GAMMA_NONE = GAMMA_NONE;
	exports.GAMMA_SRGB = GAMMA_SRGB;
	exports.GIZMOAXIS_FACE = GIZMOAXIS_FACE;
	exports.GIZMOAXIS_X = GIZMOAXIS_X;
	exports.GIZMOAXIS_XY = GIZMOAXIS_XY;
	exports.GIZMOAXIS_XYZ = GIZMOAXIS_XYZ;
	exports.GIZMOAXIS_XZ = GIZMOAXIS_XZ;
	exports.GIZMOAXIS_Y = GIZMOAXIS_Y;
	exports.GIZMOAXIS_YZ = GIZMOAXIS_YZ;
	exports.GIZMOAXIS_Z = GIZMOAXIS_Z;
	exports.GIZMOSPACE_LOCAL = GIZMOSPACE_LOCAL;
	exports.GIZMOSPACE_WORLD = GIZMOSPACE_WORLD;
	exports.GSplat = GSplat;
	exports.GSplatComponent = GSplatComponent;
	exports.GSplatComponentSystem = GSplatComponentSystem;
	exports.GSplatData = GSplatData;
	exports.GSplatHandler = GSplatHandler;
	exports.GSplatInstance = GSplatInstance;
	exports.GSplatResource = GSplatResource;
	exports.GamePads = GamePads;
	exports.Geometry = Geometry;
	exports.Gizmo = Gizmo;
	exports.GltfExporter = GltfExporter;
	exports.GraphNode = GraphNode;
	exports.GraphicsDevice = GraphicsDevice;
	exports.HierarchyHandler = HierarchyHandler;
	exports.HtmlHandler = HtmlHandler;
	exports.Http = Http;
	exports.I18n = I18n;
	exports.INDEXFORMAT_UINT16 = INDEXFORMAT_UINT16;
	exports.INDEXFORMAT_UINT32 = INDEXFORMAT_UINT32;
	exports.INDEXFORMAT_UINT8 = INDEXFORMAT_UINT8;
	exports.INTERPOLATION_CUBIC = INTERPOLATION_CUBIC;
	exports.INTERPOLATION_LINEAR = INTERPOLATION_LINEAR;
	exports.INTERPOLATION_STEP = INTERPOLATION_STEP;
	exports.ImageElement = ImageElement;
	exports.IndexBuffer = IndexBuffer;
	exports.IndexedList = IndexedList;
	exports.JointComponent = JointComponent;
	exports.JointComponentSystem = JointComponentSystem;
	exports.JsonHandler = JsonHandler;
	exports.JsonStandardMaterialParser = JsonStandardMaterialParser;
	exports.KEY_0 = KEY_0;
	exports.KEY_1 = KEY_1;
	exports.KEY_2 = KEY_2;
	exports.KEY_3 = KEY_3;
	exports.KEY_4 = KEY_4;
	exports.KEY_5 = KEY_5;
	exports.KEY_6 = KEY_6;
	exports.KEY_7 = KEY_7;
	exports.KEY_8 = KEY_8;
	exports.KEY_9 = KEY_9;
	exports.KEY_A = KEY_A;
	exports.KEY_ADD = KEY_ADD;
	exports.KEY_ALT = KEY_ALT;
	exports.KEY_B = KEY_B;
	exports.KEY_BACKSPACE = KEY_BACKSPACE;
	exports.KEY_BACK_SLASH = KEY_BACK_SLASH;
	exports.KEY_C = KEY_C;
	exports.KEY_CAPS_LOCK = KEY_CAPS_LOCK;
	exports.KEY_CLOSE_BRACKET = KEY_CLOSE_BRACKET;
	exports.KEY_COMMA = KEY_COMMA;
	exports.KEY_CONTEXT_MENU = KEY_CONTEXT_MENU;
	exports.KEY_CONTROL = KEY_CONTROL;
	exports.KEY_D = KEY_D;
	exports.KEY_DECIMAL = KEY_DECIMAL;
	exports.KEY_DELETE = KEY_DELETE;
	exports.KEY_DIVIDE = KEY_DIVIDE;
	exports.KEY_DOWN = KEY_DOWN;
	exports.KEY_E = KEY_E;
	exports.KEY_END = KEY_END;
	exports.KEY_ENTER = KEY_ENTER;
	exports.KEY_EQUAL = KEY_EQUAL;
	exports.KEY_ESCAPE = KEY_ESCAPE;
	exports.KEY_F = KEY_F;
	exports.KEY_F1 = KEY_F1;
	exports.KEY_F10 = KEY_F10;
	exports.KEY_F11 = KEY_F11;
	exports.KEY_F12 = KEY_F12;
	exports.KEY_F2 = KEY_F2;
	exports.KEY_F3 = KEY_F3;
	exports.KEY_F4 = KEY_F4;
	exports.KEY_F5 = KEY_F5;
	exports.KEY_F6 = KEY_F6;
	exports.KEY_F7 = KEY_F7;
	exports.KEY_F8 = KEY_F8;
	exports.KEY_F9 = KEY_F9;
	exports.KEY_G = KEY_G;
	exports.KEY_H = KEY_H;
	exports.KEY_HOME = KEY_HOME;
	exports.KEY_I = KEY_I;
	exports.KEY_INSERT = KEY_INSERT;
	exports.KEY_J = KEY_J;
	exports.KEY_K = KEY_K;
	exports.KEY_L = KEY_L;
	exports.KEY_LEFT = KEY_LEFT;
	exports.KEY_M = KEY_M;
	exports.KEY_META = KEY_META;
	exports.KEY_MULTIPLY = KEY_MULTIPLY;
	exports.KEY_N = KEY_N;
	exports.KEY_NUMPAD_0 = KEY_NUMPAD_0;
	exports.KEY_NUMPAD_1 = KEY_NUMPAD_1;
	exports.KEY_NUMPAD_2 = KEY_NUMPAD_2;
	exports.KEY_NUMPAD_3 = KEY_NUMPAD_3;
	exports.KEY_NUMPAD_4 = KEY_NUMPAD_4;
	exports.KEY_NUMPAD_5 = KEY_NUMPAD_5;
	exports.KEY_NUMPAD_6 = KEY_NUMPAD_6;
	exports.KEY_NUMPAD_7 = KEY_NUMPAD_7;
	exports.KEY_NUMPAD_8 = KEY_NUMPAD_8;
	exports.KEY_NUMPAD_9 = KEY_NUMPAD_9;
	exports.KEY_O = KEY_O;
	exports.KEY_OPEN_BRACKET = KEY_OPEN_BRACKET;
	exports.KEY_P = KEY_P;
	exports.KEY_PAGE_DOWN = KEY_PAGE_DOWN;
	exports.KEY_PAGE_UP = KEY_PAGE_UP;
	exports.KEY_PAUSE = KEY_PAUSE;
	exports.KEY_PERIOD = KEY_PERIOD;
	exports.KEY_PRINT_SCREEN = KEY_PRINT_SCREEN;
	exports.KEY_Q = KEY_Q;
	exports.KEY_R = KEY_R;
	exports.KEY_RETURN = KEY_RETURN;
	exports.KEY_RIGHT = KEY_RIGHT;
	exports.KEY_S = KEY_S;
	exports.KEY_SEMICOLON = KEY_SEMICOLON;
	exports.KEY_SEPARATOR = KEY_SEPARATOR;
	exports.KEY_SHIFT = KEY_SHIFT;
	exports.KEY_SLASH = KEY_SLASH;
	exports.KEY_SPACE = KEY_SPACE;
	exports.KEY_SUBTRACT = KEY_SUBTRACT;
	exports.KEY_T = KEY_T;
	exports.KEY_TAB = KEY_TAB;
	exports.KEY_U = KEY_U;
	exports.KEY_UP = KEY_UP;
	exports.KEY_V = KEY_V;
	exports.KEY_W = KEY_W;
	exports.KEY_WINDOWS = KEY_WINDOWS;
	exports.KEY_X = KEY_X;
	exports.KEY_Y = KEY_Y;
	exports.KEY_Z = KEY_Z;
	exports.Kernel = Kernel;
	exports.Key = Key;
	exports.Keyboard = Keyboard;
	exports.KeyboardEvent = KeyboardEvent;
	exports.LAYERID_DEPTH = LAYERID_DEPTH;
	exports.LAYERID_IMMEDIATE = LAYERID_IMMEDIATE;
	exports.LAYERID_SKYBOX = LAYERID_SKYBOX;
	exports.LAYERID_UI = LAYERID_UI;
	exports.LAYERID_WORLD = LAYERID_WORLD;
	exports.LAYER_FX = LAYER_FX;
	exports.LAYER_GIZMO = LAYER_GIZMO;
	exports.LAYER_HUD = LAYER_HUD;
	exports.LAYER_WORLD = LAYER_WORLD;
	exports.LIGHTFALLOFF_INVERSESQUARED = LIGHTFALLOFF_INVERSESQUARED;
	exports.LIGHTFALLOFF_LINEAR = LIGHTFALLOFF_LINEAR;
	exports.LIGHTSHAPE_DISK = LIGHTSHAPE_DISK;
	exports.LIGHTSHAPE_PUNCTUAL = LIGHTSHAPE_PUNCTUAL;
	exports.LIGHTSHAPE_RECT = LIGHTSHAPE_RECT;
	exports.LIGHTSHAPE_SPHERE = LIGHTSHAPE_SPHERE;
	exports.LIGHTTYPE_COUNT = LIGHTTYPE_COUNT;
	exports.LIGHTTYPE_DIRECTIONAL = LIGHTTYPE_DIRECTIONAL;
	exports.LIGHTTYPE_OMNI = LIGHTTYPE_OMNI;
	exports.LIGHTTYPE_POINT = LIGHTTYPE_POINT;
	exports.LIGHTTYPE_SPOT = LIGHTTYPE_SPOT;
	exports.Layer = Layer;
	exports.LayerComposition = LayerComposition;
	exports.LayoutCalculator = LayoutCalculator;
	exports.LayoutChildComponent = LayoutChildComponent;
	exports.LayoutChildComponentSystem = LayoutChildComponentSystem;
	exports.LayoutGroupComponent = LayoutGroupComponent;
	exports.LayoutGroupComponentSystem = LayoutGroupComponentSystem;
	exports.Light = Light;
	exports.LightComponent = LightComponent;
	exports.LightComponentSystem = LightComponentSystem;
	exports.LightingParams = LightingParams;
	exports.Lightmapper = Lightmapper;
	exports.LitMaterial = LitMaterial;
	exports.LitOptions = LitOptions;
	exports.LitShaderOptions = LitShaderOptions;
	exports.LocalizedAsset = LocalizedAsset;
	exports.MASK_AFFECT_DYNAMIC = MASK_AFFECT_DYNAMIC;
	exports.MASK_AFFECT_LIGHTMAPPED = MASK_AFFECT_LIGHTMAPPED;
	exports.MASK_BAKE = MASK_BAKE;
	exports.MOTION_FREE = MOTION_FREE;
	exports.MOTION_LIMITED = MOTION_LIMITED;
	exports.MOTION_LOCKED = MOTION_LOCKED;
	exports.MOUSEBUTTON_LEFT = MOUSEBUTTON_LEFT;
	exports.MOUSEBUTTON_MIDDLE = MOUSEBUTTON_MIDDLE;
	exports.MOUSEBUTTON_NONE = MOUSEBUTTON_NONE;
	exports.MOUSEBUTTON_RIGHT = MOUSEBUTTON_RIGHT;
	exports.Mat3 = Mat3;
	exports.Mat4 = Mat4;
	exports.Material = Material;
	exports.MaterialHandler = MaterialHandler;
	exports.Mesh = Mesh;
	exports.MeshInstance = MeshInstance;
	exports.MiniStats = MiniStats;
	exports.Model = Model;
	exports.ModelComponent = ModelComponent;
	exports.ModelComponentSystem = ModelComponentSystem;
	exports.ModelHandler = ModelHandler;
	exports.Morph = Morph;
	exports.MorphInstance = MorphInstance;
	exports.MorphTarget = MorphTarget;
	exports.Mouse = Mouse;
	exports.MouseEvent = MouseEvent;
	exports.Node = Node;
	exports.NullGraphicsDevice = NullGraphicsDevice;
	exports.ORIENTATION_HORIZONTAL = ORIENTATION_HORIZONTAL;
	exports.ORIENTATION_VERTICAL = ORIENTATION_VERTICAL;
	exports.OrientedBox = OrientedBox;
	exports.OutlineRenderer = OutlineRenderer;
	exports.PAD_1 = PAD_1;
	exports.PAD_2 = PAD_2;
	exports.PAD_3 = PAD_3;
	exports.PAD_4 = PAD_4;
	exports.PAD_DOWN = PAD_DOWN;
	exports.PAD_FACE_1 = PAD_FACE_1;
	exports.PAD_FACE_2 = PAD_FACE_2;
	exports.PAD_FACE_3 = PAD_FACE_3;
	exports.PAD_FACE_4 = PAD_FACE_4;
	exports.PAD_LEFT = PAD_LEFT;
	exports.PAD_L_SHOULDER_1 = PAD_L_SHOULDER_1;
	exports.PAD_L_SHOULDER_2 = PAD_L_SHOULDER_2;
	exports.PAD_L_STICK_BUTTON = PAD_L_STICK_BUTTON;
	exports.PAD_L_STICK_X = PAD_L_STICK_X;
	exports.PAD_L_STICK_Y = PAD_L_STICK_Y;
	exports.PAD_RIGHT = PAD_RIGHT;
	exports.PAD_R_SHOULDER_1 = PAD_R_SHOULDER_1;
	exports.PAD_R_SHOULDER_2 = PAD_R_SHOULDER_2;
	exports.PAD_R_STICK_BUTTON = PAD_R_STICK_BUTTON;
	exports.PAD_R_STICK_X = PAD_R_STICK_X;
	exports.PAD_R_STICK_Y = PAD_R_STICK_Y;
	exports.PAD_SELECT = PAD_SELECT;
	exports.PAD_START = PAD_START;
	exports.PAD_UP = PAD_UP;
	exports.PAD_VENDOR = PAD_VENDOR;
	exports.PARTICLEMODE_CPU = PARTICLEMODE_CPU;
	exports.PARTICLEMODE_GPU = PARTICLEMODE_GPU;
	exports.PARTICLEORIENTATION_EMITTER = PARTICLEORIENTATION_EMITTER;
	exports.PARTICLEORIENTATION_SCREEN = PARTICLEORIENTATION_SCREEN;
	exports.PARTICLEORIENTATION_WORLD = PARTICLEORIENTATION_WORLD;
	exports.PARTICLESORT_DISTANCE = PARTICLESORT_DISTANCE;
	exports.PARTICLESORT_NEWER_FIRST = PARTICLESORT_NEWER_FIRST;
	exports.PARTICLESORT_NONE = PARTICLESORT_NONE;
	exports.PARTICLESORT_OLDER_FIRST = PARTICLESORT_OLDER_FIRST;
	exports.PIXELFORMAT_111110F = PIXELFORMAT_111110F;
	exports.PIXELFORMAT_A8 = PIXELFORMAT_A8;
	exports.PIXELFORMAT_ASTC_4x4 = PIXELFORMAT_ASTC_4x4;
	exports.PIXELFORMAT_ASTC_4x4_SRGB = PIXELFORMAT_ASTC_4x4_SRGB;
	exports.PIXELFORMAT_ATC_RGB = PIXELFORMAT_ATC_RGB;
	exports.PIXELFORMAT_ATC_RGBA = PIXELFORMAT_ATC_RGBA;
	exports.PIXELFORMAT_BC6F = PIXELFORMAT_BC6F;
	exports.PIXELFORMAT_BC6UF = PIXELFORMAT_BC6UF;
	exports.PIXELFORMAT_BC7 = PIXELFORMAT_BC7;
	exports.PIXELFORMAT_BC7_SRGBA = PIXELFORMAT_BC7_SRGBA;
	exports.PIXELFORMAT_BGRA8 = PIXELFORMAT_BGRA8;
	exports.PIXELFORMAT_DEPTH = PIXELFORMAT_DEPTH;
	exports.PIXELFORMAT_DEPTH16 = PIXELFORMAT_DEPTH16;
	exports.PIXELFORMAT_DEPTHSTENCIL = PIXELFORMAT_DEPTHSTENCIL;
	exports.PIXELFORMAT_DXT1 = PIXELFORMAT_DXT1;
	exports.PIXELFORMAT_DXT1_SRGB = PIXELFORMAT_DXT1_SRGB;
	exports.PIXELFORMAT_DXT3 = PIXELFORMAT_DXT3;
	exports.PIXELFORMAT_DXT3_SRGBA = PIXELFORMAT_DXT3_SRGBA;
	exports.PIXELFORMAT_DXT5 = PIXELFORMAT_DXT5;
	exports.PIXELFORMAT_DXT5_SRGBA = PIXELFORMAT_DXT5_SRGBA;
	exports.PIXELFORMAT_ETC1 = PIXELFORMAT_ETC1;
	exports.PIXELFORMAT_ETC2_RGB = PIXELFORMAT_ETC2_RGB;
	exports.PIXELFORMAT_ETC2_RGBA = PIXELFORMAT_ETC2_RGBA;
	exports.PIXELFORMAT_ETC2_SRGB = PIXELFORMAT_ETC2_SRGB;
	exports.PIXELFORMAT_ETC2_SRGBA = PIXELFORMAT_ETC2_SRGBA;
	exports.PIXELFORMAT_L8 = PIXELFORMAT_L8;
	exports.PIXELFORMAT_L8_A8 = PIXELFORMAT_L8_A8;
	exports.PIXELFORMAT_LA8 = PIXELFORMAT_LA8;
	exports.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = PIXELFORMAT_PVRTC_2BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_2BPP_RGB_1 = PIXELFORMAT_PVRTC_2BPP_RGB_1;
	exports.PIXELFORMAT_PVRTC_2BPP_SRGBA_1 = PIXELFORMAT_PVRTC_2BPP_SRGBA_1;
	exports.PIXELFORMAT_PVRTC_2BPP_SRGB_1 = PIXELFORMAT_PVRTC_2BPP_SRGB_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
	exports.PIXELFORMAT_PVRTC_4BPP_RGB_1 = PIXELFORMAT_PVRTC_4BPP_RGB_1;
	exports.PIXELFORMAT_PVRTC_4BPP_SRGBA_1 = PIXELFORMAT_PVRTC_4BPP_SRGBA_1;
	exports.PIXELFORMAT_PVRTC_4BPP_SRGB_1 = PIXELFORMAT_PVRTC_4BPP_SRGB_1;
	exports.PIXELFORMAT_R16F = PIXELFORMAT_R16F;
	exports.PIXELFORMAT_R16I = PIXELFORMAT_R16I;
	exports.PIXELFORMAT_R16U = PIXELFORMAT_R16U;
	exports.PIXELFORMAT_R32F = PIXELFORMAT_R32F;
	exports.PIXELFORMAT_R32I = PIXELFORMAT_R32I;
	exports.PIXELFORMAT_R32U = PIXELFORMAT_R32U;
	exports.PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_R4_G4_B4_A4;
	exports.PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_R5_G5_B5_A1;
	exports.PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_R5_G6_B5;
	exports.PIXELFORMAT_R8 = PIXELFORMAT_R8;
	exports.PIXELFORMAT_R8I = PIXELFORMAT_R8I;
	exports.PIXELFORMAT_R8U = PIXELFORMAT_R8U;
	exports.PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_R8_G8_B8;
	exports.PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_R8_G8_B8_A8;
	exports.PIXELFORMAT_RG16F = PIXELFORMAT_RG16F;
	exports.PIXELFORMAT_RG16I = PIXELFORMAT_RG16I;
	exports.PIXELFORMAT_RG16U = PIXELFORMAT_RG16U;
	exports.PIXELFORMAT_RG32I = PIXELFORMAT_RG32I;
	exports.PIXELFORMAT_RG32U = PIXELFORMAT_RG32U;
	exports.PIXELFORMAT_RG8 = PIXELFORMAT_RG8;
	exports.PIXELFORMAT_RG8I = PIXELFORMAT_RG8I;
	exports.PIXELFORMAT_RG8U = PIXELFORMAT_RG8U;
	exports.PIXELFORMAT_RGB16F = PIXELFORMAT_RGB16F;
	exports.PIXELFORMAT_RGB32F = PIXELFORMAT_RGB32F;
	exports.PIXELFORMAT_RGB565 = PIXELFORMAT_RGB565;
	exports.PIXELFORMAT_RGB8 = PIXELFORMAT_RGB8;
	exports.PIXELFORMAT_RGBA16F = PIXELFORMAT_RGBA16F;
	exports.PIXELFORMAT_RGBA16I = PIXELFORMAT_RGBA16I;
	exports.PIXELFORMAT_RGBA16U = PIXELFORMAT_RGBA16U;
	exports.PIXELFORMAT_RGBA32F = PIXELFORMAT_RGBA32F;
	exports.PIXELFORMAT_RGBA32I = PIXELFORMAT_RGBA32I;
	exports.PIXELFORMAT_RGBA32U = PIXELFORMAT_RGBA32U;
	exports.PIXELFORMAT_RGBA4 = PIXELFORMAT_RGBA4;
	exports.PIXELFORMAT_RGBA5551 = PIXELFORMAT_RGBA5551;
	exports.PIXELFORMAT_RGBA8 = PIXELFORMAT_RGBA8;
	exports.PIXELFORMAT_RGBA8I = PIXELFORMAT_RGBA8I;
	exports.PIXELFORMAT_RGBA8U = PIXELFORMAT_RGBA8U;
	exports.PIXELFORMAT_SBGRA8 = PIXELFORMAT_SBGRA8;
	exports.PIXELFORMAT_SRGB = PIXELFORMAT_SRGB;
	exports.PIXELFORMAT_SRGB8 = PIXELFORMAT_SRGB8;
	exports.PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA;
	exports.PIXELFORMAT_SRGBA8 = PIXELFORMAT_SRGBA8;
	exports.PRIMITIVE_LINELOOP = PRIMITIVE_LINELOOP;
	exports.PRIMITIVE_LINES = PRIMITIVE_LINES;
	exports.PRIMITIVE_LINESTRIP = PRIMITIVE_LINESTRIP;
	exports.PRIMITIVE_POINTS = PRIMITIVE_POINTS;
	exports.PRIMITIVE_TRIANGLES = PRIMITIVE_TRIANGLES;
	exports.PRIMITIVE_TRIFAN = PRIMITIVE_TRIFAN;
	exports.PRIMITIVE_TRISTRIP = PRIMITIVE_TRISTRIP;
	exports.PROJECTION_ORTHOGRAPHIC = PROJECTION_ORTHOGRAPHIC;
	exports.PROJECTION_PERSPECTIVE = PROJECTION_PERSPECTIVE;
	exports.ParticleEmitter = ParticleEmitter;
	exports.ParticleSystemComponent = ParticleSystemComponent;
	exports.ParticleSystemComponentSystem = ParticleSystemComponentSystem;
	exports.Picker = Picker;
	exports.Plane = Plane;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PostEffect = PostEffect;
	exports.PostEffectQueue = PostEffectQueue;
	exports.ProgramLibrary = ProgramLibrary;
	exports.QuadRender = QuadRender;
	exports.Quat = Quat;
	exports.RENDERSTYLE_POINTS = RENDERSTYLE_POINTS;
	exports.RENDERSTYLE_SOLID = RENDERSTYLE_SOLID;
	exports.RENDERSTYLE_WIREFRAME = RENDERSTYLE_WIREFRAME;
	exports.RESOLUTION_AUTO = RESOLUTION_AUTO;
	exports.RESOLUTION_FIXED = RESOLUTION_FIXED;
	exports.RIGIDBODY_ACTIVE_TAG = RIGIDBODY_ACTIVE_TAG;
	exports.RIGIDBODY_CF_KINEMATIC_OBJECT = RIGIDBODY_CF_KINEMATIC_OBJECT;
	exports.RIGIDBODY_CF_NORESPONSE_OBJECT = RIGIDBODY_CF_NORESPONSE_OBJECT;
	exports.RIGIDBODY_CF_STATIC_OBJECT = RIGIDBODY_CF_STATIC_OBJECT;
	exports.RIGIDBODY_DISABLE_DEACTIVATION = RIGIDBODY_DISABLE_DEACTIVATION;
	exports.RIGIDBODY_DISABLE_SIMULATION = RIGIDBODY_DISABLE_SIMULATION;
	exports.RIGIDBODY_ISLAND_SLEEPING = RIGIDBODY_ISLAND_SLEEPING;
	exports.RIGIDBODY_TYPE_DYNAMIC = RIGIDBODY_TYPE_DYNAMIC;
	exports.RIGIDBODY_TYPE_KINEMATIC = RIGIDBODY_TYPE_KINEMATIC;
	exports.RIGIDBODY_TYPE_STATIC = RIGIDBODY_TYPE_STATIC;
	exports.RIGIDBODY_WANTS_DEACTIVATION = RIGIDBODY_WANTS_DEACTIVATION;
	exports.Ray = Ray;
	exports.RaycastResult = RaycastResult;
	exports.ReadStream = ReadStream;
	exports.RenderComponent = RenderComponent;
	exports.RenderComponentSystem = RenderComponentSystem;
	exports.RenderHandler = RenderHandler;
	exports.RenderPass = RenderPass;
	exports.RenderPassBloom = RenderPassBloom;
	exports.RenderPassCameraFrame = RenderPassCameraFrame;
	exports.RenderPassColorGrab = RenderPassColorGrab;
	exports.RenderPassCompose = RenderPassCompose;
	exports.RenderPassDepthAwareBlur = RenderPassDepthAwareBlur;
	exports.RenderPassDof = RenderPassDof;
	exports.RenderPassDownsample = RenderPassDownsample;
	exports.RenderPassForward = RenderPassForward;
	exports.RenderPassShaderQuad = RenderPassShaderQuad;
	exports.RenderPassSsao = RenderPassSsao;
	exports.RenderPassTAA = RenderPassTAA;
	exports.RenderPassUpsample = RenderPassUpsample;
	exports.RenderTarget = RenderTarget;
	exports.ResourceHandler = ResourceHandler;
	exports.ResourceLoader = ResourceLoader;
	exports.RigidBodyComponent = RigidBodyComponent;
	exports.RigidBodyComponentSystem = RigidBodyComponentSystem;
	exports.RotateGizmo = RotateGizmo;
	exports.SAMPLETYPE_DEPTH = SAMPLETYPE_DEPTH;
	exports.SAMPLETYPE_FLOAT = SAMPLETYPE_FLOAT;
	exports.SAMPLETYPE_INT = SAMPLETYPE_INT;
	exports.SAMPLETYPE_UINT = SAMPLETYPE_UINT;
	exports.SAMPLETYPE_UNFILTERABLE_FLOAT = SAMPLETYPE_UNFILTERABLE_FLOAT;
	exports.SCALEMODE_BLEND = SCALEMODE_BLEND;
	exports.SCALEMODE_NONE = SCALEMODE_NONE;
	exports.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = SCROLLBAR_VISIBILITY_SHOW_ALWAYS;
	exports.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED;
	exports.SCROLL_MODE_BOUNCE = SCROLL_MODE_BOUNCE;
	exports.SCROLL_MODE_CLAMP = SCROLL_MODE_CLAMP;
	exports.SCROLL_MODE_INFINITE = SCROLL_MODE_INFINITE;
	exports.SEMANTIC_ATTR0 = SEMANTIC_ATTR0;
	exports.SEMANTIC_ATTR1 = SEMANTIC_ATTR1;
	exports.SEMANTIC_ATTR10 = SEMANTIC_ATTR10;
	exports.SEMANTIC_ATTR11 = SEMANTIC_ATTR11;
	exports.SEMANTIC_ATTR12 = SEMANTIC_ATTR12;
	exports.SEMANTIC_ATTR13 = SEMANTIC_ATTR13;
	exports.SEMANTIC_ATTR14 = SEMANTIC_ATTR14;
	exports.SEMANTIC_ATTR15 = SEMANTIC_ATTR15;
	exports.SEMANTIC_ATTR2 = SEMANTIC_ATTR2;
	exports.SEMANTIC_ATTR3 = SEMANTIC_ATTR3;
	exports.SEMANTIC_ATTR4 = SEMANTIC_ATTR4;
	exports.SEMANTIC_ATTR5 = SEMANTIC_ATTR5;
	exports.SEMANTIC_ATTR6 = SEMANTIC_ATTR6;
	exports.SEMANTIC_ATTR7 = SEMANTIC_ATTR7;
	exports.SEMANTIC_ATTR8 = SEMANTIC_ATTR8;
	exports.SEMANTIC_ATTR9 = SEMANTIC_ATTR9;
	exports.SEMANTIC_BLENDINDICES = SEMANTIC_BLENDINDICES;
	exports.SEMANTIC_BLENDWEIGHT = SEMANTIC_BLENDWEIGHT;
	exports.SEMANTIC_COLOR = SEMANTIC_COLOR;
	exports.SEMANTIC_NORMAL = SEMANTIC_NORMAL;
	exports.SEMANTIC_POSITION = SEMANTIC_POSITION;
	exports.SEMANTIC_TANGENT = SEMANTIC_TANGENT;
	exports.SEMANTIC_TEXCOORD = SEMANTIC_TEXCOORD;
	exports.SEMANTIC_TEXCOORD0 = SEMANTIC_TEXCOORD0;
	exports.SEMANTIC_TEXCOORD1 = SEMANTIC_TEXCOORD1;
	exports.SEMANTIC_TEXCOORD2 = SEMANTIC_TEXCOORD2;
	exports.SEMANTIC_TEXCOORD3 = SEMANTIC_TEXCOORD3;
	exports.SEMANTIC_TEXCOORD4 = SEMANTIC_TEXCOORD4;
	exports.SEMANTIC_TEXCOORD5 = SEMANTIC_TEXCOORD5;
	exports.SEMANTIC_TEXCOORD6 = SEMANTIC_TEXCOORD6;
	exports.SEMANTIC_TEXCOORD7 = SEMANTIC_TEXCOORD7;
	exports.SHADERDEF_BATCH = SHADERDEF_BATCH;
	exports.SHADERDEF_DIRLM = SHADERDEF_DIRLM;
	exports.SHADERDEF_INSTANCING = SHADERDEF_INSTANCING;
	exports.SHADERDEF_LM = SHADERDEF_LM;
	exports.SHADERDEF_LMAMBIENT = SHADERDEF_LMAMBIENT;
	exports.SHADERDEF_MORPH_NORMAL = SHADERDEF_MORPH_NORMAL;
	exports.SHADERDEF_MORPH_POSITION = SHADERDEF_MORPH_POSITION;
	exports.SHADERDEF_MORPH_TEXTURE_BASED_INT = SHADERDEF_MORPH_TEXTURE_BASED_INT;
	exports.SHADERDEF_NOSHADOW = SHADERDEF_NOSHADOW;
	exports.SHADERDEF_SCREENSPACE = SHADERDEF_SCREENSPACE;
	exports.SHADERDEF_SKIN = SHADERDEF_SKIN;
	exports.SHADERDEF_TANGENTS = SHADERDEF_TANGENTS;
	exports.SHADERDEF_UV0 = SHADERDEF_UV0;
	exports.SHADERDEF_UV1 = SHADERDEF_UV1;
	exports.SHADERDEF_VCOLOR = SHADERDEF_VCOLOR;
	exports.SHADERLANGUAGE_GLSL = SHADERLANGUAGE_GLSL;
	exports.SHADERLANGUAGE_WGSL = SHADERLANGUAGE_WGSL;
	exports.SHADERPASS_ALBEDO = SHADERPASS_ALBEDO;
	exports.SHADERPASS_AO = SHADERPASS_AO;
	exports.SHADERPASS_EMISSION = SHADERPASS_EMISSION;
	exports.SHADERPASS_FORWARD = SHADERPASS_FORWARD;
	exports.SHADERPASS_GLOSS = SHADERPASS_GLOSS;
	exports.SHADERPASS_LIGHTING = SHADERPASS_LIGHTING;
	exports.SHADERPASS_METALNESS = SHADERPASS_METALNESS;
	exports.SHADERPASS_OPACITY = SHADERPASS_OPACITY;
	exports.SHADERPASS_SPECULARITY = SHADERPASS_SPECULARITY;
	exports.SHADERPASS_UV0 = SHADERPASS_UV0;
	exports.SHADERPASS_WORLDNORMAL = SHADERPASS_WORLDNORMAL;
	exports.SHADERSTAGE_COMPUTE = SHADERSTAGE_COMPUTE;
	exports.SHADERSTAGE_FRAGMENT = SHADERSTAGE_FRAGMENT;
	exports.SHADERSTAGE_VERTEX = SHADERSTAGE_VERTEX;
	exports.SHADERTAG_MATERIAL = SHADERTAG_MATERIAL;
	exports.SHADER_DEPTH = SHADER_DEPTH;
	exports.SHADER_FORWARD = SHADER_FORWARD;
	exports.SHADER_PICK = SHADER_PICK;
	exports.SHADER_PREPASS = SHADER_PREPASS;
	exports.SHADER_SHADOW = SHADER_SHADOW;
	exports.SHADOWUPDATE_NONE = SHADOWUPDATE_NONE;
	exports.SHADOWUPDATE_REALTIME = SHADOWUPDATE_REALTIME;
	exports.SHADOWUPDATE_THISFRAME = SHADOWUPDATE_THISFRAME;
	exports.SHADOW_PCF1 = SHADOW_PCF1;
	exports.SHADOW_PCF1_16F = SHADOW_PCF1_16F;
	exports.SHADOW_PCF1_32F = SHADOW_PCF1_32F;
	exports.SHADOW_PCF3 = SHADOW_PCF3;
	exports.SHADOW_PCF3_16F = SHADOW_PCF3_16F;
	exports.SHADOW_PCF3_32F = SHADOW_PCF3_32F;
	exports.SHADOW_PCF5 = SHADOW_PCF5;
	exports.SHADOW_PCF5_16F = SHADOW_PCF5_16F;
	exports.SHADOW_PCF5_32F = SHADOW_PCF5_32F;
	exports.SHADOW_PCSS_32F = SHADOW_PCSS_32F;
	exports.SHADOW_VSM16 = SHADOW_VSM16;
	exports.SHADOW_VSM32 = SHADOW_VSM32;
	exports.SHADOW_VSM_16F = SHADOW_VSM_16F;
	exports.SHADOW_VSM_32F = SHADOW_VSM_32F;
	exports.SKYTYPE_BOX = SKYTYPE_BOX;
	exports.SKYTYPE_DOME = SKYTYPE_DOME;
	exports.SKYTYPE_INFINITE = SKYTYPE_INFINITE;
	exports.SORTKEY_DEPTH = SORTKEY_DEPTH;
	exports.SORTKEY_FORWARD = SORTKEY_FORWARD;
	exports.SORTMODE_BACK2FRONT = SORTMODE_BACK2FRONT;
	exports.SORTMODE_CUSTOM = SORTMODE_CUSTOM;
	exports.SORTMODE_FRONT2BACK = SORTMODE_FRONT2BACK;
	exports.SORTMODE_MANUAL = SORTMODE_MANUAL;
	exports.SORTMODE_MATERIALMESH = SORTMODE_MATERIALMESH;
	exports.SORTMODE_NONE = SORTMODE_NONE;
	exports.SPECOCC_AO = SPECOCC_AO;
	exports.SPECOCC_GLOSSDEPENDENT = SPECOCC_GLOSSDEPENDENT;
	exports.SPECOCC_NONE = SPECOCC_NONE;
	exports.SPRITETYPE_ANIMATED = SPRITETYPE_ANIMATED;
	exports.SPRITETYPE_SIMPLE = SPRITETYPE_SIMPLE;
	exports.SPRITE_RENDERMODE_SIMPLE = SPRITE_RENDERMODE_SIMPLE;
	exports.SPRITE_RENDERMODE_SLICED = SPRITE_RENDERMODE_SLICED;
	exports.SPRITE_RENDERMODE_TILED = SPRITE_RENDERMODE_TILED;
	exports.SSAOTYPE_COMBINE = SSAOTYPE_COMBINE;
	exports.SSAOTYPE_LIGHTING = SSAOTYPE_LIGHTING;
	exports.SSAOTYPE_NONE = SSAOTYPE_NONE;
	exports.STENCILOP_DECREMENT = STENCILOP_DECREMENT;
	exports.STENCILOP_DECREMENTWRAP = STENCILOP_DECREMENTWRAP;
	exports.STENCILOP_INCREMENT = STENCILOP_INCREMENT;
	exports.STENCILOP_INCREMENTWRAP = STENCILOP_INCREMENTWRAP;
	exports.STENCILOP_INVERT = STENCILOP_INVERT;
	exports.STENCILOP_KEEP = STENCILOP_KEEP;
	exports.STENCILOP_REPLACE = STENCILOP_REPLACE;
	exports.STENCILOP_ZERO = STENCILOP_ZERO;
	exports.ScaleGizmo = ScaleGizmo;
	exports.Scene = Scene;
	exports.SceneHandler = SceneHandler;
	exports.SceneRegistry = SceneRegistry;
	exports.SceneRegistryItem = SceneRegistryItem;
	exports.SceneSettingsHandler = SceneSettingsHandler;
	exports.ScopeId = ScopeId;
	exports.ScopeSpace = ScopeSpace;
	exports.ScreenComponent = ScreenComponent;
	exports.ScreenComponentSystem = ScreenComponentSystem;
	exports.Script = Script;
	exports.ScriptAttributes = ScriptAttributes;
	exports.ScriptComponent = ScriptComponent;
	exports.ScriptComponentSystem = ScriptComponentSystem;
	exports.ScriptHandler = ScriptHandler;
	exports.ScriptRegistry = ScriptRegistry;
	exports.ScriptType = ScriptType;
	exports.ScrollViewComponent = ScrollViewComponent;
	exports.ScrollViewComponentSystem = ScrollViewComponentSystem;
	exports.ScrollbarComponent = ScrollbarComponent;
	exports.ScrollbarComponentSystem = ScrollbarComponentSystem;
	exports.Shader = Shader;
	exports.ShaderHandler = ShaderHandler;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShaderPass = ShaderPass;
	exports.SingleContactResult = SingleContactResult;
	exports.Skeleton = Skeleton;
	exports.Skin = Skin;
	exports.SkinBatchInstance = SkinBatchInstance;
	exports.SkinInstance = SkinInstance;
	exports.Sky = Sky;
	exports.SortedLoopArray = SortedLoopArray;
	exports.Sound = Sound;
	exports.SoundComponent = SoundComponent;
	exports.SoundComponentSystem = SoundComponentSystem;
	exports.SoundInstance = SoundInstance;
	exports.SoundInstance3d = SoundInstance3d;
	exports.SoundManager = SoundManager;
	exports.SoundSlot = SoundSlot;
	exports.SphereGeometry = SphereGeometry;
	exports.Sprite = Sprite;
	exports.SpriteAnimationClip = SpriteAnimationClip;
	exports.SpriteComponent = SpriteComponent;
	exports.SpriteComponentSystem = SpriteComponentSystem;
	exports.SpriteHandler = SpriteHandler;
	exports.StandardMaterial = StandardMaterial;
	exports.StandardMaterialOptions = StandardMaterialOptions;
	exports.StencilParameters = StencilParameters;
	exports.StorageBuffer = StorageBuffer;
	exports.TEXHINT_ASSET = TEXHINT_ASSET;
	exports.TEXHINT_LIGHTMAP = TEXHINT_LIGHTMAP;
	exports.TEXHINT_NONE = TEXHINT_NONE;
	exports.TEXHINT_SHADOWMAP = TEXHINT_SHADOWMAP;
	exports.TEXPROPERTY_ADDRESS_U = TEXPROPERTY_ADDRESS_U;
	exports.TEXPROPERTY_ADDRESS_V = TEXPROPERTY_ADDRESS_V;
	exports.TEXPROPERTY_ADDRESS_W = TEXPROPERTY_ADDRESS_W;
	exports.TEXPROPERTY_ALL = TEXPROPERTY_ALL;
	exports.TEXPROPERTY_ANISOTROPY = TEXPROPERTY_ANISOTROPY;
	exports.TEXPROPERTY_COMPARE_FUNC = TEXPROPERTY_COMPARE_FUNC;
	exports.TEXPROPERTY_COMPARE_ON_READ = TEXPROPERTY_COMPARE_ON_READ;
	exports.TEXPROPERTY_MAG_FILTER = TEXPROPERTY_MAG_FILTER;
	exports.TEXPROPERTY_MIN_FILTER = TEXPROPERTY_MIN_FILTER;
	exports.TEXTUREDIMENSION_1D = TEXTUREDIMENSION_1D;
	exports.TEXTUREDIMENSION_2D = TEXTUREDIMENSION_2D;
	exports.TEXTUREDIMENSION_2D_ARRAY = TEXTUREDIMENSION_2D_ARRAY;
	exports.TEXTUREDIMENSION_3D = TEXTUREDIMENSION_3D;
	exports.TEXTUREDIMENSION_CUBE = TEXTUREDIMENSION_CUBE;
	exports.TEXTUREDIMENSION_CUBE_ARRAY = TEXTUREDIMENSION_CUBE_ARRAY;
	exports.TEXTURELOCK_NONE = TEXTURELOCK_NONE;
	exports.TEXTURELOCK_READ = TEXTURELOCK_READ;
	exports.TEXTURELOCK_WRITE = TEXTURELOCK_WRITE;
	exports.TEXTUREPROJECTION_CUBE = TEXTUREPROJECTION_CUBE;
	exports.TEXTUREPROJECTION_EQUIRECT = TEXTUREPROJECTION_EQUIRECT;
	exports.TEXTUREPROJECTION_NONE = TEXTUREPROJECTION_NONE;
	exports.TEXTUREPROJECTION_OCTAHEDRAL = TEXTUREPROJECTION_OCTAHEDRAL;
	exports.TEXTURETYPE_DEFAULT = TEXTURETYPE_DEFAULT;
	exports.TEXTURETYPE_RGBE = TEXTURETYPE_RGBE;
	exports.TEXTURETYPE_RGBM = TEXTURETYPE_RGBM;
	exports.TEXTURETYPE_RGBP = TEXTURETYPE_RGBP;
	exports.TEXTURETYPE_SWIZZLEGGGR = TEXTURETYPE_SWIZZLEGGGR;
	exports.TONEMAP_ACES = TONEMAP_ACES;
	exports.TONEMAP_ACES2 = TONEMAP_ACES2;
	exports.TONEMAP_FILMIC = TONEMAP_FILMIC;
	exports.TONEMAP_HEJL = TONEMAP_HEJL;
	exports.TONEMAP_LINEAR = TONEMAP_LINEAR;
	exports.TONEMAP_NEUTRAL = TONEMAP_NEUTRAL;
	exports.TONEMAP_NONE = TONEMAP_NONE;
	exports.TRACEID_BINDGROUPFORMAT_ALLOC = TRACEID_BINDGROUPFORMAT_ALLOC;
	exports.TRACEID_BINDGROUP_ALLOC = TRACEID_BINDGROUP_ALLOC;
	exports.TRACEID_COMPUTEPIPELINE_ALLOC = TRACEID_COMPUTEPIPELINE_ALLOC;
	exports.TRACEID_GPU_TIMINGS = TRACEID_GPU_TIMINGS;
	exports.TRACEID_PIPELINELAYOUT_ALLOC = TRACEID_PIPELINELAYOUT_ALLOC;
	exports.TRACEID_RENDERPIPELINE_ALLOC = TRACEID_RENDERPIPELINE_ALLOC;
	exports.TRACEID_RENDER_ACTION = TRACEID_RENDER_ACTION;
	exports.TRACEID_RENDER_FRAME = TRACEID_RENDER_FRAME;
	exports.TRACEID_RENDER_FRAME_TIME = TRACEID_RENDER_FRAME_TIME;
	exports.TRACEID_RENDER_PASS = TRACEID_RENDER_PASS;
	exports.TRACEID_RENDER_PASS_DETAIL = TRACEID_RENDER_PASS_DETAIL;
	exports.TRACEID_RENDER_QUEUE = TRACEID_RENDER_QUEUE;
	exports.TRACEID_RENDER_TARGET_ALLOC = TRACEID_RENDER_TARGET_ALLOC;
	exports.TRACEID_SHADER_ALLOC = TRACEID_SHADER_ALLOC;
	exports.TRACEID_SHADER_COMPILE = TRACEID_SHADER_COMPILE;
	exports.TRACEID_TEXTURES = TRACEID_TEXTURES;
	exports.TRACEID_TEXTURE_ALLOC = TRACEID_TEXTURE_ALLOC;
	exports.TRACEID_VRAM_IB = TRACEID_VRAM_IB;
	exports.TRACEID_VRAM_SB = TRACEID_VRAM_SB;
	exports.TRACEID_VRAM_TEXTURE = TRACEID_VRAM_TEXTURE;
	exports.TRACEID_VRAM_VB = TRACEID_VRAM_VB;
	exports.TRACE_ID_ELEMENT = TRACE_ID_ELEMENT;
	exports.TYPE_FLOAT16 = TYPE_FLOAT16;
	exports.TYPE_FLOAT32 = TYPE_FLOAT32;
	exports.TYPE_INT16 = TYPE_INT16;
	exports.TYPE_INT32 = TYPE_INT32;
	exports.TYPE_INT8 = TYPE_INT8;
	exports.TYPE_UINT16 = TYPE_UINT16;
	exports.TYPE_UINT32 = TYPE_UINT32;
	exports.TYPE_UINT8 = TYPE_UINT8;
	exports.Tags = Tags;
	exports.Template = Template;
	exports.TemplateHandler = TemplateHandler;
	exports.TextElement = TextElement;
	exports.TextHandler = TextHandler;
	exports.Texture = Texture;
	exports.TextureAtlas = TextureAtlas;
	exports.TextureAtlasHandler = TextureAtlasHandler;
	exports.TextureHandler = TextureHandler;
	exports.TextureUtils = TextureUtils;
	exports.TorusGeometry = TorusGeometry;
	exports.Touch = Touch;
	exports.TouchDevice = TouchDevice;
	exports.TouchEvent = TouchEvent;
	exports.Tracing = Tracing;
	exports.TransformFeedback = TransformFeedback;
	exports.TransformGizmo = TransformGizmo;
	exports.TranslateGizmo = TranslateGizmo;
	exports.Tri = Tri;
	exports.UNIFORMTYPE_BOOL = UNIFORMTYPE_BOOL;
	exports.UNIFORMTYPE_BOOLARRAY = UNIFORMTYPE_BOOLARRAY;
	exports.UNIFORMTYPE_BVEC2 = UNIFORMTYPE_BVEC2;
	exports.UNIFORMTYPE_BVEC2ARRAY = UNIFORMTYPE_BVEC2ARRAY;
	exports.UNIFORMTYPE_BVEC3 = UNIFORMTYPE_BVEC3;
	exports.UNIFORMTYPE_BVEC3ARRAY = UNIFORMTYPE_BVEC3ARRAY;
	exports.UNIFORMTYPE_BVEC4 = UNIFORMTYPE_BVEC4;
	exports.UNIFORMTYPE_BVEC4ARRAY = UNIFORMTYPE_BVEC4ARRAY;
	exports.UNIFORMTYPE_FLOAT = UNIFORMTYPE_FLOAT;
	exports.UNIFORMTYPE_FLOATARRAY = UNIFORMTYPE_FLOATARRAY;
	exports.UNIFORMTYPE_INT = UNIFORMTYPE_INT;
	exports.UNIFORMTYPE_INTARRAY = UNIFORMTYPE_INTARRAY;
	exports.UNIFORMTYPE_ITEXTURE2D = UNIFORMTYPE_ITEXTURE2D;
	exports.UNIFORMTYPE_ITEXTURE2D_ARRAY = UNIFORMTYPE_ITEXTURE2D_ARRAY;
	exports.UNIFORMTYPE_ITEXTURE3D = UNIFORMTYPE_ITEXTURE3D;
	exports.UNIFORMTYPE_ITEXTURECUBE = UNIFORMTYPE_ITEXTURECUBE;
	exports.UNIFORMTYPE_IVEC2 = UNIFORMTYPE_IVEC2;
	exports.UNIFORMTYPE_IVEC2ARRAY = UNIFORMTYPE_IVEC2ARRAY;
	exports.UNIFORMTYPE_IVEC3 = UNIFORMTYPE_IVEC3;
	exports.UNIFORMTYPE_IVEC3ARRAY = UNIFORMTYPE_IVEC3ARRAY;
	exports.UNIFORMTYPE_IVEC4 = UNIFORMTYPE_IVEC4;
	exports.UNIFORMTYPE_IVEC4ARRAY = UNIFORMTYPE_IVEC4ARRAY;
	exports.UNIFORMTYPE_MAT2 = UNIFORMTYPE_MAT2;
	exports.UNIFORMTYPE_MAT3 = UNIFORMTYPE_MAT3;
	exports.UNIFORMTYPE_MAT4 = UNIFORMTYPE_MAT4;
	exports.UNIFORMTYPE_MAT4ARRAY = UNIFORMTYPE_MAT4ARRAY;
	exports.UNIFORMTYPE_TEXTURE2D = UNIFORMTYPE_TEXTURE2D;
	exports.UNIFORMTYPE_TEXTURE2D_ARRAY = UNIFORMTYPE_TEXTURE2D_ARRAY;
	exports.UNIFORMTYPE_TEXTURE2D_SHADOW = UNIFORMTYPE_TEXTURE2D_SHADOW;
	exports.UNIFORMTYPE_TEXTURE3D = UNIFORMTYPE_TEXTURE3D;
	exports.UNIFORMTYPE_TEXTURECUBE = UNIFORMTYPE_TEXTURECUBE;
	exports.UNIFORMTYPE_TEXTURECUBE_SHADOW = UNIFORMTYPE_TEXTURECUBE_SHADOW;
	exports.UNIFORMTYPE_UINT = UNIFORMTYPE_UINT;
	exports.UNIFORMTYPE_UINTARRAY = UNIFORMTYPE_UINTARRAY;
	exports.UNIFORMTYPE_UTEXTURE2D = UNIFORMTYPE_UTEXTURE2D;
	exports.UNIFORMTYPE_UTEXTURE2D_ARRAY = UNIFORMTYPE_UTEXTURE2D_ARRAY;
	exports.UNIFORMTYPE_UTEXTURE3D = UNIFORMTYPE_UTEXTURE3D;
	exports.UNIFORMTYPE_UTEXTURECUBE = UNIFORMTYPE_UTEXTURECUBE;
	exports.UNIFORMTYPE_UVEC2 = UNIFORMTYPE_UVEC2;
	exports.UNIFORMTYPE_UVEC2ARRAY = UNIFORMTYPE_UVEC2ARRAY;
	exports.UNIFORMTYPE_UVEC3 = UNIFORMTYPE_UVEC3;
	exports.UNIFORMTYPE_UVEC3ARRAY = UNIFORMTYPE_UVEC3ARRAY;
	exports.UNIFORMTYPE_UVEC4 = UNIFORMTYPE_UVEC4;
	exports.UNIFORMTYPE_UVEC4ARRAY = UNIFORMTYPE_UVEC4ARRAY;
	exports.UNIFORMTYPE_VEC2 = UNIFORMTYPE_VEC2;
	exports.UNIFORMTYPE_VEC2ARRAY = UNIFORMTYPE_VEC2ARRAY;
	exports.UNIFORMTYPE_VEC3 = UNIFORMTYPE_VEC3;
	exports.UNIFORMTYPE_VEC3ARRAY = UNIFORMTYPE_VEC3ARRAY;
	exports.UNIFORMTYPE_VEC4 = UNIFORMTYPE_VEC4;
	exports.UNIFORMTYPE_VEC4ARRAY = UNIFORMTYPE_VEC4ARRAY;
	exports.UNIFORM_BUFFER_DEFAULT_SLOT_NAME = UNIFORM_BUFFER_DEFAULT_SLOT_NAME;
	exports.URI = URI;
	exports.UniformBufferFormat = UniformBufferFormat;
	exports.UniformFormat = UniformFormat;
	exports.UsdzExporter = UsdzExporter;
	exports.VIEW_CENTER = VIEW_CENTER;
	exports.VIEW_LEFT = VIEW_LEFT;
	exports.VIEW_RIGHT = VIEW_RIGHT;
	exports.Vec2 = Vec2;
	exports.Vec3 = Vec3;
	exports.Vec4 = Vec4;
	exports.VertexBuffer = VertexBuffer;
	exports.VertexFormat = VertexFormat;
	exports.VertexIterator = VertexIterator;
	exports.WasmModule = WasmModule;
	exports.WebglGraphicsDevice = WebglGraphicsDevice;
	exports.WebgpuGraphicsDevice = WebgpuGraphicsDevice;
	exports.WorldClusters = WorldClusters;
	exports.XRDEPTHSENSINGFORMAT_F32 = XRDEPTHSENSINGFORMAT_F32;
	exports.XRDEPTHSENSINGFORMAT_L8A8 = XRDEPTHSENSINGFORMAT_L8A8;
	exports.XRDEPTHSENSINGFORMAT_R16U = XRDEPTHSENSINGFORMAT_R16U;
	exports.XRDEPTHSENSINGUSAGE_CPU = XRDEPTHSENSINGUSAGE_CPU;
	exports.XRDEPTHSENSINGUSAGE_GPU = XRDEPTHSENSINGUSAGE_GPU;
	exports.XREYE_LEFT = XREYE_LEFT;
	exports.XREYE_NONE = XREYE_NONE;
	exports.XREYE_RIGHT = XREYE_RIGHT;
	exports.XRHAND_LEFT = XRHAND_LEFT;
	exports.XRHAND_NONE = XRHAND_NONE;
	exports.XRHAND_RIGHT = XRHAND_RIGHT;
	exports.XRPAD_A = XRPAD_A;
	exports.XRPAD_B = XRPAD_B;
	exports.XRPAD_SQUEEZE = XRPAD_SQUEEZE;
	exports.XRPAD_STICK_BUTTON = XRPAD_STICK_BUTTON;
	exports.XRPAD_STICK_X = XRPAD_STICK_X;
	exports.XRPAD_STICK_Y = XRPAD_STICK_Y;
	exports.XRPAD_TOUCHPAD_BUTTON = XRPAD_TOUCHPAD_BUTTON;
	exports.XRPAD_TOUCHPAD_X = XRPAD_TOUCHPAD_X;
	exports.XRPAD_TOUCHPAD_Y = XRPAD_TOUCHPAD_Y;
	exports.XRPAD_TRIGGER = XRPAD_TRIGGER;
	exports.XRSPACE_BOUNDEDFLOOR = XRSPACE_BOUNDEDFLOOR;
	exports.XRSPACE_LOCAL = XRSPACE_LOCAL;
	exports.XRSPACE_LOCALFLOOR = XRSPACE_LOCALFLOOR;
	exports.XRSPACE_UNBOUNDED = XRSPACE_UNBOUNDED;
	exports.XRSPACE_VIEWER = XRSPACE_VIEWER;
	exports.XRTARGETRAY_GAZE = XRTARGETRAY_GAZE;
	exports.XRTARGETRAY_POINTER = XRTARGETRAY_POINTER;
	exports.XRTARGETRAY_SCREEN = XRTARGETRAY_SCREEN;
	exports.XRTRACKABLE_MESH = XRTRACKABLE_MESH;
	exports.XRTRACKABLE_PLANE = XRTRACKABLE_PLANE;
	exports.XRTRACKABLE_POINT = XRTRACKABLE_POINT;
	exports.XRTYPE_AR = XRTYPE_AR;
	exports.XRTYPE_INLINE = XRTYPE_INLINE;
	exports.XRTYPE_VR = XRTYPE_VR;
	exports.XrAnchor = XrAnchor;
	exports.XrAnchors = XrAnchors;
	exports.XrDomOverlay = XrDomOverlay;
	exports.XrFinger = XrFinger;
	exports.XrHand = XrHand;
	exports.XrHitTest = XrHitTest;
	exports.XrHitTestSource = XrHitTestSource;
	exports.XrImageTracking = XrImageTracking;
	exports.XrInput = XrInput;
	exports.XrInputSource = XrInputSource;
	exports.XrJoint = XrJoint;
	exports.XrLightEstimation = XrLightEstimation;
	exports.XrManager = XrManager;
	exports.XrMeshDetection = XrMeshDetection;
	exports.XrPlane = XrPlane;
	exports.XrPlaneDetection = XrPlaneDetection;
	exports.XrTrackedImage = XrTrackedImage;
	exports.XrView = XrView;
	exports.XrViews = XrViews;
	exports.ZoneComponent = ZoneComponent;
	exports.ZoneComponentSystem = ZoneComponentSystem;
	exports.basisInitialize = basisInitialize;
	exports.bindGroupNames = bindGroupNames;
	exports.calculateNormals = calculateNormals;
	exports.calculateTangents = calculateTangents;
	exports.createBox = createBox;
	exports.createCapsule = createCapsule;
	exports.createCone = createCone;
	exports.createCylinder = createCylinder;
	exports.createGraphicsDevice = createGraphicsDevice;
	exports.createMesh = createMesh;
	exports.createPlane = createPlane;
	exports.createScript = createScript;
	exports.createShader = createShader;
	exports.createShaderFromCode = createShaderFromCode;
	exports.createSphere = createSphere;
	exports.createTorus = createTorus;
	exports.createURI = createURI;
	exports.dracoInitialize = dracoInitialize;
	exports.drawFullscreenQuad = drawFullscreenQuad;
	exports.drawQuadWithShader = drawQuadWithShader;
	exports.extend = extend;
	exports.getPixelFormatArrayType = getPixelFormatArrayType;
	exports.getReservedScriptNames = getReservedScriptNames;
	exports.getTouchTargetCoords = getTouchTargetCoords;
	exports.guid = guid;
	exports.http = http;
	exports.isCompressedPixelFormat = isCompressedPixelFormat;
	exports.isIntegerPixelFormat = isIntegerPixelFormat;
	exports.isSrgbPixelFormat = isSrgbPixelFormat;
	exports.math = math;
	exports.now = now;
	exports.path = path;
	exports.pixelFormatInfo = pixelFormatInfo;
	exports.pixelFormatLinearToGamma = pixelFormatLinearToGamma;
	exports.platform = platform;
	exports.registerScript = registerScript;
	exports.reprojectTexture = reprojectTexture;
	exports.requiresManualGamma = requiresManualGamma;
	exports.revision = revision;
	exports.script = script;
	exports.semanticToLocation = semanticToLocation;
	exports.shaderChunks = shaderChunks;
	exports.shaderChunksLightmapper = shaderChunksLightmapper;
	exports.shadowTypeInfo = shadowTypeInfo;
	exports.string = string;
	exports.tonemapNames = tonemapNames;
	exports.typedArrayIndexFormats = typedArrayIndexFormats;
	exports.typedArrayIndexFormatsByteSize = typedArrayIndexFormatsByteSize;
	exports.typedArrayToType = typedArrayToType;
	exports.typedArrayTypes = typedArrayTypes;
	exports.typedArrayTypesByteSize = typedArrayTypesByteSize;
	exports.uniformTypeToName = uniformTypeToName;
	exports.uniformTypeToStorage = uniformTypeToStorage;
	exports.version = version;
	exports.vertexTypesNames = vertexTypesNames;

}));
